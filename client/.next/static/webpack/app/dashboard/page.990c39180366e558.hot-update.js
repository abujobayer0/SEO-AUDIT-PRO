"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./components/LaserFlow.jsx":
/*!**********************************!*\
  !*** ./components/LaserFlow.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LaserFlow: function() { return /* binding */ LaserFlow; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.core.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst VERT = \"\\nprecision highp float;\\nattribute vec3 position;\\nvoid main(){\\n  gl_Position = vec4(position, 1.0);\\n}\\n\";\nconst FRAG = \"\\n#ifdef GL_ES\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\nprecision highp float;\\nprecision mediump int;\\n\\nuniform float iTime;\\nuniform vec3 iResolution;\\nuniform vec4 iMouse;\\nuniform float uWispDensity;\\nuniform float uTiltScale;\\nuniform float uFlowTime;\\nuniform float uFogTime;\\nuniform float uBeamXFrac;\\nuniform float uBeamYFrac;\\nuniform float uFlowSpeed;\\nuniform float uVLenFactor;\\nuniform float uHLenFactor;\\nuniform float uFogIntensity;\\nuniform float uFogScale;\\nuniform float uWSpeed;\\nuniform float uWIntensity;\\nuniform float uFlowStrength;\\nuniform float uDecay;\\nuniform float uFalloffStart;\\nuniform float uFogFallSpeed;\\nuniform vec3 uColor;\\nuniform float uFade;\\n\\n// Core beam/flare shaping and dynamics\\n#define PI 3.14159265359\\n#define TWO_PI 6.28318530718\\n#define EPS 1e-6\\n#define EDGE_SOFT (DT_LOCAL*4.0)\\n#define DT_LOCAL 0.0038\\n#define TAP_RADIUS 6\\n#define R_H 150.0\\n#define R_V 150.0\\n#define FLARE_HEIGHT 16.0\\n#define FLARE_AMOUNT 8.0\\n#define FLARE_EXP 2.0\\n#define TOP_FADE_START 0.1\\n#define TOP_FADE_EXP 1.0\\n#define FLOW_PERIOD 0.5\\n#define FLOW_SHARPNESS 1.5\\n\\n// Wisps (animated micro-streaks) that travel along the beam\\n#define W_BASE_X 1.5\\n#define W_LAYER_GAP 0.25\\n#define W_LANES 10\\n#define W_SIDE_DECAY 0.5\\n#define W_HALF 0.01\\n#define W_AA 0.15\\n#define W_CELL 20.0\\n#define W_SEG_MIN 0.01\\n#define W_SEG_MAX 0.55\\n#define W_CURVE_AMOUNT 15.0\\n#define W_CURVE_RANGE (FLARE_HEIGHT - 3.0)\\n#define W_BOTTOM_EXP 10.0\\n\\n// Volumetric fog controls\\n#define FOG_ON 1\\n#define FOG_CONTRAST 1.2\\n#define FOG_SPEED_U 0.1\\n#define FOG_SPEED_V -0.1\\n#define FOG_OCTAVES 5\\n#define FOG_BOTTOM_BIAS 0.8\\n#define FOG_TILT_TO_MOUSE 0.05\\n#define FOG_TILT_DEADZONE 0.01\\n#define FOG_TILT_MAX_X 0.35\\n#define FOG_TILT_SHAPE 1.5\\n#define FOG_BEAM_MIN 0.0\\n#define FOG_BEAM_MAX 0.75\\n#define FOG_MASK_GAMMA 0.5\\n#define FOG_EXPAND_SHAPE 12.2\\n#define FOG_EDGE_MIX 0.5\\n\\n// Horizontal vignette for the fog volume\\n#define HFOG_EDGE_START 0.20\\n#define HFOG_EDGE_END 0.98\\n#define HFOG_EDGE_GAMMA 1.4\\n#define HFOG_Y_RADIUS 25.0\\n#define HFOG_Y_SOFT 60.0\\n\\n// Beam extents and edge masking\\n#define EDGE_X0 0.22\\n#define EDGE_X1 0.995\\n#define EDGE_X_GAMMA 1.25\\n#define EDGE_LUMA_T0 0.0\\n#define EDGE_LUMA_T1 2.0\\n#define DITHER_STRENGTH 1.0\\n\\n    float g(float x){return x<=0.00031308?12.92*x:1.055*pow(x,1.0/2.4)-0.055;}\\n    float bs(vec2 p,vec2 q,float powr){\\n        float d=distance(p,q),f=powr*uFalloffStart,r=(f*f)/(d*d+EPS);\\n        return powr*min(1.0,r);\\n    }\\n    float bsa(vec2 p,vec2 q,float powr,vec2 s){\\n        vec2 d=p-q; float dd=(d.x*d.x)/(s.x*s.x)+(d.y*d.y)/(s.y*s.y),f=powr*uFalloffStart,r=(f*f)/(dd+EPS);\\n        return powr*min(1.0,r);\\n    }\\n    float tri01(float x){float f=fract(x);return 1.0-abs(f*2.0-1.0);}\\n    float tauWf(float t,float tmin,float tmax){float a=smoothstep(tmin,tmin+EDGE_SOFT,t),b=1.0-smoothstep(tmax-EDGE_SOFT,tmax,t);return max(0.0,a*b);} \\n    float h21(vec2 p){p=fract(p*vec2(123.34,456.21));p+=dot(p,p+34.123);return fract(p.x*p.y);}\\n    float vnoise(vec2 p){\\n        vec2 i=floor(p),f=fract(p);\\n        float a=h21(i),b=h21(i+vec2(1,0)),c=h21(i+vec2(0,1)),d=h21(i+vec2(1,1));\\n        vec2 u=f*f*(3.0-2.0*f);\\n        return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\\n    }\\n    float fbm2(vec2 p){\\n        float v=0.0,amp=0.6; mat2 m=mat2(0.86,0.5,-0.5,0.86);\\n        for(int i=0;i<FOG_OCTAVES;++i){v+=amp*vnoise(p); p=m*p*2.03+17.1; amp*=0.52;}\\n        return v;\\n    }\\n    float rGate(float x,float l){float a=smoothstep(0.0,W_AA,x),b=1.0-smoothstep(l,l+W_AA,x);return max(0.0,a*b);}\\n    float flareY(float y){float t=clamp(1.0-(clamp(y,0.0,FLARE_HEIGHT)/max(FLARE_HEIGHT,EPS)),0.0,1.0);return pow(t,FLARE_EXP);}\\n\\n    float vWisps(vec2 uv,float topF){\\n    float y=uv.y,yf=(y+uFlowTime*uWSpeed)/W_CELL;\\n    float dRaw=clamp(uWispDensity,0.0,2.0),d=dRaw<=0.0?1.0:dRaw;\\n    float lanesF=floor(float(W_LANES)*min(d,1.0)+0.5); // WebGL1-safe\\n    int lanes=int(max(1.0,lanesF));\\n    float sp=min(d,1.0),ep=max(d-1.0,0.0);\\n    float fm=flareY(max(y,0.0)),rm=clamp(1.0-(y/max(W_CURVE_RANGE,EPS)),0.0,1.0),cm=fm*rm;\\n    const float G=0.05; float xS=1.0+(FLARE_AMOUNT*W_CURVE_AMOUNT*G)*cm;\\n    float sPix=clamp(y/R_V,0.0,1.0),bGain=pow(1.0-sPix,W_BOTTOM_EXP),sum=0.0;\\n    for(int s=0;s<2;++s){\\n        float sgn=s==0?-1.0:1.0;\\n        for(int i=0;i<W_LANES;++i){\\n            if(i>=lanes) break;\\n            float off=W_BASE_X+float(i)*W_LAYER_GAP,xc=sgn*(off*xS);\\n            float dx=abs(uv.x-xc),lat=1.0-smoothstep(W_HALF,W_HALF+W_AA,dx),amp=exp(-off*W_SIDE_DECAY);\\n            float seed=h21(vec2(off,sgn*17.0)),yf2=yf+seed*7.0,ci=floor(yf2),fy=fract(yf2);\\n            float seg=mix(W_SEG_MIN,W_SEG_MAX,h21(vec2(ci,off*2.3)));\\n            float spR=h21(vec2(ci,off+sgn*31.0)),seg1=rGate(fy,seg)*step(spR,sp);\\n            if(ep>0.0){float spR2=h21(vec2(ci*3.1+7.0,off*5.3+sgn*13.0)); float f2=fract(fy+0.5); seg1+=rGate(f2,seg*0.9)*step(spR2,ep);}\\n            sum+=amp*lat*seg1;\\n        }\\n    }\\n    float span=smoothstep(-3.0,0.0,y)*(1.0-smoothstep(R_V-6.0,R_V,y));\\n    return uWIntensity*sum*topF*bGain*span;\\n}\\n\\nvoid mainImage(out vec4 fc,in vec2 frag){\\n    vec2 C=iResolution.xy*.5; float invW=1.0/max(C.x,1.0);\\n    float sc=512.0/iResolution.x*.4;\\n    vec2 uv=(frag-C)*sc,off=vec2(uBeamXFrac*iResolution.x*sc,uBeamYFrac*iResolution.y*sc);\\n    vec2 uvc = uv - off;\\n    float a=0.0,b=0.0;\\n    float basePhase=1.5*PI+uDecay*.5; float tauMin=basePhase-uDecay; float tauMax=basePhase;\\n    float cx=clamp(uvc.x/(R_H*uHLenFactor),-1.0,1.0),tH=clamp(TWO_PI-acos(cx),tauMin,tauMax);\\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\\n        float tu=tH+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\\n        float spd=max(abs(sin(tu)),0.02),u=clamp((basePhase-tu)/max(uDecay,EPS),0.0,1.0),env=pow(1.0-abs(u*2.0-1.0),0.8);\\n        vec2 p=vec2((R_H*uHLenFactor)*cos(tu),0.0);\\n        a+=wt*bs(uvc,p,env*spd);\\n    }\\n    float yPix=uvc.y,cy=clamp(-yPix/(R_V*uVLenFactor),-1.0,1.0),tV=clamp(TWO_PI-acos(cy),tauMin,tauMax);\\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\\n        float tu=tV+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\\n        float yb=(-R_V)*cos(tu),s=clamp(yb/R_V,0.0,1.0),spd=max(abs(sin(tu)),0.02);\\n        float env=pow(1.0-s,0.6)*spd;\\n        float cap=1.0-smoothstep(TOP_FADE_START,1.0,s); cap=pow(cap,TOP_FADE_EXP); env*=cap;\\n        float ph=s/max(FLOW_PERIOD,EPS)+uFlowTime*uFlowSpeed;\\n        float fl=pow(tri01(ph),FLOW_SHARPNESS);\\n        env*=mix(1.0-uFlowStrength,1.0,fl);\\n        float yp=(-R_V*uVLenFactor)*cos(tu),m=pow(smoothstep(FLARE_HEIGHT,0.0,yp),FLARE_EXP),wx=1.0+FLARE_AMOUNT*m;\\n        vec2 sig=vec2(wx,1.0),p=vec2(0.0,yp);\\n        float mask=step(0.0,yp);\\n        b+=wt*bsa(uvc,p,mask*env,sig);\\n    }\\n    float sPix=clamp(yPix/R_V,0.0,1.0),topA=pow(1.0-smoothstep(TOP_FADE_START,1.0,sPix),TOP_FADE_EXP);\\n    float L=a+b*topA;\\n    float w=vWisps(vec2(uvc.x,yPix),topA);\\n    float fog=0.0;\\n#if FOG_ON\\n    vec2 fuv=uvc*uFogScale;\\n    float mAct=step(1.0,length(iMouse.xy)),nx=((iMouse.x-C.x)*invW)*mAct;\\n    float ax = abs(nx);\\n    float stMag = mix(ax, pow(ax, FOG_TILT_SHAPE), 0.35);\\n    float st = sign(nx) * stMag * uTiltScale;\\n    st = clamp(st, -FOG_TILT_MAX_X, FOG_TILT_MAX_X);\\n    vec2 dir=normalize(vec2(st,1.0));\\n    fuv+=uFogTime*uFogFallSpeed*dir;\\n    vec2 prp=vec2(-dir.y,dir.x);\\n    fuv+=prp*(0.08*sin(dot(uvc,prp)*0.08+uFogTime*0.9));\\n    float n=fbm2(fuv+vec2(fbm2(fuv+vec2(7.3,2.1)),fbm2(fuv+vec2(-3.7,5.9)))*0.6);\\n    n=pow(clamp(n,0.0,1.0),FOG_CONTRAST);\\n    float pixW = 1.0 / max(iResolution.y, 1.0);\\n#ifdef GL_OES_standard_derivatives\\n    float wL = max(fwidth(L), pixW);\\n#else\\n    float wL = pixW;\\n#endif\\n    float m0=pow(smoothstep(FOG_BEAM_MIN - wL, FOG_BEAM_MAX + wL, L),FOG_MASK_GAMMA);\\n    float bm=1.0-pow(1.0-m0,FOG_EXPAND_SHAPE); bm=mix(bm*m0,bm,FOG_EDGE_MIX);\\n    float yP=1.0-smoothstep(HFOG_Y_RADIUS,HFOG_Y_RADIUS+HFOG_Y_SOFT,abs(yPix));\\n    float nxF=abs((frag.x-C.x)*invW),hE=1.0-smoothstep(HFOG_EDGE_START,HFOG_EDGE_END,nxF); hE=pow(clamp(hE,0.0,1.0),HFOG_EDGE_GAMMA);\\n    float hW=mix(1.0,hE,clamp(yP,0.0,1.0));\\n    float bBias=mix(1.0,1.0-sPix,FOG_BOTTOM_BIAS);\\n    float browserFogIntensity = uFogIntensity;\\n    browserFogIntensity *= 1.8;\\n    float radialFade = 1.0 - smoothstep(0.0, 0.7, length(uvc) / 120.0);\\n    float safariFog = n * browserFogIntensity * bBias * bm * hW * radialFade;\\n    fog = safariFog;\\n#endif\\n    float LF=L+fog;\\n    float dith=(h21(frag)-0.5)*(DITHER_STRENGTH/255.0);\\n    float tone=g(LF+w);\\n    vec3 col=tone*uColor+dith;\\n    float alpha=clamp(g(L+w*0.6)+dith*0.6,0.0,1.0);\\n    float nxE=abs((frag.x-C.x)*invW),xF=pow(clamp(1.0-smoothstep(EDGE_X0,EDGE_X1,nxE),0.0,1.0),EDGE_X_GAMMA);\\n    float scene=LF+max(0.0,w)*0.5,hi=smoothstep(EDGE_LUMA_T0,EDGE_LUMA_T1,scene);\\n    float eM=mix(xF,1.0,hi);\\n    col*=eM; alpha*=eM;\\n    col*=uFade; alpha*=uFade;\\n    fc=vec4(col,alpha);\\n}\\n\\nvoid main(){\\n  vec4 fc;\\n  mainImage(fc, gl_FragCoord.xy);\\n  gl_FragColor = fc;\\n}\\n\";\nconst LaserFlow = (param)=>{\n    let { className, style, wispDensity = 1, dpr, mouseSmoothTime = 0.0, mouseTiltStrength = 0.01, horizontalBeamOffset = 0.1, verticalBeamOffset = 0.0, flowSpeed = 0.35, verticalSizing = 2.0, horizontalSizing = 0.5, fogIntensity = 0.45, fogScale = 0.3, wispSpeed = 15.0, wispIntensity = 5.0, flowStrength = 0.25, decay = 1.1, falloffStart = 1.2, fogFallSpeed = 0.6, color = \"#FF79C6\" } = param;\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const rendererRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const uniformsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const hasFadedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const rectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const baseDprRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(1);\n    const currentDprRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(1);\n    const fpsSamplesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const lastFpsCheckRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(performance.now());\n    const emaDtRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(16.7);\n    const pausedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const inViewRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    const hexToRGB = (hex)=>{\n        let c = hex.trim();\n        if (c[0] === \"#\") c = c.slice(1);\n        if (c.length === 3) c = c.split(\"\").map((x)=>x + x).join(\"\");\n        const n = parseInt(c, 16) || 0xffffff;\n        return {\n            r: (n >> 16 & 255) / 255,\n            g: (n >> 8 & 255) / 255,\n            b: (n & 255) / 255\n        };\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const mount = mountRef.current;\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n            antialias: false,\n            alpha: false,\n            depth: false,\n            stencil: false,\n            powerPreference: \"high-performance\",\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: false,\n            failIfMajorPerformanceCaveat: false,\n            logarithmicDepthBuffer: false\n        });\n        rendererRef.current = renderer;\n        baseDprRef.current = Math.min(dpr !== null && dpr !== void 0 ? dpr : window.devicePixelRatio || 1, 2);\n        currentDprRef.current = baseDprRef.current;\n        renderer.setPixelRatio(currentDprRef.current);\n        renderer.shadowMap.enabled = false;\n        renderer.outputColorSpace = three__WEBPACK_IMPORTED_MODULE_3__.SRGBColorSpace;\n        renderer.setClearColor(0x000000, 1);\n        const canvas = renderer.domElement;\n        canvas.style.width = \"100%\";\n        canvas.style.height = \"100%\";\n        canvas.style.display = \"block\";\n        mount.appendChild(canvas);\n        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.BufferAttribute(new Float32Array([\n            -1,\n            -1,\n            0,\n            3,\n            -1,\n            0,\n            -1,\n            3,\n            0\n        ]), 3));\n        const uniforms = {\n            iTime: {\n                value: 0\n            },\n            iResolution: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 1, 1)\n            },\n            iMouse: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0, 0, 0, 0)\n            },\n            uWispDensity: {\n                value: wispDensity\n            },\n            uTiltScale: {\n                value: mouseTiltStrength\n            },\n            uFlowTime: {\n                value: 0\n            },\n            uFogTime: {\n                value: 0\n            },\n            uBeamXFrac: {\n                value: horizontalBeamOffset\n            },\n            uBeamYFrac: {\n                value: verticalBeamOffset\n            },\n            uFlowSpeed: {\n                value: flowSpeed\n            },\n            uVLenFactor: {\n                value: verticalSizing\n            },\n            uHLenFactor: {\n                value: horizontalSizing\n            },\n            uFogIntensity: {\n                value: fogIntensity\n            },\n            uFogScale: {\n                value: fogScale\n            },\n            uWSpeed: {\n                value: wispSpeed\n            },\n            uWIntensity: {\n                value: wispIntensity\n            },\n            uFlowStrength: {\n                value: flowStrength\n            },\n            uDecay: {\n                value: decay\n            },\n            uFalloffStart: {\n                value: falloffStart\n            },\n            uFogFallSpeed: {\n                value: fogFallSpeed\n            },\n            uColor: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 1, 1)\n            },\n            uFade: {\n                value: hasFadedRef.current ? 1 : 0\n            }\n        };\n        uniformsRef.current = uniforms;\n        const material = new three__WEBPACK_IMPORTED_MODULE_3__.RawShaderMaterial({\n            vertexShader: VERT,\n            fragmentShader: FRAG,\n            uniforms,\n            transparent: false,\n            depthTest: false,\n            depthWrite: false,\n            blending: three__WEBPACK_IMPORTED_MODULE_3__.NormalBlending\n        });\n        const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geometry, material);\n        mesh.frustumCulled = false;\n        scene.add(mesh);\n        const clock = new three__WEBPACK_IMPORTED_MODULE_3__.Clock();\n        let prevTime = 0;\n        let fade = hasFadedRef.current ? 1 : 0;\n        const mouseTarget = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0, 0);\n        const mouseSmooth = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0, 0);\n        const setSizeNow = ()=>{\n            const w = mount.clientWidth || 1;\n            const h = mount.clientHeight || 1;\n            const pr = currentDprRef.current;\n            renderer.setPixelRatio(pr);\n            renderer.setSize(w, h, false);\n            uniforms.iResolution.value.set(w * pr, h * pr, pr);\n            rectRef.current = canvas.getBoundingClientRect();\n        };\n        let resizeRaf = 0;\n        const scheduleResize = ()=>{\n            if (resizeRaf) cancelAnimationFrame(resizeRaf);\n            resizeRaf = requestAnimationFrame(setSizeNow);\n        };\n        setSizeNow();\n        const ro = new ResizeObserver(scheduleResize);\n        ro.observe(mount);\n        const io = new IntersectionObserver((entries)=>{\n            var _entries_;\n            var _entries__isIntersecting;\n            inViewRef.current = (_entries__isIntersecting = (_entries_ = entries[0]) === null || _entries_ === void 0 ? void 0 : _entries_.isIntersecting) !== null && _entries__isIntersecting !== void 0 ? _entries__isIntersecting : true;\n        }, {\n            root: null,\n            threshold: 0\n        });\n        io.observe(mount);\n        const onVis = ()=>{\n            pausedRef.current = document.hidden;\n        };\n        document.addEventListener(\"visibilitychange\", onVis, {\n            passive: true\n        });\n        const updateMouse = (clientX, clientY)=>{\n            const rect = rectRef.current;\n            if (!rect) return;\n            const x = clientX - rect.left;\n            const y = clientY - rect.top;\n            const ratio = currentDprRef.current;\n            const hb = rect.height * ratio;\n            mouseTarget.set(x * ratio, hb - y * ratio);\n        };\n        const onMove = (ev)=>updateMouse(ev.clientX, ev.clientY);\n        const onLeave = ()=>mouseTarget.set(0, 0);\n        canvas.addEventListener(\"pointermove\", onMove, {\n            passive: true\n        });\n        canvas.addEventListener(\"pointerdown\", onMove, {\n            passive: true\n        });\n        canvas.addEventListener(\"pointerenter\", onMove, {\n            passive: true\n        });\n        canvas.addEventListener(\"pointerleave\", onLeave, {\n            passive: true\n        });\n        const onCtxLost = (e)=>{\n            e.preventDefault();\n            pausedRef.current = true;\n        };\n        const onCtxRestored = ()=>{\n            pausedRef.current = false;\n            scheduleResize();\n        };\n        canvas.addEventListener(\"webglcontextlost\", onCtxLost, false);\n        canvas.addEventListener(\"webglcontextrestored\", onCtxRestored, false);\n        let raf = 0;\n        const clamp = (v, lo, hi)=>Math.max(lo, Math.min(hi, v));\n        const dprFloor = 0.6;\n        const lowerThresh = 50;\n        const upperThresh = 58;\n        const adjustDprIfNeeded = (now)=>{\n            const elapsed = now - lastFpsCheckRef.current;\n            if (elapsed < 750) return;\n            const samples = fpsSamplesRef.current;\n            if (samples.length === 0) {\n                lastFpsCheckRef.current = now;\n                return;\n            }\n            const avgFps = samples.reduce((a, b)=>a + b, 0) / samples.length;\n            let next = currentDprRef.current;\n            const base = baseDprRef.current;\n            if (avgFps < lowerThresh) {\n                next = clamp(currentDprRef.current * 0.9, dprFloor, base);\n            } else if (avgFps > upperThresh && currentDprRef.current < base) {\n                next = clamp(currentDprRef.current * 1.05, dprFloor, base);\n            }\n            if (Math.abs(next - currentDprRef.current) > 0.01) {\n                currentDprRef.current = next;\n                setSizeNow();\n            }\n            fpsSamplesRef.current = [];\n            lastFpsCheckRef.current = now;\n        };\n        const animate = ()=>{\n            raf = requestAnimationFrame(animate);\n            if (pausedRef.current || !inViewRef.current) return;\n            const t = clock.getElapsedTime();\n            const dt = Math.max(0, t - prevTime);\n            prevTime = t;\n            const dtMs = dt * 1000;\n            emaDtRef.current = emaDtRef.current * 0.9 + dtMs * 0.1;\n            const instFps = 1000 / Math.max(1, emaDtRef.current);\n            fpsSamplesRef.current.push(instFps);\n            uniforms.iTime.value = t;\n            const cdt = Math.min(0.033, Math.max(0.001, dt));\n            uniforms.uFlowTime.value += cdt;\n            uniforms.uFogTime.value += cdt;\n            if (!hasFadedRef.current) {\n                const fadeDur = 1.0;\n                fade = Math.min(1, fade + cdt / fadeDur);\n                uniforms.uFade.value = fade;\n                if (fade >= 1) hasFadedRef.current = true;\n            }\n            const tau = Math.max(1e-3, mouseSmoothTime);\n            const alpha = 1 - Math.exp(-cdt / tau);\n            mouseSmooth.lerp(mouseTarget, alpha);\n            uniforms.iMouse.value.set(mouseSmooth.x, mouseSmooth.y, 0, 0);\n            renderer.render(scene, camera);\n            adjustDprIfNeeded(performance.now());\n        };\n        animate();\n        return ()=>{\n            cancelAnimationFrame(raf);\n            ro.disconnect();\n            io.disconnect();\n            document.removeEventListener(\"visibilitychange\", onVis);\n            canvas.removeEventListener(\"pointermove\", onMove);\n            canvas.removeEventListener(\"pointerdown\", onMove);\n            canvas.removeEventListener(\"pointerenter\", onMove);\n            canvas.removeEventListener(\"pointerleave\", onLeave);\n            canvas.removeEventListener(\"webglcontextlost\", onCtxLost);\n            canvas.removeEventListener(\"webglcontextrestored\", onCtxRestored);\n            geometry.dispose();\n            material.dispose();\n            renderer.dispose();\n            if (mount.contains(canvas)) mount.removeChild(canvas);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        dpr\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const uniforms = uniformsRef.current;\n        if (!uniforms) return;\n        uniforms.uWispDensity.value = wispDensity;\n        uniforms.uTiltScale.value = mouseTiltStrength;\n        uniforms.uBeamXFrac.value = horizontalBeamOffset;\n        uniforms.uBeamYFrac.value = verticalBeamOffset;\n        uniforms.uFlowSpeed.value = flowSpeed;\n        uniforms.uVLenFactor.value = verticalSizing;\n        uniforms.uHLenFactor.value = horizontalSizing;\n        uniforms.uFogIntensity.value = fogIntensity;\n        uniforms.uFogScale.value = fogScale;\n        uniforms.uWSpeed.value = wispSpeed;\n        uniforms.uWIntensity.value = wispIntensity;\n        uniforms.uFlowStrength.value = flowStrength;\n        uniforms.uDecay.value = decay;\n        uniforms.uFalloffStart.value = falloffStart;\n        uniforms.uFogFallSpeed.value = fogFallSpeed;\n        const { r, g, b } = hexToRGB(color || \"#FFFFFF\");\n        uniforms.uColor.value.set(r, g, b);\n    }, [\n        wispDensity,\n        mouseTiltStrength,\n        horizontalBeamOffset,\n        verticalBeamOffset,\n        flowSpeed,\n        verticalSizing,\n        horizontalSizing,\n        fogIntensity,\n        fogScale,\n        wispSpeed,\n        wispIntensity,\n        flowStrength,\n        decay,\n        falloffStart,\n        fogFallSpeed,\n        color\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef,\n        className: \"w-full  h-full relative \".concat(className || \"\"),\n        style: style\n    }, void 0, false, {\n        fileName: \"/Users/abujobayer/white label seo audit tool/client/components/LaserFlow.jsx\",\n        lineNumber: 562,\n        columnNumber: 10\n    }, undefined);\n};\n_s(LaserFlow, \"02eBwPLcPvNFpzTzTvnXGIa49Xk=\");\n_c = LaserFlow;\n/* harmony default export */ __webpack_exports__[\"default\"] = (LaserFlow);\nvar _c;\n$RefreshReg$(_c, \"LaserFlow\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTGFzZXJGbG93LmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwQztBQUNYO0FBRS9CLE1BQU1HLE9BQVE7QUFRZCxNQUFNQyxPQUFRO0FBb09QLE1BQU1DLFlBQVk7UUFBQyxFQUN4QkMsU0FBUyxFQUNUQyxLQUFLLEVBQ0xDLGNBQWMsQ0FBQyxFQUNmQyxHQUFHLEVBQ0hDLGtCQUFrQixHQUFHLEVBQ3JCQyxvQkFBb0IsSUFBSSxFQUN4QkMsdUJBQXVCLEdBQUcsRUFDMUJDLHFCQUFxQixHQUFHLEVBQ3hCQyxZQUFZLElBQUksRUFDaEJDLGlCQUFpQixHQUFHLEVBQ3BCQyxtQkFBbUIsR0FBRyxFQUN0QkMsZUFBZSxJQUFJLEVBQ25CQyxXQUFXLEdBQUcsRUFDZEMsWUFBWSxJQUFJLEVBQ2hCQyxnQkFBZ0IsR0FBRyxFQUNuQkMsZUFBZSxJQUFJLEVBQ25CQyxRQUFRLEdBQUcsRUFDWEMsZUFBZSxHQUFHLEVBQ2xCQyxlQUFlLEdBQUcsRUFDbEJDLFFBQVEsU0FBUyxFQUNsQjs7SUFDQyxNQUFNQyxXQUFXekIsNkNBQU1BLENBQUM7SUFDeEIsTUFBTTBCLGNBQWMxQiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNMkIsY0FBYzNCLDZDQUFNQSxDQUFDO0lBQzNCLE1BQU00QixjQUFjNUIsNkNBQU1BLENBQUM7SUFDM0IsTUFBTTZCLFVBQVU3Qiw2Q0FBTUEsQ0FBQztJQUN2QixNQUFNOEIsYUFBYTlCLDZDQUFNQSxDQUFDO0lBQzFCLE1BQU0rQixnQkFBZ0IvQiw2Q0FBTUEsQ0FBQztJQUM3QixNQUFNZ0MsZ0JBQWdCaEMsNkNBQU1BLENBQUMsRUFBRTtJQUMvQixNQUFNaUMsa0JBQWtCakMsNkNBQU1BLENBQUNrQyxZQUFZQyxHQUFHO0lBQzlDLE1BQU1DLFdBQVdwQyw2Q0FBTUEsQ0FBQztJQUN4QixNQUFNcUMsWUFBWXJDLDZDQUFNQSxDQUFDO0lBQ3pCLE1BQU1zQyxZQUFZdEMsNkNBQU1BLENB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QUMsRUFBRSxHQUFHZCxTQUFTZixTQUFTO1FBQ3RDb0UsU0FBU3dCLE1BQU0sQ0FBQ3RCLEtBQUssQ0FBQ21ELEdBQUcsQ0FBQzlGLEdBQUdDLEdBQUdDO0lBQ2xDLEdBQUc7UUFDRDlDO1FBQ0FHO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO0tBQ0Q7SUFFRCxxQkFBTyw4REFBQ2lNO1FBQUlDLEtBQUtqTTtRQUFVcEIsV0FBVywyQkFBMkMsT0FBaEJBLGFBQWE7UUFBTUMsT0FBT0E7Ozs7OztBQUM3RixFQUFFO0dBblVXRjtLQUFBQTtBQXFVYiwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0xhc2VyRmxvdy5qc3g/OWM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCI7XG5cbmNvbnN0IFZFUlQgPSBgXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcbnZvaWQgbWFpbigpe1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XG59XG5gO1xuXG5jb25zdCBGUkFHID0gYFxuI2lmZGVmIEdMX0VTXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxuI2VuZGlmXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5wcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cbnVuaWZvcm0gZmxvYXQgaVRpbWU7XG51bmlmb3JtIHZlYzMgaVJlc29sdXRpb247XG51bmlmb3JtIHZlYzQgaU1vdXNlO1xudW5pZm9ybSBmbG9hdCB1V2lzcERlbnNpdHk7XG51bmlmb3JtIGZsb2F0IHVUaWx0U2NhbGU7XG51bmlmb3JtIGZsb2F0IHVGbG93VGltZTtcbnVuaWZvcm0gZmxvYXQgdUZvZ1RpbWU7XG51bmlmb3JtIGZsb2F0IHVCZWFtWEZyYWM7XG51bmlmb3JtIGZsb2F0IHVCZWFtWUZyYWM7XG51bmlmb3JtIGZsb2F0IHVGbG93U3BlZWQ7XG51bmlmb3JtIGZsb2F0IHVWTGVuRmFjdG9yO1xudW5pZm9ybSBmbG9hdCB1SExlbkZhY3RvcjtcbnVuaWZvcm0gZmxvYXQgdUZvZ0ludGVuc2l0eTtcbnVuaWZvcm0gZmxvYXQgdUZvZ1NjYWxlO1xudW5pZm9ybSBmbG9hdCB1V1NwZWVkO1xudW5pZm9ybSBmbG9hdCB1V0ludGVuc2l0eTtcbnVuaWZvcm0gZmxvYXQgdUZsb3dTdHJlbmd0aDtcbnVuaWZvcm0gZmxvYXQgdURlY2F5O1xudW5pZm9ybSBmbG9hdCB1RmFsbG9mZlN0YXJ0O1xudW5pZm9ybSBmbG9hdCB1Rm9nRmFsbFNwZWVkO1xudW5pZm9ybSB2ZWMzIHVDb2xvcjtcbnVuaWZvcm0gZmxvYXQgdUZhZGU7XG5cbi8vIENvcmUgYmVhbS9mbGFyZSBzaGFwaW5nIGFuZCBkeW5hbWljc1xuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XG4jZGVmaW5lIFRXT19QSSA2LjI4MzE4NTMwNzE4XG4jZGVmaW5lIEVQUyAxZS02XG4jZGVmaW5lIEVER0VfU09GVCAoRFRfTE9DQUwqNC4wKVxuI2RlZmluZSBEVF9MT0NBTCAwLjAwMzhcbiNkZWZpbmUgVEFQX1JBRElVUyA2XG4jZGVmaW5lIFJfSCAxNTAuMFxuI2RlZmluZSBSX1YgMTUwLjBcbiNkZWZpbmUgRkxBUkVfSEVJR0hUIDE2LjBcbiNkZWZpbmUgRkxBUkVfQU1PVU5UIDguMFxuI2RlZmluZSBGTEFSRV9FWFAgMi4wXG4jZGVmaW5lIFRPUF9GQURFX1NUQVJUIDAuMVxuI2RlZmluZSBUT1BfRkFERV9FWFAgMS4wXG4jZGVmaW5lIEZMT1dfUEVSSU9EIDAuNVxuI2RlZmluZSBGTE9XX1NIQVJQTkVTUyAxLjVcblxuLy8gV2lzcHMgKGFuaW1hdGVkIG1pY3JvLXN0cmVha3MpIHRoYXQgdHJhdmVsIGFsb25nIHRoZSBiZWFtXG4jZGVmaW5lIFdfQkFTRV9YIDEuNVxuI2RlZmluZSBXX0xBWUVSX0dBUCAwLjI1XG4jZGVmaW5lIFdfTEFORVMgMTBcbiNkZWZpbmUgV19TSURFX0RFQ0FZIDAuNVxuI2RlZmluZSBXX0hBTEYgMC4wMVxuI2RlZmluZSBXX0FBIDAuMTVcbiNkZWZpbmUgV19DRUxMIDIwLjBcbiNkZWZpbmUgV19TRUdfTUlOIDAuMDFcbiNkZWZpbmUgV19TRUdfTUFYIDAuNTVcbiNkZWZpbmUgV19DVVJWRV9BTU9VTlQgMTUuMFxuI2RlZmluZSBXX0NVUlZFX1JBTkdFIChGTEFSRV9IRUlHSFQgLSAzLjApXG4jZGVmaW5lIFdfQk9UVE9NX0VYUCAxMC4wXG5cbi8vIFZvbHVtZXRyaWMgZm9nIGNvbnRyb2xzXG4jZGVmaW5lIEZPR19PTiAxXG4jZGVmaW5lIEZPR19DT05UUkFTVCAxLjJcbiNkZWZpbmUgRk9HX1NQRUVEX1UgMC4xXG4jZGVmaW5lIEZPR19TUEVFRF9WIC0wLjFcbiNkZWZpbmUgRk9HX09DVEFWRVMgNVxuI2RlZmluZSBGT0dfQk9UVE9NX0JJQVMgMC44XG4jZGVmaW5lIEZPR19USUxUX1RPX01PVVNFIDAuMDVcbiNkZWZpbmUgRk9HX1RJTFRfREVBRFpPTkUgMC4wMVxuI2RlZmluZSBGT0dfVElMVF9NQVhfWCAwLjM1XG4jZGVmaW5lIEZPR19USUxUX1NIQVBFIDEuNVxuI2RlZmluZSBGT0dfQkVBTV9NSU4gMC4wXG4jZGVmaW5lIEZPR19CRUFNX01BWCAwLjc1XG4jZGVmaW5lIEZPR19NQVNLX0dBTU1BIDAuNVxuI2RlZmluZSBGT0dfRVhQQU5EX1NIQVBFIDEyLjJcbiNkZWZpbmUgRk9HX0VER0VfTUlYIDAuNVxuXG4vLyBIb3Jpem9udGFsIHZpZ25ldHRlIGZvciB0aGUgZm9nIHZvbHVtZVxuI2RlZmluZSBIRk9HX0VER0VfU1RBUlQgMC4yMFxuI2RlZmluZSBIRk9HX0VER0VfRU5EIDAuOThcbiNkZWZpbmUgSEZPR19FREdFX0dBTU1BIDEuNFxuI2RlZmluZSBIRk9HX1lfUkFESVVTIDI1LjBcbiNkZWZpbmUgSEZPR19ZX1NPRlQgNjAuMFxuXG4vLyBCZWFtIGV4dGVudHMgYW5kIGVkZ2UgbWFza2luZ1xuI2RlZmluZSBFREdFX1gwIDAuMjJcbiNkZWZpbmUgRURHRV9YMSAwLjk5NVxuI2RlZmluZSBFREdFX1hfR0FNTUEgMS4yNVxuI2RlZmluZSBFREdFX0xVTUFfVDAgMC4wXG4jZGVmaW5lIEVER0VfTFVNQV9UMSAyLjBcbiNkZWZpbmUgRElUSEVSX1NUUkVOR1RIIDEuMFxuXG4gICAgZmxvYXQgZyhmbG9hdCB4KXtyZXR1cm4geDw9MC4wMDAzMTMwOD8xMi45Mip4OjEuMDU1KnBvdyh4LDEuMC8yLjQpLTAuMDU1O31cbiAgICBmbG9hdCBicyh2ZWMyIHAsdmVjMiBxLGZsb2F0IHBvd3Ipe1xuICAgICAgICBmbG9hdCBkPWRpc3RhbmNlKHAscSksZj1wb3dyKnVGYWxsb2ZmU3RhcnQscj0oZipmKS8oZCpkK0VQUyk7XG4gICAgICAgIHJldHVybiBwb3dyKm1pbigxLjAscik7XG4gICAgfVxuICAgIGZsb2F0IGJzYSh2ZWMyIHAsdmVjMiBxLGZsb2F0IHBvd3IsdmVjMiBzKXtcbiAgICAgICAgdmVjMiBkPXAtcTsgZmxvYXQgZGQ9KGQueCpkLngpLyhzLngqcy54KSsoZC55KmQueSkvKHMueSpzLnkpLGY9cG93cip1RmFsbG9mZlN0YXJ0LHI9KGYqZikvKGRkK0VQUyk7XG4gICAgICAgIHJldHVybiBwb3dyKm1pbigxLjAscik7XG4gICAgfVxuICAgIGZsb2F0IHRyaTAxKGZsb2F0IHgpe2Zsb2F0IGY9ZnJhY3QoeCk7cmV0dXJuIDEuMC1hYnMoZioyLjAtMS4wKTt9XG4gICAgZmxvYXQgdGF1V2YoZmxvYXQgdCxmbG9hdCB0bWluLGZsb2F0IHRtYXgpe2Zsb2F0IGE9c21vb3Roc3RlcCh0bWluLHRtaW4rRURHRV9TT0ZULHQpLGI9MS4wLXNtb290aHN0ZXAodG1heC1FREdFX1NPRlQsdG1heCx0KTtyZXR1cm4gbWF4KDAuMCxhKmIpO30gXG4gICAgZmxvYXQgaDIxKHZlYzIgcCl7cD1mcmFjdChwKnZlYzIoMTIzLjM0LDQ1Ni4yMSkpO3ArPWRvdChwLHArMzQuMTIzKTtyZXR1cm4gZnJhY3QocC54KnAueSk7fVxuICAgIGZsb2F0IHZub2lzZSh2ZWMyIHApe1xuICAgICAgICB2ZWMyIGk9Zmxvb3IocCksZj1mcmFjdChwKTtcbiAgICAgICAgZmxvYXQgYT1oMjEoaSksYj1oMjEoaSt2ZWMyKDEsMCkpLGM9aDIxKGkrdmVjMigwLDEpKSxkPWgyMShpK3ZlYzIoMSwxKSk7XG4gICAgICAgIHZlYzIgdT1mKmYqKDMuMC0yLjAqZik7XG4gICAgICAgIHJldHVybiBtaXgobWl4KGEsYix1LngpLG1peChjLGQsdS54KSx1LnkpO1xuICAgIH1cbiAgICBmbG9hdCBmYm0yKHZlYzIgcCl7XG4gICAgICAgIGZsb2F0IHY9MC4wLGFtcD0wLjY7IG1hdDIgbT1tYXQyKDAuODYsMC41LC0wLjUsMC44Nik7XG4gICAgICAgIGZvcihpbnQgaT0wO2k8Rk9HX09DVEFWRVM7KytpKXt2Kz1hbXAqdm5vaXNlKHApOyBwPW0qcCoyLjAzKzE3LjE7IGFtcCo9MC41Mjt9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBmbG9hdCByR2F0ZShmbG9hdCB4LGZsb2F0IGwpe2Zsb2F0IGE9c21vb3Roc3RlcCgwLjAsV19BQSx4KSxiPTEuMC1zbW9vdGhzdGVwKGwsbCtXX0FBLHgpO3JldHVybiBtYXgoMC4wLGEqYik7fVxuICAgIGZsb2F0IGZsYXJlWShmbG9hdCB5KXtmbG9hdCB0PWNsYW1wKDEuMC0oY2xhbXAoeSwwLjAsRkxBUkVfSEVJR0hUKS9tYXgoRkxBUkVfSEVJR0hULEVQUykpLDAuMCwxLjApO3JldHVybiBwb3codCxGTEFSRV9FWFApO31cblxuICAgIGZsb2F0IHZXaXNwcyh2ZWMyIHV2LGZsb2F0IHRvcEYpe1xuICAgIGZsb2F0IHk9dXYueSx5Zj0oeSt1Rmxvd1RpbWUqdVdTcGVlZCkvV19DRUxMO1xuICAgIGZsb2F0IGRSYXc9Y2xhbXAodVdpc3BEZW5zaXR5LDAuMCwyLjApLGQ9ZFJhdzw9MC4wPzEuMDpkUmF3O1xuICAgIGZsb2F0IGxhbmVzRj1mbG9vcihmbG9hdChXX0xBTkVTKSptaW4oZCwxLjApKzAuNSk7IC8vIFdlYkdMMS1zYWZlXG4gICAgaW50IGxhbmVzPWludChtYXgoMS4wLGxhbmVzRikpO1xuICAgIGZsb2F0IHNwPW1pbihkLDEuMCksZXA9bWF4KGQtMS4wLDAuMCk7XG4gICAgZmxvYXQgZm09ZmxhcmVZKG1heCh5LDAuMCkpLHJtPWNsYW1wKDEuMC0oeS9tYXgoV19DVVJWRV9SQU5HRSxFUFMpKSwwLjAsMS4wKSxjbT1mbSpybTtcbiAgICBjb25zdCBmbG9hdCBHPTAuMDU7IGZsb2F0IHhTPTEuMCsoRkxBUkVfQU1PVU5UKldfQ1VSVkVfQU1PVU5UKkcpKmNtO1xuICAgIGZsb2F0IHNQaXg9Y2xhbXAoeS9SX1YsMC4wLDEuMCksYkdhaW49cG93KDEuMC1zUGl4LFdfQk9UVE9NX0VYUCksc3VtPTAuMDtcbiAgICBmb3IoaW50IHM9MDtzPDI7KytzKXtcbiAgICAgICAgZmxvYXQgc2duPXM9PTA/LTEuMDoxLjA7XG4gICAgICAgIGZvcihpbnQgaT0wO2k8V19MQU5FUzsrK2kpe1xuICAgICAgICAgICAgaWYoaT49bGFuZXMpIGJyZWFrO1xuICAgICAgICAgICAgZmxvYXQgb2ZmPVdfQkFTRV9YK2Zsb2F0KGkpKldfTEFZRVJfR0FQLHhjPXNnbioob2ZmKnhTKTtcbiAgICAgICAgICAgIGZsb2F0IGR4PWFicyh1di54LXhjKSxsYXQ9MS4wLXNtb290aHN0ZXAoV19IQUxGLFdfSEFMRitXX0FBLGR4KSxhbXA9ZXhwKC1vZmYqV19TSURFX0RFQ0FZKTtcbiAgICAgICAgICAgIGZsb2F0IHNlZWQ9aDIxKHZlYzIob2ZmLHNnbioxNy4wKSkseWYyPXlmK3NlZWQqNy4wLGNpPWZsb29yKHlmMiksZnk9ZnJhY3QoeWYyKTtcbiAgICAgICAgICAgIGZsb2F0IHNlZz1taXgoV19TRUdfTUlOLFdfU0VHX01BWCxoMjEodmVjMihjaSxvZmYqMi4zKSkpO1xuICAgICAgICAgICAgZmxvYXQgc3BSPWgyMSh2ZWMyKGNpLG9mZitzZ24qMzEuMCkpLHNlZzE9ckdhdGUoZnksc2VnKSpzdGVwKHNwUixzcCk7XG4gICAgICAgICAgICBpZihlcD4wLjApe2Zsb2F0IHNwUjI9aDIxKHZlYzIoY2kqMy4xKzcuMCxvZmYqNS4zK3NnbioxMy4wKSk7IGZsb2F0IGYyPWZyYWN0KGZ5KzAuNSk7IHNlZzErPXJHYXRlKGYyLHNlZyowLjkpKnN0ZXAoc3BSMixlcCk7fVxuICAgICAgICAgICAgc3VtKz1hbXAqbGF0KnNlZzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmxvYXQgc3Bhbj1zbW9vdGhzdGVwKC0zLjAsMC4wLHkpKigxLjAtc21vb3Roc3RlcChSX1YtNi4wLFJfVix5KSk7XG4gICAgcmV0dXJuIHVXSW50ZW5zaXR5KnN1bSp0b3BGKmJHYWluKnNwYW47XG59XG5cbnZvaWQgbWFpbkltYWdlKG91dCB2ZWM0IGZjLGluIHZlYzIgZnJhZyl7XG4gICAgdmVjMiBDPWlSZXNvbHV0aW9uLnh5Ki41OyBmbG9hdCBpbnZXPTEuMC9tYXgoQy54LDEuMCk7XG4gICAgZmxvYXQgc2M9NTEyLjAvaVJlc29sdXRpb24ueCouNDtcbiAgICB2ZWMyIHV2PShmcmFnLUMpKnNjLG9mZj12ZWMyKHVCZWFtWEZyYWMqaVJlc29sdXRpb24ueCpzYyx1QmVhbVlGcmFjKmlSZXNvbHV0aW9uLnkqc2MpO1xuICAgIHZlYzIgdXZjID0gdXYgLSBvZmY7XG4gICAgZmxvYXQgYT0wLjAsYj0wLjA7XG4gICAgZmxvYXQgYmFzZVBoYXNlPTEuNSpQSSt1RGVjYXkqLjU7IGZsb2F0IHRhdU1pbj1iYXNlUGhhc2UtdURlY2F5OyBmbG9hdCB0YXVNYXg9YmFzZVBoYXNlO1xuICAgIGZsb2F0IGN4PWNsYW1wKHV2Yy54LyhSX0gqdUhMZW5GYWN0b3IpLC0xLjAsMS4wKSx0SD1jbGFtcChUV09fUEktYWNvcyhjeCksdGF1TWluLHRhdU1heCk7XG4gICAgZm9yKGludCBrPS1UQVBfUkFESVVTO2s8PVRBUF9SQURJVVM7KytrKXtcbiAgICAgICAgZmxvYXQgdHU9dEgrZmxvYXQoaykqRFRfTE9DQUwsd3Q9dGF1V2YodHUsdGF1TWluLHRhdU1heCk7IGlmKHd0PD0wLjApIGNvbnRpbnVlO1xuICAgICAgICBmbG9hdCBzcGQ9bWF4KGFicyhzaW4odHUpKSwwLjAyKSx1PWNsYW1wKChiYXNlUGhhc2UtdHUpL21heCh1RGVjYXksRVBTKSwwLjAsMS4wKSxlbnY9cG93KDEuMC1hYnModSoyLjAtMS4wKSwwLjgpO1xuICAgICAgICB2ZWMyIHA9dmVjMigoUl9IKnVITGVuRmFjdG9yKSpjb3ModHUpLDAuMCk7XG4gICAgICAgIGErPXd0KmJzKHV2YyxwLGVudipzcGQpO1xuICAgIH1cbiAgICBmbG9hdCB5UGl4PXV2Yy55LGN5PWNsYW1wKC15UGl4LyhSX1YqdVZMZW5GYWN0b3IpLC0xLjAsMS4wKSx0Vj1jbGFtcChUV09fUEktYWNvcyhjeSksdGF1TWluLHRhdU1heCk7XG4gICAgZm9yKGludCBrPS1UQVBfUkFESVVTO2s8PVRBUF9SQURJVVM7KytrKXtcbiAgICAgICAgZmxvYXQgdHU9dFYrZmxvYXQoaykqRFRfTE9DQUwsd3Q9dGF1V2YodHUsdGF1TWluLHRhdU1heCk7IGlmKHd0PD0wLjApIGNvbnRpbnVlO1xuICAgICAgICBmbG9hdCB5Yj0oLVJfVikqY29zKHR1KSxzPWNsYW1wKHliL1JfViwwLjAsMS4wKSxzcGQ9bWF4KGFicyhzaW4odHUpKSwwLjAyKTtcbiAgICAgICAgZmxvYXQgZW52PXBvdygxLjAtcywwLjYpKnNwZDtcbiAgICAgICAgZmxvYXQgY2FwPTEuMC1zbW9vdGhzdGVwKFRPUF9GQURFX1NUQVJULDEuMCxzKTsgY2FwPXBvdyhjYXAsVE9QX0ZBREVfRVhQKTsgZW52Kj1jYXA7XG4gICAgICAgIGZsb2F0IHBoPXMvbWF4KEZMT1dfUEVSSU9ELEVQUykrdUZsb3dUaW1lKnVGbG93U3BlZWQ7XG4gICAgICAgIGZsb2F0IGZsPXBvdyh0cmkwMShwaCksRkxPV19TSEFSUE5FU1MpO1xuICAgICAgICBlbnYqPW1peCgxLjAtdUZsb3dTdHJlbmd0aCwxLjAsZmwpO1xuICAgICAgICBmbG9hdCB5cD0oLVJfVip1VkxlbkZhY3RvcikqY29zKHR1KSxtPXBvdyhzbW9vdGhzdGVwKEZMQVJFX0hFSUdIVCwwLjAseXApLEZMQVJFX0VYUCksd3g9MS4wK0ZMQVJFX0FNT1VOVCptO1xuICAgICAgICB2ZWMyIHNpZz12ZWMyKHd4LDEuMCkscD12ZWMyKDAuMCx5cCk7XG4gICAgICAgIGZsb2F0IG1hc2s9c3RlcCgwLjAseXApO1xuICAgICAgICBiKz13dCpic2EodXZjLHAsbWFzayplbnYsc2lnKTtcbiAgICB9XG4gICAgZmxvYXQgc1BpeD1jbGFtcCh5UGl4L1JfViwwLjAsMS4wKSx0b3BBPXBvdygxLjAtc21vb3Roc3RlcChUT1BfRkFERV9TVEFSVCwxLjAsc1BpeCksVE9QX0ZBREVfRVhQKTtcbiAgICBmbG9hdCBMPWErYip0b3BBO1xuICAgIGZsb2F0IHc9dldpc3BzKHZlYzIodXZjLngseVBpeCksdG9wQSk7XG4gICAgZmxvYXQgZm9nPTAuMDtcbiNpZiBGT0dfT05cbiAgICB2ZWMyIGZ1dj11dmMqdUZvZ1NjYWxlO1xuICAgIGZsb2F0IG1BY3Q9c3RlcCgxLjAsbGVuZ3RoKGlNb3VzZS54eSkpLG54PSgoaU1vdXNlLngtQy54KSppbnZXKSptQWN0O1xuICAgIGZsb2F0IGF4ID0gYWJzKG54KTtcbiAgICBmbG9hdCBzdE1hZyA9IG1peChheCwgcG93KGF4LCBGT0dfVElMVF9TSEFQRSksIDAuMzUpO1xuICAgIGZsb2F0IHN0ID0gc2lnbihueCkgKiBzdE1hZyAqIHVUaWx0U2NhbGU7XG4gICAgc3QgPSBjbGFtcChzdCwgLUZPR19USUxUX01BWF9YLCBGT0dfVElMVF9NQVhfWCk7XG4gICAgdmVjMiBkaXI9bm9ybWFsaXplKHZlYzIoc3QsMS4wKSk7XG4gICAgZnV2Kz11Rm9nVGltZSp1Rm9nRmFsbFNwZWVkKmRpcjtcbiAgICB2ZWMyIHBycD12ZWMyKC1kaXIueSxkaXIueCk7XG4gICAgZnV2Kz1wcnAqKDAuMDgqc2luKGRvdCh1dmMscHJwKSowLjA4K3VGb2dUaW1lKjAuOSkpO1xuICAgIGZsb2F0IG49ZmJtMihmdXYrdmVjMihmYm0yKGZ1dit2ZWMyKDcuMywyLjEpKSxmYm0yKGZ1dit2ZWMyKC0zLjcsNS45KSkpKjAuNik7XG4gICAgbj1wb3coY2xhbXAobiwwLjAsMS4wKSxGT0dfQ09OVFJBU1QpO1xuICAgIGZsb2F0IHBpeFcgPSAxLjAgLyBtYXgoaVJlc29sdXRpb24ueSwgMS4wKTtcbiNpZmRlZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcbiAgICBmbG9hdCB3TCA9IG1heChmd2lkdGgoTCksIHBpeFcpO1xuI2Vsc2VcbiAgICBmbG9hdCB3TCA9IHBpeFc7XG4jZW5kaWZcbiAgICBmbG9hdCBtMD1wb3coc21vb3Roc3RlcChGT0dfQkVBTV9NSU4gLSB3TCwgRk9HX0JFQU1fTUFYICsgd0wsIEwpLEZPR19NQVNLX0dBTU1BKTtcbiAgICBmbG9hdCBibT0xLjAtcG93KDEuMC1tMCxGT0dfRVhQQU5EX1NIQVBFKTsgYm09bWl4KGJtKm0wLGJtLEZPR19FREdFX01JWCk7XG4gICAgZmxvYXQgeVA9MS4wLXNtb290aHN0ZXAoSEZPR19ZX1JBRElVUyxIRk9HX1lfUkFESVVTK0hGT0dfWV9TT0ZULGFicyh5UGl4KSk7XG4gICAgZmxvYXQgbnhGPWFicygoZnJhZy54LUMueCkqaW52VyksaEU9MS4wLXNtb290aHN0ZXAoSEZPR19FREdFX1NUQVJULEhGT0dfRURHRV9FTkQsbnhGKTsgaEU9cG93KGNsYW1wKGhFLDAuMCwxLjApLEhGT0dfRURHRV9HQU1NQSk7XG4gICAgZmxvYXQgaFc9bWl4KDEuMCxoRSxjbGFtcCh5UCwwLjAsMS4wKSk7XG4gICAgZmxvYXQgYkJpYXM9bWl4KDEuMCwxLjAtc1BpeCxGT0dfQk9UVE9NX0JJQVMpO1xuICAgIGZsb2F0IGJyb3dzZXJGb2dJbnRlbnNpdHkgPSB1Rm9nSW50ZW5zaXR5O1xuICAgIGJyb3dzZXJGb2dJbnRlbnNpdHkgKj0gMS44O1xuICAgIGZsb2F0IHJhZGlhbEZhZGUgPSAxLjAgLSBzbW9vdGhzdGVwKDAuMCwgMC43LCBsZW5ndGgodXZjKSAvIDEyMC4wKTtcbiAgICBmbG9hdCBzYWZhcmlGb2cgPSBuICogYnJvd3NlckZvZ0ludGVuc2l0eSAqIGJCaWFzICogYm0gKiBoVyAqIHJhZGlhbEZhZGU7XG4gICAgZm9nID0gc2FmYXJpRm9nO1xuI2VuZGlmXG4gICAgZmxvYXQgTEY9TCtmb2c7XG4gICAgZmxvYXQgZGl0aD0oaDIxKGZyYWcpLTAuNSkqKERJVEhFUl9TVFJFTkdUSC8yNTUuMCk7XG4gICAgZmxvYXQgdG9uZT1nKExGK3cpO1xuICAgIHZlYzMgY29sPXRvbmUqdUNvbG9yK2RpdGg7XG4gICAgZmxvYXQgYWxwaGE9Y2xhbXAoZyhMK3cqMC42KStkaXRoKjAuNiwwLjAsMS4wKTtcbiAgICBmbG9hdCBueEU9YWJzKChmcmFnLngtQy54KSppbnZXKSx4Rj1wb3coY2xhbXAoMS4wLXNtb290aHN0ZXAoRURHRV9YMCxFREdFX1gxLG54RSksMC4wLDEuMCksRURHRV9YX0dBTU1BKTtcbiAgICBmbG9hdCBzY2VuZT1MRittYXgoMC4wLHcpKjAuNSxoaT1zbW9vdGhzdGVwKEVER0VfTFVNQV9UMCxFREdFX0xVTUFfVDEsc2NlbmUpO1xuICAgIGZsb2F0IGVNPW1peCh4RiwxLjAsaGkpO1xuICAgIGNvbCo9ZU07IGFscGhhKj1lTTtcbiAgICBjb2wqPXVGYWRlOyBhbHBoYSo9dUZhZGU7XG4gICAgZmM9dmVjNChjb2wsYWxwaGEpO1xufVxuXG52b2lkIG1haW4oKXtcbiAgdmVjNCBmYztcbiAgbWFpbkltYWdlKGZjLCBnbF9GcmFnQ29vcmQueHkpO1xuICBnbF9GcmFnQ29sb3IgPSBmYztcbn1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYXNlckZsb3cgPSAoe1xuICBjbGFzc05hbWUsXG4gIHN0eWxlLFxuICB3aXNwRGVuc2l0eSA9IDEsXG4gIGRwcixcbiAgbW91c2VTbW9vdGhUaW1lID0gMC4wLFxuICBtb3VzZVRpbHRTdHJlbmd0aCA9IDAuMDEsXG4gIGhvcml6b250YWxCZWFtT2Zmc2V0ID0gMC4xLFxuICB2ZXJ0aWNhbEJlYW1PZmZzZXQgPSAwLjAsXG4gIGZsb3dTcGVlZCA9IDAuMzUsXG4gIHZlcnRpY2FsU2l6aW5nID0gMi4wLFxuICBob3Jpem9udGFsU2l6aW5nID0gMC41LFxuICBmb2dJbnRlbnNpdHkgPSAwLjQ1LFxuICBmb2dTY2FsZSA9IDAuMyxcbiAgd2lzcFNwZWVkID0gMTUuMCxcbiAgd2lzcEludGVuc2l0eSA9IDUuMCxcbiAgZmxvd1N0cmVuZ3RoID0gMC4yNSxcbiAgZGVjYXkgPSAxLjEsXG4gIGZhbGxvZmZTdGFydCA9IDEuMixcbiAgZm9nRmFsbFNwZWVkID0gMC42LFxuICBjb2xvciA9IFwiI0ZGNzlDNlwiLFxufSkgPT4ge1xuICBjb25zdCBtb3VudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcmVuZGVyZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHVuaWZvcm1zUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBoYXNGYWRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHJlY3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGJhc2VEcHJSZWYgPSB1c2VSZWYoMSk7XG4gIGNvbnN0IGN1cnJlbnREcHJSZWYgPSB1c2VSZWYoMSk7XG4gIGNvbnN0IGZwc1NhbXBsZXNSZWYgPSB1c2VSZWYoW10pO1xuICBjb25zdCBsYXN0RnBzQ2hlY2tSZWYgPSB1c2VSZWYocGVyZm9ybWFuY2Uubm93KCkpO1xuICBjb25zdCBlbWFEdFJlZiA9IHVzZVJlZigxNi43KTtcbiAgY29uc3QgcGF1c2VkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaW5WaWV3UmVmID0gdXNlUmVmKHRydWUpO1xuXG4gIGNvbnN0IGhleFRvUkdCID0gKGhleCkgPT4ge1xuICAgIGxldCBjID0gaGV4LnRyaW0oKTtcbiAgICBpZiAoY1swXSA9PT0gXCIjXCIpIGMgPSBjLnNsaWNlKDEpO1xuICAgIGlmIChjLmxlbmd0aCA9PT0gMylcbiAgICAgIGMgPSBjXG4gICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAubWFwKCh4KSA9PiB4ICsgeClcbiAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgY29uc3QgbiA9IHBhcnNlSW50KGMsIDE2KSB8fCAweGZmZmZmZjtcbiAgICByZXR1cm4geyByOiAoKG4gPj4gMTYpICYgMjU1KSAvIDI1NSwgZzogKChuID4+IDgpICYgMjU1KSAvIDI1NSwgYjogKG4gJiAyNTUpIC8gMjU1IH07XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBtb3VudCA9IG1vdW50UmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICBwb3dlclByZWZlcmVuY2U6IFwiaGlnaC1wZXJmb3JtYW5jZVwiLFxuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgICAgIGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgIH0pO1xuICAgIHJlbmRlcmVyUmVmLmN1cnJlbnQgPSByZW5kZXJlcjtcblxuICAgIGJhc2VEcHJSZWYuY3VycmVudCA9IE1hdGgubWluKGRwciA/PyAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSksIDIpO1xuICAgIGN1cnJlbnREcHJSZWYuY3VycmVudCA9IGJhc2VEcHJSZWYuY3VycmVudDtcblxuICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8oY3VycmVudERwclJlZi5jdXJyZW50KTtcbiAgICByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBUSFJFRS5TUkdCQ29sb3JTcGFjZTtcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAxKTtcbiAgICBjb25zdCBjYW52YXMgPSByZW5kZXJlci5kb21FbGVtZW50O1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBtb3VudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuXG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMCwgMSk7XG5cbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAwLCAzLCAtMSwgMCwgLTEsIDMsIDBdKSwgMykpO1xuXG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICBpVGltZTogeyB2YWx1ZTogMCB9LFxuICAgICAgaVJlc29sdXRpb246IHsgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpIH0sXG4gICAgICBpTW91c2U6IHsgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KDAsIDAsIDAsIDApIH0sXG4gICAgICB1V2lzcERlbnNpdHk6IHsgdmFsdWU6IHdpc3BEZW5zaXR5IH0sXG4gICAgICB1VGlsdFNjYWxlOiB7IHZhbHVlOiBtb3VzZVRpbHRTdHJlbmd0aCB9LFxuICAgICAgdUZsb3dUaW1lOiB7IHZhbHVlOiAwIH0sXG4gICAgICB1Rm9nVGltZTogeyB2YWx1ZTogMCB9LFxuICAgICAgdUJlYW1YRnJhYzogeyB2YWx1ZTogaG9yaXpvbnRhbEJlYW1PZmZzZXQgfSxcbiAgICAgIHVCZWFtWUZyYWM6IHsgdmFsdWU6IHZlcnRpY2FsQmVhbU9mZnNldCB9LFxuICAgICAgdUZsb3dTcGVlZDogeyB2YWx1ZTogZmxvd1NwZWVkIH0sXG4gICAgICB1VkxlbkZhY3RvcjogeyB2YWx1ZTogdmVydGljYWxTaXppbmcgfSxcbiAgICAgIHVITGVuRmFjdG9yOiB7IHZhbHVlOiBob3Jpem9udGFsU2l6aW5nIH0sXG4gICAgICB1Rm9nSW50ZW5zaXR5OiB7IHZhbHVlOiBmb2dJbnRlbnNpdHkgfSxcbiAgICAgIHVGb2dTY2FsZTogeyB2YWx1ZTogZm9nU2NhbGUgfSxcbiAgICAgIHVXU3BlZWQ6IHsgdmFsdWU6IHdpc3BTcGVlZCB9LFxuICAgICAgdVdJbnRlbnNpdHk6IHsgdmFsdWU6IHdpc3BJbnRlbnNpdHkgfSxcbiAgICAgIHVGbG93U3RyZW5ndGg6IHsgdmFsdWU6IGZsb3dTdHJlbmd0aCB9LFxuICAgICAgdURlY2F5OiB7IHZhbHVlOiBkZWNheSB9LFxuICAgICAgdUZhbGxvZmZTdGFydDogeyB2YWx1ZTogZmFsbG9mZlN0YXJ0IH0sXG4gICAgICB1Rm9nRmFsbFNwZWVkOiB7IHZhbHVlOiBmb2dGYWxsU3BlZWQgfSxcbiAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoMSwgMSwgMSkgfSxcbiAgICAgIHVGYWRlOiB7IHZhbHVlOiBoYXNGYWRlZFJlZi5jdXJyZW50ID8gMSA6IDAgfSxcbiAgICB9O1xuICAgIHVuaWZvcm1zUmVmLmN1cnJlbnQgPSB1bmlmb3JtcztcblxuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsKHtcbiAgICAgIHZlcnRleFNoYWRlcjogVkVSVCxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBGUkFHLFxuICAgICAgdW5pZm9ybXMsXG4gICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gICAgfSk7XG5cbiAgICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICBtZXNoLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgICBzY2VuZS5hZGQobWVzaCk7XG5cbiAgICBjb25zdCBjbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgIGxldCBwcmV2VGltZSA9IDA7XG4gICAgbGV0IGZhZGUgPSBoYXNGYWRlZFJlZi5jdXJyZW50ID8gMSA6IDA7XG5cbiAgICBjb25zdCBtb3VzZVRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IyKDAsIDApO1xuICAgIGNvbnN0IG1vdXNlU21vb3RoID0gbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCk7XG5cbiAgICBjb25zdCBzZXRTaXplTm93ID0gKCkgPT4ge1xuICAgICAgY29uc3QgdyA9IG1vdW50LmNsaWVudFdpZHRoIHx8IDE7XG4gICAgICBjb25zdCBoID0gbW91bnQuY2xpZW50SGVpZ2h0IHx8IDE7XG4gICAgICBjb25zdCBwciA9IGN1cnJlbnREcHJSZWYuY3VycmVudDtcbiAgICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8ocHIpO1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3LCBoLCBmYWxzZSk7XG4gICAgICB1bmlmb3Jtcy5pUmVzb2x1dGlvbi52YWx1ZS5zZXQodyAqIHByLCBoICogcHIsIHByKTtcbiAgICAgIHJlY3RSZWYuY3VycmVudCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9O1xuXG4gICAgbGV0IHJlc2l6ZVJhZiA9IDA7XG4gICAgY29uc3Qgc2NoZWR1bGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAocmVzaXplUmFmKSBjYW5jZWxBbmltYXRpb25GcmFtZShyZXNpemVSYWYpO1xuICAgICAgcmVzaXplUmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldFNpemVOb3cpO1xuICAgIH07XG5cbiAgICBzZXRTaXplTm93KCk7XG4gICAgY29uc3Qgcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoc2NoZWR1bGVSZXNpemUpO1xuICAgIHJvLm9ic2VydmUobW91bnQpO1xuXG4gICAgY29uc3QgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAoZW50cmllcykgPT4ge1xuICAgICAgICBpblZpZXdSZWYuY3VycmVudCA9IGVudHJpZXNbMF0/LmlzSW50ZXJzZWN0aW5nID8/IHRydWU7XG4gICAgICB9LFxuICAgICAgeyByb290OiBudWxsLCB0aHJlc2hvbGQ6IDAgfVxuICAgICk7XG4gICAgaW8ub2JzZXJ2ZShtb3VudCk7XG5cbiAgICBjb25zdCBvblZpcyA9ICgpID0+IHtcbiAgICAgIHBhdXNlZFJlZi5jdXJyZW50ID0gZG9jdW1lbnQuaGlkZGVuO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAgIGNvbnN0IHVwZGF0ZU1vdXNlID0gKGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSByZWN0UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIXJlY3QpIHJldHVybjtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3QgeSA9IGNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgIGNvbnN0IHJhdGlvID0gY3VycmVudERwclJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgaGIgPSByZWN0LmhlaWdodCAqIHJhdGlvO1xuICAgICAgbW91c2VUYXJnZXQuc2V0KHggKiByYXRpbywgaGIgLSB5ICogcmF0aW8pO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3ZlID0gKGV2KSA9PiB1cGRhdGVNb3VzZShldi5jbGllbnRYLCBldi5jbGllbnRZKTtcbiAgICBjb25zdCBvbkxlYXZlID0gKCkgPT4gbW91c2VUYXJnZXQuc2V0KDAsIDApO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgb25Nb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBvbk1vdmUsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBvbk1vdmUsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBvbkxlYXZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICBjb25zdCBvbkN0eExvc3QgPSAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGF1c2VkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3Qgb25DdHhSZXN0b3JlZCA9ICgpID0+IHtcbiAgICAgIHBhdXNlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBzY2hlZHVsZVJlc2l6ZSgpO1xuICAgIH07XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIG9uQ3R4TG9zdCwgZmFsc2UpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgb25DdHhSZXN0b3JlZCwgZmFsc2UpO1xuXG4gICAgbGV0IHJhZiA9IDA7XG5cbiAgICBjb25zdCBjbGFtcCA9ICh2LCBsbywgaGkpID0+IE1hdGgubWF4KGxvLCBNYXRoLm1pbihoaSwgdikpO1xuICAgIGNvbnN0IGRwckZsb29yID0gMC42O1xuICAgIGNvbnN0IGxvd2VyVGhyZXNoID0gNTA7XG4gICAgY29uc3QgdXBwZXJUaHJlc2ggPSA1ODtcblxuICAgIGNvbnN0IGFkanVzdERwcklmTmVlZGVkID0gKG5vdykgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIGxhc3RGcHNDaGVja1JlZi5jdXJyZW50O1xuICAgICAgaWYgKGVsYXBzZWQgPCA3NTApIHJldHVybjtcblxuICAgICAgY29uc3Qgc2FtcGxlcyA9IGZwc1NhbXBsZXNSZWYuY3VycmVudDtcbiAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsYXN0RnBzQ2hlY2tSZWYuY3VycmVudCA9IG5vdztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYXZnRnBzID0gc2FtcGxlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHNhbXBsZXMubGVuZ3RoO1xuXG4gICAgICBsZXQgbmV4dCA9IGN1cnJlbnREcHJSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGJhc2UgPSBiYXNlRHByUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChhdmdGcHMgPCBsb3dlclRocmVzaCkge1xuICAgICAgICBuZXh0ID0gY2xhbXAoY3VycmVudERwclJlZi5jdXJyZW50ICogMC45LCBkcHJGbG9vciwgYmFzZSk7XG4gICAgICB9IGVsc2UgaWYgKGF2Z0ZwcyA+IHVwcGVyVGhyZXNoICYmIGN1cnJlbnREcHJSZWYuY3VycmVudCA8IGJhc2UpIHtcbiAgICAgICAgbmV4dCA9IGNsYW1wKGN1cnJlbnREcHJSZWYuY3VycmVudCAqIDEuMDUsIGRwckZsb29yLCBiYXNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKG5leHQgLSBjdXJyZW50RHByUmVmLmN1cnJlbnQpID4gMC4wMSkge1xuICAgICAgICBjdXJyZW50RHByUmVmLmN1cnJlbnQgPSBuZXh0O1xuICAgICAgICBzZXRTaXplTm93KCk7XG4gICAgICB9XG5cbiAgICAgIGZwc1NhbXBsZXNSZWYuY3VycmVudCA9IFtdO1xuICAgICAgbGFzdEZwc0NoZWNrUmVmLmN1cnJlbnQgPSBub3c7XG4gICAgfTtcblxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICByYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICBpZiAocGF1c2VkUmVmLmN1cnJlbnQgfHwgIWluVmlld1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHQgPSBjbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgICAgY29uc3QgZHQgPSBNYXRoLm1heCgwLCB0IC0gcHJldlRpbWUpO1xuICAgICAgcHJldlRpbWUgPSB0O1xuXG4gICAgICBjb25zdCBkdE1zID0gZHQgKiAxMDAwO1xuICAgICAgZW1hRHRSZWYuY3VycmVudCA9IGVtYUR0UmVmLmN1cnJlbnQgKiAwLjkgKyBkdE1zICogMC4xO1xuICAgICAgY29uc3QgaW5zdEZwcyA9IDEwMDAgLyBNYXRoLm1heCgxLCBlbWFEdFJlZi5jdXJyZW50KTtcbiAgICAgIGZwc1NhbXBsZXNSZWYuY3VycmVudC5wdXNoKGluc3RGcHMpO1xuXG4gICAgICB1bmlmb3Jtcy5pVGltZS52YWx1ZSA9IHQ7XG5cbiAgICAgIGNvbnN0IGNkdCA9IE1hdGgubWluKDAuMDMzLCBNYXRoLm1heCgwLjAwMSwgZHQpKTtcbiAgICAgIHVuaWZvcm1zLnVGbG93VGltZS52YWx1ZSArPSBjZHQ7XG4gICAgICB1bmlmb3Jtcy51Rm9nVGltZS52YWx1ZSArPSBjZHQ7XG5cbiAgICAgIGlmICghaGFzRmFkZWRSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBmYWRlRHVyID0gMS4wO1xuICAgICAgICBmYWRlID0gTWF0aC5taW4oMSwgZmFkZSArIGNkdCAvIGZhZGVEdXIpO1xuICAgICAgICB1bmlmb3Jtcy51RmFkZS52YWx1ZSA9IGZhZGU7XG4gICAgICAgIGlmIChmYWRlID49IDEpIGhhc0ZhZGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXUgPSBNYXRoLm1heCgxZS0zLCBtb3VzZVNtb290aFRpbWUpO1xuICAgICAgY29uc3QgYWxwaGEgPSAxIC0gTWF0aC5leHAoLWNkdCAvIHRhdSk7XG4gICAgICBtb3VzZVNtb290aC5sZXJwKG1vdXNlVGFyZ2V0LCBhbHBoYSk7XG4gICAgICB1bmlmb3Jtcy5pTW91c2UudmFsdWUuc2V0KG1vdXNlU21vb3RoLngsIG1vdXNlU21vb3RoLnksIDAsIDApO1xuXG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG5cbiAgICAgIGFkanVzdERwcklmTmVlZGVkKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9O1xuXG4gICAgYW5pbWF0ZSgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgICByby5kaXNjb25uZWN0KCk7XG4gICAgICBpby5kaXNjb25uZWN0KCk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpcyk7XG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG9uTW92ZSk7XG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIG9uTW92ZSk7XG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBvbk1vdmUpO1xuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgb25MZWF2ZSk7XG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgb25DdHhMb3N0KTtcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgb25DdHhSZXN0b3JlZCk7XG4gICAgICBnZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICBtYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICByZW5kZXJlci5kaXNwb3NlKCk7XG4gICAgICBpZiAobW91bnQuY29udGFpbnMoY2FudmFzKSkgbW91bnQucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2Rwcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB1bmlmb3Jtc1JlZi5jdXJyZW50O1xuICAgIGlmICghdW5pZm9ybXMpIHJldHVybjtcblxuICAgIHVuaWZvcm1zLnVXaXNwRGVuc2l0eS52YWx1ZSA9IHdpc3BEZW5zaXR5O1xuICAgIHVuaWZvcm1zLnVUaWx0U2NhbGUudmFsdWUgPSBtb3VzZVRpbHRTdHJlbmd0aDtcbiAgICB1bmlmb3Jtcy51QmVhbVhGcmFjLnZhbHVlID0gaG9yaXpvbnRhbEJlYW1PZmZzZXQ7XG4gICAgdW5pZm9ybXMudUJlYW1ZRnJhYy52YWx1ZSA9IHZlcnRpY2FsQmVhbU9mZnNldDtcbiAgICB1bmlmb3Jtcy51Rmxvd1NwZWVkLnZhbHVlID0gZmxvd1NwZWVkO1xuICAgIHVuaWZvcm1zLnVWTGVuRmFjdG9yLnZhbHVlID0gdmVydGljYWxTaXppbmc7XG4gICAgdW5pZm9ybXMudUhMZW5GYWN0b3IudmFsdWUgPSBob3Jpem9udGFsU2l6aW5nO1xuICAgIHVuaWZvcm1zLnVGb2dJbnRlbnNpdHkudmFsdWUgPSBmb2dJbnRlbnNpdHk7XG4gICAgdW5pZm9ybXMudUZvZ1NjYWxlLnZhbHVlID0gZm9nU2NhbGU7XG4gICAgdW5pZm9ybXMudVdTcGVlZC52YWx1ZSA9IHdpc3BTcGVlZDtcbiAgICB1bmlmb3Jtcy51V0ludGVuc2l0eS52YWx1ZSA9IHdpc3BJbnRlbnNpdHk7XG4gICAgdW5pZm9ybXMudUZsb3dTdHJlbmd0aC52YWx1ZSA9IGZsb3dTdHJlbmd0aDtcbiAgICB1bmlmb3Jtcy51RGVjYXkudmFsdWUgPSBkZWNheTtcbiAgICB1bmlmb3Jtcy51RmFsbG9mZlN0YXJ0LnZhbHVlID0gZmFsbG9mZlN0YXJ0O1xuICAgIHVuaWZvcm1zLnVGb2dGYWxsU3BlZWQudmFsdWUgPSBmb2dGYWxsU3BlZWQ7XG5cbiAgICBjb25zdCB7IHIsIGcsIGIgfSA9IGhleFRvUkdCKGNvbG9yIHx8IFwiI0ZGRkZGRlwiKTtcbiAgICB1bmlmb3Jtcy51Q29sb3IudmFsdWUuc2V0KHIsIGcsIGIpO1xuICB9LCBbXG4gICAgd2lzcERlbnNpdHksXG4gICAgbW91c2VUaWx0U3RyZW5ndGgsXG4gICAgaG9yaXpvbnRhbEJlYW1PZmZzZXQsXG4gICAgdmVydGljYWxCZWFtT2Zmc2V0LFxuICAgIGZsb3dTcGVlZCxcbiAgICB2ZXJ0aWNhbFNpemluZyxcbiAgICBob3Jpem9udGFsU2l6aW5nLFxuICAgIGZvZ0ludGVuc2l0eSxcbiAgICBmb2dTY2FsZSxcbiAgICB3aXNwU3BlZWQsXG4gICAgd2lzcEludGVuc2l0eSxcbiAgICBmbG93U3RyZW5ndGgsXG4gICAgZGVjYXksXG4gICAgZmFsbG9mZlN0YXJ0LFxuICAgIGZvZ0ZhbGxTcGVlZCxcbiAgICBjb2xvcixcbiAgXSk7XG5cbiAgcmV0dXJuIDxkaXYgcmVmPXttb3VudFJlZn0gY2xhc3NOYW1lPXtgdy1mdWxsICBoLWZ1bGwgcmVsYXRpdmUgJHtjbGFzc05hbWUgfHwgXCJcIn1gfSBzdHlsZT17c3R5bGV9IC8+O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTGFzZXJGbG93O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIlRIUkVFIiwiVkVSVCIsIkZSQUciLCJMYXNlckZsb3ciLCJjbGFzc05hbWUiLCJzdHlsZSIsIndpc3BEZW5zaXR5IiwiZHByIiwibW91c2VTbW9vdGhUaW1lIiwibW91c2VUaWx0U3RyZW5ndGgiLCJob3Jpem9udGFsQmVhbU9mZnNldCIsInZlcnRpY2FsQmVhbU9mZnNldCIsImZsb3dTcGVlZCIsInZlcnRpY2FsU2l6aW5nIiwiaG9yaXpvbnRhbFNpemluZyIsImZvZ0ludGVuc2l0eSIsImZvZ1NjYWxlIiwid2lzcFNwZWVkIiwid2lzcEludGVuc2l0eSIsImZsb3dTdHJlbmd0aCIsImRlY2F5IiwiZmFsbG9mZlN0YXJ0IiwiZm9nRmFsbFNwZWVkIiwiY29sb3IiLCJtb3VudFJlZiIsInJlbmRlcmVyUmVmIiwidW5pZm9ybXNSZWYiLCJoYXNGYWRlZFJlZiIsInJlY3RSZWYiLCJiYXNlRHByUmVmIiwiY3VycmVudERwclJlZiIsImZwc1NhbXBsZXNSZWYiLCJsYXN0RnBzQ2hlY2tSZWYiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVtYUR0UmVmIiwicGF1c2VkUmVmIiwiaW5WaWV3UmVmIiwiaGV4VG9SR0IiLCJoZXgiLCJjIiwidHJpbSIsInNsaWNlIiwibGVuZ3RoIiwic3BsaXQiLCJtYXAiLCJ4Iiwiam9pbiIsIm4iLCJwYXJzZUludCIsInIiLCJnIiwiYiIsIm1vdW50IiwiY3VycmVudCIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFudGlhbGlhcyIsImFscGhhIiwiZGVwdGgiLCJzdGVuY2lsIiwicG93ZXJQcmVmZXJlbmNlIiwicHJlbXVsdGlwbGllZEFscGhhIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCIsImxvZ2FyaXRobWljRGVwdGhCdWZmZXIiLCJNYXRoIiwibWluIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFBpeGVsUmF0aW8iLCJzaGFkb3dNYXAiLCJlbmFibGVkIiwib3V0cHV0Q29sb3JTcGFjZSIsIlNSR0JDb2xvclNwYWNlIiwic2V0Q2xlYXJDb2xvciIsImNhbnZhcyIsImRvbUVsZW1lbnQiLCJ3aWR0aCIsImhlaWdodCIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmEiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJnZW9tZXRyeSIsIkJ1ZmZlckdlb21ldHJ5Iiwic2V0QXR0cmlidXRlIiwiQnVmZmVyQXR0cmlidXRlIiwiRmxvYXQzMkFycmF5IiwidW5pZm9ybXMiLCJpVGltZSIsInZhbHVlIiwiaVJlc29sdXRpb24iLCJWZWN0b3IzIiwiaU1vdXNlIiwiVmVjdG9yNCIsInVXaXNwRGVuc2l0eSIsInVUaWx0U2NhbGUiLCJ1Rmxvd1RpbWUiLCJ1Rm9nVGltZSIsInVCZWFtWEZyYWMiLCJ1QmVhbVlGcmFjIiwidUZsb3dTcGVlZCIsInVWTGVuRmFjdG9yIiwidUhMZW5GYWN0b3IiLCJ1Rm9nSW50ZW5zaXR5IiwidUZvZ1NjYWxlIiwidVdTcGVlZCIsInVXSW50ZW5zaXR5IiwidUZsb3dTdHJlbmd0aCIsInVEZWNheSIsInVGYWxsb2ZmU3RhcnQiLCJ1Rm9nRmFsbFNwZWVkIiwidUNvbG9yIiwidUZhZGUiLCJtYXRlcmlhbCIsIlJhd1NoYWRlck1hdGVyaWFsIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJ0cmFuc3BhcmVudCIsImRlcHRoVGVzdCIsImRlcHRoV3JpdGUiLCJibGVuZGluZyIsIk5vcm1hbEJsZW5kaW5nIiwibWVzaCIsIk1lc2giLCJmcnVzdHVtQ3VsbGVkIiwiYWRkIiwiY2xvY2siLCJDbG9jayIsInByZXZUaW1lIiwiZmFkZSIsIm1vdXNlVGFyZ2V0IiwiVmVjdG9yMiIsIm1vdXNlU21vb3RoIiwic2V0U2l6ZU5vdyIsInciLCJjbGllbnRXaWR0aCIsImgiLCJjbGllbnRIZWlnaHQiLCJwciIsInNldFNpemUiLCJzZXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZXNpemVSYWYiLCJzY2hlZHVsZVJlc2l6ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicm8iLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJpbyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cmllcyIsImlzSW50ZXJzZWN0aW5nIiwicm9vdCIsInRocmVzaG9sZCIsIm9uVmlzIiwiZG9jdW1lbnQiLCJoaWRkZW4iLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInVwZGF0ZU1vdXNlIiwiY2xpZW50WCIsImNsaWVudFkiLCJyZWN0IiwibGVmdCIsInkiLCJ0b3AiLCJyYXRpbyIsImhiIiwib25Nb3ZlIiwiZXYiLCJvbkxlYXZlIiwib25DdHhMb3N0IiwiZSIsInByZXZlbnREZWZhdWx0Iiwib25DdHhSZXN0b3JlZCIsInJhZiIsImNsYW1wIiwidiIsImxvIiwiaGkiLCJtYXgiLCJkcHJGbG9vciIsImxvd2VyVGhyZXNoIiwidXBwZXJUaHJlc2giLCJhZGp1c3REcHJJZk5lZWRlZCIsImVsYXBzZWQiLCJzYW1wbGVzIiwiYXZnRnBzIiwicmVkdWNlIiwiYSIsIm5leHQiLCJiYXNlIiwiYWJzIiwiYW5pbWF0ZSIsInQiLCJnZXRFbGFwc2VkVGltZSIsImR0IiwiZHRNcyIsImluc3RGcHMiLCJwdXNoIiwiY2R0IiwiZmFkZUR1ciIsInRhdSIsImV4cCIsImxlcnAiLCJyZW5kZXIiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpc3Bvc2UiLCJjb250YWlucyIsInJlbW92ZUNoaWxkIiwiZGl2IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/LaserFlow.jsx\n"));

/***/ })

});