"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/postprocessing";
exports.ids = ["vendor-chunks/postprocessing"];
exports.modules = {

/***/ "(ssr)/./node_modules/postprocessing/build/index.js":
/*!****************************************************!*\
  !*** ./node_modules/postprocessing/build/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASCIIEffect: () => (/* binding */ ASCIIEffect),\n/* harmony export */   ASCIITexture: () => (/* binding */ ASCIITexture),\n/* harmony export */   AdaptiveLuminanceMaterial: () => (/* binding */ AdaptiveLuminanceMaterial),\n/* harmony export */   AdaptiveLuminancePass: () => (/* binding */ AdaptiveLuminancePass),\n/* harmony export */   BlendFunction: () => (/* binding */ BlendFunction),\n/* harmony export */   BlendMode: () => (/* binding */ BlendMode),\n/* harmony export */   BloomEffect: () => (/* binding */ BloomEffect),\n/* harmony export */   BlurPass: () => (/* binding */ KawaseBlurPass),\n/* harmony export */   BokehEffect: () => (/* binding */ BokehEffect),\n/* harmony export */   BokehMaterial: () => (/* binding */ BokehMaterial),\n/* harmony export */   BoxBlurMaterial: () => (/* binding */ BoxBlurMaterial),\n/* harmony export */   BoxBlurPass: () => (/* binding */ BoxBlurPass),\n/* harmony export */   BrightnessContrastEffect: () => (/* binding */ BrightnessContrastEffect),\n/* harmony export */   ChromaticAberrationEffect: () => (/* binding */ ChromaticAberrationEffect),\n/* harmony export */   CircleOfConfusionMaterial: () => (/* binding */ CircleOfConfusionMaterial),\n/* harmony export */   ClearMaskPass: () => (/* binding */ ClearMaskPass),\n/* harmony export */   ClearPass: () => (/* binding */ ClearPass),\n/* harmony export */   ColorAverageEffect: () => (/* binding */ ColorAverageEffect),\n/* harmony export */   ColorChannel: () => (/* binding */ ColorChannel),\n/* harmony export */   ColorDepthEffect: () => (/* binding */ ColorDepthEffect),\n/* harmony export */   ColorEdgesMaterial: () => (/* binding */ EdgeDetectionMaterial),\n/* harmony export */   ConvolutionMaterial: () => (/* binding */ KawaseBlurMaterial),\n/* harmony export */   CopyMaterial: () => (/* binding */ CopyMaterial),\n/* harmony export */   CopyPass: () => (/* binding */ CopyPass),\n/* harmony export */   DepthComparisonMaterial: () => (/* binding */ DepthComparisonMaterial),\n/* harmony export */   DepthCopyMaterial: () => (/* binding */ DepthCopyMaterial),\n/* harmony export */   DepthCopyMode: () => (/* binding */ DepthCopyMode),\n/* harmony export */   DepthCopyPass: () => (/* binding */ DepthCopyPass),\n/* harmony export */   DepthDownsamplingMaterial: () => (/* binding */ DepthDownsamplingMaterial),\n/* harmony export */   DepthDownsamplingPass: () => (/* binding */ DepthDownsamplingPass),\n/* harmony export */   DepthEffect: () => (/* binding */ DepthEffect),\n/* harmony export */   DepthMaskMaterial: () => (/* binding */ DepthMaskMaterial),\n/* harmony export */   DepthOfFieldEffect: () => (/* binding */ DepthOfFieldEffect),\n/* harmony export */   DepthPass: () => (/* binding */ DepthPass),\n/* harmony export */   DepthPickingPass: () => (/* binding */ DepthPickingPass),\n/* harmony export */   DepthSavePass: () => (/* binding */ DepthCopyPass),\n/* harmony export */   DepthTestStrategy: () => (/* binding */ DepthTestStrategy),\n/* harmony export */   Disposable: () => (/* binding */ Disposable),\n/* harmony export */   DotScreenEffect: () => (/* binding */ DotScreenEffect),\n/* harmony export */   DownsamplingMaterial: () => (/* binding */ DownsamplingMaterial),\n/* harmony export */   EdgeDetectionMaterial: () => (/* binding */ EdgeDetectionMaterial),\n/* harmony export */   EdgeDetectionMode: () => (/* binding */ EdgeDetectionMode),\n/* harmony export */   Effect: () => (/* binding */ Effect),\n/* harmony export */   EffectAttribute: () => (/* binding */ EffectAttribute),\n/* harmony export */   EffectComposer: () => (/* binding */ EffectComposer),\n/* harmony export */   EffectMaterial: () => (/* binding */ EffectMaterial),\n/* harmony export */   EffectPass: () => (/* binding */ EffectPass),\n/* harmony export */   EffectShaderData: () => (/* binding */ EffectShaderData),\n/* harmony export */   EffectShaderSection: () => (/* binding */ EffectShaderSection),\n/* harmony export */   FXAAEffect: () => (/* binding */ FXAAEffect),\n/* harmony export */   GammaCorrectionEffect: () => (/* binding */ GammaCorrectionEffect),\n/* harmony export */   GaussKernel: () => (/* binding */ GaussKernel),\n/* harmony export */   GaussianBlurMaterial: () => (/* binding */ GaussianBlurMaterial),\n/* harmony export */   GaussianBlurPass: () => (/* binding */ GaussianBlurPass),\n/* harmony export */   GlitchEffect: () => (/* binding */ GlitchEffect),\n/* harmony export */   GlitchMode: () => (/* binding */ GlitchMode),\n/* harmony export */   GodRaysEffect: () => (/* binding */ GodRaysEffect),\n/* harmony export */   GodRaysMaterial: () => (/* binding */ GodRaysMaterial),\n/* harmony export */   GridEffect: () => (/* binding */ GridEffect),\n/* harmony export */   HueSaturationEffect: () => (/* binding */ HueSaturationEffect),\n/* harmony export */   ImmutableTimer: () => (/* binding */ ImmutableTimer),\n/* harmony export */   Initializable: () => (/* binding */ Initializable),\n/* harmony export */   KawaseBlurMaterial: () => (/* binding */ KawaseBlurMaterial),\n/* harmony export */   KawaseBlurPass: () => (/* binding */ KawaseBlurPass),\n/* harmony export */   KernelSize: () => (/* binding */ KernelSize),\n/* harmony export */   LUT1DEffect: () => (/* binding */ LUT1DEffect),\n/* harmony export */   LUT3DEffect: () => (/* binding */ LUT3DEffect),\n/* harmony export */   LUT3dlLoader: () => (/* binding */ LUT3dlLoader),\n/* harmony export */   LUTCubeLoader: () => (/* binding */ LUTCubeLoader),\n/* harmony export */   LUTEffect: () => (/* binding */ LUT3DEffect),\n/* harmony export */   LUTOperation: () => (/* binding */ LUTOperation),\n/* harmony export */   LambdaPass: () => (/* binding */ LambdaPass),\n/* harmony export */   LensDistortionEffect: () => (/* binding */ LensDistortionEffect),\n/* harmony export */   LookupTexture: () => (/* binding */ LookupTexture),\n/* harmony export */   LookupTexture3D: () => (/* binding */ LookupTexture),\n/* harmony export */   LuminanceMaterial: () => (/* binding */ LuminanceMaterial),\n/* harmony export */   LuminancePass: () => (/* binding */ LuminancePass),\n/* harmony export */   MaskFunction: () => (/* binding */ MaskFunction),\n/* harmony export */   MaskMaterial: () => (/* binding */ MaskMaterial),\n/* harmony export */   MaskPass: () => (/* binding */ MaskPass),\n/* harmony export */   MipmapBlurPass: () => (/* binding */ MipmapBlurPass),\n/* harmony export */   NoiseEffect: () => (/* binding */ NoiseEffect),\n/* harmony export */   NoiseTexture: () => (/* binding */ NoiseTexture),\n/* harmony export */   NormalPass: () => (/* binding */ NormalPass),\n/* harmony export */   OutlineEdgesMaterial: () => (/* binding */ OutlineMaterial),\n/* harmony export */   OutlineEffect: () => (/* binding */ OutlineEffect),\n/* harmony export */   OutlineMaterial: () => (/* binding */ OutlineMaterial),\n/* harmony export */   OverrideMaterialManager: () => (/* binding */ OverrideMaterialManager),\n/* harmony export */   Pass: () => (/* binding */ Pass),\n/* harmony export */   PixelationEffect: () => (/* binding */ PixelationEffect),\n/* harmony export */   PredicationMode: () => (/* binding */ PredicationMode),\n/* harmony export */   RawImageData: () => (/* binding */ RawImageData),\n/* harmony export */   RealisticBokehEffect: () => (/* binding */ RealisticBokehEffect),\n/* harmony export */   RenderPass: () => (/* binding */ RenderPass),\n/* harmony export */   Resizable: () => (/* binding */ Resizable),\n/* harmony export */   Resizer: () => (/* binding */ Resolution),\n/* harmony export */   Resolution: () => (/* binding */ Resolution),\n/* harmony export */   SMAAAreaImageData: () => (/* binding */ SMAAAreaImageData),\n/* harmony export */   SMAAEffect: () => (/* binding */ SMAAEffect),\n/* harmony export */   SMAAImageGenerator: () => (/* binding */ SMAAImageGenerator),\n/* harmony export */   SMAAImageLoader: () => (/* binding */ SMAAImageLoader),\n/* harmony export */   SMAAPreset: () => (/* binding */ SMAAPreset),\n/* harmony export */   SMAASearchImageData: () => (/* binding */ SMAASearchImageData),\n/* harmony export */   SMAAWeightsMaterial: () => (/* binding */ SMAAWeightsMaterial),\n/* harmony export */   SSAOEffect: () => (/* binding */ SSAOEffect),\n/* harmony export */   SSAOMaterial: () => (/* binding */ SSAOMaterial),\n/* harmony export */   SavePass: () => (/* binding */ CopyPass),\n/* harmony export */   ScanlineEffect: () => (/* binding */ ScanlineEffect),\n/* harmony export */   Section: () => (/* binding */ EffectShaderSection),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   SelectiveBloomEffect: () => (/* binding */ SelectiveBloomEffect),\n/* harmony export */   SepiaEffect: () => (/* binding */ SepiaEffect),\n/* harmony export */   ShaderPass: () => (/* binding */ ShaderPass),\n/* harmony export */   ShockWaveEffect: () => (/* binding */ ShockWaveEffect),\n/* harmony export */   TetrahedralUpscaler: () => (/* binding */ TetrahedralUpscaler),\n/* harmony export */   TextureEffect: () => (/* binding */ TextureEffect),\n/* harmony export */   TiltShiftBlurMaterial: () => (/* binding */ TiltShiftBlurMaterial),\n/* harmony export */   TiltShiftBlurPass: () => (/* binding */ TiltShiftBlurPass),\n/* harmony export */   TiltShiftEffect: () => (/* binding */ TiltShiftEffect),\n/* harmony export */   Timer: () => (/* binding */ Timer),\n/* harmony export */   ToneMappingEffect: () => (/* binding */ ToneMappingEffect),\n/* harmony export */   ToneMappingMode: () => (/* binding */ ToneMappingMode),\n/* harmony export */   UpsamplingMaterial: () => (/* binding */ UpsamplingMaterial),\n/* harmony export */   VignetteEffect: () => (/* binding */ VignetteEffect),\n/* harmony export */   VignetteTechnique: () => (/* binding */ VignetteTechnique),\n/* harmony export */   WebGLExtension: () => (/* binding */ WebGLExtension),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/**\n * postprocessing v6.37.8 build Fri Sep 12 2025\n * https://github.com/pmndrs/postprocessing\n * Copyright 2015-2025 Raoul van Rüschen\n * @license Zlib\n */ // package.json\nvar version = \"6.37.8\";\n// src/core/Disposable.js\nvar Disposable = class {\n    /**\n   * Frees internal resources.\n   */ dispose() {}\n};\n// src/core/EffectComposer.js\n\n// src/core/Timer.js\nvar MILLISECONDS_TO_SECONDS = 1 / 1e3;\nvar SECONDS_TO_MILLISECONDS = 1e3;\nvar Timer = class {\n    /**\n   * Constructs a new timer.\n   */ constructor(){\n        this.startTime = performance.now();\n        this.previousTime = 0;\n        this.currentTime = 0;\n        this._delta = 0;\n        this._elapsed = 0;\n        this._fixedDelta = 1e3 / 60;\n        this.timescale = 1;\n        this.useFixedDelta = false;\n        this._autoReset = false;\n    }\n    /**\n   * Enables or disables auto reset based on page visibility.\n   *\n   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page\n   * is hidden. Has no effect if the API is not supported.\n   *\n   * @type {Boolean}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n   */ get autoReset() {\n        return this._autoReset;\n    }\n    set autoReset(value) {\n        if (typeof document !== \"undefined\" && document.hidden !== void 0) {\n            if (value) {\n                document.addEventListener(\"visibilitychange\", this);\n            } else {\n                document.removeEventListener(\"visibilitychange\", this);\n            }\n            this._autoReset = value;\n        }\n    }\n    get delta() {\n        return this._delta * MILLISECONDS_TO_SECONDS;\n    }\n    get fixedDelta() {\n        return this._fixedDelta * MILLISECONDS_TO_SECONDS;\n    }\n    set fixedDelta(value) {\n        this._fixedDelta = value * SECONDS_TO_MILLISECONDS;\n    }\n    get elapsed() {\n        return this._elapsed * MILLISECONDS_TO_SECONDS;\n    }\n    /**\n   * Updates this timer.\n   *\n   * @param {Boolean} [timestamp] - The current time in milliseconds.\n   */ update(timestamp) {\n        if (this.useFixedDelta) {\n            this._delta = this.fixedDelta;\n        } else {\n            this.previousTime = this.currentTime;\n            this.currentTime = (timestamp !== void 0 ? timestamp : performance.now()) - this.startTime;\n            this._delta = this.currentTime - this.previousTime;\n        }\n        this._delta *= this.timescale;\n        this._elapsed += this._delta;\n    }\n    /**\n   * Resets this timer.\n   */ reset() {\n        this._delta = 0;\n        this._elapsed = 0;\n        this.currentTime = performance.now() - this.startTime;\n    }\n    getDelta() {\n        return this.delta;\n    }\n    getElapsed() {\n        return this.elapsed;\n    }\n    handleEvent(e) {\n        if (!document.hidden) {\n            this.currentTime = performance.now() - this.startTime;\n        }\n    }\n    dispose() {\n        this.autoReset = false;\n    }\n};\n// src/passes/Pass.js\n\nvar fullscreenGeometry = /* @__PURE__ */ (()=>{\n    const vertices = new Float32Array([\n        -1,\n        -1,\n        0,\n        3,\n        -1,\n        0,\n        -1,\n        3,\n        0\n    ]);\n    const uvs = new Float32Array([\n        0,\n        0,\n        2,\n        0,\n        0,\n        2\n    ]);\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(uvs, 2));\n    return geometry;\n})();\nvar Pass = class _Pass {\n    /**\n   * A shared fullscreen triangle.\n   *\n   * The screen size is 2x2 units (NDC). A triangle needs to be 4x4 units to fill the screen.\n   * @see https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/\n   * @type {BufferGeometry}\n   * @internal\n   */ static get fullscreenGeometry() {\n        return fullscreenGeometry;\n    }\n    /**\n   * Constructs a new pass.\n   *\n   * @param {String} [name] - The name of this pass. Does not have to be unique.\n   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.\n   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.\n   */ constructor(name = \"Pass\", scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene(), camera = new three__WEBPACK_IMPORTED_MODULE_0__.Camera()){\n        this.name = name;\n        this.renderer = null;\n        this.scene = scene;\n        this.camera = camera;\n        this.screen = null;\n        this.rtt = true;\n        this.needsSwap = true;\n        this.needsDepthTexture = false;\n        this.enabled = true;\n    }\n    /**\n   * Sets the render to screen flag.\n   *\n   * If this flag is changed, the fullscreen material will be updated as well.\n   *\n   * @type {Boolean}\n   */ get renderToScreen() {\n        return !this.rtt;\n    }\n    set renderToScreen(value) {\n        if (this.rtt === value) {\n            const material = this.fullscreenMaterial;\n            if (material !== null) {\n                material.needsUpdate = true;\n            }\n            this.rtt = !value;\n        }\n    }\n    /**\n   * Sets the main scene.\n   *\n   * @type {Scene}\n   */ set mainScene(value) {}\n    /**\n   * Sets the main camera.\n   *\n   * @type {Camera}\n   */ set mainCamera(value) {}\n    /**\n   * Sets the renderer\n   *\n   * @deprecated\n   * @param {WebGLRenderer} renderer - The renderer.\n   */ setRenderer(renderer) {\n        this.renderer = renderer;\n    }\n    /**\n   * Indicates whether this pass is enabled.\n   *\n   * @deprecated Use enabled instead.\n   * @return {Boolean} Whether this pass is enabled.\n   */ isEnabled() {\n        return this.enabled;\n    }\n    /**\n   * Enables or disables this pass.\n   *\n   * @deprecated Use enabled instead.\n   * @param {Boolean} value - Whether the pass should be enabled.\n   */ setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n   * The fullscreen material.\n   *\n   * @type {Material}\n   */ get fullscreenMaterial() {\n        return this.screen !== null ? this.screen.material : null;\n    }\n    set fullscreenMaterial(value) {\n        let screen = this.screen;\n        if (screen !== null) {\n            screen.material = value;\n        } else {\n            screen = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(_Pass.fullscreenGeometry, value);\n            screen.frustumCulled = false;\n            if (this.scene === null) {\n                this.scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n            }\n            this.scene.add(screen);\n            this.screen = screen;\n        }\n    }\n    /**\n   * Returns the current fullscreen material.\n   *\n   * @deprecated Use fullscreenMaterial instead.\n   * @return {Material} The current fullscreen material, or null if there is none.\n   */ getFullscreenMaterial() {\n        return this.fullscreenMaterial;\n    }\n    /**\n   * Sets the fullscreen material.\n   *\n   * @deprecated Use fullscreenMaterial instead.\n   * @protected\n   * @param {Material} value - A fullscreen material.\n   */ setFullscreenMaterial(value) {\n        this.fullscreenMaterial = value;\n    }\n    /**\n   * Returns the current depth texture.\n   *\n   * @return {Texture} The current depth texture, or null if there is none.\n   */ getDepthTexture() {\n        return null;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * This method will be called automatically by the {@link EffectComposer}.\n   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {}\n    /**\n   * Renders this pass.\n   *\n   * This is an abstract method that must be overridden.\n   *\n   * @abstract\n   * @throws {Error} An error is thrown if the method is not overridden.\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        throw new Error(\"Render method not implemented!\");\n    }\n    /**\n   * Sets the size.\n   *\n   * You may override this method if you want to be informed about the size of the backbuffer/canvas.\n   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {}\n    /**\n   * Performs initialization tasks.\n   *\n   * This method is called when this pass is added to an {@link EffectComposer}.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {}\n    /**\n   * Performs a shallow search for disposable properties and deletes them.\n   *\n   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free\n   * memory when you're certain that you don't need this pass anymore.\n   */ dispose() {\n        for (const key of Object.keys(this)){\n            const property = this[key];\n            const isDisposable = property instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture || property instanceof _Pass;\n            if (isDisposable) {\n                this[key].dispose();\n            }\n        }\n        if (this.fullscreenMaterial !== null) {\n            this.fullscreenMaterial.dispose();\n        }\n    }\n};\n// src/passes/ClearMaskPass.js\nvar ClearMaskPass = class extends Pass {\n    /**\n   * Constructs a new clear mask pass.\n   */ constructor(){\n        super(\"ClearMaskPass\", null, null);\n        this.needsSwap = false;\n    }\n    /**\n   * Disables the global stencil test.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const stencil = renderer.state.buffers.stencil;\n        stencil.setLocked(false);\n        stencil.setTest(false);\n    }\n};\n// src/passes/CopyPass.js\n\n// src/materials/CopyMaterial.js\n\n// src/materials/glsl/copy.frag\nvar copy_default = `#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}`;\n// src/materials/glsl/common.vert\nvar common_default = `varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/CopyMaterial.js\nvar CopyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new copy material.\n   */ constructor(){\n        super({\n            name: \"CopyMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                opacity: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: copy_default,\n            vertexShader: common_default\n        });\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Number} value - The buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Returns the opacity.\n   *\n   * @deprecated Use opacity instead.\n   * @return {Number} The opacity.\n   */ getOpacity(value) {\n        return this.uniforms.opacity.value;\n    }\n    /**\n   * Sets the opacity.\n   *\n   * @deprecated Use opacity instead.\n   * @param {Number} value - The opacity.\n   */ setOpacity(value) {\n        this.uniforms.opacity.value = value;\n    }\n};\n// src/passes/CopyPass.js\nvar CopyPass = class extends Pass {\n    /**\n   * Constructs a new save pass.\n   *\n   * @param {WebGLRenderTarget} [renderTarget] - A render target.\n   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.\n   */ constructor(renderTarget, autoResize = true){\n        super(\"CopyPass\");\n        this.fullscreenMaterial = new CopyMaterial();\n        this.needsSwap = false;\n        this.renderTarget = renderTarget;\n        if (renderTarget === void 0) {\n            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                stencilBuffer: false,\n                depthBuffer: false\n            });\n            this.renderTarget.texture.name = \"CopyPass.Target\";\n        }\n        this.autoResize = autoResize;\n    }\n    /**\n   * Enables or disables auto resizing of the render target.\n   *\n   * @deprecated Use autoResize instead.\n   * @type {Boolean}\n   */ get resize() {\n        return this.autoResize;\n    }\n    set resize(value) {\n        this.autoResize = value;\n    }\n    /**\n   * The output texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the output texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Enables or disables auto resizing of the render target.\n   *\n   * @deprecated Use autoResize instead.\n   * @param {Boolean} value - Whether the render target size should be updated automatically.\n   */ setAutoResizeEnabled(value) {\n        this.autoResize = value;\n    }\n    /**\n   * Saves the input buffer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        this.fullscreenMaterial.inputBuffer = inputBuffer.texture;\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        if (this.autoResize) {\n            this.renderTarget.setSize(width, height);\n        }\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0) {\n            this.renderTarget.texture.type = frameBufferType;\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n};\n// src/passes/ClearPass.js\n\nvar color = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Color();\nvar ClearPass = class extends Pass {\n    /**\n   * Constructs a new clear pass.\n   *\n   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.\n   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.\n   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.\n   */ constructor(color2 = true, depth = true, stencil = false){\n        super(\"ClearPass\", null, null);\n        this.needsSwap = false;\n        this.color = color2;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.overrideClearColor = null;\n        this.overrideClearAlpha = -1;\n    }\n    /**\n   * Sets the clear flags.\n   *\n   * @param {Boolean} color - Whether the color buffer should be cleared.\n   * @param {Boolean} depth - Whether the depth buffer should be cleared.\n   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.\n   */ setClearFlags(color2, depth, stencil) {\n        this.color = color2;\n        this.depth = depth;\n        this.stencil = stencil;\n    }\n    /**\n   * Returns the override clear color. Default is null.\n   *\n   * @deprecated Use overrideClearColor instead.\n   * @return {Color} The clear color.\n   */ getOverrideClearColor() {\n        return this.overrideClearColor;\n    }\n    /**\n   * Sets the override clear color.\n   *\n   * @deprecated Use overrideClearColor instead.\n   * @param {Color} value - The clear color.\n   */ setOverrideClearColor(value) {\n        this.overrideClearColor = value;\n    }\n    /**\n   * Returns the override clear alpha. Default is -1.\n   *\n   * @deprecated Use overrideClearAlpha instead.\n   * @return {Number} The clear alpha.\n   */ getOverrideClearAlpha() {\n        return this.overrideClearAlpha;\n    }\n    /**\n   * Sets the override clear alpha.\n   *\n   * @deprecated Use overrideClearAlpha instead.\n   * @param {Number} value - The clear alpha.\n   */ setOverrideClearAlpha(value) {\n        this.overrideClearAlpha = value;\n    }\n    /**\n   * Clears the input buffer or the screen.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const overrideClearColor = this.overrideClearColor;\n        const overrideClearAlpha = this.overrideClearAlpha;\n        const clearAlpha = renderer.getClearAlpha();\n        const hasOverrideClearColor = overrideClearColor !== null;\n        const hasOverrideClearAlpha = overrideClearAlpha >= 0;\n        if (hasOverrideClearColor) {\n            renderer.getClearColor(color);\n            renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);\n        } else if (hasOverrideClearAlpha) {\n            renderer.setClearAlpha(overrideClearAlpha);\n        }\n        renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);\n        renderer.clear(this.color, this.depth, this.stencil);\n        if (hasOverrideClearColor) {\n            renderer.setClearColor(color, clearAlpha);\n        } else if (hasOverrideClearAlpha) {\n            renderer.setClearAlpha(clearAlpha);\n        }\n    }\n};\n// src/passes/MaskPass.js\nvar MaskPass = class extends Pass {\n    /**\n   * Constructs a new mask pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use.\n   */ constructor(scene, camera){\n        super(\"MaskPass\", scene, camera);\n        this.needsSwap = false;\n        this.clearPass = new ClearPass(false, false, true);\n        this.inverse = false;\n    }\n    set mainScene(value) {\n        this.scene = value;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n    }\n    /**\n   * Indicates whether the mask should be inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this.inverse;\n    }\n    set inverted(value) {\n        this.inverse = value;\n    }\n    /**\n   * Indicates whether this pass should clear the stencil buffer.\n   *\n   * @type {Boolean}\n   * @deprecated Use clearPass.enabled instead.\n   */ get clear() {\n        return this.clearPass.enabled;\n    }\n    set clear(value) {\n        this.clearPass.enabled = value;\n    }\n    /**\n   * Returns the internal clear pass.\n   *\n   * @deprecated Use clearPass.enabled instead.\n   * @return {ClearPass} The clear pass.\n   */ getClearPass() {\n        return this.clearPass;\n    }\n    /**\n   * Indicates whether the mask is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the mask is inverted.\n   */ isInverted() {\n        return this.inverted;\n    }\n    /**\n   * Enables or disable mask inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the mask should be inverted.\n   */ setInverted(value) {\n        this.inverted = value;\n    }\n    /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const context = renderer.getContext();\n        const buffers = renderer.state.buffers;\n        const scene = this.scene;\n        const camera = this.camera;\n        const clearPass = this.clearPass;\n        const writeValue = this.inverted ? 0 : 1;\n        const clearValue = 1 - writeValue;\n        buffers.color.setMask(false);\n        buffers.depth.setMask(false);\n        buffers.color.setLocked(true);\n        buffers.depth.setLocked(true);\n        buffers.stencil.setTest(true);\n        buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n        buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);\n        buffers.stencil.setClear(clearValue);\n        buffers.stencil.setLocked(true);\n        if (this.clearPass.enabled) {\n            if (this.renderToScreen) {\n                clearPass.render(renderer, null);\n            } else {\n                clearPass.render(renderer, inputBuffer);\n                clearPass.render(renderer, outputBuffer);\n            }\n        }\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null);\n            renderer.render(scene, camera);\n        } else {\n            renderer.setRenderTarget(inputBuffer);\n            renderer.render(scene, camera);\n            renderer.setRenderTarget(outputBuffer);\n            renderer.render(scene, camera);\n        }\n        buffers.color.setLocked(false);\n        buffers.depth.setLocked(false);\n        buffers.stencil.setLocked(false);\n        buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);\n        buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n        buffers.stencil.setLocked(true);\n    }\n};\n// src/core/EffectComposer.js\nvar EffectComposer = class {\n    /**\n   * Constructs a new effect composer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer that should be used.\n   * @param {Object} [options] - The options.\n   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.\n   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.\n   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.\n   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.\n   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.\n   */ constructor(renderer = null, { depthBuffer = true, stencilBuffer = false, multisampling = 0, frameBufferType } = {}){\n        this.renderer = null;\n        this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);\n        this.outputBuffer = this.inputBuffer.clone();\n        this.copyPass = new CopyPass();\n        this.depthTexture = null;\n        this.passes = [];\n        this.timer = new Timer();\n        this.autoRenderToScreen = true;\n        this.setRenderer(renderer);\n    }\n    /**\n   * The current amount of samples used for multisample anti-aliasing.\n   *\n   * @type {Number}\n   */ get multisampling() {\n        return this.inputBuffer.samples || 0;\n    }\n    /**\n   * Sets the amount of MSAA samples.\n   *\n   * Requires WebGL 2. Set to zero to disable multisampling.\n   *\n   * @type {Number}\n   */ set multisampling(value) {\n        const buffer = this.inputBuffer;\n        const multisampling = this.multisampling;\n        if (multisampling > 0 && value > 0) {\n            this.inputBuffer.samples = value;\n            this.outputBuffer.samples = value;\n            this.inputBuffer.dispose();\n            this.outputBuffer.dispose();\n        } else if (multisampling !== value) {\n            this.inputBuffer.dispose();\n            this.outputBuffer.dispose();\n            this.inputBuffer = this.createBuffer(buffer.depthBuffer, buffer.stencilBuffer, buffer.texture.type, value);\n            this.inputBuffer.depthTexture = this.depthTexture;\n            this.outputBuffer = this.inputBuffer.clone();\n        }\n    }\n    /**\n   * Returns the internal timer.\n   *\n   * @return {Timer} The timer.\n   */ getTimer() {\n        return this.timer;\n    }\n    /**\n   * Returns the renderer.\n   *\n   * @return {WebGLRenderer} The renderer.\n   */ getRenderer() {\n        return this.renderer;\n    }\n    /**\n   * Sets the renderer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   */ setRenderer(renderer) {\n        this.renderer = renderer;\n        if (renderer !== null) {\n            const size = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n            const alpha = renderer.getContext().getContextAttributes().alpha;\n            const frameBufferType = this.inputBuffer.texture.type;\n            if (frameBufferType === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.inputBuffer.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.outputBuffer.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.inputBuffer.dispose();\n                this.outputBuffer.dispose();\n            }\n            renderer.autoClear = false;\n            this.setSize(size.width, size.height);\n            for (const pass of this.passes){\n                pass.initialize(renderer, alpha, frameBufferType);\n            }\n        }\n    }\n    /**\n   * Replaces the current renderer with the given one.\n   *\n   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the\n   * previous one, all passes will be updated.\n   *\n   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM\n   * element of the new renderer will take its place.\n   *\n   * @deprecated Use setRenderer instead.\n   * @param {WebGLRenderer} renderer - The new renderer.\n   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.\n   * @return {WebGLRenderer} The old renderer.\n   */ replaceRenderer(renderer, updateDOM = true) {\n        const oldRenderer = this.renderer;\n        const parent = oldRenderer.domElement.parentNode;\n        this.setRenderer(renderer);\n        if (updateDOM && parent !== null) {\n            parent.removeChild(oldRenderer.domElement);\n            parent.appendChild(renderer.domElement);\n        }\n        return oldRenderer;\n    }\n    /**\n   * Creates a depth texture attachment that will be provided to all passes.\n   *\n   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture\n   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.\n   *\n   * @private\n   * @return {DepthTexture} The depth texture.\n   */ createDepthTexture() {\n        const depthTexture = this.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture();\n        this.inputBuffer.depthTexture = depthTexture;\n        this.inputBuffer.dispose();\n        if (this.inputBuffer.stencilBuffer) {\n            depthTexture.format = three__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat;\n            depthTexture.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type;\n        } else {\n            depthTexture.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType;\n        }\n        return depthTexture;\n    }\n    /**\n   * Deletes the current depth texture.\n   *\n   * @private\n   */ deleteDepthTexture() {\n        if (this.depthTexture !== null) {\n            this.depthTexture.dispose();\n            this.depthTexture = null;\n            this.inputBuffer.depthTexture = null;\n            this.inputBuffer.dispose();\n            for (const pass of this.passes){\n                pass.setDepthTexture(null);\n            }\n        }\n    }\n    /**\n   * Creates a new render target.\n   *\n   * @deprecated Create buffers manually via WebGLRenderTarget instead.\n   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.\n   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.\n   * @param {Number} type - The frame buffer type.\n   * @param {Number} multisampling - The number of samples to use for antialiasing.\n   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.\n   */ createBuffer(depthBuffer, stencilBuffer, type, multisampling) {\n        const renderer = this.renderer;\n        const size = renderer === null ? new three__WEBPACK_IMPORTED_MODULE_0__.Vector2() : renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        const options = {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            stencilBuffer,\n            depthBuffer,\n            type\n        };\n        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(size.width, size.height, options);\n        if (multisampling > 0) {\n            renderTarget.ignoreDepthForMultisampleCopy = false;\n            renderTarget.samples = multisampling;\n        }\n        if (type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n            renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        }\n        renderTarget.texture.name = \"EffectComposer.Buffer\";\n        renderTarget.texture.generateMipmaps = false;\n        return renderTarget;\n    }\n    /**\n   * Can be used to change the main scene for all registered passes and effects.\n   *\n   * @param {Scene} scene - The scene.\n   */ setMainScene(scene) {\n        for (const pass of this.passes){\n            pass.mainScene = scene;\n        }\n    }\n    /**\n   * Can be used to change the main camera for all registered passes and effects.\n   *\n   * @param {Camera} camera - The camera.\n   */ setMainCamera(camera) {\n        for (const pass of this.passes){\n            pass.mainCamera = camera;\n        }\n    }\n    /**\n   * Adds a pass, optionally at a specific index.\n   *\n   * @param {Pass} pass - A new pass.\n   * @param {Number} [index] - An index at which the pass should be inserted.\n   */ addPass(pass, index) {\n        const passes = this.passes;\n        const renderer = this.renderer;\n        const drawingBufferSize = renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        const alpha = renderer.getContext().getContextAttributes().alpha;\n        const frameBufferType = this.inputBuffer.texture.type;\n        pass.setRenderer(renderer);\n        pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        pass.initialize(renderer, alpha, frameBufferType);\n        if (this.autoRenderToScreen) {\n            if (passes.length > 0) {\n                passes[passes.length - 1].renderToScreen = false;\n            }\n            if (pass.renderToScreen) {\n                this.autoRenderToScreen = false;\n            }\n        }\n        if (index !== void 0) {\n            passes.splice(index, 0, pass);\n        } else {\n            passes.push(pass);\n        }\n        if (this.autoRenderToScreen) {\n            passes[passes.length - 1].renderToScreen = true;\n        }\n        if (pass.needsDepthTexture || this.depthTexture !== null) {\n            if (this.depthTexture === null) {\n                const depthTexture = this.createDepthTexture();\n                for (pass of passes){\n                    pass.setDepthTexture(depthTexture);\n                }\n            } else {\n                pass.setDepthTexture(this.depthTexture);\n            }\n        }\n    }\n    /**\n   * Removes a pass.\n   *\n   * @param {Pass} pass - The pass.\n   */ removePass(pass) {\n        const passes = this.passes;\n        const index = passes.indexOf(pass);\n        const exists = index !== -1;\n        const removed = exists && passes.splice(index, 1).length > 0;\n        if (removed) {\n            if (this.depthTexture !== null) {\n                const reducer = (a, b)=>a || b.needsDepthTexture;\n                const depthTextureRequired = passes.reduce(reducer, false);\n                if (!depthTextureRequired) {\n                    if (pass.getDepthTexture() === this.depthTexture) {\n                        pass.setDepthTexture(null);\n                    }\n                    this.deleteDepthTexture();\n                }\n            }\n            if (this.autoRenderToScreen) {\n                if (index === passes.length) {\n                    pass.renderToScreen = false;\n                    if (passes.length > 0) {\n                        passes[passes.length - 1].renderToScreen = true;\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * Removes all passes.\n   */ removeAllPasses() {\n        const passes = this.passes;\n        this.deleteDepthTexture();\n        if (passes.length > 0) {\n            if (this.autoRenderToScreen) {\n                passes[passes.length - 1].renderToScreen = false;\n            }\n            this.passes = [];\n        }\n    }\n    /**\n   * Renders all enabled passes in the order in which they were added.\n   *\n   * @param {Number} [deltaTime] - The time since the last frame in seconds.\n   */ render(deltaTime) {\n        const renderer = this.renderer;\n        const copyPass = this.copyPass;\n        let inputBuffer = this.inputBuffer;\n        let outputBuffer = this.outputBuffer;\n        let stencilTest = false;\n        let context, stencil, buffer;\n        if (deltaTime === void 0) {\n            this.timer.update();\n            deltaTime = this.timer.getDelta();\n        }\n        for (const pass of this.passes){\n            if (pass.enabled) {\n                pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n                if (pass.needsSwap) {\n                    if (stencilTest) {\n                        copyPass.renderToScreen = pass.renderToScreen;\n                        context = renderer.getContext();\n                        stencil = renderer.state.buffers.stencil;\n                        stencil.setFunc(context.NOTEQUAL, 1, 4294967295);\n                        copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n                        stencil.setFunc(context.EQUAL, 1, 4294967295);\n                    }\n                    buffer = inputBuffer;\n                    inputBuffer = outputBuffer;\n                    outputBuffer = buffer;\n                }\n                if (pass instanceof MaskPass) {\n                    stencilTest = true;\n                } else if (pass instanceof ClearMaskPass) {\n                    stencilTest = false;\n                }\n            }\n        }\n    }\n    /**\n   * Sets the size of the buffers, passes and the renderer.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.\n   */ setSize(width, height, updateStyle) {\n        const renderer = this.renderer;\n        const currentSize = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        if (width === void 0 || height === void 0) {\n            width = currentSize.width;\n            height = currentSize.height;\n        }\n        if (currentSize.width !== width || currentSize.height !== height) {\n            renderer.setSize(width, height, updateStyle);\n        }\n        const drawingBufferSize = renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        for (const pass of this.passes){\n            pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        }\n    }\n    /**\n   * Resets this composer by deleting all passes and creating new buffers.\n   */ reset() {\n        this.dispose();\n        this.autoRenderToScreen = true;\n    }\n    /**\n   * Disposes this composer and all passes.\n   */ dispose() {\n        for (const pass of this.passes){\n            pass.dispose();\n        }\n        this.passes = [];\n        if (this.inputBuffer !== null) {\n            this.inputBuffer.dispose();\n        }\n        if (this.outputBuffer !== null) {\n            this.outputBuffer.dispose();\n        }\n        this.deleteDepthTexture();\n        this.copyPass.dispose();\n        this.timer.dispose();\n        Pass.fullscreenGeometry.dispose();\n    }\n};\n// src/core/EffectShaderData.js\n\n// src/enums/EffectAttribute.js\nvar EffectAttribute = {\n    NONE: 0,\n    DEPTH: 1,\n    CONVOLUTION: 2\n};\n// src/enums/EffectShaderSection.js\nvar EffectShaderSection = {\n    FRAGMENT_HEAD: \"FRAGMENT_HEAD\",\n    FRAGMENT_MAIN_UV: \"FRAGMENT_MAIN_UV\",\n    FRAGMENT_MAIN_IMAGE: \"FRAGMENT_MAIN_IMAGE\",\n    VERTEX_HEAD: \"VERTEX_HEAD\",\n    VERTEX_MAIN_SUPPORT: \"VERTEX_MAIN_SUPPORT\"\n};\n// src/core/EffectShaderData.js\nvar EffectShaderData = class {\n    /**\n   * Constructs new shader data.\n   */ constructor(){\n        this.shaderParts = /* @__PURE__ */ new Map([\n            [\n                EffectShaderSection.FRAGMENT_HEAD,\n                null\n            ],\n            [\n                EffectShaderSection.FRAGMENT_MAIN_UV,\n                null\n            ],\n            [\n                EffectShaderSection.FRAGMENT_MAIN_IMAGE,\n                null\n            ],\n            [\n                EffectShaderSection.VERTEX_HEAD,\n                null\n            ],\n            [\n                EffectShaderSection.VERTEX_MAIN_SUPPORT,\n                null\n            ]\n        ]);\n        this.defines = /* @__PURE__ */ new Map();\n        this.uniforms = /* @__PURE__ */ new Map();\n        this.blendModes = /* @__PURE__ */ new Map();\n        this.extensions = /* @__PURE__ */ new Set();\n        this.attributes = EffectAttribute.NONE;\n        this.varyings = /* @__PURE__ */ new Set();\n        this.uvTransformation = false;\n        this.readDepth = false;\n        this.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n    }\n};\n// src/core/GaussKernel.js\nfunction getCoefficients(n) {\n    let result;\n    if (n === 0) {\n        result = new Float64Array(0);\n    } else if (n === 1) {\n        result = new Float64Array([\n            1\n        ]);\n    } else if (n > 1) {\n        let row0 = new Float64Array(n);\n        let row1 = new Float64Array(n);\n        for(let y = 1; y <= n; ++y){\n            for(let x = 0; x < y; ++x){\n                row1[x] = x === 0 || x === y - 1 ? 1 : row0[x - 1] + row0[x];\n            }\n            result = row1;\n            row1 = row0;\n            row0 = result;\n        }\n    }\n    return result;\n}\nvar GaussKernel = class {\n    /**\n   * Constructs a new Gauss kernel.\n   *\n   * @param {Number} kernelSize - The kernel size. Should be an odd number in the range [3, 1020].\n   * @param {Number} [edgeBias=2] - Determines how many edge coefficients should be cut off for increased accuracy.\n   */ constructor(kernelSize, edgeBias = 2){\n        this.weights = null;\n        this.offsets = null;\n        this.linearWeights = null;\n        this.linearOffsets = null;\n        this.generate(kernelSize, edgeBias);\n    }\n    /**\n   * The number of steps for discrete sampling.\n   *\n   * @type {Number}\n   */ get steps() {\n        return this.offsets === null ? 0 : this.offsets.length;\n    }\n    /**\n   * The number of steps for linear sampling.\n   *\n   * @type {Number}\n   */ get linearSteps() {\n        return this.linearOffsets === null ? 0 : this.linearOffsets.length;\n    }\n    /**\n   * Generates the kernel.\n   *\n   * @private\n   * @param {Number} kernelSize - The kernel size.\n   * @param {Number} edgeBias - The amount of edge coefficients to ignore.\n   */ generate(kernelSize, edgeBias) {\n        if (kernelSize < 3 || kernelSize > 1020) {\n            throw new Error(\"The kernel size must be in the range [3, 1020]\");\n        }\n        const n = kernelSize + edgeBias * 2;\n        const coefficients = edgeBias > 0 ? getCoefficients(n).slice(edgeBias, -edgeBias) : getCoefficients(n);\n        const mid = Math.floor((coefficients.length - 1) / 2);\n        const sum = coefficients.reduce((a, b)=>a + b, 0);\n        const weights = coefficients.slice(mid);\n        const offsets = [\n            ...Array(mid + 1).keys()\n        ];\n        const linearWeights = new Float64Array(Math.floor(offsets.length / 2));\n        const linearOffsets = new Float64Array(linearWeights.length);\n        linearWeights[0] = weights[0] / sum;\n        for(let i = 1, j = 1, l = offsets.length - 1; i < l; i += 2, ++j){\n            const offset0 = offsets[i], offset1 = offsets[i + 1];\n            const weight0 = weights[i], weight1 = weights[i + 1];\n            const w = weight0 + weight1;\n            const o = (offset0 * weight0 + offset1 * weight1) / w;\n            linearWeights[j] = w / sum;\n            linearOffsets[j] = o;\n        }\n        for(let i = 0, l = weights.length, s = 1 / sum; i < l; ++i){\n            weights[i] *= s;\n        }\n        const linearWeightSum = (linearWeights.reduce((a, b)=>a + b, 0) - linearWeights[0] * 0.5) * 2;\n        if (linearWeightSum !== 0) {\n            for(let i = 0, l = linearWeights.length, s = 1 / linearWeightSum; i < l; ++i){\n                linearWeights[i] *= s;\n            }\n        }\n        this.offsets = offsets;\n        this.weights = weights;\n        this.linearOffsets = linearOffsets;\n        this.linearWeights = linearWeights;\n    }\n};\n// src/core/ImmutableTimer.js\nvar ImmutableTimer = class {\n    /**\n   * The current delta time in seconds.\n   *\n   * @type {Number}\n   */ getDelta() {\n        return NaN;\n    }\n    /**\n   * The elapsed time in seconds.\n   *\n   * @type {Number}\n   */ getElapsed() {\n        return NaN;\n    }\n};\n// src/core/Initializable.js\nvar Initializable = class {\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {}\n};\n// src/core/OverrideMaterialManager.js\n\nvar workaroundEnabled = false;\nvar OverrideMaterialManager = class {\n    /**\n   * Constructs a new override material manager.\n   *\n   * @param {Material} [material=null] - An override material.\n   */ constructor(material = null){\n        this.originalMaterials = /* @__PURE__ */ new Map();\n        this.material = null;\n        this.materials = null;\n        this.materialsBackSide = null;\n        this.materialsDoubleSide = null;\n        this.materialsFlatShaded = null;\n        this.materialsFlatShadedBackSide = null;\n        this.materialsFlatShadedDoubleSide = null;\n        this.setMaterial(material);\n        this.meshCount = 0;\n        this.replaceMaterial = (node)=>{\n            if (node.isMesh) {\n                let materials;\n                if (node.material.flatShading) {\n                    switch(node.material.side){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:\n                            materials = this.materialsFlatShadedDoubleSide;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.BackSide:\n                            materials = this.materialsFlatShadedBackSide;\n                            break;\n                        default:\n                            materials = this.materialsFlatShaded;\n                            break;\n                    }\n                } else {\n                    switch(node.material.side){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:\n                            materials = this.materialsDoubleSide;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.BackSide:\n                            materials = this.materialsBackSide;\n                            break;\n                        default:\n                            materials = this.materials;\n                            break;\n                    }\n                }\n                this.originalMaterials.set(node, node.material);\n                if (node.isSkinnedMesh) {\n                    node.material = materials[2];\n                } else if (node.isInstancedMesh) {\n                    node.material = materials[1];\n                } else {\n                    node.material = materials[0];\n                }\n                ++this.meshCount;\n            }\n        };\n    }\n    /**\n   * Clones the given material.\n   *\n   * @private\n   * @param {Material} material - The material.\n   * @return {Material} The cloned material.\n   */ cloneMaterial(material) {\n        if (!(material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial)) {\n            return material.clone();\n        }\n        const uniforms = material.uniforms;\n        const textureUniforms = /* @__PURE__ */ new Map();\n        for(const key in uniforms){\n            const value = uniforms[key].value;\n            if (value.isRenderTargetTexture) {\n                uniforms[key].value = null;\n                textureUniforms.set(key, value);\n            }\n        }\n        const clone = material.clone();\n        for (const entry of textureUniforms){\n            uniforms[entry[0]].value = entry[1];\n            clone.uniforms[entry[0]].value = entry[1];\n        }\n        return clone;\n    }\n    /**\n   * Sets the override material.\n   *\n   * @param {Material} material - The material.\n   */ setMaterial(material) {\n        this.disposeMaterials();\n        this.material = material;\n        if (material !== null) {\n            const materials = this.materials = [\n                this.cloneMaterial(material),\n                this.cloneMaterial(material),\n                this.cloneMaterial(material)\n            ];\n            for (const m2 of materials){\n                m2.uniforms = Object.assign({}, material.uniforms);\n                m2.side = three__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n            }\n            materials[2].skinning = true;\n            this.materialsBackSide = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.side = three__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n                return c2;\n            });\n            this.materialsDoubleSide = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n                return c2;\n            });\n            this.materialsFlatShaded = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.flatShading = true;\n                return c2;\n            });\n            this.materialsFlatShadedBackSide = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.flatShading = true;\n                c2.side = three__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n                return c2;\n            });\n            this.materialsFlatShadedDoubleSide = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.flatShading = true;\n                c2.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n                return c2;\n            });\n        }\n    }\n    /**\n   * Renders the scene with the override material.\n   *\n   * @private\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Scene} scene - A scene.\n   * @param {Camera} camera - A camera.\n   */ render(renderer, scene, camera) {\n        const shadowMapEnabled = renderer.shadowMap.enabled;\n        renderer.shadowMap.enabled = false;\n        if (workaroundEnabled) {\n            const originalMaterials = this.originalMaterials;\n            this.meshCount = 0;\n            scene.traverse(this.replaceMaterial);\n            renderer.render(scene, camera);\n            for (const entry of originalMaterials){\n                entry[0].material = entry[1];\n            }\n            if (this.meshCount !== originalMaterials.size) {\n                originalMaterials.clear();\n            }\n        } else {\n            const overrideMaterial = scene.overrideMaterial;\n            scene.overrideMaterial = this.material;\n            renderer.render(scene, camera);\n            scene.overrideMaterial = overrideMaterial;\n        }\n        renderer.shadowMap.enabled = shadowMapEnabled;\n    }\n    /**\n   * Deletes cloned override materials.\n   *\n   * @private\n   */ disposeMaterials() {\n        if (this.material !== null) {\n            const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);\n            for (const m2 of materials){\n                m2.dispose();\n            }\n        }\n    }\n    /**\n   * Performs cleanup tasks.\n   */ dispose() {\n        this.originalMaterials.clear();\n        this.disposeMaterials();\n    }\n    /**\n   * Indicates whether the override material workaround is enabled.\n   *\n   * @type {Boolean}\n   */ static get workaroundEnabled() {\n        return workaroundEnabled;\n    }\n    /**\n   * Enables or disables the override material workaround globally.\n   *\n   * This only affects post processing passes and effects.\n   *\n   * @type {Boolean}\n   */ static set workaroundEnabled(value) {\n        workaroundEnabled = value;\n    }\n};\n// src/core/Resizable.js\nvar Resizable = class {\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {}\n};\n// src/core/Resolution.js\n\nvar AUTO_SIZE = -1;\nvar Resolution = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n    /**\n   * Constructs a new resolution.\n   *\n   * TODO Remove resizable param.\n   * @param {Resizable} resizable - A resizable object.\n   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.\n   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.\n   * @param {Number} [scale=1.0] - A resolution scale.\n   */ constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1){\n        super();\n        this.resizable = resizable;\n        this.baseSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n        this.preferredSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(width, height);\n        this.target = this.preferredSize;\n        this.s = scale;\n        this.effectiveSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.addEventListener(\"change\", ()=>this.updateEffectiveSize());\n        this.updateEffectiveSize();\n    }\n    /**\n   * Calculates the effective size.\n   *\n   * @private\n   */ updateEffectiveSize() {\n        const base = this.baseSize;\n        const preferred = this.preferredSize;\n        const effective = this.effectiveSize;\n        const scale = this.scale;\n        if (preferred.width !== AUTO_SIZE) {\n            effective.width = preferred.width;\n        } else if (preferred.height !== AUTO_SIZE) {\n            effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));\n        } else {\n            effective.width = Math.round(base.width * scale);\n        }\n        if (preferred.height !== AUTO_SIZE) {\n            effective.height = preferred.height;\n        } else if (preferred.width !== AUTO_SIZE) {\n            effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));\n        } else {\n            effective.height = Math.round(base.height * scale);\n        }\n    }\n    /**\n   * The effective width.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.\n   *\n   * @type {Number}\n   */ get width() {\n        return this.effectiveSize.width;\n    }\n    set width(value) {\n        this.preferredWidth = value;\n    }\n    /**\n   * The effective height.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.\n   *\n   * @type {Number}\n   */ get height() {\n        return this.effectiveSize.height;\n    }\n    set height(value) {\n        this.preferredHeight = value;\n    }\n    /**\n   * Returns the effective width.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.\n   *\n   * @deprecated Use width instead.\n   * @return {Number} The effective width.\n   */ getWidth() {\n        return this.width;\n    }\n    /**\n   * Returns the effective height.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.\n   *\n   * @deprecated Use height instead.\n   * @return {Number} The effective height.\n   */ getHeight() {\n        return this.height;\n    }\n    /**\n   * The resolution scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.s;\n    }\n    set scale(value) {\n        if (this.s !== value) {\n            this.s = value;\n            this.preferredSize.setScalar(AUTO_SIZE);\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */ getScale() {\n        return this.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The scale.\n   */ setScale(value) {\n        this.scale = value;\n    }\n    /**\n   * The base width.\n   *\n   * @type {Number}\n   */ get baseWidth() {\n        return this.baseSize.width;\n    }\n    set baseWidth(value) {\n        if (this.baseSize.width !== value) {\n            this.baseSize.width = value;\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the base width.\n   *\n   * @deprecated Use baseWidth instead.\n   * @return {Number} The base width.\n   */ getBaseWidth() {\n        return this.baseWidth;\n    }\n    /**\n   * Sets the base width.\n   *\n   * @deprecated Use baseWidth instead.\n   * @param {Number} value - The width.\n   */ setBaseWidth(value) {\n        this.baseWidth = value;\n    }\n    /**\n   * The base height.\n   *\n   * @type {Number}\n   */ get baseHeight() {\n        return this.baseSize.height;\n    }\n    set baseHeight(value) {\n        if (this.baseSize.height !== value) {\n            this.baseSize.height = value;\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the base height.\n   *\n   * @deprecated Use baseHeight instead.\n   * @return {Number} The base height.\n   */ getBaseHeight() {\n        return this.baseHeight;\n    }\n    /**\n   * Sets the base height.\n   *\n   * @deprecated Use baseHeight instead.\n   * @param {Number} value - The height.\n   */ setBaseHeight(value) {\n        this.baseHeight = value;\n    }\n    /**\n   * Sets the base size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setBaseSize(width, height) {\n        if (this.baseSize.width !== width || this.baseSize.height !== height) {\n            this.baseSize.set(width, height);\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * The preferred width.\n   *\n   * @type {Number}\n   */ get preferredWidth() {\n        return this.preferredSize.width;\n    }\n    set preferredWidth(value) {\n        if (this.preferredSize.width !== value) {\n            this.preferredSize.width = value;\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the preferred width.\n   *\n   * @deprecated Use preferredWidth instead.\n   * @return {Number} The preferred width.\n   */ getPreferredWidth() {\n        return this.preferredWidth;\n    }\n    /**\n   * Sets the preferred width.\n   *\n   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.\n   *\n   * @deprecated Use preferredWidth instead.\n   * @param {Number} value - The width.\n   */ setPreferredWidth(value) {\n        this.preferredWidth = value;\n    }\n    /**\n   * The preferred height.\n   *\n   * @type {Number}\n   */ get preferredHeight() {\n        return this.preferredSize.height;\n    }\n    set preferredHeight(value) {\n        if (this.preferredSize.height !== value) {\n            this.preferredSize.height = value;\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the preferred height.\n   *\n   * @deprecated Use preferredHeight instead.\n   * @return {Number} The preferred height.\n   */ getPreferredHeight() {\n        return this.preferredHeight;\n    }\n    /**\n   * Sets the preferred height.\n   *\n   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.\n   *\n   * @deprecated Use preferredHeight instead.\n   * @param {Number} value - The height.\n   */ setPreferredHeight(value) {\n        this.preferredHeight = value;\n    }\n    /**\n   * Sets the preferred size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setPreferredSize(width, height) {\n        if (this.preferredSize.width !== width || this.preferredSize.height !== height) {\n            this.preferredSize.set(width, height);\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Copies the given resolution.\n   *\n   * @param {Resolution} resolution - The resolution.\n   */ copy(resolution) {\n        this.s = resolution.scale;\n        this.baseSize.set(resolution.baseWidth, resolution.baseHeight);\n        this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);\n        this.dispatchEvent({\n            type: \"change\"\n        });\n        this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n    /**\n   * An auto sizing constant.\n   *\n   * Can be used to automatically calculate the width or height based on the original aspect ratio.\n   *\n   * @type {Number}\n   */ static get AUTO_SIZE() {\n        return AUTO_SIZE;\n    }\n};\n// src/utils/IdManager.js\nvar IdManager = class {\n    /**\n   * Constructs a new ID manager.\n   *\n   * @param initialId - The first ID.\n   */ constructor(initialId = 0){\n        this.nextId = initialId;\n    }\n    /**\n   * Returns the next unique ID.\n   *\n   * @return The ID.\n   */ getNextId() {\n        return this.nextId++;\n    }\n    /**\n   * Resets the ID counter.\n   *\n   * @param initialId - The first ID.\n   * @return This manager.\n   */ reset(initialId = 0) {\n        this.nextId = initialId;\n        return this;\n    }\n};\n// src/core/Selection.js\nvar idManager = /* @__PURE__ */ new IdManager(2);\nvar Selection = class extends Set {\n    /**\n   * Constructs a new selection.\n   *\n   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.\n   * @param {Number} [layer] - A dedicated render layer for selected objects. Range is `[2, 31]`. Starts at 2 if omitted.\n   */ constructor(iterable, layer = idManager.getNextId()){\n        super();\n        this.exclusive = false;\n        this._layer = layer;\n        if (this._layer < 1 || this._layer > 31) {\n            console.warn(\"Layer out of range, resetting to 2\");\n            idManager.reset(2);\n            this._layer = idManager.getNextId();\n        }\n        if (iterable !== void 0) {\n            this.set(iterable);\n        }\n    }\n    /**\n   * The render layer for selected objects.\n   *\n   * @type {Number}\n   */ get layer() {\n        return this._layer;\n    }\n    set layer(value) {\n        const currentLayer = this._layer;\n        for (const object of this){\n            object.layers.disable(currentLayer);\n            object.layers.enable(value);\n        }\n        this._layer = value;\n    }\n    /**\n   * Returns the current render layer for selected objects.\n   *\n   * The default layer is 2. If this collides with your own custom layers, please change it before rendering!\n   *\n   * @deprecated Use layer instead.\n   * @return {Number} The layer.\n   */ getLayer() {\n        return this.layer;\n    }\n    /**\n   * Sets the render layer for selected objects.\n   *\n   * The current selection will be updated accordingly.\n   *\n   * @deprecated Use layer instead.\n   * @param {Number} value - The layer. Range is [0, 31].\n   */ setLayer(value) {\n        this.layer = value;\n    }\n    /**\n   * Indicates whether objects that are added to this selection will be removed from all other layers.\n   *\n   * @deprecated Use exclusive instead.\n   * @return {Number} Whether this selection is exclusive. Default is false.\n   */ isExclusive() {\n        return this.exclusive;\n    }\n    /**\n   * Controls whether objects that are added to this selection should be removed from all other layers.\n   *\n   * @deprecated Use exclusive instead.\n   * @param {Number} value - Whether this selection should be exclusive.\n   */ setExclusive(value) {\n        this.exclusive = value;\n    }\n    /**\n   * Clears this selection.\n   *\n   * @return {Selection} This selection.\n   */ clear() {\n        const layer = this.layer;\n        for (const object of this){\n            object.layers.disable(layer);\n        }\n        return super.clear();\n    }\n    /**\n   * Clears this selection and adds the given objects.\n   *\n   * @param {Iterable<Object3D>} objects - The objects that should be selected.\n   * @return {Selection} This selection.\n   */ set(objects) {\n        this.clear();\n        for (const object of objects){\n            this.add(object);\n        }\n        return this;\n    }\n    /**\n   * An alias for {@link has}.\n   *\n   * @param {Object3D} object - An object.\n   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.\n   * @deprecated Added for backward-compatibility.\n   */ indexOf(object) {\n        return this.has(object) ? 0 : -1;\n    }\n    /**\n   * Adds an object to this selection.\n   *\n   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.\n   *\n   * @param {Object3D} object - The object that should be selected.\n   * @return {Selection} This selection.\n   */ add(object) {\n        if (this.exclusive) {\n            object.layers.set(this.layer);\n        } else {\n            object.layers.enable(this.layer);\n        }\n        return super.add(object);\n    }\n    /**\n   * Removes an object from this selection.\n   *\n   * @param {Object3D} object - The object that should be deselected.\n   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.\n   */ delete(object) {\n        if (this.has(object)) {\n            object.layers.disable(this.layer);\n        }\n        return super.delete(object);\n    }\n    /**\n   * Removes an existing object from the selection. If the object doesn't exist it's added instead.\n   *\n   * @param {Object3D} object - The object.\n   * @return {Boolean} Returns true if the object is added, false otherwise.\n   */ toggle(object) {\n        let result;\n        if (this.has(object)) {\n            this.delete(object);\n            result = false;\n        } else {\n            this.add(object);\n            result = true;\n        }\n        return result;\n    }\n    /**\n   * Sets the visibility of all selected objects.\n   *\n   * This method enables or disables render layer 0 of all selected objects.\n   *\n   * @param {Boolean} visible - Whether the selected objects should be visible.\n   * @return {Selection} This selection.\n   */ setVisible(visible) {\n        for (const object of this){\n            if (visible) {\n                object.layers.enable(0);\n            } else {\n                object.layers.disable(0);\n            }\n        }\n        return this;\n    }\n};\n// src/effects/blending/BlendMode.js\n\n// src/enums/BlendFunction.js\nvar BlendFunction = {\n    SKIP: 9,\n    SET: 30,\n    ADD: 0,\n    ALPHA: 1,\n    AVERAGE: 2,\n    COLOR: 3,\n    COLOR_BURN: 4,\n    COLOR_DODGE: 5,\n    DARKEN: 6,\n    DIFFERENCE: 7,\n    DIVIDE: 8,\n    DST: 9,\n    EXCLUSION: 10,\n    HARD_LIGHT: 11,\n    HARD_MIX: 12,\n    HUE: 13,\n    INVERT: 14,\n    INVERT_RGB: 15,\n    LIGHTEN: 16,\n    LINEAR_BURN: 17,\n    LINEAR_DODGE: 18,\n    LINEAR_LIGHT: 19,\n    LUMINOSITY: 20,\n    MULTIPLY: 21,\n    NEGATION: 22,\n    NORMAL: 23,\n    OVERLAY: 24,\n    PIN_LIGHT: 25,\n    REFLECT: 26,\n    SATURATION: 27,\n    SCREEN: 28,\n    SOFT_LIGHT: 29,\n    SRC: 30,\n    SUBTRACT: 31,\n    VIVID_LIGHT: 32\n};\n// src/effects/blending/glsl/add.frag\nvar add_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}`;\n// src/effects/blending/glsl/alpha.frag\nvar alpha_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}`;\n// src/effects/blending/glsl/average.frag\nvar average_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}`;\n// src/effects/blending/glsl/color.frag\nvar color_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/color-burn.frag\nvar color_burn_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/color-dodge.frag\nvar color_dodge_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/darken.frag\nvar darken_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}`;\n// src/effects/blending/glsl/difference.frag\nvar difference_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}`;\n// src/effects/blending/glsl/divide.frag\nvar divide_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}`;\n// src/effects/blending/glsl/exclusion.frag\nvar exclusion_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}`;\n// src/effects/blending/glsl/hard-light.frag\nvar hard_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/hard-mix.frag\nvar hard_mix_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}`;\n// src/effects/blending/glsl/hue.frag\nvar hue_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/invert.frag\nvar invert_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}`;\n// src/effects/blending/glsl/invert-rgb.frag\nvar invert_rgb_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}`;\n// src/effects/blending/glsl/lighten.frag\nvar lighten_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}`;\n// src/effects/blending/glsl/linear-burn.frag\nvar linear_burn_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}`;\n// src/effects/blending/glsl/linear-dodge.frag\nvar linear_dodge_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}`;\n// src/effects/blending/glsl/linear-light.frag\nvar linear_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}`;\n// src/effects/blending/glsl/luminosity.frag\nvar luminosity_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/multiply.frag\nvar multiply_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}`;\n// src/effects/blending/glsl/negation.frag\nvar negation_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}`;\n// src/effects/blending/glsl/normal.frag\nvar normal_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}`;\n// src/effects/blending/glsl/overlay.frag\nvar overlay_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/pin-light.frag\nvar pin_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/reflect.frag\nvar reflect_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/saturation.frag\nvar saturation_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/screen.frag\nvar screen_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}`;\n// src/effects/blending/glsl/soft-light.frag\nvar soft_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/glsl/src.frag\nvar src_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}`;\n// src/effects/blending/glsl/subtract.frag\nvar subtract_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}`;\n// src/effects/blending/glsl/vivid-light.frag\nvar vivid_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}`;\n// src/effects/blending/BlendMode.js\nvar blendFunctions = /* @__PURE__ */ new Map([\n    [\n        BlendFunction.ADD,\n        add_default\n    ],\n    [\n        BlendFunction.ALPHA,\n        alpha_default\n    ],\n    [\n        BlendFunction.AVERAGE,\n        average_default\n    ],\n    [\n        BlendFunction.COLOR,\n        color_default\n    ],\n    [\n        BlendFunction.COLOR_BURN,\n        color_burn_default\n    ],\n    [\n        BlendFunction.COLOR_DODGE,\n        color_dodge_default\n    ],\n    [\n        BlendFunction.DARKEN,\n        darken_default\n    ],\n    [\n        BlendFunction.DIFFERENCE,\n        difference_default\n    ],\n    [\n        BlendFunction.DIVIDE,\n        divide_default\n    ],\n    [\n        BlendFunction.DST,\n        null\n    ],\n    [\n        BlendFunction.EXCLUSION,\n        exclusion_default\n    ],\n    [\n        BlendFunction.HARD_LIGHT,\n        hard_light_default\n    ],\n    [\n        BlendFunction.HARD_MIX,\n        hard_mix_default\n    ],\n    [\n        BlendFunction.HUE,\n        hue_default\n    ],\n    [\n        BlendFunction.INVERT,\n        invert_default\n    ],\n    [\n        BlendFunction.INVERT_RGB,\n        invert_rgb_default\n    ],\n    [\n        BlendFunction.LIGHTEN,\n        lighten_default\n    ],\n    [\n        BlendFunction.LINEAR_BURN,\n        linear_burn_default\n    ],\n    [\n        BlendFunction.LINEAR_DODGE,\n        linear_dodge_default\n    ],\n    [\n        BlendFunction.LINEAR_LIGHT,\n        linear_light_default\n    ],\n    [\n        BlendFunction.LUMINOSITY,\n        luminosity_default\n    ],\n    [\n        BlendFunction.MULTIPLY,\n        multiply_default\n    ],\n    [\n        BlendFunction.NEGATION,\n        negation_default\n    ],\n    [\n        BlendFunction.NORMAL,\n        normal_default\n    ],\n    [\n        BlendFunction.OVERLAY,\n        overlay_default\n    ],\n    [\n        BlendFunction.PIN_LIGHT,\n        pin_light_default\n    ],\n    [\n        BlendFunction.REFLECT,\n        reflect_default\n    ],\n    [\n        BlendFunction.SATURATION,\n        saturation_default\n    ],\n    [\n        BlendFunction.SCREEN,\n        screen_default\n    ],\n    [\n        BlendFunction.SOFT_LIGHT,\n        soft_light_default\n    ],\n    [\n        BlendFunction.SRC,\n        src_default\n    ],\n    [\n        BlendFunction.SUBTRACT,\n        subtract_default\n    ],\n    [\n        BlendFunction.VIVID_LIGHT,\n        vivid_light_default\n    ]\n]);\nvar BlendMode = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n    /**\n   * Constructs a new blend mode.\n   *\n   * @param {BlendFunction} blendFunction - The blend function.\n   * @param {Number} opacity - The opacity of the color that will be blended with the base color.\n   */ constructor(blendFunction, opacity = 1){\n        super();\n        this._blendFunction = blendFunction;\n        this.opacity = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(opacity);\n    }\n    /**\n   * Returns the opacity.\n   *\n   * @return {Number} The opacity.\n   */ getOpacity() {\n        return this.opacity.value;\n    }\n    /**\n   * Sets the opacity.\n   *\n   * @param {Number} value - The opacity.\n   */ setOpacity(value) {\n        this.opacity.value = value;\n    }\n    /**\n   * The blend function.\n   *\n   * @type {BlendFunction}\n   */ get blendFunction() {\n        return this._blendFunction;\n    }\n    set blendFunction(value) {\n        this._blendFunction = value;\n        this.dispatchEvent({\n            type: \"change\"\n        });\n    }\n    /**\n   * Returns the blend function.\n   *\n   * @deprecated Use blendFunction instead.\n   * @return {BlendFunction} The blend function.\n   */ getBlendFunction() {\n        return this.blendFunction;\n    }\n    /**\n   * Sets the blend function.\n   *\n   * @deprecated Use blendFunction instead.\n   * @param {BlendFunction} value - The blend function.\n   */ setBlendFunction(value) {\n        this.blendFunction = value;\n    }\n    /**\n   * Returns the blend function shader code.\n   *\n   * @return {String} The blend function shader code.\n   */ getShaderCode() {\n        return blendFunctions.get(this.blendFunction);\n    }\n};\n// src/effects/ASCIIEffect.js\n\n// src/textures/ASCIITexture.js\n\nvar ASCIITexture = class extends three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture {\n    /**\n   * Constructs a new ASCII texture.\n   *\n   * @param {Object} [options] - The options.\n   * @param {String} [options.characters] - The character set to render. Defaults to a common ASCII art charset.\n   * @param {String} [options.font=\"Arial\"] - The font.\n   * @param {Number} [options.fontSize=54] - The font size in pixels.\n   * @param {Number} [options.size=1024] - The texture size.\n   * @param {Number} [options.cellCount=16] - The cell count along each side of the texture.\n   */ constructor({ characters = \" .:,'-^=*+?!|0#X%WM@\", font = \"Arial\", fontSize = 54, size = 1024, cellCount = 16 } = {}){\n        super(document.createElement(\"canvas\"), void 0, three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping);\n        const canvas = this.image;\n        canvas.width = canvas.height = size;\n        const context = canvas.getContext(\"2d\");\n        const cellSize = size / cellCount;\n        context.font = `${fontSize}px ${font}`;\n        context.textAlign = \"center\";\n        context.textBaseline = \"middle\";\n        context.fillStyle = \"#ffffff\";\n        for(let i = 0, l = characters.length; i < l; ++i){\n            const char = characters[i];\n            const x = i % cellCount;\n            const y = Math.floor(i / cellCount);\n            context.fillText(char, x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);\n        }\n        this.characterCount = characters.length;\n        this.cellCount = cellCount;\n    }\n};\n// src/effects/Effect.js\n\nvar Effect = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n    /**\n   * Constructs a new effect.\n   *\n   * @param {String} name - The name of this effect. Doesn't have to be unique.\n   * @param {String} fragmentShader - The fragment shader. This shader is required.\n   * @param {Object} [options] - Additional options.\n   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.\n   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.\n   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.\n   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.\n   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.\n   */ constructor(name, fragmentShader, { attributes = EffectAttribute.NONE, blendFunction = BlendFunction.NORMAL, defines = /* @__PURE__ */ new Map(), uniforms = /* @__PURE__ */ new Map(), extensions = null, vertexShader = null } = {}){\n        super();\n        this.name = name;\n        this.renderer = null;\n        this.attributes = attributes;\n        this.fragmentShader = fragmentShader;\n        this.vertexShader = vertexShader;\n        this.defines = defines;\n        this.uniforms = uniforms;\n        this.extensions = extensions;\n        this.blendMode = new BlendMode(blendFunction);\n        this.blendMode.addEventListener(\"change\", (event)=>this.setChanged());\n        this._inputColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n        this._outputColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace;\n    }\n    /**\n   * The input color space.\n   *\n   * @type {ColorSpace}\n   * @experimental\n   */ get inputColorSpace() {\n        return this._inputColorSpace;\n    }\n    /**\n   * @type {ColorSpace}\n   * @protected\n   * @experimental\n   */ set inputColorSpace(value) {\n        this._inputColorSpace = value;\n        this.setChanged();\n    }\n    /**\n   * The output color space.\n   *\n   * Should only be changed if this effect converts the input colors to a different color space.\n   *\n   * @type {ColorSpace}\n   * @experimental\n   */ get outputColorSpace() {\n        return this._outputColorSpace;\n    }\n    /**\n   * @type {ColorSpace}\n   * @protected\n   * @experimental\n   */ set outputColorSpace(value) {\n        this._outputColorSpace = value;\n        this.setChanged();\n    }\n    /**\n   * Sets the main scene.\n   *\n   * @type {Scene}\n   */ set mainScene(value) {}\n    /**\n   * Sets the main camera.\n   *\n   * @type {Camera}\n   */ set mainCamera(value) {}\n    /**\n   * Returns the name of this effect.\n   *\n   * @deprecated Use name instead.\n   * @return {String} The name.\n   */ getName() {\n        return this.name;\n    }\n    /**\n   * Sets the renderer.\n   *\n   * @deprecated\n   * @param {WebGLRenderer} renderer - The renderer.\n   */ setRenderer(renderer) {\n        this.renderer = renderer;\n    }\n    /**\n   * Returns the preprocessor macro definitions.\n   *\n   * @deprecated Use defines instead.\n   * @return {Map<String, String>} The extensions.\n   */ getDefines() {\n        return this.defines;\n    }\n    /**\n   * Returns the uniforms of this effect.\n   *\n   * @deprecated Use uniforms instead.\n   * @return {Map<String, Uniform>} The extensions.\n   */ getUniforms() {\n        return this.uniforms;\n    }\n    /**\n   * Returns the WebGL extensions that are required by this effect.\n   *\n   * @deprecated Use extensions instead.\n   * @return {Set<WebGLExtension>} The extensions.\n   */ getExtensions() {\n        return this.extensions;\n    }\n    /**\n   * Returns the blend mode.\n   *\n   * The result of this effect will be blended with the result of the previous effect using this blend mode.\n   *\n   * @deprecated Use blendMode instead.\n   * @return {BlendMode} The blend mode.\n   */ getBlendMode() {\n        return this.blendMode;\n    }\n    /**\n   * Returns the effect attributes.\n   *\n   * @return {EffectAttribute} The attributes.\n   */ getAttributes() {\n        return this.attributes;\n    }\n    /**\n   * Sets the effect attributes.\n   *\n   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes\n   * imply a higher priority.\n   *\n   * @protected\n   * @param {EffectAttribute} attributes - The attributes.\n   */ setAttributes(attributes) {\n        this.attributes = attributes;\n        this.setChanged();\n    }\n    /**\n   * Returns the fragment shader.\n   *\n   * @return {String} The fragment shader.\n   */ getFragmentShader() {\n        return this.fragmentShader;\n    }\n    /**\n   * Sets the fragment shader.\n   *\n   * @protected\n   * @param {String} fragmentShader - The fragment shader.\n   */ setFragmentShader(fragmentShader) {\n        this.fragmentShader = fragmentShader;\n        this.setChanged();\n    }\n    /**\n   * Returns the vertex shader.\n   *\n   * @return {String} The vertex shader.\n   */ getVertexShader() {\n        return this.vertexShader;\n    }\n    /**\n   * Sets the vertex shader.\n   *\n   * @protected\n   * @param {String} vertexShader - The vertex shader.\n   */ setVertexShader(vertexShader) {\n        this.vertexShader = vertexShader;\n        this.setChanged();\n    }\n    /**\n   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.\n   *\n   * Should be called after changing macros or extensions and after adding/removing uniforms.\n   *\n   * @protected\n   */ setChanged() {\n        this.dispatchEvent({\n            type: \"change\"\n        });\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * You may override this method if your effect requires direct access to the depth texture that is bound to the\n   * associated {@link EffectPass}.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {}\n    /**\n   * Updates this effect by performing supporting operations.\n   *\n   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the\n   * blend function is set to `SKIP`.\n   *\n   * You may override this method if you need to update custom uniforms or render additional off-screen textures.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {}\n    /**\n   * Updates the size of this effect.\n   *\n   * You may override this method if you want to be informed about the size of the backbuffer/canvas.\n   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {}\n    /**\n   * Performs initialization tasks.\n   *\n   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }\n   */ initialize(renderer, alpha, frameBufferType) {}\n    /**\n   * Performs a shallow search for properties that define a dispose method and deletes them.\n   *\n   * The {@link EffectComposer} calls this method when it is being destroyed.\n   */ dispose() {\n        for (const key of Object.keys(this)){\n            const property = this[key];\n            const isDisposable = property instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture || property instanceof Pass;\n            if (isDisposable) {\n                this[key].dispose();\n            }\n        }\n    }\n};\n// src/effects/glsl/ascii.frag\nvar ascii_default = `uniform sampler2D asciiTexture;uniform vec4 cellCount;\n#ifdef USE_COLOR\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 pixelizedUv=cellCount.zw*(0.5+floor(uv*cellCount.xy));vec4 texel=texture(inputBuffer,pixelizedUv);float lum=min(luminance(texel.rgb),1.0);\n#ifdef INVERTED\nlum=1.0-lum;\n#endif\nfloat characterIndex=floor(CHAR_COUNT_MINUS_ONE*lum);vec2 characterPosition=vec2(mod(characterIndex,TEX_CELL_COUNT),floor(characterIndex*INV_TEX_CELL_COUNT));vec2 offset=vec2(characterPosition.x,-characterPosition.y)*INV_TEX_CELL_COUNT;vec2 characterUv=mod(uv*(cellCount.xy*INV_TEX_CELL_COUNT),INV_TEX_CELL_COUNT);characterUv=characterUv-vec2(0.0,INV_TEX_CELL_COUNT)+offset;float asciiCharacter=texture(asciiTexture,characterUv).r;\n#ifdef USE_COLOR\noutputColor=vec4(color*asciiCharacter,inputColor.a);\n#else\noutputColor=vec4(texel.rgb*asciiCharacter,inputColor.a);\n#endif\n}`;\n// src/effects/ASCIIEffect.js\nvar ASCIIEffect = class extends Effect {\n    /**\n   * Constructs a new ASCII effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {ASCIITexture} [options.asciiTexture] - An ASCII character lookup texture.\n   * @param {Number} [options.cellSize=16] - The cell size. It's recommended to use even numbers.\n   * @param {Number} [options.color=null] - A color to use instead of the scene colors.\n   * @param {Boolean} [options.inverted=false] - Inverts the effect.\n   */ constructor({ asciiTexture = new ASCIITexture(), cellSize = 16, color: color2 = null, inverted = false } = {}){\n        super(\"ASCIIEffect\", ascii_default, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"asciiTexture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"cellCount\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4())\n                ],\n                [\n                    \"color\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color())\n                ]\n            ])\n        });\n        this._cellSize = -1;\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.asciiTexture = asciiTexture;\n        this.cellSize = cellSize;\n        this.color = color2;\n        this.inverted = inverted;\n    }\n    /**\n   * The current ASCII lookup texture.\n   *\n   * @type {ASCIITexture}\n   */ get asciiTexture() {\n        return this.uniforms.get(\"asciiTexture\").value;\n    }\n    set asciiTexture(value) {\n        const currentTexture = this.uniforms.get(\"asciiTexture\").value;\n        this.uniforms.get(\"asciiTexture\").value = value;\n        if (currentTexture !== null && currentTexture !== value) {\n            currentTexture.dispose();\n        }\n        if (value !== null) {\n            const cellCount = value.cellCount;\n            this.defines.set(\"CHAR_COUNT_MINUS_ONE\", (value.characterCount - 1).toFixed(1));\n            this.defines.set(\"TEX_CELL_COUNT\", cellCount.toFixed(1));\n            this.defines.set(\"INV_TEX_CELL_COUNT\", (1 / cellCount).toFixed(9));\n            this.setChanged();\n        }\n    }\n    /**\n   * A color that overrides the scene colors.\n   *\n   * @type {Color | String | Number | null}\n   */ get color() {\n        return this.uniforms.get(\"color\").value;\n    }\n    set color(value) {\n        if (value !== null) {\n            this.uniforms.get(\"color\").value.set(value);\n        }\n        if (this.defines.has(\"USE_COLOR\") && value === null) {\n            this.defines.delete(\"USE_COLOR\");\n            this.setChanged();\n        } else if (!this.defines.has(\"USE_COLOR\") && value !== null) {\n            this.defines.set(\"USE_COLOR\", \"1\");\n            this.setChanged();\n        }\n    }\n    /**\n   * Controls whether the effect should be inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this.defines.has(\"INVERTED\");\n    }\n    set inverted(value) {\n        if (this.inverted !== value) {\n            if (value) {\n                this.defines.set(\"INVERTED\", \"1\");\n            } else {\n                this.defines.delete(\"INVERTED\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * The cell size.\n   *\n   * @type {Number}\n   */ get cellSize() {\n        return this._cellSize;\n    }\n    set cellSize(value) {\n        if (this._cellSize !== value) {\n            this._cellSize = value;\n            this.updateCellCount();\n        }\n    }\n    /**\n   * Updates the cell count uniform.\n   *\n   * @private\n   */ updateCellCount() {\n        const cellCount = this.uniforms.get(\"cellCount\").value;\n        const resolution = this.resolution;\n        cellCount.x = resolution.width / this.cellSize;\n        cellCount.y = resolution.height / this.cellSize;\n        cellCount.z = 1 / cellCount.x;\n        cellCount.w = 1 / cellCount.y;\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.resolution.set(width, height);\n        this.updateCellCount();\n    }\n    /**\n   * Deletes internal render targets and textures.\n   */ dispose() {\n        if (this.asciiTexture !== null) {\n            this.asciiTexture.dispose();\n        }\n        super.dispose();\n    }\n};\n// src/effects/BloomEffect.js\n\n// src/enums/KernelSize.js\nvar KernelSize = {\n    VERY_SMALL: 0,\n    SMALL: 1,\n    MEDIUM: 2,\n    LARGE: 3,\n    VERY_LARGE: 4,\n    HUGE: 5\n};\n// src/passes/KawaseBlurPass.js\n\n// src/materials/KawaseBlurMaterial.js\n\n// src/materials/glsl/convolution.kawase.frag\nvar convolution_kawase_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}`;\n// src/materials/glsl/convolution.kawase.vert\nvar convolution_kawase_default2 = `uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/KawaseBlurMaterial.js\nvar kernelPresets = [\n    new Float32Array([\n        0,\n        0\n    ]),\n    new Float32Array([\n        0,\n        1,\n        1\n    ]),\n    new Float32Array([\n        0,\n        1,\n        1,\n        2\n    ]),\n    new Float32Array([\n        0,\n        1,\n        2,\n        2,\n        3\n    ]),\n    new Float32Array([\n        0,\n        1,\n        2,\n        3,\n        4,\n        4,\n        5\n    ]),\n    new Float32Array([\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        7,\n        8,\n        9,\n        10\n    ])\n];\nvar KawaseBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new convolution material.\n   *\n   * TODO Remove texelSize param.\n   * @param {Vector4} [texelSize] - Deprecated.\n   */ constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4()){\n        super({\n            name: \"KawaseBlurMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4()),\n                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                kernel: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_kawase_default,\n            vertexShader: convolution_kawase_default2\n        });\n        this.setTexelSize(texelSize.x, texelSize.y);\n        this.kernelSize = KernelSize.MEDIUM;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.inputBuffer = value;\n    }\n    /**\n   * The kernel sequence for the current kernel size.\n   *\n   * @type {Float32Array}\n   */ get kernelSequence() {\n        return kernelPresets[this.kernelSize];\n    }\n    /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * Returns the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */ getScale() {\n        return this.uniforms.scale.value;\n    }\n    /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} value - The scale.\n   */ setScale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * Returns the kernel.\n   *\n   * @return {Float32Array} The kernel.\n   * @deprecated Implementation detail, removed with no replacement.\n   */ getKernel() {\n        return null;\n    }\n    /**\n   * The current kernel.\n   *\n   * @type {Number}\n   */ get kernel() {\n        return this.uniforms.kernel.value;\n    }\n    set kernel(value) {\n        this.uniforms.kernel.value = value;\n    }\n    /**\n   * Sets the current kernel.\n   *\n   * @deprecated Use kernel instead.\n   * @param {Number} value - The kernel.\n   */ setKernel(value) {\n        this.kernel = value;\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const x = 1 / width, y = 1 / height;\n        this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);\n    }\n};\n// src/passes/KawaseBlurPass.js\nvar KawaseBlurPass = class extends Pass {\n    /**\n   * Constructs a new Kawase blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor({ kernelSize = KernelSize.MEDIUM, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"KawaseBlurPass\");\n        this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetA.texture.name = \"Blur.Target.A\";\n        this.renderTargetB = this.renderTargetA.clone();\n        this.renderTargetB.texture.name = \"Blur.Target.B\";\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this._blurMaterial = new KawaseBlurMaterial();\n        this._blurMaterial.kernelSize = kernelSize;\n        this.copyMaterial = new CopyMaterial();\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * The blur material.\n   *\n   * @type {KawaseBlurMaterial}\n   */ get blurMaterial() {\n        return this._blurMaterial;\n    }\n    /**\n   * The blur material.\n   *\n   * @type {KawaseBlurMaterial}\n   * @protected\n   */ set blurMaterial(value) {\n        this._blurMaterial = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use copyMaterial.dithering instead.\n   */ get dithering() {\n        return this.copyMaterial.dithering;\n    }\n    set dithering(value) {\n        this.copyMaterial.dithering = value;\n    }\n    /**\n   * The kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurMaterial.kernelSize instead.\n   */ get kernelSize() {\n        return this.blurMaterial.kernelSize;\n    }\n    set kernelSize(value) {\n        this.blurMaterial.kernelSize = value;\n    }\n    /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */ get width() {\n        return this.resolution.width;\n    }\n    /**\n   * Sets the render width.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.preferredWidth instead.\n   */ set width(value) {\n        this.resolution.preferredWidth = value;\n    }\n    /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */ get height() {\n        return this.resolution.height;\n    }\n    /**\n   * Sets the render height.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.preferredHeight instead.\n   */ set height(value) {\n        this.resolution.preferredHeight = value;\n    }\n    /**\n   * The current blur scale.\n   *\n   * @type {Number}\n   * @deprecated Use blurMaterial.scale instead.\n   */ get scale() {\n        return this.blurMaterial.scale;\n    }\n    set scale(value) {\n        this.blurMaterial.scale = value;\n    }\n    /**\n   * Returns the current blur scale.\n   *\n   * @deprecated Use blurMaterial.scale instead.\n   * @return {Number} The scale.\n   */ getScale() {\n        return this.blurMaterial.scale;\n    }\n    /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use blurMaterial.scale instead.\n   * @param {Number} value - The scale.\n   */ setScale(value) {\n        this.blurMaterial.scale = value;\n    }\n    /**\n   * Returns the kernel size.\n   *\n   * @deprecated Use blurMaterial.kernelSize instead.\n   * @return {KernelSize} The kernel size.\n   */ getKernelSize() {\n        return this.kernelSize;\n    }\n    /**\n   * Sets the kernel size.\n   *\n   * Larger kernels require more processing power but scale well with larger render resolutions.\n   *\n   * @deprecated Use blurMaterial.kernelSize instead.\n   * @param {KernelSize} value - The kernel size.\n   */ setKernelSize(value) {\n        this.kernelSize = value;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const renderTargetA = this.renderTargetA;\n        const renderTargetB = this.renderTargetB;\n        const material = this.blurMaterial;\n        const kernelSequence = material.kernelSequence;\n        let previousBuffer = inputBuffer;\n        this.fullscreenMaterial = material;\n        for(let i = 0, l = kernelSequence.length; i < l; ++i){\n            const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;\n            material.kernel = kernelSequence[i];\n            material.inputBuffer = previousBuffer.texture;\n            renderer.setRenderTarget(buffer);\n            renderer.render(scene, camera);\n            previousBuffer = buffer;\n        }\n        this.fullscreenMaterial = this.copyMaterial;\n        this.copyMaterial.inputBuffer = previousBuffer.texture;\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(scene, camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.renderTargetA.setSize(w, h);\n        this.renderTargetB.setSize(w, h);\n        this.blurMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0) {\n            this.renderTargetA.texture.type = frameBufferType;\n            this.renderTargetB.texture.type = frameBufferType;\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n                this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTargetA.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.renderTargetB.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n    /**\n   * An auto sizing flag.\n   *\n   * @type {Number}\n   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.\n   */ static get AUTO_SIZE() {\n        return Resolution.AUTO_SIZE;\n    }\n};\n// src/passes/LuminancePass.js\n\n// src/materials/LuminanceMaterial.js\n\n// src/materials/glsl/luminance.frag\nvar luminance_default = `#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);mask=low*high;\n#elif defined(THRESHOLD)\nmask=smoothstep(threshold,threshold+smoothing,l);\n#endif\n#ifdef COLOR\ngl_FragColor=texel*mask;\n#else\ngl_FragColor=vec4(l*mask);\n#endif\n}`;\n// src/materials/LuminanceMaterial.js\nvar LuminanceMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new luminance material.\n   *\n   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.\n   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.\n   */ constructor(colorOutput = false, luminanceRange = null){\n        super({\n            name: \"LuminanceMaterial\",\n            defines: {\n                THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                threshold: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n                smoothing: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                range: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: luminance_default,\n            vertexShader: common_default\n        });\n        this.colorOutput = colorOutput;\n        this.luminanceRange = luminanceRange;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The luminance threshold.\n   *\n   * @type {Number}\n   */ get threshold() {\n        return this.uniforms.threshold.value;\n    }\n    set threshold(value) {\n        if (this.smoothing > 0 || value > 0) {\n            this.defines.THRESHOLD = \"1\";\n        } else {\n            delete this.defines.THRESHOLD;\n        }\n        this.uniforms.threshold.value = value;\n    }\n    /**\n   * Returns the luminance threshold.\n   *\n   * @deprecated Use threshold instead.\n   * @return {Number} The threshold.\n   */ getThreshold() {\n        return this.threshold;\n    }\n    /**\n   * Sets the luminance threshold.\n   *\n   * @deprecated Use threshold instead.\n   * @param {Number} value - The threshold.\n   */ setThreshold(value) {\n        this.threshold = value;\n    }\n    /**\n   * The luminance threshold smoothing.\n   *\n   * @type {Number}\n   */ get smoothing() {\n        return this.uniforms.smoothing.value;\n    }\n    set smoothing(value) {\n        if (this.threshold > 0 || value > 0) {\n            this.defines.THRESHOLD = \"1\";\n        } else {\n            delete this.defines.THRESHOLD;\n        }\n        this.uniforms.smoothing.value = value;\n    }\n    /**\n   * Returns the luminance threshold smoothing factor.\n   *\n   * @deprecated Use smoothing instead.\n   * @return {Number} The smoothing factor.\n   */ getSmoothingFactor() {\n        return this.smoothing;\n    }\n    /**\n   * Sets the luminance threshold smoothing factor.\n   *\n   * @deprecated Use smoothing instead.\n   * @param {Number} value - The smoothing factor.\n   */ setSmoothingFactor(value) {\n        this.smoothing = value;\n    }\n    /**\n   * Indicates whether the luminance threshold is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Adjust the threshold or smoothing factor instead.\n   */ get useThreshold() {\n        return this.threshold > 0 || this.smoothing > 0;\n    }\n    set useThreshold(value) {}\n    /**\n   * Indicates whether color output is enabled.\n   *\n   * @type {Boolean}\n   */ get colorOutput() {\n        return this.defines.COLOR !== void 0;\n    }\n    set colorOutput(value) {\n        if (value) {\n            this.defines.COLOR = \"1\";\n        } else {\n            delete this.defines.COLOR;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether color output is enabled.\n   *\n   * @deprecated Use colorOutput instead.\n   * @return {Boolean} Whether color output is enabled.\n   */ isColorOutputEnabled(value) {\n        return this.colorOutput;\n    }\n    /**\n   * Enables or disables color output.\n   *\n   * @deprecated Use colorOutput instead.\n   * @param {Boolean} value - Whether color output should be enabled.\n   */ setColorOutputEnabled(value) {\n        this.colorOutput = value;\n    }\n    /**\n   * Indicates whether luminance masking is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get useRange() {\n        return this.luminanceRange !== null;\n    }\n    set useRange(value) {\n        this.luminanceRange = null;\n    }\n    /**\n   * The luminance range. Set to null to disable.\n   *\n   * @type {Boolean}\n   */ get luminanceRange() {\n        return this.uniforms.range.value;\n    }\n    set luminanceRange(value) {\n        if (value !== null) {\n            this.defines.RANGE = \"1\";\n        } else {\n            delete this.defines.RANGE;\n        }\n        this.uniforms.range.value = value;\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the current luminance range.\n   *\n   * @deprecated Use luminanceRange instead.\n   * @return {Vector2} The luminance range.\n   */ getLuminanceRange() {\n        return this.luminanceRange;\n    }\n    /**\n   * Sets a luminance range. Set to null to disable.\n   *\n   * @deprecated Use luminanceRange instead.\n   * @param {Vector2} value - The luminance range.\n   */ setLuminanceRange(value) {\n        this.luminanceRange = value;\n    }\n};\n// src/passes/LuminancePass.js\nvar LuminancePass = class extends Pass {\n    /**\n   * Constructs a new luminance pass.\n   *\n   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor({ renderTarget, luminanceRange, colorOutput, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"LuminancePass\");\n        this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);\n        this.needsSwap = false;\n        this.renderTarget = renderTarget;\n        if (this.renderTarget === void 0) {\n            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n                depthBuffer: false\n            });\n            this.renderTarget.texture.name = \"LuminancePass.Target\";\n        }\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    /**\n   * The luminance texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the luminance texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Renders the luminance.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const material = this.fullscreenMaterial;\n        material.inputBuffer = inputBuffer.texture;\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            this.renderTarget.texture.type = frameBufferType;\n            this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        }\n    }\n};\n// src/passes/MipmapBlurPass.js\n\n// src/materials/DownsamplingMaterial.js\n\n// src/materials/glsl/convolution.downsampling.frag\nvar convolution_downsampling_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}`;\n// src/materials/glsl/convolution.downsampling.vert\nvar convolution_downsampling_default2 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/DownsamplingMaterial.js\nvar DownsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new downsampling material.\n   */ constructor(){\n        super({\n            name: \"DownsamplingMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_downsampling_default,\n            vertexShader: convolution_downsampling_default2\n        });\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/UpsamplingMaterial.js\n\n// src/materials/glsl/convolution.upsampling.frag\nvar convolution_upsampling_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}`;\n// src/materials/glsl/convolution.upsampling.vert\nvar convolution_upsampling_default2 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/UpsamplingMaterial.js\nvar UpsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new upsampling material.\n   */ constructor(){\n        super({\n            name: \"UpsamplingMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                supportBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                radius: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.85)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_upsampling_default,\n            vertexShader: convolution_upsampling_default2\n        });\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * A support buffer.\n   *\n   * @type {Texture}\n   */ set supportBuffer(value) {\n        this.uniforms.supportBuffer.value = value;\n    }\n    /**\n   * The blur radius.\n   *\n   * @type {Number}\n   */ get radius() {\n        return this.uniforms.radius.value;\n    }\n    set radius(value) {\n        this.uniforms.radius.value = value;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/passes/MipmapBlurPass.js\nvar MipmapBlurPass = class extends Pass {\n    /**\n   * Constructs a new mipmap blur pass.\n   *\n   * @param {Object} [options] - The options.\n   */ constructor(){\n        super(\"MipmapBlurPass\");\n        this.needsSwap = false;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"Upsampling.Mipmap0\";\n        this.downsamplingMipmaps = [];\n        this.upsamplingMipmaps = [];\n        this.downsamplingMaterial = new DownsamplingMaterial();\n        this.upsamplingMaterial = new UpsamplingMaterial();\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    }\n    /**\n   * A texture that contains the blurred result.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * The MIP levels. Default is 8.\n   *\n   * @type {Number}\n   */ get levels() {\n        return this.downsamplingMipmaps.length;\n    }\n    set levels(value) {\n        if (this.levels !== value) {\n            const renderTarget = this.renderTarget;\n            this.dispose();\n            this.downsamplingMipmaps = [];\n            this.upsamplingMipmaps = [];\n            for(let i = 0; i < value; ++i){\n                const mipmap = renderTarget.clone();\n                mipmap.texture.name = \"Downsampling.Mipmap\" + i;\n                this.downsamplingMipmaps.push(mipmap);\n            }\n            this.upsamplingMipmaps.push(renderTarget);\n            for(let i = 1, l = value - 1; i < l; ++i){\n                const mipmap = renderTarget.clone();\n                mipmap.texture.name = \"Upsampling.Mipmap\" + i;\n                this.upsamplingMipmaps.push(mipmap);\n            }\n            this.setSize(this.resolution.x, this.resolution.y);\n        }\n    }\n    /**\n   * The blur radius.\n   *\n   * @type {Number}\n   */ get radius() {\n        return this.upsamplingMaterial.radius;\n    }\n    set radius(value) {\n        this.upsamplingMaterial.radius = value;\n    }\n    /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const { scene, camera } = this;\n        const { downsamplingMaterial, upsamplingMaterial } = this;\n        const { downsamplingMipmaps, upsamplingMipmaps } = this;\n        let previousBuffer = inputBuffer;\n        this.fullscreenMaterial = downsamplingMaterial;\n        for(let i = 0, l = downsamplingMipmaps.length; i < l; ++i){\n            const mipmap = downsamplingMipmaps[i];\n            downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);\n            downsamplingMaterial.inputBuffer = previousBuffer.texture;\n            renderer.setRenderTarget(mipmap);\n            renderer.render(scene, camera);\n            previousBuffer = mipmap;\n        }\n        this.fullscreenMaterial = upsamplingMaterial;\n        for(let i = upsamplingMipmaps.length - 1; i >= 0; --i){\n            const mipmap = upsamplingMipmaps[i];\n            upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);\n            upsamplingMaterial.inputBuffer = previousBuffer.texture;\n            upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;\n            renderer.setRenderTarget(mipmap);\n            renderer.render(scene, camera);\n            previousBuffer = mipmap;\n        }\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.set(width, height);\n        let w = resolution.width, h = resolution.height;\n        for(let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i){\n            w = Math.round(w * 0.5);\n            h = Math.round(h * 0.5);\n            this.downsamplingMipmaps[i].setSize(w, h);\n            if (i < this.upsamplingMipmaps.length) {\n                this.upsamplingMipmaps[i].setSize(w, h);\n            }\n        }\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0) {\n            const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);\n            for (const mipmap of mipmaps){\n                mipmap.texture.type = frameBufferType;\n            }\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n                this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                for (const mipmap of mipmaps){\n                    mipmap.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                }\n            }\n        }\n    }\n    /**\n   * Deletes internal render targets and textures.\n   */ dispose() {\n        super.dispose();\n        for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)){\n            mipmap.dispose();\n        }\n    }\n};\n// src/effects/glsl/bloom.frag\nvar bloom_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`;\n// src/effects/BloomEffect.js\nvar BloomEffect = class extends Effect {\n    /**\n   * Constructs a new bloom effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Number} [options.luminanceThreshold=1.0] - The luminance threshold. Raise this value to mask out darker elements in the scene.\n   * @param {Number} [options.luminanceSmoothing=0.03] - Controls the smoothness of the luminance threshold.\n   * @param {Boolean} [options.mipmapBlur=true] - Enables or disables mipmap blur.\n   * @param {Number} [options.intensity=1.0] - The bloom intensity.\n   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.\n   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.\n   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   */ constructor({ blendFunction = BlendFunction.SCREEN, luminanceThreshold = 1, luminanceSmoothing = 0.03, mipmapBlur = true, intensity = 1, radius = 0.85, levels = 8, kernelSize = KernelSize.LARGE, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"BloomEffect\", bloom_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"map\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"intensity\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(intensity)\n                ]\n            ])\n        });\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"Bloom.Target\";\n        this.blurPass = new KawaseBlurPass({\n            kernelSize\n        });\n        this.luminancePass = new LuminancePass({\n            colorOutput: true\n        });\n        this.luminanceMaterial.threshold = luminanceThreshold;\n        this.luminanceMaterial.smoothing = luminanceSmoothing;\n        this.mipmapBlurPass = new MipmapBlurPass();\n        this.mipmapBlurPass.enabled = mipmapBlur;\n        this.mipmapBlurPass.radius = radius;\n        this.mipmapBlurPass.levels = levels;\n        this.uniforms.get(\"map\").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    /**\n   * A texture that contains the intermediate result of this effect.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;\n    }\n    /**\n   * Returns the generated bloom texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Returns the blur pass.\n   *\n   * @deprecated\n   * @return {KawaseBlurPass} The blur pass.\n   */ getBlurPass() {\n        return this.blurPass;\n    }\n    /**\n   * Returns the luminance pass.\n   *\n   * @deprecated Use luminancePass instead.\n   * @return {LuminancePass} The luminance pass.\n   */ getLuminancePass() {\n        return this.luminancePass;\n    }\n    /**\n   * The luminance material.\n   *\n   * @type {LuminanceMaterial}\n   */ get luminanceMaterial() {\n        return this.luminancePass.fullscreenMaterial;\n    }\n    /**\n   * Returns the luminance material.\n   *\n   * @deprecated Use luminanceMaterial instead.\n   * @return {LuminanceMaterial} The material.\n   */ getLuminanceMaterial() {\n        return this.luminancePass.fullscreenMaterial;\n    }\n    /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated\n   */ get width() {\n        return this.resolution.width;\n    }\n    set width(value) {\n        this.resolution.preferredWidth = value;\n    }\n    /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated\n   */ get height() {\n        return this.resolution.height;\n    }\n    set height(value) {\n        this.resolution.preferredHeight = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use EffectPass.dithering instead.\n   */ get dithering() {\n        return this.blurPass.dithering;\n    }\n    set dithering(value) {\n        this.blurPass.dithering = value;\n    }\n    /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated\n   */ get kernelSize() {\n        return this.blurPass.kernelSize;\n    }\n    set kernelSize(value) {\n        this.blurPass.kernelSize = value;\n    }\n    /**\n   * @type {Number}\n   * @deprecated\n   */ get distinction() {\n        console.warn(this.name, \"distinction was removed\");\n        return 1;\n    }\n    set distinction(value) {\n        console.warn(this.name, \"distinction was removed\");\n    }\n    /**\n   * The bloom intensity.\n   *\n   * @type {Number}\n   */ get intensity() {\n        return this.uniforms.get(\"intensity\").value;\n    }\n    set intensity(value) {\n        this.uniforms.get(\"intensity\").value = value;\n    }\n    /**\n   * The bloom intensity.\n   *\n   * @deprecated Use intensity instead.\n   * @return {Number} The intensity.\n   */ getIntensity() {\n        return this.intensity;\n    }\n    /**\n   * Sets the bloom intensity.\n   *\n   * @deprecated Use intensity instead.\n   * @param {Number} value - The intensity.\n   */ setIntensity(value) {\n        this.intensity = value;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const renderTarget = this.renderTarget;\n        const luminancePass = this.luminancePass;\n        if (luminancePass.enabled) {\n            luminancePass.render(renderer, inputBuffer);\n            if (this.mipmapBlurPass.enabled) {\n                this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);\n            } else {\n                this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);\n            }\n        } else {\n            if (this.mipmapBlurPass.enabled) {\n                this.mipmapBlurPass.render(renderer, inputBuffer);\n            } else {\n                this.blurPass.render(renderer, inputBuffer, renderTarget);\n            }\n        }\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n        this.blurPass.resolution.copy(resolution);\n        this.luminancePass.setSize(width, height);\n        this.mipmapBlurPass.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurPass.initialize(renderer, alpha, frameBufferType);\n        this.luminancePass.initialize(renderer, alpha, frameBufferType);\n        this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);\n        if (frameBufferType !== void 0) {\n            this.renderTarget.texture.type = frameBufferType;\n            if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n};\n// src/effects/BokehEffect.js\n\n// src/effects/glsl/bokeh.frag\nvar bokeh_default = `uniform float focus;uniform float dof;uniform float aperture;uniform float maxBlur;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec2 aspectCorrection=vec2(1.0,aspect);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat focusNear=clamp(focus-dof,0.0,1.0);float focusFar=clamp(focus+dof,0.0,1.0);float low=step(linearDepth,focusNear);float high=step(focusFar,linearDepth);float factor=(linearDepth-focusNear)*low+(linearDepth-focusFar)*high;vec2 dofBlur=vec2(clamp(factor*aperture,-maxBlur,maxBlur));vec2 dofblur9=dofBlur*0.9;vec2 dofblur7=dofBlur*0.7;vec2 dofblur4=dofBlur*0.4;vec4 color=inputColor;color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur4);outputColor=color/41.0;}`;\n// src/effects/BokehEffect.js\nvar BokehEffect = class extends Effect {\n    /**\n   * Constructs a new bokeh effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.focus=0.5] - The focus distance ratio, ranging from 0.0 to 1.0.\n   * @param {Number} [options.dof=0.02] - Depth of field. An area in front of and behind the focal point that still appears sharp.\n   * @param {Number} [options.aperture=0.015] - Camera aperture scale. Bigger values for stronger blur and shallower depth of field.\n   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.\n   */ constructor({ blendFunction, focus = 0.5, dof = 0.02, aperture = 0.015, maxBlur = 1 } = {}){\n        super(\"BokehEffect\", bokeh_default, {\n            blendFunction,\n            attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"focus\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focus)\n                ],\n                [\n                    \"dof\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(dof)\n                ],\n                [\n                    \"aperture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(aperture)\n                ],\n                [\n                    \"maxBlur\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxBlur)\n                ]\n            ])\n        });\n    }\n};\n// src/effects/BrightnessContrastEffect.js\n\n// src/effects/glsl/brightness-contrast.frag\nvar brightness_contrast_default = `uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}`;\n// src/effects/BrightnessContrastEffect.js\nvar BrightnessContrastEffect = class extends Effect {\n    /**\n   * Constructs a new brightness/contrast effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.brightness=0.0] - The brightness factor, ranging from -1 to 1, where 0 means no change.\n   * @param {Number} [options.contrast=0.0] - The contrast factor, ranging from -1 to 1, where 0 means no change.\n   */ constructor({ blendFunction = BlendFunction.SRC, brightness = 0, contrast = 0 } = {}){\n        super(\"BrightnessContrastEffect\", brightness_contrast_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"brightness\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(brightness)\n                ],\n                [\n                    \"contrast\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(contrast)\n                ]\n            ])\n        });\n        this.inputColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n    }\n    /**\n   * The brightness.\n   *\n   * @type {Number}\n   */ get brightness() {\n        return this.uniforms.get(\"brightness\").value;\n    }\n    set brightness(value) {\n        this.uniforms.get(\"brightness\").value = value;\n    }\n    /**\n   * Returns the brightness.\n   *\n   * @deprecated Use brightness instead.\n   * @return {Number} The brightness.\n   */ getBrightness() {\n        return this.brightness;\n    }\n    /**\n   * Sets the brightness.\n   *\n   * @deprecated Use brightness instead.\n   * @param {Number} value - The brightness.\n   */ setBrightness(value) {\n        this.brightness = value;\n    }\n    /**\n   * The contrast.\n   *\n   * @type {Number}\n   */ get contrast() {\n        return this.uniforms.get(\"contrast\").value;\n    }\n    set contrast(value) {\n        this.uniforms.get(\"contrast\").value = value;\n    }\n    /**\n   * Returns the contrast.\n   *\n   * @deprecated Use contrast instead.\n   * @return {Number} The contrast.\n   */ getContrast() {\n        return this.contrast;\n    }\n    /**\n   * Sets the contrast.\n   *\n   * @deprecated Use contrast instead.\n   * @param {Number} value - The contrast.\n   */ setContrast(value) {\n        this.contrast = value;\n    }\n};\n// src/effects/glsl/color-average.frag\nvar color_average_default = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}`;\n// src/effects/ColorAverageEffect.js\nvar ColorAverageEffect = class extends Effect {\n    /**\n   * Constructs a new color average effect.\n   *\n   * @param {BlendFunction} [blendFunction] - The blend function of this effect.\n   */ constructor(blendFunction){\n        super(\"ColorAverageEffect\", color_average_default, {\n            blendFunction\n        });\n    }\n};\n// src/effects/ColorDepthEffect.js\n\n// src/effects/glsl/color-depth.frag\nvar color_depth_default = `uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}`;\n// src/effects/ColorDepthEffect.js\nvar ColorDepthEffect = class extends Effect {\n    /**\n   * Constructs a new color depth effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.bits=16] - The color bit depth.\n   */ constructor({ blendFunction, bits = 16 } = {}){\n        super(\"ColorDepthEffect\", color_depth_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"factor\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ]\n            ])\n        });\n        this.bits = 0;\n        this.bitDepth = bits;\n    }\n    /**\n   * The virtual amount of color bits.\n   *\n   * Each color channel effectively uses a fourth of the total amount of bits. Alpha remains unaffected.\n   *\n   * @type {Number}\n   */ get bitDepth() {\n        return this.bits;\n    }\n    set bitDepth(value) {\n        this.bits = value;\n        this.uniforms.get(\"factor\").value = Math.pow(2, value / 3);\n    }\n    /**\n   * Returns the current color bit depth.\n   *\n   * @return {Number} The bit depth.\n   */ getBitDepth() {\n        return this.bitDepth;\n    }\n    /**\n   * Sets the virtual amount of color bits.\n   *\n   * @param {Number} value - The bit depth.\n   */ setBitDepth(value) {\n        this.bitDepth = value;\n    }\n};\n// src/effects/ChromaticAberrationEffect.js\n\n// src/effects/glsl/chromatic-aberration.frag\nvar chromatic_aberration_default = `#ifdef RADIAL_MODULATION\nuniform float modulationOffset;\n#endif\nvarying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;\n#ifdef RADIAL_MODULATION\nconst vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}\n#else\nif(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}\n#endif\noutputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}`;\n// src/effects/glsl/chromatic-aberration.vert\nvar chromatic_aberration_default2 = `uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}`;\n// src/effects/ChromaticAberrationEffect.js\nvar ChromaticAberrationEffect = class extends Effect {\n    /**\n   * Constructs a new chromatic aberration effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.offset] - The color offset.\n   * @param {Boolean} [options.radialModulation=false] - Whether the effect should be modulated with a radial gradient.\n   * @param {Number} [options.modulationOffset=0.15] - The modulation offset. Only applies if `radialModulation` is enabled.\n   */ constructor({ offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1e-3, 5e-4), radialModulation = false, modulationOffset = 0.15 } = {}){\n        super(\"ChromaticAberrationEffect\", chromatic_aberration_default, {\n            vertexShader: chromatic_aberration_default2,\n            attributes: EffectAttribute.CONVOLUTION,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"offset\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(offset)\n                ],\n                [\n                    \"modulationOffset\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(modulationOffset)\n                ]\n            ])\n        });\n        this.radialModulation = radialModulation;\n    }\n    /**\n   * The color offset.\n   *\n   * @type {Vector2}\n   */ get offset() {\n        return this.uniforms.get(\"offset\").value;\n    }\n    set offset(value) {\n        this.uniforms.get(\"offset\").value = value;\n    }\n    /**\n   * Indicates whether radial modulation is enabled.\n   *\n   * When enabled, the effect will be weaker in the middle and stronger towards the screen edges.\n   *\n   * @type {Boolean}\n   */ get radialModulation() {\n        return this.defines.has(\"RADIAL_MODULATION\");\n    }\n    set radialModulation(value) {\n        if (value) {\n            this.defines.set(\"RADIAL_MODULATION\", \"1\");\n        } else {\n            this.defines.delete(\"RADIAL_MODULATION\");\n        }\n        this.setChanged();\n    }\n    /**\n   * The modulation offset.\n   *\n   * @type {Number}\n   */ get modulationOffset() {\n        return this.uniforms.get(\"modulationOffset\").value;\n    }\n    set modulationOffset(value) {\n        this.uniforms.get(\"modulationOffset\").value = value;\n    }\n    /**\n   * Returns the color offset vector.\n   *\n   * @deprecated Use offset instead.\n   * @return {Vector2} The offset.\n   */ getOffset() {\n        return this.offset;\n    }\n    /**\n   * Sets the color offset vector.\n   *\n   * @deprecated Use offset instead.\n   * @param {Vector2} value - The offset.\n   */ setOffset(value) {\n        this.offset = value;\n    }\n};\n// src/effects/glsl/depth.frag\nvar depth_default = `void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef INVERTED\nvec3 color=vec3(1.0-depth);\n#else\nvec3 color=vec3(depth);\n#endif\noutputColor=vec4(color,inputColor.a);}`;\n// src/effects/DepthEffect.js\nvar DepthEffect = class extends Effect {\n    /**\n   * Constructs a new depth effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.inverted=false] - Whether the depth should be inverted.\n   */ constructor({ blendFunction = BlendFunction.SRC, inverted = false } = {}){\n        super(\"DepthEffect\", depth_default, {\n            blendFunction,\n            attributes: EffectAttribute.DEPTH\n        });\n        this.inverted = inverted;\n    }\n    /**\n   * Indicates whether depth should be inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this.defines.has(\"INVERTED\");\n    }\n    set inverted(value) {\n        if (this.inverted !== value) {\n            if (value) {\n                this.defines.set(\"INVERTED\", \"1\");\n            } else {\n                this.defines.delete(\"INVERTED\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether the rendered depth is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the rendered depth is inverted.\n   */ isInverted() {\n        return this.inverted;\n    }\n    /**\n   * Enables or disables depth inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether depth should be inverted.\n   */ setInverted(value) {\n        this.inverted = value;\n    }\n};\n// src/effects/DepthOfFieldEffect.js\n\n// src/enums/ColorChannel.js\nvar ColorChannel = {\n    RED: 0,\n    GREEN: 1,\n    BLUE: 2,\n    ALPHA: 3\n};\n// src/enums/MaskFunction.js\nvar MaskFunction = {\n    DISCARD: 0,\n    MULTIPLY: 1,\n    MULTIPLY_RGB_SET_ALPHA: 2,\n    MULTIPLY_RGB: 3\n};\n// src/materials/BokehMaterial.js\n\n// src/materials/glsl/convolution.bokeh.frag\nvar convolution_bokeh_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}`;\n// src/materials/BokehMaterial.js\nvar BokehMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new bokeh material.\n   *\n   * @param {Boolean} [fill=false] - Enables or disables the bokeh highlight fill mode.\n   * @param {Boolean} [foreground=false] - Determines whether this material will be applied to foreground colors.\n   */ constructor(fill = false, foreground = false){\n        super({\n            name: \"BokehMaterial\",\n            defines: {\n                PASS: fill ? \"2\" : \"1\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                cocBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                kernel64: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                kernel16: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_bokeh_default,\n            vertexShader: common_default\n        });\n        if (foreground) {\n            this.defines.FOREGROUND = \"1\";\n        }\n        this.generateKernel();\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The circle of confusion buffer.\n   *\n   * @type {Texture}\n   */ set cocBuffer(value) {\n        this.uniforms.cocBuffer.value = value;\n    }\n    /**\n   * Sets the circle of confusion buffer.\n   *\n   * @deprecated Use cocBuffer instead.\n   * @param {Texture} value - The buffer.\n   */ setCoCBuffer(value) {\n        this.uniforms.cocBuffer.value = value;\n    }\n    /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * Returns the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */ getScale(value) {\n        return this.scale;\n    }\n    /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The scale.\n   */ setScale(value) {\n        this.scale = value;\n    }\n    /**\n   * Generates the blur kernel.\n   *\n   * @private\n   */ generateKernel() {\n        const GOLDEN_ANGLE = 2.39996323;\n        const points64 = new Float64Array(128);\n        const points16 = new Float64Array(32);\n        let i64 = 0, i16 = 0;\n        for(let i = 0, sqrt80 = Math.sqrt(80); i < 80; ++i){\n            const theta = i * GOLDEN_ANGLE;\n            const r = Math.sqrt(i) / sqrt80;\n            const u = r * Math.cos(theta), v3 = r * Math.sin(theta);\n            if (i % 5 === 0) {\n                points16[i16++] = u;\n                points16[i16++] = v3;\n            } else {\n                points64[i64++] = u;\n                points64[i64++] = v3;\n            }\n        }\n        this.uniforms.kernel64.value = points64;\n        this.uniforms.kernel16.value = points16;\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y);\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/CircleOfConfusionMaterial.js\n\n// src/utils/orthographicDepthToViewZ.js\nfunction orthographicDepthToViewZ(depth, near, far) {\n    return depth * (near - far) - near;\n}\n// src/utils/viewZToOrthographicDepth.js\nfunction viewZToOrthographicDepth(viewZ, near, far) {\n    return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);\n}\n// src/materials/glsl/circle-of-confusion.frag\nvar circle_of_confusion_default = `#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`;\n// src/materials/CircleOfConfusionMaterial.js\nvar CircleOfConfusionMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new CoC material.\n   *\n   * @param {Camera} camera - A camera.\n   */ constructor(camera){\n        super({\n            name: \"CircleOfConfusionMaterial\",\n            defines: {\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                focusDistance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n                focusRange: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n                cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n                cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: circle_of_confusion_default,\n            vertexShader: common_default\n        });\n        this.uniforms.focalLength = this.uniforms.focusRange;\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get near() {\n        return this.uniforms.cameraNear.value;\n    }\n    /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get far() {\n        return this.uniforms.cameraFar.value;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * The focus distance. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get focusDistance() {\n        return this.uniforms.focusDistance.value;\n    }\n    set focusDistance(value) {\n        this.uniforms.focusDistance.value = value;\n    }\n    /**\n   * The focus distance in world units.\n   *\n   * @type {Number}\n   */ get worldFocusDistance() {\n        return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far);\n    }\n    set worldFocusDistance(value) {\n        this.focusDistance = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * Returns the focus distance.\n   *\n   * @deprecated Use focusDistance instead.\n   * @return {Number} The focus distance.\n   */ getFocusDistance(value) {\n        this.uniforms.focusDistance.value = value;\n    }\n    /**\n   * Sets the focus distance.\n   *\n   * @deprecated Use focusDistance instead.\n   * @param {Number} value - The focus distance.\n   */ setFocusDistance(value) {\n        this.uniforms.focusDistance.value = value;\n    }\n    /**\n   * The focal length.\n   *\n   * @deprecated Renamed to focusRange.\n   * @type {Number}\n   */ get focalLength() {\n        return this.focusRange;\n    }\n    set focalLength(value) {\n        this.focusRange = value;\n    }\n    /**\n   * The focus range. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get focusRange() {\n        return this.uniforms.focusRange.value;\n    }\n    set focusRange(value) {\n        this.uniforms.focusRange.value = value;\n    }\n    /**\n   * The focus range in world units.\n   *\n   * @type {Number}\n   */ get worldFocusRange() {\n        return -orthographicDepthToViewZ(this.focusRange, this.near, this.far);\n    }\n    set worldFocusRange(value) {\n        this.focusRange = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * Returns the focal length.\n   *\n   * @deprecated Use focusRange instead.\n   * @return {Number} The focal length.\n   */ getFocalLength(value) {\n        return this.focusRange;\n    }\n    /**\n   * Sets the focal length.\n   *\n   * @deprecated Use focusRange instead.\n   * @param {Number} value - The focal length.\n   */ setFocalLength(value) {\n        this.focusRange = value;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNear.value = camera.near;\n            this.uniforms.cameraFar.value = camera.far;\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n};\n// src/materials/MaskMaterial.js\n\n// src/materials/glsl/mask.frag\nvar mask_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}`;\n// src/materials/MaskMaterial.js\nvar MaskMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new mask material.\n   *\n   * @param {Texture} [maskTexture] - The mask texture.\n   */ constructor(maskTexture = null){\n        super({\n            name: \"MaskMaterial\",\n            uniforms: {\n                maskTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maskTexture),\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                strength: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: mask_default,\n            vertexShader: common_default\n        });\n        this.colorChannel = ColorChannel.RED;\n        this.maskFunction = MaskFunction.DISCARD;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The mask texture.\n   *\n   * @type {Texture}\n   */ set maskTexture(value) {\n        this.uniforms.maskTexture.value = value;\n        delete this.defines.MASK_PRECISION_HIGH;\n        if (value.type !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            this.defines.MASK_PRECISION_HIGH = \"1\";\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the mask texture.\n   *\n   * @deprecated Use maskTexture instead.\n   * @param {Texture} value - The texture.\n   */ setMaskTexture(value) {\n        this.maskTexture = value;\n    }\n    /**\n   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.\n   *\n   * @type {ColorChannel}\n   */ set colorChannel(value) {\n        this.defines.COLOR_CHANNEL = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.\n   *\n   * @deprecated Use colorChannel instead.\n   * @param {ColorChannel} value - The channel.\n   */ setColorChannel(value) {\n        this.colorChannel = value;\n    }\n    /**\n   * The masking technique. Default is `MaskFunction.DISCARD`.\n   *\n   * @type {MaskFunction}\n   */ set maskFunction(value) {\n        this.defines.MASK_FUNCTION = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the masking technique. Default is `MaskFunction.DISCARD`.\n   *\n   * @deprecated Use maskFunction instead.\n   * @param {MaskFunction} value - The function.\n   */ setMaskFunction(value) {\n        this.maskFunction = value;\n    }\n    /**\n   * Indicates whether the masking is inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this.defines.INVERTED !== void 0;\n    }\n    set inverted(value) {\n        if (this.inverted && !value) {\n            delete this.defines.INVERTED;\n        } else if (value) {\n            this.defines.INVERTED = \"1\";\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether the masking is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the masking is inverted.\n   */ isInverted() {\n        return this.inverted;\n    }\n    /**\n   * Determines whether the masking should be inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the masking should be inverted.\n   */ setInverted(value) {\n        this.inverted = value;\n    }\n    /**\n   * The current mask strength.\n   *\n   * Individual mask values will be clamped to [0.0, 1.0]. Has no effect when the mask function is set to `DISCARD`.\n   *\n   * @type {Number}\n   */ get strength() {\n        return this.uniforms.strength.value;\n    }\n    set strength(value) {\n        this.uniforms.strength.value = value;\n    }\n    /**\n   * Returns the current mask strength.\n   *\n   * @deprecated Use strength instead.\n   * @return {Number} The mask strength.\n   */ getStrength() {\n        return this.strength;\n    }\n    /**\n   * Sets the mask strength.\n   *\n   * Has no effect when the mask function is set to `DISCARD`.\n   *\n   * @deprecated Use strength instead.\n   * @param {Number} value - The mask strength.\n   */ setStrength(value) {\n        this.strength = value;\n    }\n};\n// src/passes/ShaderPass.js\n\nvar ShaderPass = class extends Pass {\n    /**\n   * Constructs a new shader pass.\n   *\n   * @param {ShaderMaterial} material - A shader material.\n   * @param {String} [input=\"inputBuffer\"] - The name of the input buffer uniform.\n   */ constructor(material, input = \"inputBuffer\"){\n        super(\"ShaderPass\");\n        this.fullscreenMaterial = material;\n        this.input = input;\n    }\n    /**\n   * Sets the name of the input buffer uniform.\n   *\n   * @param {String} input - The name of the input buffer uniform.\n   * @deprecated Use input instead.\n   */ setInput(input) {\n        this.input = input;\n    }\n    /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const uniforms = this.fullscreenMaterial.uniforms;\n        if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {\n            uniforms[this.input].value = inputBuffer.texture;\n        }\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        }\n    }\n};\n// src/effects/glsl/depth-of-field.frag\nvar depth_of_field_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}`;\n// src/effects/DepthOfFieldEffect.js\nvar DepthOfFieldEffect = class extends Effect {\n    /**\n   * Constructs a new depth of field effect.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.worldFocusDistance] - The focus distance in world units.\n   * @param {Number} [options.worldFocusRange] - The focus distance in world units.\n   * @param {Number} [options.focusDistance=0.0] - The normalized focus distance. Range is [0.0, 1.0].\n   * @param {Number} [options.focusRange=0.1] - The focus range. Range is [0.0, 1.0].\n   * @param {Number} [options.focalLength=0.1] - Deprecated.\n   * @param {Number} [options.bokehScale=1.0] - The scale of the bokeh blur.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(camera, { blendFunction, worldFocusDistance, worldFocusRange, focusDistance = 0, focalLength = 0.1, focusRange = focalLength, bokehScale = 1, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"DepthOfFieldEffect\", depth_of_field_default, {\n            blendFunction,\n            attributes: EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"nearColorBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"farColorBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"nearCoCBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"farCoCBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ]\n            ])\n        });\n        this.camera = camera;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"DoF.Intermediate\";\n        this.renderTargetMasked = this.renderTarget.clone();\n        this.renderTargetMasked.texture.name = \"DoF.Masked.Far\";\n        this.renderTargetNear = this.renderTarget.clone();\n        this.renderTargetNear.texture.name = \"DoF.Bokeh.Near\";\n        this.uniforms.get(\"nearColorBuffer\").value = this.renderTargetNear.texture;\n        this.renderTargetFar = this.renderTarget.clone();\n        this.renderTargetFar.texture.name = \"DoF.Bokeh.Far\";\n        this.uniforms.get(\"farColorBuffer\").value = this.renderTargetFar.texture;\n        this.renderTargetCoC = this.renderTarget.clone();\n        this.renderTargetCoC.texture.name = \"DoF.CoC\";\n        this.uniforms.get(\"farCoCBuffer\").value = this.renderTargetCoC.texture;\n        this.renderTargetCoCBlurred = this.renderTargetCoC.clone();\n        this.renderTargetCoCBlurred.texture.name = \"DoF.CoC.Blurred\";\n        this.uniforms.get(\"nearCoCBuffer\").value = this.renderTargetCoCBlurred.texture;\n        this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));\n        const cocMaterial = this.cocMaterial;\n        cocMaterial.focusDistance = focusDistance;\n        cocMaterial.focusRange = focusRange;\n        if (worldFocusDistance !== void 0) {\n            cocMaterial.worldFocusDistance = worldFocusDistance;\n        }\n        if (worldFocusRange !== void 0) {\n            cocMaterial.worldFocusRange = worldFocusRange;\n        }\n        this.blurPass = new KawaseBlurPass({\n            resolutionScale,\n            resolutionX,\n            resolutionY,\n            kernelSize: KernelSize.MEDIUM\n        });\n        this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture));\n        const maskMaterial = this.maskPass.fullscreenMaterial;\n        maskMaterial.colorChannel = ColorChannel.GREEN;\n        this.maskFunction = MaskFunction.MULTIPLY_RGB;\n        this.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true));\n        this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;\n        this.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true));\n        this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;\n        this.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false));\n        this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;\n        this.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false));\n        this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;\n        this.target = null;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.bokehScale = bokehScale;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.cocMaterial.copyCameraSettings(value);\n    }\n    /**\n   * The circle of confusion texture.\n   *\n   * @type {Texture}\n   */ get cocTexture() {\n        return this.renderTargetCoC.texture;\n    }\n    /**\n   * The mask function. Default is `MULTIPLY_RGB`.\n   *\n   * @type {MaskFunction}\n   */ get maskFunction() {\n        return this.maskPass.fullscreenMaterial.maskFunction;\n    }\n    set maskFunction(value) {\n        if (this.maskFunction !== value) {\n            this.defines.set(\"MASK_FUNCTION\", value.toFixed(0));\n            this.maskPass.fullscreenMaterial.maskFunction = value;\n            this.setChanged();\n        }\n    }\n    /**\n   * The circle of confusion material.\n   *\n   * @type {CircleOfConfusionMaterial}\n   */ get cocMaterial() {\n        return this.cocPass.fullscreenMaterial;\n    }\n    /**\n   * The circle of confusion material.\n   *\n   * @deprecated Use cocMaterial instead.\n   * @type {CircleOfConfusionMaterial}\n   */ get circleOfConfusionMaterial() {\n        return this.cocMaterial;\n    }\n    /**\n   * Returns the circle of confusion material.\n   *\n   * @deprecated Use cocMaterial instead.\n   * @return {CircleOfConfusionMaterial} The material.\n   */ getCircleOfConfusionMaterial() {\n        return this.cocMaterial;\n    }\n    /**\n   * Returns the pass that blurs the foreground CoC buffer to soften edges.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */ getBlurPass() {\n        return this.blurPass;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * The current bokeh scale.\n   *\n   * @type {Number}\n   */ get bokehScale() {\n        return this.uniforms.get(\"scale\").value;\n    }\n    set bokehScale(value) {\n        this.bokehNearBasePass.fullscreenMaterial.scale = value;\n        this.bokehNearFillPass.fullscreenMaterial.scale = value;\n        this.bokehFarBasePass.fullscreenMaterial.scale = value;\n        this.bokehFarFillPass.fullscreenMaterial.scale = value;\n        this.maskPass.fullscreenMaterial.strength = value;\n        this.uniforms.get(\"scale\").value = value;\n    }\n    /**\n   * Returns the current bokeh scale.\n   *\n   * @deprecated Use bokehScale instead.\n   * @return {Number} The scale.\n   */ getBokehScale() {\n        return this.bokehScale;\n    }\n    /**\n   * Sets the bokeh scale.\n   *\n   * @deprecated Use bokehScale instead.\n   * @param {Number} value - The scale.\n   */ setBokehScale(value) {\n        this.bokehScale = value;\n    }\n    /**\n   * Returns the current auto focus target.\n   *\n   * @deprecated Use target instead.\n   * @return {Vector3} The target.\n   */ getTarget() {\n        return this.target;\n    }\n    /**\n   * Sets the auto focus target.\n   *\n   * @deprecated Use target instead.\n   * @param {Vector3} value - The target.\n   */ setTarget(value) {\n        this.target = value;\n    }\n    /**\n   * Calculates the focus distance from the camera to the given position.\n   *\n   * @param {Vector3} target - The target.\n   * @return {Number} The normalized focus distance.\n   */ calculateFocusDistance(target) {\n        const camera = this.camera;\n        const distance = camera.position.distanceTo(target);\n        return viewZToOrthographicDepth(-distance, camera.near, camera.far);\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.cocMaterial.depthBuffer = depthTexture;\n        this.cocMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const renderTarget = this.renderTarget;\n        const renderTargetCoC = this.renderTargetCoC;\n        const renderTargetCoCBlurred = this.renderTargetCoCBlurred;\n        const renderTargetMasked = this.renderTargetMasked;\n        if (this.target !== null) {\n            const distance = this.calculateFocusDistance(this.target);\n            this.cocMaterial.focusDistance = distance;\n        }\n        this.cocPass.render(renderer, null, renderTargetCoC);\n        this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCBlurred);\n        this.maskPass.render(renderer, inputBuffer, renderTargetMasked);\n        this.bokehFarBasePass.render(renderer, renderTargetMasked, renderTarget);\n        this.bokehFarFillPass.render(renderer, renderTarget, this.renderTargetFar);\n        this.bokehNearBasePass.render(renderer, inputBuffer, renderTarget);\n        this.bokehNearFillPass.render(renderer, renderTarget, this.renderTargetNear);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.cocPass.setSize(width, height);\n        this.blurPass.setSize(width, height);\n        this.maskPass.setSize(width, height);\n        this.renderTargetFar.setSize(width, height);\n        this.renderTargetCoC.setSize(width, height);\n        this.renderTargetMasked.setSize(width, height);\n        this.renderTarget.setSize(w, h);\n        this.renderTargetNear.setSize(w, h);\n        this.renderTargetCoCBlurred.setSize(w, h);\n        this.bokehNearBasePass.fullscreenMaterial.setSize(width, height);\n        this.bokehNearFillPass.fullscreenMaterial.setSize(width, height);\n        this.bokehFarBasePass.fullscreenMaterial.setSize(width, height);\n        this.bokehFarFillPass.fullscreenMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.cocPass.initialize(renderer, alpha, frameBufferType);\n        this.maskPass.initialize(renderer, alpha, frameBufferType);\n        this.bokehNearBasePass.initialize(renderer, alpha, frameBufferType);\n        this.bokehNearFillPass.initialize(renderer, alpha, frameBufferType);\n        this.bokehFarBasePass.initialize(renderer, alpha, frameBufferType);\n        this.bokehFarFillPass.initialize(renderer, alpha, frameBufferType);\n        this.blurPass.initialize(renderer, alpha, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);\n        if (renderer.capabilities.logarithmicDepthBuffer) {\n            this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = \"1\";\n        }\n        if (frameBufferType !== void 0) {\n            this.renderTarget.texture.type = frameBufferType;\n            this.renderTargetNear.texture.type = frameBufferType;\n            this.renderTargetFar.texture.type = frameBufferType;\n            this.renderTargetMasked.texture.type = frameBufferType;\n            if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.renderTargetNear.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.renderTargetFar.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.renderTargetMasked.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n};\n// src/effects/DotScreenEffect.js\n\n// src/effects/glsl/dot-screen.frag\nvar dot_screen_default = `uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}`;\n// src/effects/DotScreenEffect.js\nvar DotScreenEffect = class extends Effect {\n    /**\n   * Constructs a new dot screen effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.angle=1.57] - The angle of the dot pattern.\n   * @param {Number} [options.scale=1.0] - The scale of the dot pattern.\n   */ constructor({ blendFunction, angle = Math.PI * 0.5, scale = 1 } = {}){\n        super(\"DotScreenEffect\", dot_screen_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"angle\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(scale)\n                ]\n            ])\n        });\n        this.angle = angle;\n    }\n    /**\n   * The angle.\n   *\n   * @type {Number}\n   */ get angle() {\n        return Math.acos(this.uniforms.get(\"angle\").value.y);\n    }\n    set angle(value) {\n        this.uniforms.get(\"angle\").value.set(Math.sin(value), Math.cos(value));\n    }\n    /**\n   * Returns the pattern angle.\n   *\n   * @deprecated Use angle instead.\n   * @return {Number} The angle in radians.\n   */ getAngle() {\n        return this.angle;\n    }\n    /**\n   * Sets the pattern angle.\n   *\n   * @deprecated Use angle instead.\n   * @param {Number} value - The angle in radians.\n   */ setAngle(value) {\n        this.angle = value;\n    }\n    /**\n   * The scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.get(\"scale\").value;\n    }\n    set scale(value) {\n        this.uniforms.get(\"scale\").value = value;\n    }\n};\n// src/effects/glsl/fxaa.frag\nvar fxaa_default = `#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n#define ONE_OVER_TWELVE 0.08333333333333333\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}`;\n// src/effects/glsl/fxaa.vert\nvar fxaa_default2 = `varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}`;\n// src/effects/FXAAEffect.js\nvar FXAAEffect = class extends Effect {\n    /**\n   * Constructs a new FXAA effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   */ constructor({ blendFunction = BlendFunction.SRC } = {}){\n        super(\"FXAAEffect\", fxaa_default, {\n            vertexShader: fxaa_default2,\n            blendFunction,\n            defines: /* @__PURE__ */ new Map([\n                [\n                    \"EDGE_THRESHOLD_MIN\",\n                    \"0.0312\"\n                ],\n                [\n                    \"EDGE_THRESHOLD_MAX\",\n                    \"0.125\"\n                ],\n                [\n                    \"SUBPIXEL_QUALITY\",\n                    \"0.75\"\n                ],\n                [\n                    \"SAMPLES\",\n                    \"12\"\n                ]\n            ])\n        });\n    }\n    /**\n   * The minimum edge detection threshold. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get minEdgeThreshold() {\n        return Number(this.defines.get(\"EDGE_THRESHOLD_MIN\"));\n    }\n    set minEdgeThreshold(value) {\n        this.defines.set(\"EDGE_THRESHOLD_MIN\", value.toFixed(12));\n        this.setChanged();\n    }\n    /**\n   * The maximum edge detection threshold. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get maxEdgeThreshold() {\n        return Number(this.defines.get(\"EDGE_THRESHOLD_MAX\"));\n    }\n    set maxEdgeThreshold(value) {\n        this.defines.set(\"EDGE_THRESHOLD_MAX\", value.toFixed(12));\n        this.setChanged();\n    }\n    /**\n   * The subpixel blend quality. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get subpixelQuality() {\n        return Number(this.defines.get(\"SUBPIXEL_QUALITY\"));\n    }\n    set subpixelQuality(value) {\n        this.defines.set(\"SUBPIXEL_QUALITY\", value.toFixed(12));\n        this.setChanged();\n    }\n    /**\n   * The maximum amount of edge detection samples.\n   *\n   * @type {Number}\n   */ get samples() {\n        return Number(this.defines.get(\"SAMPLES\"));\n    }\n    set samples(value) {\n        this.defines.set(\"SAMPLES\", value.toFixed(0));\n        this.setChanged();\n    }\n};\n// src/effects/GammaCorrectionEffect.js\n\n// src/effects/glsl/gamma-correction.frag\nvar gamma_correction_default = `uniform float gamma;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=LinearToGamma(max(inputColor,0.0),gamma);}`;\n// src/effects/GammaCorrectionEffect.js\nvar GammaCorrectionEffect = class extends Effect {\n    /**\n   * Constructs a new gamma correction effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.gamma=2.0] - The gamma factor.\n   */ constructor({ blendFunction = BlendFunction.SRC, gamma = 2 } = {}){\n        super(\"GammaCorrectionEffect\", gamma_correction_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"gamma\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(gamma)\n                ]\n            ])\n        });\n    }\n};\n// src/effects/GlitchEffect.js\n\n// src/enums/GlitchMode.js\nvar GlitchMode = {\n    DISABLED: 0,\n    SPORADIC: 1,\n    CONSTANT_MILD: 2,\n    CONSTANT_WILD: 3\n};\n// src/textures/NoiseTexture.js\n\nfunction getNoise(size, format, type) {\n    const channels = /* @__PURE__ */ new Map([\n        [\n            three__WEBPACK_IMPORTED_MODULE_0__.RedFormat,\n            1\n        ],\n        [\n            three__WEBPACK_IMPORTED_MODULE_0__.RGFormat,\n            2\n        ],\n        [\n            three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            4\n        ]\n    ]);\n    let data;\n    if (!channels.has(format)) {\n        console.error(\"Invalid noise texture format\");\n    }\n    if (type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        data = new Uint8Array(size * channels.get(format));\n        for(let i = 0, l = data.length; i < l; ++i){\n            data[i] = Math.random() * 255 + 0.5;\n        }\n    } else {\n        data = new Float32Array(size * channels.get(format));\n        for(let i = 0, l = data.length; i < l; ++i){\n            data[i] = Math.random();\n        }\n    }\n    return data;\n}\nvar NoiseTexture = class extends three__WEBPACK_IMPORTED_MODULE_0__.DataTexture {\n    /**\n   * Constructs a new noise texture.\n   *\n   * Supported formats are `RGBAFormat`, `RedFormat` and `RGFormat`.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   * @param {Number} [format=RedFormat] - The texture format.\n   * @param {Number} [type=UnsignedByteType] - The texture type.\n   */ constructor(width, height, format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat, type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType){\n        super(getNoise(width * height, format, type), width, height, format, type);\n        this.needsUpdate = true;\n    }\n};\n// src/effects/glsl/glitch.frag\nvar glitch_default = `uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seeds;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seeds.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seeds.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seeds*(random*0.2);}}`;\n// src/effects/GlitchEffect.js\nvar textureTag = \"Glitch.Generated\";\nfunction randomFloat(low, high) {\n    return low + Math.random() * (high - low);\n}\nvar GlitchEffect = class extends Effect {\n    /**\n   * Constructs a new glitch effect.\n   *\n   * TODO Change ratio to 0.15.\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.chromaticAberrationOffset] - A chromatic aberration offset. If provided, the glitch effect will influence this offset.\n   * @param {Vector2} [options.delay] - The minimum and maximum delay between glitch activations in seconds.\n   * @param {Vector2} [options.duration] - The minimum and maximum duration of a glitch in seconds.\n   * @param {Vector2} [options.strength] - The strength of weak and strong glitches.\n   * @param {Texture} [options.perturbationMap] - A perturbation map. If none is provided, a noise texture will be created.\n   * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.\n   * @param {Number} [options.columns=0.05] - The scale of the blocky glitch columns.\n   * @param {Number} [options.ratio=0.85] - The threshold for strong glitches.\n   */ constructor({ chromaticAberrationOffset = null, delay = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1.5, 3.5), duration = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.6, 1), strength = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.3, 1), columns = 0.05, ratio = 0.85, perturbationMap = null, dtSize = 64 } = {}){\n        super(\"GlitchEffect\", glitch_default, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"perturbationMap\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"columns\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(columns)\n                ],\n                [\n                    \"active\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)\n                ],\n                [\n                    \"random\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"seeds\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"distortion\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ]\n            ])\n        });\n        if (perturbationMap === null) {\n            const map = new NoiseTexture(dtSize, dtSize, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n            map.name = textureTag;\n            this.perturbationMap = map;\n        } else {\n            this.perturbationMap = perturbationMap;\n        }\n        this.time = 0;\n        this.distortion = this.uniforms.get(\"distortion\").value;\n        this.delay = delay;\n        this.duration = duration;\n        this.breakPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(randomFloat(this.delay.x, this.delay.y), randomFloat(this.duration.x, this.duration.y));\n        this.strength = strength;\n        this.mode = GlitchMode.SPORADIC;\n        this.ratio = ratio;\n        this.chromaticAberrationOffset = chromaticAberrationOffset;\n    }\n    /**\n   * Random number seeds.\n   *\n   * @type {Vector2}\n   * @private\n   */ get seeds() {\n        return this.uniforms.get(\"seeds\").value;\n    }\n    /**\n   * Indicates whether the glitch effect is currently active.\n   *\n   * @type {Boolean}\n   */ get active() {\n        return this.uniforms.get(\"active\").value;\n    }\n    /**\n   * Indicates whether the glitch effect is currently active.\n   *\n   * @deprecated Use active instead.\n   * @return {Boolean} Whether the glitch effect is active.\n   */ isActive() {\n        return this.active;\n    }\n    /**\n   * The minimum delay between glitch activations.\n   *\n   * @type {Number}\n   */ get minDelay() {\n        return this.delay.x;\n    }\n    set minDelay(value) {\n        this.delay.x = value;\n    }\n    /**\n   * Returns the minimum delay between glitch activations.\n   *\n   * @deprecated Use minDelay instead.\n   * @return {Number} The minimum delay in seconds.\n   */ getMinDelay() {\n        return this.delay.x;\n    }\n    /**\n   * Sets the minimum delay between glitch activations.\n   *\n   * @deprecated Use minDelay instead.\n   * @param {Number} value - The minimum delay in seconds.\n   */ setMinDelay(value) {\n        this.delay.x = value;\n    }\n    /**\n   * The maximum delay between glitch activations.\n   *\n   * @type {Number}\n   */ get maxDelay() {\n        return this.delay.y;\n    }\n    set maxDelay(value) {\n        this.delay.y = value;\n    }\n    /**\n   * Returns the maximum delay between glitch activations.\n   *\n   * @deprecated Use maxDelay instead.\n   * @return {Number} The maximum delay in seconds.\n   */ getMaxDelay() {\n        return this.delay.y;\n    }\n    /**\n   * Sets the maximum delay between glitch activations.\n   *\n   * @deprecated Use maxDelay instead.\n   * @param {Number} value - The maximum delay in seconds.\n   */ setMaxDelay(value) {\n        this.delay.y = value;\n    }\n    /**\n   * The minimum duration of sporadic glitches.\n   *\n   * @type {Number}\n   */ get minDuration() {\n        return this.duration.x;\n    }\n    set minDuration(value) {\n        this.duration.x = value;\n    }\n    /**\n   * Returns the minimum duration of sporadic glitches.\n   *\n   * @deprecated Use minDuration instead.\n   * @return {Number} The minimum duration in seconds.\n   */ getMinDuration() {\n        return this.duration.x;\n    }\n    /**\n   * Sets the minimum duration of sporadic glitches.\n   *\n   * @deprecated Use minDuration instead.\n   * @param {Number} value - The minimum duration in seconds.\n   */ setMinDuration(value) {\n        this.duration.x = value;\n    }\n    /**\n   * The maximum duration of sporadic glitches.\n   *\n   * @type {Number}\n   */ get maxDuration() {\n        return this.duration.y;\n    }\n    set maxDuration(value) {\n        this.duration.y = value;\n    }\n    /**\n   * Returns the maximum duration of sporadic glitches.\n   *\n   * @deprecated Use maxDuration instead.\n   * @return {Number} The maximum duration in seconds.\n   */ getMaxDuration() {\n        return this.duration.y;\n    }\n    /**\n   * Sets the maximum duration of sporadic glitches.\n   *\n   * @deprecated Use maxDuration instead.\n   * @param {Number} value - The maximum duration in seconds.\n   */ setMaxDuration(value) {\n        this.duration.y = value;\n    }\n    /**\n   * The strength of weak glitches.\n   *\n   * @type {Number}\n   */ get minStrength() {\n        return this.strength.x;\n    }\n    set minStrength(value) {\n        this.strength.x = value;\n    }\n    /**\n   * Returns the strength of weak glitches.\n   *\n   * @deprecated Use minStrength instead.\n   * @return {Number} The strength.\n   */ getMinStrength() {\n        return this.strength.x;\n    }\n    /**\n   * Sets the strength of weak glitches.\n   *\n   * @deprecated Use minStrength instead.\n   * @param {Number} value - The strength.\n   */ setMinStrength(value) {\n        this.strength.x = value;\n    }\n    /**\n   * The strength of strong glitches.\n   *\n   * @type {Number}\n   */ get maxStrength() {\n        return this.strength.y;\n    }\n    set maxStrength(value) {\n        this.strength.y = value;\n    }\n    /**\n   * Returns the strength of strong glitches.\n   *\n   * @deprecated Use maxStrength instead.\n   * @return {Number} The strength.\n   */ getMaxStrength() {\n        return this.strength.y;\n    }\n    /**\n   * Sets the strength of strong glitches.\n   *\n   * @deprecated Use maxStrength instead.\n   * @param {Number} value - The strength.\n   */ setMaxStrength(value) {\n        this.strength.y = value;\n    }\n    /**\n   * Returns the current glitch mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {GlitchMode} The mode.\n   */ getMode() {\n        return this.mode;\n    }\n    /**\n   * Sets the current glitch mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {GlitchMode} value - The mode.\n   */ setMode(value) {\n        this.mode = value;\n    }\n    /**\n   * Returns the glitch ratio.\n   *\n   * @deprecated Use ratio instead.\n   * @return {Number} The ratio.\n   */ getGlitchRatio() {\n        return 1 - this.ratio;\n    }\n    /**\n   * Sets the ratio of weak (0.0) and strong (1.0) glitches.\n   *\n   * @deprecated Use ratio instead.\n   * @param {Number} value - The ratio. Range is [0.0, 1.0].\n   */ setGlitchRatio(value) {\n        this.ratio = Math.min(Math.max(1 - value, 0), 1);\n    }\n    /**\n   * The glitch column size.\n   *\n   * @type {Number}\n   */ get columns() {\n        return this.uniforms.get(\"columns\").value;\n    }\n    set columns(value) {\n        this.uniforms.get(\"columns\").value = value;\n    }\n    /**\n   * Returns the glitch column size.\n   *\n   * @deprecated Use columns instead.\n   * @return {Number} The glitch column size.\n   */ getGlitchColumns() {\n        return this.columns;\n    }\n    /**\n   * Sets the glitch column size.\n   *\n   * @deprecated Use columns instead.\n   * @param {Number} value - The glitch column size.\n   */ setGlitchColumns(value) {\n        this.columns = value;\n    }\n    /**\n   * Returns the chromatic aberration offset.\n   *\n   * @deprecated Use chromaticAberrationOffset instead.\n   * @return {Vector2} The offset.\n   */ getChromaticAberrationOffset() {\n        return this.chromaticAberrationOffset;\n    }\n    /**\n   * Sets the chromatic aberration offset.\n   *\n   * @deprecated Use chromaticAberrationOffset instead.\n   * @param {Vector2} value - The offset.\n   */ setChromaticAberrationOffset(value) {\n        this.chromaticAberrationOffset = value;\n    }\n    /**\n   * The perturbation map.\n   *\n   * @type {Texture}\n   */ get perturbationMap() {\n        return this.uniforms.get(\"perturbationMap\").value;\n    }\n    set perturbationMap(value) {\n        const currentMap = this.perturbationMap;\n        if (currentMap !== null && currentMap.name === textureTag) {\n            currentMap.dispose();\n        }\n        value.minFilter = value.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        value.wrapS = value.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n        value.generateMipmaps = false;\n        this.uniforms.get(\"perturbationMap\").value = value;\n    }\n    /**\n   * Returns the current perturbation map.\n   *\n   * @deprecated Use perturbationMap instead.\n   * @return {Texture} The current perturbation map.\n   */ getPerturbationMap() {\n        return this.perturbationMap;\n    }\n    /**\n   * Replaces the current perturbation map with the given one.\n   *\n   * The current map will be disposed if it was generated by this effect.\n   *\n   * @deprecated Use perturbationMap instead.\n   * @param {Texture} value - The new perturbation map.\n   */ setPerturbationMap(value) {\n        this.perturbationMap = value;\n    }\n    /**\n   * Generates a perturbation map.\n   *\n   * @deprecated Use NoiseTexture instead.\n   * @param {Number} [value=64] - The texture size.\n   * @return {DataTexture} The perturbation map.\n   */ generatePerturbationMap(value = 64) {\n        const map = new NoiseTexture(value, value, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n        map.name = textureTag;\n        return map;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const mode = this.mode;\n        const breakPoint = this.breakPoint;\n        const offset = this.chromaticAberrationOffset;\n        const s = this.strength;\n        let time = this.time;\n        let active = false;\n        let r = 0, a = 0;\n        let trigger;\n        if (mode !== GlitchMode.DISABLED) {\n            if (mode === GlitchMode.SPORADIC) {\n                time += deltaTime;\n                trigger = time > breakPoint.x;\n                if (time >= breakPoint.x + breakPoint.y) {\n                    breakPoint.set(randomFloat(this.delay.x, this.delay.y), randomFloat(this.duration.x, this.duration.y));\n                    time = 0;\n                }\n            }\n            r = Math.random();\n            this.uniforms.get(\"random\").value = r;\n            if (trigger && r > this.ratio || mode === GlitchMode.CONSTANT_WILD) {\n                active = true;\n                r *= s.y * 0.03;\n                a = randomFloat(-Math.PI, Math.PI);\n                this.seeds.set(randomFloat(-s.y, s.y), randomFloat(-s.y, s.y));\n                this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n            } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {\n                active = true;\n                r *= s.x * 0.03;\n                a = randomFloat(-Math.PI, Math.PI);\n                this.seeds.set(randomFloat(-s.x, s.x), randomFloat(-s.x, s.x));\n                this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n            }\n            this.time = time;\n        }\n        if (offset !== null) {\n            if (active) {\n                offset.set(Math.cos(a), Math.sin(a)).multiplyScalar(r);\n            } else {\n                offset.set(0, 0);\n            }\n        }\n        this.uniforms.get(\"active\").value = active;\n    }\n    /**\n   * Deletes generated resources.\n   */ dispose() {\n        const map = this.perturbationMap;\n        if (map !== null && map.name === textureTag) {\n            map.dispose();\n        }\n    }\n};\n// src/effects/GodRaysEffect.js\n\n// src/materials/DepthMaskMaterial.js\n\n// src/enums/DepthTestStrategy.js\nvar DepthTestStrategy = {\n    DEFAULT: 0,\n    KEEP_MAX_DEPTH: 1,\n    DISCARD_MAX_DEPTH: 2\n};\n// src/materials/glsl/depth-mask.frag\nvar depth_mask_default = `#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\n#else\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\n#endif\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}varying vec2 vUv;void main(){vec2 depth;\n#if DEPTH_PACKING_0 == 3201\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\n#else\ndepth.x=texture2D(depthBuffer0,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;\n#endif\n#endif\n#if DEPTH_PACKING_1 == 3201\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\n#else\ndepth.y=texture2D(depthBuffer1,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;\n#endif\n#endif\nbool isMaxDepth=(depth.x==1.0);\n#ifdef PERSPECTIVE_CAMERA\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\n#endif\n#if DEPTH_TEST_STRATEGY == 0\nbool keep=depthTest(depth.x,depth.y);\n#elif DEPTH_TEST_STRATEGY == 1\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\n#else\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\n#endif\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`;\n// src/materials/DepthMaskMaterial.js\nvar DepthMaskMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new depth mask material.\n   */ constructor(){\n        super({\n            name: \"DepthMaskMaterial\",\n            defines: {\n                DEPTH_EPSILON: \"0.0001\",\n                DEPTH_PACKING_0: \"0\",\n                DEPTH_PACKING_1: \"0\",\n                DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer0: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer1: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1))\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: depth_mask_default,\n            vertexShader: common_default\n        });\n        this.depthMode = three__WEBPACK_IMPORTED_MODULE_0__.LessDepth;\n    }\n    /**\n   * The primary depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer0(value) {\n        this.uniforms.depthBuffer0.value = value;\n    }\n    /**\n   * The primary depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking0(value) {\n        this.defines.DEPTH_PACKING_0 = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the base depth buffer.\n   *\n   * @deprecated Use depthBuffer0 and depthPacking0 instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer0(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer0 = buffer;\n        this.depthPacking0 = depthPacking;\n    }\n    /**\n   * The secondary depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer1(value) {\n        this.uniforms.depthBuffer1.value = value;\n    }\n    /**\n   * The secondary depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking1(value) {\n        this.defines.DEPTH_PACKING_1 = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer that will be compared with the base depth buffer.\n   *\n   * @deprecated Use depthBuffer1 and depthPacking1 instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer1(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer1 = buffer;\n        this.depthPacking1 = depthPacking;\n    }\n    /**\n   * The strategy for handling maximum depth.\n   *\n   * @type {DepthTestStrategy}\n   */ get maxDepthStrategy() {\n        return Number(this.defines.DEPTH_TEST_STRATEGY);\n    }\n    set maxDepthStrategy(value) {\n        this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether maximum depth values should be preserved.\n   *\n   * @type {Boolean}\n   * @deprecated Use maxDepthStrategy instead.\n   */ get keepFar() {\n        return this.maxDepthStrategy;\n    }\n    set keepFar(value) {\n        this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;\n    }\n    /**\n   * Returns the strategy for dealing with maximum depth values.\n   *\n   * @deprecated Use maxDepthStrategy instead.\n   * @return {DepthTestStrategy} The strategy.\n   */ getMaxDepthStrategy() {\n        return this.maxDepthStrategy;\n    }\n    /**\n   * Sets the strategy for dealing with maximum depth values.\n   *\n   * @deprecated Use maxDepthStrategy instead.\n   * @param {DepthTestStrategy} value - The strategy.\n   */ setMaxDepthStrategy(value) {\n        this.maxDepthStrategy = value;\n    }\n    /**\n   * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-4`.\n   *\n   * @type {Number}\n   */ get epsilon() {\n        return Number(this.defines.DEPTH_EPSILON);\n    }\n    set epsilon(value) {\n        this.defines.DEPTH_EPSILON = value.toFixed(16);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the current error threshold for depth comparisons.\n   *\n   * @deprecated Use epsilon instead.\n   * @return {Number} The error threshold.\n   */ getEpsilon() {\n        return this.epsilon;\n    }\n    /**\n   * Sets the depth comparison error threshold.\n   *\n   * @deprecated Use epsilon instead.\n   * @param {Number} value - The new error threshold.\n   */ setEpsilon(value) {\n        this.epsilon = value;\n    }\n    /**\n   * The depth mode.\n   *\n   * @see https://threejs.org/docs/#api/en/constants/Materials\n   * @type {DepthModes}\n   */ get depthMode() {\n        return Number(this.defines.DEPTH_MODE);\n    }\n    set depthMode(value) {\n        let depthTest;\n        switch(value){\n            case three__WEBPACK_IMPORTED_MODULE_0__.NeverDepth:\n                depthTest = \"false\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.AlwaysDepth:\n                depthTest = \"true\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth:\n                depthTest = \"abs(d1 - d0) <= DEPTH_EPSILON\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth:\n                depthTest = \"abs(d1 - d0) > DEPTH_EPSILON\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.LessDepth:\n                depthTest = \"d0 > d1\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth:\n                depthTest = \"d0 >= d1\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualDepth:\n                depthTest = \"d0 <= d1\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.GreaterDepth:\n            default:\n                depthTest = \"d0 < d1\";\n                break;\n        }\n        this.defines.DEPTH_MODE = value.toFixed(0);\n        this.defines[\"depthTest(d0, d1)\"] = depthTest;\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the current depth mode.\n   *\n   * @deprecated Use depthMode instead.\n   * @return {DepthModes} The depth mode. Default is `LessDepth`.\n   */ getDepthMode() {\n        return this.depthMode;\n    }\n    /**\n   * Sets the depth mode.\n   *\n   * @deprecated Use depthMode instead.\n   * @param {DepthModes} mode - The depth mode.\n   */ setDepthMode(mode) {\n        this.depthMode = mode;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n};\n// src/materials/GodRaysMaterial.js\n\n// src/materials/glsl/convolution.god-rays.frag\nvar convolution_god_rays_default = `#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);\n#include <dithering_fragment>\n}`;\n// src/materials/GodRaysMaterial.js\nvar GodRaysMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new god rays material.\n   *\n   * TODO Remove lightPosition param.\n   * @param {Vector2} lightPosition - Deprecated.\n   */ constructor(lightPosition){\n        super({\n            name: \"GodRaysMaterial\",\n            defines: {\n                SAMPLES_INT: \"60\",\n                SAMPLES_FLOAT: \"60.0\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                lightPosition: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(lightPosition),\n                density: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                decay: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                weight: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                exposure: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                clampMax: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_god_rays_default,\n            vertexShader: common_default\n        });\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The screen space position of the light source.\n   *\n   * @type {Vector2}\n   */ get lightPosition() {\n        return this.uniforms.lightPosition.value;\n    }\n    /**\n   * Returns the screen space position of the light source.\n   *\n   * @deprecated Use lightPosition instead.\n   * @return {Vector2} The position.\n   */ getLightPosition() {\n        return this.uniforms.lightPosition.value;\n    }\n    /**\n   * Sets the screen space position of the light source.\n   *\n   * @deprecated Use lightPosition instead.\n   * @param {Vector2} value - The position.\n   */ setLightPosition(value) {\n        this.uniforms.lightPosition.value = value;\n    }\n    /**\n   * The density.\n   *\n   * @type {Number}\n   */ get density() {\n        return this.uniforms.density.value;\n    }\n    set density(value) {\n        this.uniforms.density.value = value;\n    }\n    /**\n   * Returns the density.\n   *\n   * @deprecated Use density instead.\n   * @return {Number} The density.\n   */ getDensity() {\n        return this.uniforms.density.value;\n    }\n    /**\n   * Sets the density.\n   *\n   * @deprecated Use density instead.\n   * @param {Number} value - The density.\n   */ setDensity(value) {\n        this.uniforms.density.value = value;\n    }\n    /**\n   * The decay.\n   *\n   * @type {Number}\n   */ get decay() {\n        return this.uniforms.decay.value;\n    }\n    set decay(value) {\n        this.uniforms.decay.value = value;\n    }\n    /**\n   * Returns the decay.\n   *\n   * @deprecated Use decay instead.\n   * @return {Number} The decay.\n   */ getDecay() {\n        return this.uniforms.decay.value;\n    }\n    /**\n   * Sets the decay.\n   *\n   * @deprecated Use decay instead.\n   * @param {Number} value - The decay.\n   */ setDecay(value) {\n        this.uniforms.decay.value = value;\n    }\n    /**\n   * The weight.\n   *\n   * @type {Number}\n   */ get weight() {\n        return this.uniforms.weight.value;\n    }\n    set weight(value) {\n        this.uniforms.weight.value = value;\n    }\n    /**\n   * Returns the weight.\n   *\n   * @deprecated Use weight instead.\n   * @return {Number} The weight.\n   */ getWeight() {\n        return this.uniforms.weight.value;\n    }\n    /**\n   * Sets the weight.\n   *\n   * @deprecated Use weight instead.\n   * @param {Number} value - The weight.\n   */ setWeight(value) {\n        this.uniforms.weight.value = value;\n    }\n    /**\n   * The exposure.\n   *\n   * @type {Number}\n   */ get exposure() {\n        return this.uniforms.exposure.value;\n    }\n    set exposure(value) {\n        this.uniforms.exposure.value = value;\n    }\n    /**\n   * Returns the exposure.\n   *\n   * @deprecated Use exposure instead.\n   * @return {Number} The exposure.\n   */ getExposure() {\n        return this.uniforms.exposure.value;\n    }\n    /**\n   * Sets the exposure.\n   *\n   * @deprecated Use exposure instead.\n   * @param {Number} value - The exposure.\n   */ setExposure(value) {\n        this.uniforms.exposure.value = value;\n    }\n    /**\n   * The maximum light intensity.\n   *\n   * @type {Number}\n   */ get maxIntensity() {\n        return this.uniforms.clampMax.value;\n    }\n    set maxIntensity(value) {\n        this.uniforms.clampMax.value = value;\n    }\n    /**\n   * Returns the maximum light intensity.\n   *\n   * @deprecated Use maxIntensity instead.\n   * @return {Number} The maximum light intensity.\n   */ getMaxIntensity() {\n        return this.uniforms.clampMax.value;\n    }\n    /**\n   * Sets the maximum light intensity.\n   *\n   * @deprecated Use maxIntensity instead.\n   * @param {Number} value - The maximum light intensity.\n   */ setMaxIntensity(value) {\n        this.uniforms.clampMax.value = value;\n    }\n    /**\n   * The amount of samples per pixel.\n   *\n   * @type {Number}\n   */ get samples() {\n        return Number(this.defines.SAMPLES_INT);\n    }\n    set samples(value) {\n        const s = Math.floor(value);\n        this.defines.SAMPLES_INT = s.toFixed(0);\n        this.defines.SAMPLES_FLOAT = s.toFixed(1);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the amount of samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @return {Number} The sample count.\n   */ getSamples() {\n        return this.samples;\n    }\n    /**\n   * Sets the amount of samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @param {Number} value - The sample count.\n   */ setSamples(value) {\n        this.samples = value;\n    }\n};\n// src/passes/RenderPass.js\nvar RenderPass = class extends Pass {\n    /**\n   * Constructs a new render pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Material} [overrideMaterial=null] - An override material.\n   */ constructor(scene, camera, overrideMaterial = null){\n        super(\"RenderPass\", scene, camera);\n        this.needsSwap = false;\n        this.clearPass = new ClearPass();\n        this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);\n        this.ignoreBackground = false;\n        this.skipShadowMapUpdate = false;\n        this.selection = null;\n    }\n    set mainScene(value) {\n        this.scene = value;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n    }\n    get renderToScreen() {\n        return super.renderToScreen;\n    }\n    set renderToScreen(value) {\n        super.renderToScreen = value;\n        this.clearPass.renderToScreen = value;\n    }\n    /**\n   * The current override material.\n   *\n   * @type {Material}\n   */ get overrideMaterial() {\n        const manager = this.overrideMaterialManager;\n        return manager !== null ? manager.material : null;\n    }\n    set overrideMaterial(value) {\n        const manager = this.overrideMaterialManager;\n        if (value !== null) {\n            if (manager !== null) {\n                manager.setMaterial(value);\n            } else {\n                this.overrideMaterialManager = new OverrideMaterialManager(value);\n            }\n        } else if (manager !== null) {\n            manager.dispose();\n            this.overrideMaterialManager = null;\n        }\n    }\n    /**\n   * Returns the current override material.\n   *\n   * @deprecated Use overrideMaterial instead.\n   * @return {Material} The material.\n   */ getOverrideMaterial() {\n        return this.overrideMaterial;\n    }\n    /**\n   * Sets the override material.\n   *\n   * @deprecated Use overrideMaterial instead.\n   * @return {Material} value - The material.\n   */ setOverrideMaterial(value) {\n        this.overrideMaterial = value;\n    }\n    /**\n   * Indicates whether the target buffer should be cleared before rendering.\n   *\n   * @type {Boolean}\n   * @deprecated Use clearPass.enabled instead.\n   */ get clear() {\n        return this.clearPass.enabled;\n    }\n    set clear(value) {\n        this.clearPass.enabled = value;\n    }\n    /**\n   * Returns the selection. Default is `null` (no restriction).\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */ getSelection() {\n        return this.selection;\n    }\n    /**\n   * Sets the selection. Set to `null` to disable.\n   *\n   * @deprecated Use selection instead.\n   * @param {Selection} value - The selection.\n   */ setSelection(value) {\n        this.selection = value;\n    }\n    /**\n   * Indicates whether the scene background is disabled.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @return {Boolean} Whether the scene background is disabled.\n   */ isBackgroundDisabled() {\n        return this.ignoreBackground;\n    }\n    /**\n   * Enables or disables the scene background.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @param {Boolean} value - Whether the scene background should be disabled.\n   */ setBackgroundDisabled(value) {\n        this.ignoreBackground = value;\n    }\n    /**\n   * Indicates whether the shadow map auto update is disabled.\n   *\n   * @deprecated Use skipShadowMapUpdate instead.\n   * @return {Boolean} Whether the shadow map update is disabled.\n   */ isShadowMapDisabled() {\n        return this.skipShadowMapUpdate;\n    }\n    /**\n   * Enables or disables the shadow map auto update.\n   *\n   * @deprecated Use skipShadowMapUpdate instead.\n   * @param {Boolean} value - Whether the shadow map auto update should be disabled.\n   */ setShadowMapDisabled(value) {\n        this.skipShadowMapUpdate = value;\n    }\n    /**\n   * Returns the clear pass.\n   *\n   * @deprecated Use clearPass.enabled instead.\n   * @return {ClearPass} The clear pass.\n   */ getClearPass() {\n        return this.clearPass;\n    }\n    /**\n   * Renders the scene.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const selection = this.selection;\n        const mask = camera.layers.mask;\n        const background = scene.background;\n        const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;\n        const renderTarget = this.renderToScreen ? null : inputBuffer;\n        if (selection !== null) {\n            camera.layers.set(selection.getLayer());\n        }\n        if (this.skipShadowMapUpdate) {\n            renderer.shadowMap.autoUpdate = false;\n        }\n        if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {\n            scene.background = null;\n        }\n        if (this.clearPass.enabled) {\n            this.clearPass.render(renderer, inputBuffer);\n        }\n        renderer.setRenderTarget(renderTarget);\n        if (this.overrideMaterialManager !== null) {\n            this.overrideMaterialManager.render(renderer, scene, camera);\n        } else {\n            renderer.render(scene, camera);\n        }\n        camera.layers.mask = mask;\n        scene.background = background;\n        renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;\n    }\n};\n// src/effects/glsl/god-rays.frag\nvar god_rays_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}`;\n// src/effects/GodRaysEffect.js\nvar v = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar m = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nvar GodRaysEffect = class extends Effect {\n    /**\n   * Constructs a new god rays effect.\n   *\n   * @param {Camera} [camera] - The main camera.\n   * @param {Mesh|Points} [lightSource] - The light source. Must not write depth and has to be flagged as transparent.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Number} [options.samples=60.0] - The number of samples per pixel.\n   * @param {Number} [options.density=0.96] - The density of the light rays.\n   * @param {Number} [options.decay=0.9] - An illumination decay factor.\n   * @param {Number} [options.weight=0.4] - A light ray weight factor.\n   * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.\n   * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   * @param {KernelSize} [options.kernelSize=KernelSize.SMALL] - The blur kernel size. Has no effect if blur is disabled.\n   * @param {Boolean} [options.blur=true] - Whether the god rays should be blurred to reduce artifacts.\n   */ constructor(camera, lightSource, { blendFunction = BlendFunction.SCREEN, samples = 60, density = 0.96, decay = 0.9, weight = 0.4, exposure = 0.6, clampMax = 1, blur = true, kernelSize = KernelSize.SMALL, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"GodRaysEffect\", god_rays_default, {\n            blendFunction,\n            attributes: EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"map\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.camera = camera;\n        this._lightSource = lightSource;\n        this.lightSource = lightSource;\n        this.lightScene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this.screenPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetA.texture.name = \"GodRays.Target.A\";\n        this.renderTargetB = this.renderTargetA.clone();\n        this.renderTargetB.texture.name = \"GodRays.Target.B\";\n        this.uniforms.get(\"map\").value = this.renderTargetB.texture;\n        this.renderTargetLight = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1);\n        this.renderTargetLight.texture.name = \"GodRays.Light\";\n        this.renderTargetLight.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture();\n        this.renderPassLight = new RenderPass(this.lightScene, camera);\n        this.renderPassLight.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.clearPass = new ClearPass(true, false, false);\n        this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.blurPass = new KawaseBlurPass({\n            kernelSize\n        });\n        this.blurPass.enabled = blur;\n        this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n        const depthMaskMaterial = this.depthMaskMaterial;\n        depthMaskMaterial.depthBuffer1 = this.renderTargetLight.depthTexture;\n        depthMaskMaterial.copyCameraSettings(camera);\n        this.godRaysPass = new ShaderPass(new GodRaysMaterial(this.screenPosition));\n        const godRaysMaterial = this.godRaysMaterial;\n        godRaysMaterial.density = density;\n        godRaysMaterial.decay = decay;\n        godRaysMaterial.weight = weight;\n        godRaysMaterial.exposure = exposure;\n        godRaysMaterial.maxIntensity = clampMax;\n        godRaysMaterial.samples = samples;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.renderPassLight.mainCamera = value;\n        this.depthMaskMaterial.copyCameraSettings(value);\n    }\n    /**\n   * Sets the light source.\n   *\n   * @type {Mesh|Points}\n   */ get lightSource() {\n        return this._lightSource;\n    }\n    set lightSource(value) {\n        this._lightSource = value;\n        if (value !== null) {\n            value.material.depthWrite = false;\n            value.material.transparent = true;\n        }\n    }\n    /**\n   * Returns the blur pass that reduces aliasing artifacts and makes the light softer.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */ getBlurPass() {\n        return this.blurPass;\n    }\n    /**\n   * A texture that contains the intermediate result of this effect.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTargetB.texture;\n    }\n    /**\n   * Returns the god rays texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.texture;\n    }\n    /**\n   * The depth mask material.\n   *\n   * @type {DepthMaskMaterial}\n   * @private\n   */ get depthMaskMaterial() {\n        return this.depthMaskPass.fullscreenMaterial;\n    }\n    /**\n   * The internal god rays material.\n   *\n   * @type {GodRaysMaterial}\n   */ get godRaysMaterial() {\n        return this.godRaysPass.fullscreenMaterial;\n    }\n    /**\n   * Returns the god rays material.\n   *\n   * @deprecated Use godRaysMaterial instead.\n   * @return {GodRaysMaterial} The material.\n   */ getGodRaysMaterial() {\n        return this.godRaysMaterial;\n    }\n    /**\n   * Returns the resolution of this effect.\n   *\n   * @deprecated Use resolution instead.\n   * @return {GodRaysMaterial} The material.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */ get width() {\n        return this.resolution.width;\n    }\n    set width(value) {\n        this.resolution.preferredWidth = value;\n    }\n    /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */ get height() {\n        return this.resolution.height;\n    }\n    set height(value) {\n        this.resolution.preferredHeight = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get dithering() {\n        return this.godRaysMaterial.dithering;\n    }\n    set dithering(value) {\n        const material = this.godRaysMaterial;\n        material.dithering = value;\n        material.needsUpdate = true;\n    }\n    /**\n   * Indicates whether the god rays should be blurred to reduce artifacts.\n   *\n   * @type {Boolean}\n   * @deprecated Use blurPass.enabled instead.\n   */ get blur() {\n        return this.blurPass.enabled;\n    }\n    set blur(value) {\n        this.blurPass.enabled = value;\n    }\n    /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurPass.kernelSize instead.\n   */ get kernelSize() {\n        return this.blurPass.kernelSize;\n    }\n    set kernelSize(value) {\n        this.blurPass.kernelSize = value;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * The number of samples per pixel.\n   *\n   * @type {Number}\n   * @deprecated Use godRaysMaterial.samples instead.\n   */ get samples() {\n        return this.godRaysMaterial.samples;\n    }\n    /**\n   * A higher sample count improves quality at the cost of performance.\n   *\n   * @type {Number}\n   * @deprecated Use godRaysMaterial.samples instead.\n   */ set samples(value) {\n        this.godRaysMaterial.samples = value;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {Number} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthMaskPass.fullscreenMaterial.depthBuffer0 = depthTexture;\n        this.depthMaskPass.fullscreenMaterial.depthPacking0 = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const lightSource = this.lightSource;\n        const parent = lightSource.parent;\n        const matrixAutoUpdate = lightSource.matrixAutoUpdate;\n        const renderTargetA = this.renderTargetA;\n        const renderTargetLight = this.renderTargetLight;\n        lightSource.material.depthWrite = true;\n        lightSource.matrixAutoUpdate = false;\n        lightSource.updateWorldMatrix(true, false);\n        if (parent !== null) {\n            if (!matrixAutoUpdate) {\n                m.copy(lightSource.matrix);\n            }\n            lightSource.matrix.copy(lightSource.matrixWorld);\n        }\n        this.lightScene.add(lightSource);\n        this.renderPassLight.render(renderer, renderTargetLight);\n        this.clearPass.render(renderer, renderTargetA);\n        this.depthMaskPass.render(renderer, renderTargetLight, renderTargetA);\n        lightSource.material.depthWrite = false;\n        lightSource.matrixAutoUpdate = matrixAutoUpdate;\n        if (parent !== null) {\n            if (!matrixAutoUpdate) {\n                lightSource.matrix.copy(m);\n            }\n            parent.add(lightSource);\n        }\n        v.setFromMatrixPosition(lightSource.matrixWorld).project(this.camera);\n        this.screenPosition.set(Math.min(Math.max((v.x + 1) * 0.5, -1), 2), Math.min(Math.max((v.y + 1) * 0.5, -1), 2));\n        if (this.blurPass.enabled) {\n            this.blurPass.render(renderer, renderTargetA, renderTargetA);\n        }\n        this.godRaysPass.render(renderer, renderTargetA, this.renderTargetB);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.renderTargetA.setSize(w, h);\n        this.renderTargetB.setSize(w, h);\n        this.renderTargetLight.setSize(w, h);\n        this.blurPass.resolution.copy(resolution);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurPass.initialize(renderer, alpha, frameBufferType);\n        this.renderPassLight.initialize(renderer, alpha, frameBufferType);\n        this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n        this.godRaysPass.initialize(renderer, alpha, frameBufferType);\n        if (frameBufferType !== void 0) {\n            this.renderTargetA.texture.type = frameBufferType;\n            this.renderTargetB.texture.type = frameBufferType;\n            this.renderTargetLight.texture.type = frameBufferType;\n            if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTargetA.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.renderTargetB.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.renderTargetLight.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n};\n// src/effects/GridEffect.js\n\n// src/effects/glsl/grid.frag\nvar grid_default = `uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}`;\n// src/effects/GridEffect.js\nvar GridEffect = class extends Effect {\n    /**\n   * Constructs a new grid effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.\n   * @param {Number} [options.scale=1.0] - The scale of the grid pattern.\n   * @param {Number} [options.lineWidth=0.0] - The line width of the grid pattern.\n   */ constructor({ blendFunction = BlendFunction.OVERLAY, scale = 1, lineWidth = 0 } = {}){\n        super(\"GridEffect\", grid_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"lineWidth\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(lineWidth)\n                ]\n            ])\n        });\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.s = 0;\n        this.scale = scale;\n        this.l = 0;\n        this.lineWidth = lineWidth;\n    }\n    /**\n   * The scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.s;\n    }\n    set scale(value) {\n        this.s = Math.max(value, 1e-6);\n        this.setSize(this.resolution.width, this.resolution.height);\n    }\n    /**\n   * Returns the current grid scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The grid scale.\n   */ getScale() {\n        return this.scale;\n    }\n    /**\n   * Sets the grid scale.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The new grid scale.\n   */ setScale(value) {\n        this.scale = value;\n    }\n    /**\n   * The line width.\n   *\n   * @type {Number}\n   */ get lineWidth() {\n        return this.l;\n    }\n    set lineWidth(value) {\n        this.l = value;\n        this.setSize(this.resolution.width, this.resolution.height);\n    }\n    /**\n   * Returns the current grid line width.\n   *\n   * @deprecated Use lineWidth instead.\n   * @return {Number} The grid line width.\n   */ getLineWidth() {\n        return this.lineWidth;\n    }\n    /**\n   * Sets the grid line width.\n   *\n   * @deprecated Use lineWidth instead.\n   * @param {Number} value - The new grid line width.\n   */ setLineWidth(value) {\n        this.lineWidth = value;\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.resolution.set(width, height);\n        const aspect = width / height;\n        const scale = this.scale * (height * 0.125);\n        this.uniforms.get(\"scale\").value.set(aspect * scale, scale);\n        this.uniforms.get(\"lineWidth\").value = scale / height + this.lineWidth;\n    }\n};\n// src/effects/HueSaturationEffect.js\n\n// src/effects/glsl/hue-saturation.frag\nvar hue_saturation_default = `uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}`;\n// src/effects/HueSaturationEffect.js\nvar HueSaturationEffect = class extends Effect {\n    /**\n   * Constructs a new hue/saturation effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.hue=0.0] - The hue in radians.\n   * @param {Number} [options.saturation=0.0] - The saturation factor, ranging from -1 to 1, where 0 means no change.\n   */ constructor({ blendFunction = BlendFunction.SRC, hue = 0, saturation = 0 } = {}){\n        super(\"HueSaturationEffect\", hue_saturation_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"hue\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())\n                ],\n                [\n                    \"saturation\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(saturation)\n                ]\n            ])\n        });\n        this.hue = hue;\n    }\n    /**\n   * The saturation.\n   *\n   * @type {Number}\n   */ get saturation() {\n        return this.uniforms.get(\"saturation\").value;\n    }\n    set saturation(value) {\n        this.uniforms.get(\"saturation\").value = value;\n    }\n    /**\n   * Returns the saturation.\n   *\n   * @deprecated Use saturation instead.\n   * @return {Number} The saturation.\n   */ getSaturation() {\n        return this.saturation;\n    }\n    /**\n   * Sets the saturation.\n   *\n   * @deprecated Use saturation instead.\n   * @param {Number} value - The saturation.\n   */ setSaturation(value) {\n        this.saturation = value;\n    }\n    /**\n   * The hue.\n   *\n   * @type {Number}\n   */ get hue() {\n        const hue = this.uniforms.get(\"hue\").value;\n        return Math.acos((hue.x * 3 - 1) / 2);\n    }\n    set hue(value) {\n        const s = Math.sin(value), c2 = Math.cos(value);\n        this.uniforms.get(\"hue\").value.set((2 * c2 + 1) / 3, (-Math.sqrt(3) * s - c2 + 1) / 3, (Math.sqrt(3) * s - c2 + 1) / 3);\n    }\n    /**\n   * Returns the hue.\n   *\n   * @deprecated Use hue instead.\n   * @return {Number} The hue in radians.\n   */ getHue() {\n        return this.hue;\n    }\n    /**\n   * Sets the hue.\n   *\n   * @deprecated Use hue instead.\n   * @param {Number} value - The hue in radians.\n   */ setHue(value) {\n        this.hue = value;\n    }\n};\n// src/effects/LensDistortionEffect.js\n\n// src/effects/glsl/lens-distortion.frag\nvar lens_distortion_default = `uniform vec2 distortion;uniform vec2 principalPoint;uniform vec2 focalLength;uniform float skew;float mask(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void mainUv(inout vec2 uv){vec2 xn=2.0*(uv.st-0.5);vec3 xDistorted=vec3((1.0+distortion*dot(xn,xn))*xn,1.0);mat3 kk=mat3(vec3(focalLength.x,0.0,0.0),vec3(skew*focalLength.x,focalLength.y,0.0),vec3(principalPoint.x,principalPoint.y,1.0));uv=(kk*xDistorted).xy*0.5+0.5;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=mask(uv)*inputColor;}`;\n// src/effects/LensDistortionEffect.js\nvar LensDistortionEffect = class extends Effect {\n    /**\n   * Constructs a new lens distortion effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.distortion] - The distortion value.\n   * @param {Vector2} [options.principalPoint] - The center point.\n   * @param {Vector2} [options.focalLength] - The focal length.\n   * @param {Number} [options.skew=0] - The skew value.\n   */ constructor({ distortion = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0), principalPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0), focalLength = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1), skew = 0 } = {}){\n        super(\"LensDistortionEffect\", lens_distortion_default, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"distortion\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(distortion)\n                ],\n                [\n                    \"principalPoint\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(principalPoint)\n                ],\n                [\n                    \"focalLength\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focalLength)\n                ],\n                [\n                    \"skew\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(skew)\n                ]\n            ])\n        });\n    }\n    /**\n   * The radial distortion coefficients. Default is (0, 0).\n   *\n   * @type {Vector2}\n   */ get distortion() {\n        return this.uniforms.get(\"distortion\").value;\n    }\n    set distortion(value) {\n        this.uniforms.get(\"distortion\").value = value;\n    }\n    /**\n   * The principal point. Default is (0, 0).\n   *\n   * @type {Vector2}\n   */ get principalPoint() {\n        return this.uniforms.get(\"principalPoint\").value;\n    }\n    set principalPoint(value) {\n        this.uniforms.get(\"principalPoint\").value = value;\n    }\n    /**\n   * The focal length. Default is (1, 1).\n   *\n   * @type {Vector2}\n   */ get focalLength() {\n        return this.uniforms.get(\"focalLength\").value;\n    }\n    set focalLength(value) {\n        this.uniforms.get(\"focalLength\").value = value;\n    }\n    /**\n   * The skew factor in radians.\n   *\n   * @type {Number}\n   */ get skew() {\n        return this.uniforms.get(\"skew\").value;\n    }\n    set skew(value) {\n        this.uniforms.get(\"skew\").value = value;\n    }\n};\n// src/effects/LUT1DEffect.js\n\n// src/effects/glsl/lut-1d.frag\nvar lut_1d_default = `#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(texture2D(lut,vec2(inputColor.r,0.5)).r,texture2D(lut,vec2(inputColor.g,0.5)).r,texture2D(lut,vec2(inputColor.b,0.5)).r,inputColor.a);}`;\n// src/effects/LUT1DEffect.js\nvar LUT1DEffect = class extends Effect {\n    /**\n   * Constructs a new color grading effect.\n   *\n   * @param {Texture} lut - The lookup texture.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   */ constructor(lut, { blendFunction = BlendFunction.SRC } = {}){\n        super(\"LUT1DEffect\", lut_1d_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"lut\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.lut = lut;\n    }\n    /**\n   * The LUT.\n   *\n   * @type {Texture}\n   */ get lut() {\n        return this.uniforms.get(\"lut\").value;\n    }\n    set lut(value) {\n        this.uniforms.get(\"lut\").value = value;\n        if (value !== null && (value.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType || value.type === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType)) {\n            this.defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n        }\n    }\n};\n// src/effects/LUT3DEffect.js\n\n// src/textures/lut/LookupTexture.js\n\n// src/enums/LUTOperation.js\nvar LUTOperation = {\n    SCALE_UP: \"lut.scaleup\"\n};\n// src/textures/RawImageData.js\nfunction createCanvas(width, height, data) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    canvas.width = width;\n    canvas.height = height;\n    if (data instanceof Image) {\n        context.drawImage(data, 0, 0);\n    } else {\n        const imageData = context.createImageData(width, height);\n        imageData.data.set(data);\n        context.putImageData(imageData, 0, 0);\n    }\n    return canvas;\n}\nvar RawImageData = class _RawImageData {\n    /**\n   * Constructs a new image data container.\n   *\n   * @param {Number} [width=0] - The width of the image.\n   * @param {Number} [height=0] - The height of the image.\n   * @param {Uint8ClampedArray<ArrayBuffer>} [data=null] - The image data.\n   */ constructor(width = 0, height = 0, data = null){\n        this.width = width;\n        this.height = height;\n        this.data = data;\n    }\n    /**\n   * Creates a canvas from this image data.\n   *\n   * @return {Canvas} The canvas, or null if it couldn't be created.\n   */ toCanvas() {\n        return typeof document === \"undefined\" ? null : createCanvas(this.width, this.height, this.data);\n    }\n    /**\n   * Creates a new image data container.\n   *\n   * @param {ImageData|Image} image - An image or plain image data.\n   * @return {RawImageData} The image data.\n   */ static from(image) {\n        const { width, height } = image;\n        let data;\n        if (image instanceof Image) {\n            const canvas = createCanvas(width, height, image);\n            if (canvas !== null) {\n                const context = canvas.getContext(\"2d\");\n                data = context.getImageData(0, 0, width, height).data;\n            }\n        } else {\n            data = image.data;\n        }\n        return new _RawImageData(width, height, data);\n    }\n};\n// temp/lut/worker.txt\nvar worker_default = '\"use strict\";(()=>{var O={SCALE_UP:\"lut.scaleup\"};var _=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function k(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=_[0];P[0]=s,P[1]=F,P[2]=f;let o=_[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(r**3*4),y=t instanceof Uint8Array?255:1,h=r**2,A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;k(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener(\"message\",a=>{let t=a.data,r=t.data;switch(t.operation){case O.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();\\n';\n// src/textures/lut/LookupTexture.js\nvar c = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Color();\nvar LookupTexture = class _LookupTexture extends three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture {\n    /**\n   * Constructs a cubic 3D lookup texture.\n   *\n   * @param {TypedArray} data - The pixel data. The default format is RGBA.\n   * @param {Number} size - The sidelength.\n   */ constructor(data, size){\n        super(data, size, size, size);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n        this.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n        this.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n        this.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n        this.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n        this.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n        this.wrapR = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n        this.unpackAlignment = 1;\n        this.needsUpdate = true;\n        this.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n        this.domainMin = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.domainMax = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n    }\n    /**\n   * Indicates that this is an instance of LookupTexture3D.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get isLookupTexture3D() {\n        return true;\n    }\n    /**\n   * Scales this LUT up to a given target size using tetrahedral interpolation.\n   *\n   * @param {Number} size - The target sidelength.\n   * @param {Boolean} [transferData=true] - Extra fast mode. Set to false to keep the original data intact.\n   * @return {Promise<LookupTexture>} A promise that resolves with a new LUT upon completion.\n   */ scaleUp(size, transferData = true) {\n        const image = this.image;\n        let promise;\n        if (size <= image.width) {\n            promise = Promise.reject(new Error(\"The target size must be greater than the current size\"));\n        } else {\n            promise = new Promise((resolve, reject)=>{\n                const workerURL = URL.createObjectURL(new Blob([\n                    worker_default\n                ], {\n                    type: \"text/javascript\"\n                }));\n                const worker = new Worker(workerURL);\n                worker.addEventListener(\"error\", (event)=>reject(event.error));\n                worker.addEventListener(\"message\", (event)=>{\n                    const lut = new _LookupTexture(event.data, size);\n                    this.colorSpace = lut.colorSpace;\n                    lut.type = this.type;\n                    lut.name = this.name;\n                    URL.revokeObjectURL(workerURL);\n                    resolve(lut);\n                });\n                const transferList = transferData ? [\n                    image.data.buffer\n                ] : [];\n                worker.postMessage({\n                    operation: LUTOperation.SCALE_UP,\n                    data: image.data,\n                    size\n                }, transferList);\n            });\n        }\n        return promise;\n    }\n    /**\n   * Applies the given LUT to this one.\n   *\n   * @param {LookupTexture} lut - A LUT. Must have the same dimensions, type and format as this LUT.\n   * @return {LookupTexture} This texture.\n   */ applyLUT(lut) {\n        const img0 = this.image;\n        const img1 = lut.image;\n        const size0 = Math.min(img0.width, img0.height, img0.depth);\n        const size1 = Math.min(img1.width, img1.height, img1.depth);\n        if (size0 !== size1) {\n            console.error(\"Size mismatch\");\n        } else if (lut.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType || this.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n            console.error(\"Both LUTs must be FloatType textures\");\n        } else if (lut.format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat || this.format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat) {\n            console.error(\"Both LUTs must be RGBA textures\");\n        } else {\n            const data0 = img0.data;\n            const data1 = img1.data;\n            const size = size0;\n            const sizeSq = size ** 2;\n            const s = size - 1;\n            for(let i = 0, l = size ** 3; i < l; ++i){\n                const i4 = i * 4;\n                const r = data0[i4 + 0] * s;\n                const g = data0[i4 + 1] * s;\n                const b = data0[i4 + 2] * s;\n                const iRGB = Math.round(r + g * size + b * sizeSq) * 4;\n                data0[i4 + 0] = data1[iRGB + 0];\n                data0[i4 + 1] = data1[iRGB + 1];\n                data0[i4 + 2] = data1[iRGB + 2];\n            }\n            this.needsUpdate = true;\n        }\n        return this;\n    }\n    /**\n   * Converts the LUT data into unsigned byte data.\n   *\n   * This is a lossy operation which should only be performed after all other transformations have been applied.\n   *\n   * @return {LookupTexture} This texture.\n   */ convertToUint8() {\n        if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n            const floatData = this.image.data;\n            const uint8Data = new Uint8Array(floatData.length);\n            for(let i = 0, l = floatData.length; i < l; ++i){\n                uint8Data[i] = floatData[i] * 255 + 0.5;\n            }\n            this.image.data = uint8Data;\n            this.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType;\n            this.needsUpdate = true;\n        }\n        return this;\n    }\n    /**\n   * Converts the LUT data into float data.\n   *\n   * @return {LookupTexture} This texture.\n   */ convertToFloat() {\n        if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            const uint8Data = this.image.data;\n            const floatData = new Float32Array(uint8Data.length);\n            for(let i = 0, l = uint8Data.length; i < l; ++i){\n                floatData[i] = uint8Data[i] / 255;\n            }\n            this.image.data = floatData;\n            this.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n            this.needsUpdate = true;\n        }\n        return this;\n    }\n    /**\n   * Converts this LUT into RGBA data.\n   *\n   * @deprecated LUTs are RGBA by default since three r137.\n   * @return {LookupTexture} This texture.\n   */ convertToRGBA() {\n        console.warn(\"LookupTexture\", \"convertToRGBA() is deprecated, LUTs are now RGBA by default\");\n        return this;\n    }\n    /**\n   * Converts the output of this LUT into sRGB color space.\n   *\n   * @return {LookupTexture} This texture.\n   */ convertLinearToSRGB() {\n        const data = this.image.data;\n        if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n            for(let i = 0, l = data.length; i < l; i += 4){\n                c.fromArray(data, i).convertLinearToSRGB().toArray(data, i);\n            }\n            this.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            this.needsUpdate = true;\n        } else {\n            console.error(\"Color space conversion requires FloatType data\");\n        }\n        return this;\n    }\n    /**\n   * Converts the output of this LUT into linear color space.\n   *\n   * @return {LookupTexture} This texture.\n   */ convertSRGBToLinear() {\n        const data = this.image.data;\n        if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n            for(let i = 0, l = data.length; i < l; i += 4){\n                c.fromArray(data, i).convertSRGBToLinear().toArray(data, i);\n            }\n            this.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n            this.needsUpdate = true;\n        } else {\n            console.error(\"Color space conversion requires FloatType data\");\n        }\n        return this;\n    }\n    /**\n   * Converts this LUT into a 2D data texture.\n   *\n   * Please note that custom input domains are not carried over to 2D textures.\n   *\n   * @return {DataTexture} The texture.\n   */ toDataTexture() {\n        const width = this.image.width;\n        const height = this.image.height * this.image.depth;\n        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(this.image.data, width, height);\n        texture.name = this.name;\n        texture.type = this.type;\n        texture.format = this.format;\n        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n        texture.wrapS = this.wrapS;\n        texture.wrapT = this.wrapT;\n        texture.generateMipmaps = false;\n        texture.needsUpdate = true;\n        this.colorSpace = texture.colorSpace;\n        return texture;\n    }\n    /**\n   * Creates a new 3D LUT by copying a given LUT.\n   *\n   * Common image-based textures will be converted into 3D data textures.\n   *\n   * @param {Texture} texture - The LUT. Assumed to be cubic.\n   * @return {LookupTexture} A new 3D LUT.\n   */ static from(texture) {\n        const image = texture.image;\n        const { width, height } = image;\n        const size = Math.min(width, height);\n        let data;\n        if (image instanceof Image) {\n            const rawImageData = RawImageData.from(image);\n            const src = rawImageData.data;\n            if (width > height) {\n                data = new Uint8Array(src.length);\n                for(let z = 0; z < size; ++z){\n                    for(let y = 0; y < size; ++y){\n                        for(let x = 0; x < size; ++x){\n                            const i4 = (x + z * size + y * size * size) * 4;\n                            const j4 = (x + y * size + z * size * size) * 4;\n                            data[j4 + 0] = src[i4 + 0];\n                            data[j4 + 1] = src[i4 + 1];\n                            data[j4 + 2] = src[i4 + 2];\n                            data[j4 + 3] = src[i4 + 3];\n                        }\n                    }\n                }\n            } else {\n                data = new Uint8Array(src.buffer);\n            }\n        } else {\n            data = image.data.slice();\n        }\n        const lut = new _LookupTexture(data, size);\n        lut.type = texture.type;\n        lut.name = texture.name;\n        texture.colorSpace = lut.colorSpace;\n        return lut;\n    }\n    /**\n   * Creates a neutral 3D LUT.\n   *\n   * @param {Number} size - The sidelength.\n   * @return {LookupTexture} A neutral 3D LUT.\n   */ static createNeutral(size) {\n        const data = new Float32Array(size ** 3 * 4);\n        const sizeSq = size ** 2;\n        const s = 1 / (size - 1);\n        for(let r = 0; r < size; ++r){\n            for(let g = 0; g < size; ++g){\n                for(let b = 0; b < size; ++b){\n                    const i4 = (r + g * size + b * sizeSq) * 4;\n                    data[i4 + 0] = r * s;\n                    data[i4 + 1] = g * s;\n                    data[i4 + 2] = b * s;\n                    data[i4 + 3] = 1;\n                }\n            }\n        }\n        const lut = new _LookupTexture(data, size);\n        lut.name = \"neutral\";\n        return lut;\n    }\n};\n// src/effects/glsl/lut-3d.frag\nvar lut_3d_default = `uniform vec3 scale;uniform vec3 offset;\n#ifdef CUSTOM_INPUT_DOMAIN\nuniform vec3 domainMin;uniform vec3 domainMax;\n#endif\n#ifdef LUT_3D\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler3D lut;\n#else\nuniform mediump sampler3D lut;\n#endif\n#else\nuniform lowp sampler3D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){\n#ifdef TETRAHEDRAL_INTERPOLATION\nvec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);\n#else\nreturn texture(lut,rgb);\n#endif\n}\n#else\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);\n#ifdef LUT_STRIP_HORIZONTAL\nfloat xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);\n#else\nfloat yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);\n#endif\nvec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=inputColor.rgb;\n#ifdef CUSTOM_INPUT_DOMAIN\nif(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(scale*c+offset).rgb;}else{c=inputColor.rgb;}\n#else\n#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\nc=clamp(c,0.0,1.0);\n#endif\nc=applyLUT(scale*c+offset).rgb;\n#endif\noutputColor=vec4(c,inputColor.a);}`;\n// src/effects/LUT3DEffect.js\nvar LUT3DEffect = class extends Effect {\n    /**\n   * Constructs a new color grading effect.\n   *\n   * @param {Texture} lut - The lookup texture.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.tetrahedralInterpolation=false] - Enables or disables tetrahedral interpolation.\n   * @param {ColorSpace} [options.inputColorSpace=SRGBColorSpace] - The input color space.\n   */ constructor(lut, { blendFunction = BlendFunction.SRC, tetrahedralInterpolation = false, inputColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace } = {}){\n        super(\"LUT3DEffect\", lut_3d_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"lut\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())\n                ],\n                [\n                    \"offset\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())\n                ],\n                [\n                    \"domainMin\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"domainMax\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.tetrahedralInterpolation = tetrahedralInterpolation;\n        this.inputColorSpace = inputColorSpace;\n        this.lut = lut;\n    }\n    /**\n   * The LUT.\n   *\n   * @type {Texture}\n   */ get lut() {\n        return this.uniforms.get(\"lut\").value;\n    }\n    set lut(value) {\n        const defines = this.defines;\n        const uniforms = this.uniforms;\n        if (this.lut !== value) {\n            uniforms.get(\"lut\").value = value;\n            if (value !== null) {\n                const image = value.image;\n                const tetrahedralInterpolation = this.tetrahedralInterpolation;\n                defines.clear();\n                defines.set(\"LUT_SIZE\", Math.min(image.width, image.height).toFixed(16));\n                defines.set(\"LUT_TEXEL_WIDTH\", (1 / image.width).toFixed(16));\n                defines.set(\"LUT_TEXEL_HEIGHT\", (1 / image.height).toFixed(16));\n                uniforms.get(\"domainMin\").value = null;\n                uniforms.get(\"domainMax\").value = null;\n                if (value.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType || value.type === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType) {\n                    defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n                }\n                if (image.width > image.height) {\n                    defines.set(\"LUT_STRIP_HORIZONTAL\", \"1\");\n                } else if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n                    defines.set(\"LUT_3D\", \"1\");\n                }\n                if (value instanceof LookupTexture) {\n                    const min = value.domainMin;\n                    const max = value.domainMax;\n                    if (min.x !== 0 || min.y !== 0 || min.z !== 0 || max.x !== 1 || max.y !== 1 || max.z !== 1) {\n                        defines.set(\"CUSTOM_INPUT_DOMAIN\", \"1\");\n                        uniforms.get(\"domainMin\").value = min.clone();\n                        uniforms.get(\"domainMax\").value = max.clone();\n                    }\n                }\n                this.tetrahedralInterpolation = tetrahedralInterpolation;\n            }\n        }\n    }\n    /**\n   * Returns the current LUT.\n   *\n   * @deprecated Use lut instead.\n   * @return {Texture} The LUT.\n   */ getLUT() {\n        return this.lut;\n    }\n    /**\n   * Sets the LUT.\n   *\n   * @deprecated Use lut instead.\n   * @param {Texture} value - The LUT.\n   */ setLUT(value) {\n        this.lut = value;\n    }\n    /**\n   * Updates the scale and offset for the LUT sampling coordinates.\n   *\n   * @private\n   */ updateScaleOffset() {\n        const lut = this.lut;\n        if (lut !== null) {\n            const size = Math.min(lut.image.width, lut.image.height);\n            const scale = this.uniforms.get(\"scale\").value;\n            const offset = this.uniforms.get(\"offset\").value;\n            if (this.tetrahedralInterpolation && lut instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n                if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n                    const domainScale = lut.domainMax.clone().sub(lut.domainMin);\n                    scale.setScalar(size - 1).divide(domainScale);\n                    offset.copy(lut.domainMin).negate().multiply(scale);\n                } else {\n                    scale.setScalar(size - 1);\n                    offset.setScalar(0);\n                }\n            } else {\n                if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n                    const domainScale = lut.domainMax.clone().sub(lut.domainMin).multiplyScalar(size);\n                    scale.setScalar(size - 1).divide(domainScale);\n                    offset.copy(lut.domainMin).negate().multiply(scale).addScalar(1 / (2 * size));\n                } else {\n                    scale.setScalar((size - 1) / size);\n                    offset.setScalar(1 / (2 * size));\n                }\n            }\n        }\n    }\n    /**\n   * Configures parameters for tetrahedral interpolation.\n   *\n   * @private\n   */ configureTetrahedralInterpolation() {\n        const lut = this.lut;\n        if (lut !== null) {\n            lut.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            lut.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            if (this.tetrahedralInterpolation) {\n                if (lut instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n                    lut.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n                    lut.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n                } else {\n                    console.warn(\"Tetrahedral interpolation requires a 3D texture\");\n                }\n            }\n            lut.needsUpdate = true;\n        }\n    }\n    /**\n   * Indicates whether tetrahedral interpolation is enabled. Requires a 3D LUT, disabled by default.\n   *\n   * Tetrahedral interpolation produces highly accurate results but is slower than hardware interpolation.\n   *\n   * @type {Boolean}\n   */ get tetrahedralInterpolation() {\n        return this.defines.has(\"TETRAHEDRAL_INTERPOLATION\");\n    }\n    set tetrahedralInterpolation(value) {\n        if (value) {\n            this.defines.set(\"TETRAHEDRAL_INTERPOLATION\", \"1\");\n        } else {\n            this.defines.delete(\"TETRAHEDRAL_INTERPOLATION\");\n        }\n        this.configureTetrahedralInterpolation();\n        this.updateScaleOffset();\n        this.setChanged();\n    }\n    /**\n   * Enables or disables tetrahedral interpolation.\n   *\n   * @deprecated Use tetrahedralInterpolation instead.\n   * @param {Boolean} value - Whether tetrahedral interpolation should be enabled.\n   */ setTetrahedralInterpolationEnabled(value) {\n        this.tetrahedralInterpolation = value;\n    }\n};\n// src/enums/DepthCopyMode.js\nvar DepthCopyMode = {\n    FULL: 0,\n    SINGLE: 1\n};\n// src/enums/EdgeDetectionMode.js\nvar EdgeDetectionMode = {\n    DEPTH: 0,\n    LUMA: 1,\n    COLOR: 2\n};\n// src/enums/PredicationMode.js\nvar PredicationMode = {\n    DISABLED: 0,\n    DEPTH: 1,\n    CUSTOM: 2\n};\n// src/enums/SMAAPreset.js\nvar SMAAPreset = {\n    LOW: 0,\n    MEDIUM: 1,\n    HIGH: 2,\n    ULTRA: 3\n};\n// src/enums/ToneMappingMode.js\nvar ToneMappingMode = {\n    LINEAR: 0,\n    REINHARD: 1,\n    REINHARD2: 2,\n    REINHARD2_ADAPTIVE: 3,\n    UNCHARTED2: 4,\n    OPTIMIZED_CINEON: 5,\n    CINEON: 5,\n    ACES_FILMIC: 6,\n    AGX: 7,\n    NEUTRAL: 8\n};\n// src/enums/VignetteTechnique.js\nvar VignetteTechnique = {\n    DEFAULT: 0,\n    ESKIL: 1\n};\n// src/enums/WebGLExtension.js\nvar WebGLExtension = {\n    DERIVATIVES: \"derivatives\",\n    FRAG_DEPTH: \"fragDepth\",\n    DRAW_BUFFERS: \"drawBuffers\",\n    SHADER_TEXTURE_LOD: \"shaderTextureLOD\"\n};\n// src/effects/glsl/noise.frag\nvar noise_default = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}`;\n// src/effects/NoiseEffect.js\nvar NoiseEffect = class extends Effect {\n    /**\n   * Constructs a new noise effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Boolean} [options.premultiply=false] - Whether the noise should be multiplied with the input colors prior to blending.\n   */ constructor({ blendFunction = BlendFunction.SCREEN, premultiply = false } = {}){\n        super(\"NoiseEffect\", noise_default, {\n            blendFunction\n        });\n        this.premultiply = premultiply;\n    }\n    /**\n   * Indicates whether noise will be multiplied with the input colors prior to blending.\n   *\n   * @type {Boolean}\n   */ get premultiply() {\n        return this.defines.has(\"PREMULTIPLY\");\n    }\n    set premultiply(value) {\n        if (this.premultiply !== value) {\n            if (value) {\n                this.defines.set(\"PREMULTIPLY\", \"1\");\n            } else {\n                this.defines.delete(\"PREMULTIPLY\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether noise will be multiplied with the input colors prior to blending.\n   *\n   * @deprecated Use premultiply instead.\n   * @return {Boolean} Whether noise is premultiplied.\n   */ isPremultiplied() {\n        return this.premultiply;\n    }\n    /**\n   * Controls whether noise should be multiplied with the input colors prior to blending.\n   *\n   * @deprecated Use premultiply instead.\n   * @param {Boolean} value - Whether noise should be premultiplied.\n   */ setPremultiplied(value) {\n        this.premultiply = value;\n    }\n};\n// src/effects/OutlineEffect.js\n\n// src/materials/DepthComparisonMaterial.js\n\n// src/materials/glsl/depth-comparison.frag\nvar depth_comparison_default = `#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\n#if DEPTH_PACKING == 3201\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#else\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\n#endif\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`;\n// src/materials/glsl/depth-comparison.vert\nvar depth_comparison_default2 = `#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}`;\n// src/materials/DepthComparisonMaterial.js\nvar DepthComparisonMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new depth comparison material.\n   *\n   * @param {Texture} [depthTexture=null] - A depth texture.\n   * @param {PerspectiveCamera} [camera] - A camera.\n   */ constructor(depthTexture = null, camera){\n        super({\n            name: \"DepthComparisonMaterial\",\n            defines: {\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n                cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: depth_comparison_default,\n            vertexShader: depth_comparison_default2\n        });\n        this.depthBuffer = depthTexture;\n        this.depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking;\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=RGBADepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNear.value = camera.near;\n            this.uniforms.cameraFar.value = camera.far;\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n};\n// src/materials/OutlineMaterial.js\n\n// src/materials/glsl/outline.frag\nvar outline_default = `uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}`;\n// src/materials/glsl/outline.vert\nvar outline_default2 = `uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/OutlineMaterial.js\nvar OutlineMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new outline material.\n   *\n   * TODO Remove texelSize param.\n   * @param {Vector2} [texelSize] - The screen texel size.\n   */ constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()){\n        super({\n            name: \"OutlineMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: outline_default,\n            vertexShader: outline_default2\n        });\n        this.uniforms.texelSize.value.set(texelSize.x, texelSize.y);\n        this.uniforms.maskTexture = this.uniforms.inputBuffer;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y);\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/passes/DepthPass.js\n\nvar DepthPass = class extends Pass {\n    /**\n   * Constructs a new depth pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Object} [options] - The options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(scene, camera, { renderTarget, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"DepthPass\");\n        this.needsSwap = false;\n        this.renderPass = new RenderPass(scene, camera, new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({\n            depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking\n        }));\n        const renderPass = this.renderPass;\n        renderPass.skipShadowMapUpdate = true;\n        renderPass.ignoreBackground = true;\n        const clearPass = renderPass.clearPass;\n        clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        clearPass.overrideClearAlpha = 1;\n        this.renderTarget = renderTarget;\n        if (this.renderTarget === void 0) {\n            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter\n            });\n            this.renderTarget.texture.name = \"DepthPass.Target\";\n        }\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    set mainScene(value) {\n        this.renderPass.mainScene = value;\n    }\n    set mainCamera(value) {\n        this.renderPass.mainCamera = value;\n    }\n    /**\n   * The depth texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the depth texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Renders the scene depth.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const renderTarget = this.renderToScreen ? null : this.renderTarget;\n        this.renderPass.render(renderer, renderTarget);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n};\n// src/effects/glsl/outline.frag\nvar outline_default3 = `uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texture2D(patternTexture,vUvPattern);\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}`;\n// src/effects/glsl/outline.vert\nvar outline_default4 = `uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}`;\n// src/effects/OutlineEffect.js\nvar OutlineEffect = class extends Effect {\n    /**\n   * Constructs a new outline effect.\n   *\n   * @param {Scene} scene - The main scene.\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function. Use `BlendFunction.ALPHA` for dark outlines.\n   * @param {Texture} [options.patternTexture=null] - A pattern texture.\n   * @param {Number} [options.patternScale=1.0] - The pattern scale.\n   * @param {Number} [options.edgeStrength=1.0] - The edge strength.\n   * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.\n   * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.\n   * @param {Number} [options.hiddenEdgeColor=0x22090a] - The color of hidden edges.\n   * @param {KernelSize} [options.kernelSize=KernelSize.VERY_SMALL] - The blur kernel size.\n   * @param {Boolean} [options.blur=false] - Whether the outline should be blurred.\n   * @param {Boolean} [options.xRay=true] - Whether occluded parts of selected objects should be visible.\n   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(scene, camera, { blendFunction = BlendFunction.SCREEN, patternTexture = null, patternScale = 1, edgeStrength = 1, pulseSpeed = 0, visibleEdgeColor = 16777215, hiddenEdgeColor = 2230538, kernelSize = KernelSize.VERY_SMALL, blur = false, xRay = true, multisampling = 0, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"OutlineEffect\", outline_default3, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"maskTexture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"edgeTexture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"edgeStrength\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(edgeStrength)\n                ],\n                [\n                    \"visibleEdgeColor\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color(visibleEdgeColor))\n                ],\n                [\n                    \"hiddenEdgeColor\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color(hiddenEdgeColor))\n                ],\n                [\n                    \"pulse\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"patternScale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(patternScale)\n                ],\n                [\n                    \"patternTexture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.blendMode.addEventListener(\"change\", (event)=>{\n            if (this.blendMode.blendFunction === BlendFunction.ALPHA) {\n                this.defines.set(\"ALPHA\", \"1\");\n            } else {\n                this.defines.delete(\"ALPHA\");\n            }\n            this.setChanged();\n        });\n        this.blendMode.blendFunction = blendFunction;\n        this.patternTexture = patternTexture;\n        this.xRay = xRay;\n        this.scene = scene;\n        this.camera = camera;\n        this.renderTargetMask = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1);\n        this.renderTargetMask.samples = multisampling;\n        this.renderTargetMask.texture.name = \"Outline.Mask\";\n        this.uniforms.get(\"maskTexture\").value = this.renderTargetMask.texture;\n        this.renderTargetOutline = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetOutline.texture.name = \"Outline.Edges\";\n        this.uniforms.get(\"edgeTexture\").value = this.renderTargetOutline.texture;\n        this.clearPass = new ClearPass();\n        this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.clearPass.overrideClearAlpha = 1;\n        this.depthPass = new DepthPass(scene, camera);\n        this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));\n        const clearPass = this.maskPass.clearPass;\n        clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        clearPass.overrideClearAlpha = 1;\n        this.blurPass = new KawaseBlurPass({\n            resolutionScale,\n            resolutionX,\n            resolutionY,\n            kernelSize\n        });\n        this.blurPass.enabled = blur;\n        const resolution = this.blurPass.resolution;\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.outlinePass = new ShaderPass(new OutlineMaterial());\n        const outlineMaterial = this.outlinePass.fullscreenMaterial;\n        outlineMaterial.inputBuffer = this.renderTargetMask.texture;\n        this.time = 0;\n        this.forceUpdate = true;\n        this.selection = new Selection();\n        this.pulseSpeed = pulseSpeed;\n    }\n    set mainScene(value) {\n        this.scene = value;\n        this.depthPass.mainScene = value;\n        this.maskPass.mainScene = value;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.depthPass.mainCamera = value;\n        this.maskPass.mainCamera = value;\n        this.maskPass.overrideMaterial.copyCameraSettings(value);\n    }\n    /**\n   * The resolution of this effect.\n   *\n   * @type {Resolution}\n   */ get resolution() {\n        return this.blurPass.resolution;\n    }\n    /**\n   * Returns the resolution.\n   *\n   * @return {Resizer} The resolution.\n   */ getResolution() {\n        return this.blurPass.getResolution();\n    }\n    /**\n   * The amount of MSAA samples.\n   *\n   * Requires WebGL 2. Set to zero to disable multisampling.\n   *\n   * @experimental Requires three >= r138.\n   * @type {Number}\n   */ get multisampling() {\n        return this.renderTargetMask.samples;\n    }\n    set multisampling(value) {\n        this.renderTargetMask.samples = value;\n        this.renderTargetMask.dispose();\n    }\n    /**\n   * The pattern scale.\n   *\n   * @type {Number}\n   */ get patternScale() {\n        return this.uniforms.get(\"patternScale\").value;\n    }\n    set patternScale(value) {\n        this.uniforms.get(\"patternScale\").value = value;\n    }\n    /**\n   * The edge strength.\n   *\n   * @type {Number}\n   */ get edgeStrength() {\n        return this.uniforms.get(\"edgeStrength\").value;\n    }\n    set edgeStrength(value) {\n        this.uniforms.get(\"edgeStrength\").value = value;\n    }\n    /**\n   * The visible edge color.\n   *\n   * @type {Color}\n   */ get visibleEdgeColor() {\n        return this.uniforms.get(\"visibleEdgeColor\").value;\n    }\n    set visibleEdgeColor(value) {\n        this.uniforms.get(\"visibleEdgeColor\").value = value;\n    }\n    /**\n   * The hidden edge color.\n   *\n   * @type {Color}\n   */ get hiddenEdgeColor() {\n        return this.uniforms.get(\"hiddenEdgeColor\").value;\n    }\n    set hiddenEdgeColor(value) {\n        this.uniforms.get(\"hiddenEdgeColor\").value = value;\n    }\n    /**\n   * Returns the blur pass.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */ getBlurPass() {\n        return this.blurPass;\n    }\n    /**\n   * Returns the selection.\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */ getSelection() {\n        return this.selection;\n    }\n    /**\n   * Returns the pulse speed.\n   *\n   * @deprecated Use pulseSpeed instead.\n   * @return {Number} The speed.\n   */ getPulseSpeed() {\n        return this.pulseSpeed;\n    }\n    /**\n   * Sets the pulse speed. Set to zero to disable.\n   *\n   * @deprecated Use pulseSpeed instead.\n   * @param {Number} value - The speed.\n   */ setPulseSpeed(value) {\n        this.pulseSpeed = value;\n    }\n    /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */ get width() {\n        return this.resolution.width;\n    }\n    set width(value) {\n        this.resolution.preferredWidth = value;\n    }\n    /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */ get height() {\n        return this.resolution.height;\n    }\n    set height(value) {\n        this.resolution.preferredHeight = value;\n    }\n    /**\n   * The selection layer.\n   *\n   * @type {Number}\n   * @deprecated Use selection.layer instead.\n   */ get selectionLayer() {\n        return this.selection.layer;\n    }\n    set selectionLayer(value) {\n        this.selection.layer = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get dithering() {\n        return this.blurPass.dithering;\n    }\n    set dithering(value) {\n        this.blurPass.dithering = value;\n    }\n    /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurPass.kernelSize instead.\n   */ get kernelSize() {\n        return this.blurPass.kernelSize;\n    }\n    set kernelSize(value) {\n        this.blurPass.kernelSize = value;\n    }\n    /**\n   * Indicates whether the outlines should be blurred.\n   *\n   * @type {Boolean}\n   * @deprecated Use blurPass.enabled instead.\n   */ get blur() {\n        return this.blurPass.enabled;\n    }\n    set blur(value) {\n        this.blurPass.enabled = value;\n    }\n    /**\n   * Indicates whether X-ray mode is enabled.\n   *\n   * @type {Boolean}\n   */ get xRay() {\n        return this.defines.has(\"X_RAY\");\n    }\n    set xRay(value) {\n        if (this.xRay !== value) {\n            if (value) {\n                this.defines.set(\"X_RAY\", \"1\");\n            } else {\n                this.defines.delete(\"X_RAY\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether X-ray mode is enabled.\n   *\n   * @deprecated Use xRay instead.\n   * @return {Boolean} Whether X-ray mode is enabled.\n   */ isXRayEnabled() {\n        return this.xRay;\n    }\n    /**\n   * Enables or disables X-ray outlines.\n   *\n   * @deprecated Use xRay instead.\n   * @param {Boolean} value - Whether X-ray should be enabled.\n   */ setXRayEnabled(value) {\n        this.xRay = value;\n    }\n    /**\n   * The pattern texture. Set to `null` to disable.\n   *\n   * @type {Texture}\n   */ get patternTexture() {\n        return this.uniforms.get(\"patternTexture\").value;\n    }\n    set patternTexture(value) {\n        if (value !== null) {\n            value.wrapS = value.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            this.defines.set(\"USE_PATTERN\", \"1\");\n            this.setVertexShader(outline_default4);\n        } else {\n            this.defines.delete(\"USE_PATTERN\");\n            this.setVertexShader(null);\n        }\n        this.uniforms.get(\"patternTexture\").value = value;\n        this.setChanged();\n    }\n    /**\n   * Sets the pattern texture.\n   *\n   * @deprecated Use patternTexture instead.\n   * @param {Texture} value - The new texture.\n   */ setPatternTexture(value) {\n        this.patternTexture = value;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Clears the current selection and selects a list of objects.\n   *\n   * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.set() instead.\n   */ setSelection(objects) {\n        this.selection.set(objects);\n        return this;\n    }\n    /**\n   * Clears the list of selected objects.\n   *\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.clear() instead.\n   */ clearSelection() {\n        this.selection.clear();\n        return this;\n    }\n    /**\n   * Selects an object.\n   *\n   * @param {Object3D} object - The object that should be outlined.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.add() instead.\n   */ selectObject(object) {\n        this.selection.add(object);\n        return this;\n    }\n    /**\n   * Deselects an object.\n   *\n   * @param {Object3D} object - The object that should no longer be outlined.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.delete() instead.\n   */ deselectObject(object) {\n        this.selection.delete(object);\n        return this;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const selection = this.selection;\n        const uniforms = this.uniforms;\n        const pulse = uniforms.get(\"pulse\");\n        const background = scene.background;\n        const mask = camera.layers.mask;\n        if (this.forceUpdate || selection.size > 0) {\n            scene.background = null;\n            pulse.value = 1;\n            if (this.pulseSpeed > 0) {\n                pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;\n            }\n            this.time += deltaTime;\n            selection.setVisible(false);\n            this.depthPass.render(renderer);\n            selection.setVisible(true);\n            camera.layers.set(selection.layer);\n            this.maskPass.render(renderer, this.renderTargetMask);\n            camera.layers.mask = mask;\n            scene.background = background;\n            this.outlinePass.render(renderer, null, this.renderTargetOutline);\n            if (this.blurPass.enabled) {\n                this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetOutline);\n            }\n        }\n        this.forceUpdate = selection.size > 0;\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.blurPass.setSize(width, height);\n        this.renderTargetMask.setSize(width, height);\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.depthPass.setSize(w, h);\n        this.renderTargetOutline.setSize(w, h);\n        this.outlinePass.fullscreenMaterial.setSize(w, h);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurPass.initialize(renderer, alpha, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);\n        if (frameBufferType !== void 0) {\n            this.depthPass.initialize(renderer, alpha, frameBufferType);\n            this.maskPass.initialize(renderer, alpha, frameBufferType);\n            this.outlinePass.initialize(renderer, alpha, frameBufferType);\n        }\n    }\n};\n// src/effects/PixelationEffect.js\n\n// src/effects/glsl/pixelation.frag\nvar pixelation_default = `uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}`;\n// src/effects/PixelationEffect.js\nvar PixelationEffect = class extends Effect {\n    /**\n   * Constructs a new pixelation effect.\n   *\n   * @param {Object} [granularity=30.0] - The pixel granularity.\n   */ constructor(granularity = 30){\n        super(\"PixelationEffect\", pixelation_default, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"active\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)\n                ],\n                [\n                    \"d\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4())\n                ]\n            ])\n        });\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this._granularity = 0;\n        this.granularity = granularity;\n    }\n    /**\n   * The pixel granularity.\n   *\n   * A higher value yields coarser visuals.\n   *\n   * @type {Number}\n   */ get granularity() {\n        return this._granularity;\n    }\n    set granularity(value) {\n        let d = Math.floor(value);\n        if (d % 2 > 0) {\n            d += 1;\n        }\n        this._granularity = d;\n        this.uniforms.get(\"active\").value = d > 0;\n        this.setSize(this.resolution.width, this.resolution.height);\n    }\n    /**\n   * Returns the pixel granularity.\n   *\n   * @deprecated Use granularity instead.\n   * @return {Number} The granularity.\n   */ getGranularity() {\n        return this.granularity;\n    }\n    /**\n   * Sets the pixel granularity.\n   *\n   * @deprecated Use granularity instead.\n   * @param {Number} value - The new granularity.\n   */ setGranularity(value) {\n        this.granularity = value;\n    }\n    /**\n   * Updates the granularity.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.set(width, height);\n        const d = this.granularity;\n        const x = d / resolution.x;\n        const y = d / resolution.y;\n        this.uniforms.get(\"d\").value.set(x, y, 1 / x, 1 / y);\n    }\n};\n// src/effects/RealisticBokehEffect.js\n\n// src/effects/glsl/realistic-bokeh.frag\nvar realistic_bokeh_default = `uniform float focus;uniform float focalLength;uniform float fStop;uniform float maxBlur;uniform float luminanceThreshold;uniform float luminanceGain;uniform float bias;uniform float fringe;\n#ifdef MANUAL_DOF\nuniform vec4 dof;\n#endif\n#ifdef PENTAGON\nfloat pentagon(const in vec2 coords){const vec4 HS0=vec4(1.0,0.0,0.0,1.0);const vec4 HS1=vec4(0.309016994,0.951056516,0.0,1.0);const vec4 HS2=vec4(-0.809016994,0.587785252,0.0,1.0);const vec4 HS3=vec4(-0.809016994,-0.587785252,0.0,1.0);const vec4 HS4=vec4(0.309016994,-0.951056516,0.0,1.0);const vec4 HS5=vec4(0.0,0.0,1.0,1.0);const vec4 ONE=vec4(1.0);const float P_FEATHER=0.4;const float N_FEATHER=-P_FEATHER;float inOrOut=-4.0;vec4 P=vec4(coords,vec2(RINGS_FLOAT-1.3));vec4 dist=vec4(dot(P,HS0),dot(P,HS1),dot(P,HS2),dot(P,HS3));dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dot(dist,ONE);dist.x=dot(P,HS4);dist.y=HS5.w-abs(P.z);dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dist.x;return clamp(inOrOut,0.0,1.0);}\n#endif\nvec3 processTexel(const in vec2 coords,const in float blur){vec2 scale=texelSize*fringe*blur;vec3 c=vec3(texture2D(inputBuffer,coords+vec2(0.0,1.0)*scale).r,texture2D(inputBuffer,coords+vec2(-0.866,-0.5)*scale).g,texture2D(inputBuffer,coords+vec2(0.866,-0.5)*scale).b);float luminance=linearToRelativeLuminance(c);float threshold=max((luminance-luminanceThreshold)*luminanceGain,0.0);return c+mix(vec3(0.0),c,threshold*blur);}float gather(const in float i,const in float j,const in float ringSamples,const in vec2 uv,const in vec2 blurFactor,const in float blur,inout vec3 color){float step=PI2/ringSamples;vec2 wh=vec2(cos(j*step)*i,sin(j*step)*i);\n#ifdef PENTAGON\nfloat p=pentagon(wh);\n#else\nfloat p=1.0;\n#endif\ncolor+=processTexel(wh*blurFactor+uv,blur)*mix(1.0,i/RINGS_FLOAT,bias)*p;return mix(1.0,i/RINGS_FLOAT,bias)*p;}void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\n#ifdef MANUAL_DOF\nfloat focalPlane=linearDepth-focus;float farDoF=(focalPlane-dof.z)/dof.w;float nearDoF=(-focalPlane-dof.x)/dof.y;float blur=(focalPlane>0.0)?farDoF:nearDoF;\n#else\nconst float CIRCLE_OF_CONFUSION=0.03;float focalPlaneMM=focus*1000.0;float depthMM=linearDepth*1000.0;float focalPlane=(depthMM*focalLength)/(depthMM-focalLength);float farDoF=(focalPlaneMM*focalLength)/(focalPlaneMM-focalLength);float nearDoF=(focalPlaneMM-focalLength)/(focalPlaneMM*fStop*CIRCLE_OF_CONFUSION);float blur=abs(focalPlane-farDoF)*nearDoF;\n#endif\nconst int MAX_RING_SAMPLES=RINGS_INT*SAMPLES_INT;blur=clamp(blur,0.0,1.0);vec3 color=inputColor.rgb;if(blur>=0.05){vec2 blurFactor=blur*maxBlur*texelSize;float s=1.0;int ringSamples;for(int i=1;i<=RINGS_INT;i++){ringSamples=i*SAMPLES_INT;for(int j=0;j<MAX_RING_SAMPLES;j++){if(j>=ringSamples){break;}s+=gather(float(i),float(j),float(ringSamples),uv,blurFactor,blur,color);}}color/=s;}\n#ifdef SHOW_FOCUS\nfloat edge=0.002*linearDepth;float m=clamp(smoothstep(0.0,edge,blur),0.0,1.0);float e=clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);color=mix(color,vec3(1.0,0.5,0.0),(1.0-m)*0.6);color=mix(color,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\n#endif\noutputColor=vec4(color,inputColor.a);}`;\n// src/effects/RealisticBokehEffect.js\nvar RealisticBokehEffect = class extends Effect {\n    /**\n   * Constructs a new bokeh effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.focus=1.0] - The focus distance in world units.\n   * @param {Number} [options.focalLength=24.0] - The focal length of the main camera.\n   * @param {Number} [options.fStop=0.9] - The ratio of the lens focal length to the diameter of the entrance pupil (aperture).\n   * @param {Number} [options.luminanceThreshold=0.5] - A luminance threshold.\n   * @param {Number} [options.luminanceGain=2.0] - A luminance gain factor.\n   * @param {Number} [options.bias=0.5] - A blur bias.\n   * @param {Number} [options.fringe=0.7] - A blur offset.\n   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.\n   * @param {Boolean} [options.rings=3] - The number of blur iterations.\n   * @param {Boolean} [options.samples=2] - The amount of samples taken per ring.\n   * @param {Boolean} [options.showFocus=false] - Whether the focal point should be highlighted. Useful for debugging.\n   * @param {Boolean} [options.manualDoF=false] - Enables manual control over the depth of field.\n   * @param {Boolean} [options.pentagon=false] - Enables pentagonal blur shapes. Requires a high number of rings and samples.\n   */ constructor({ blendFunction, focus = 1, focalLength = 24, fStop = 0.9, luminanceThreshold = 0.5, luminanceGain = 2, bias = 0.5, fringe = 0.7, maxBlur = 1, rings = 3, samples = 2, showFocus = false, manualDoF = false, pentagon = false } = {}){\n        super(\"RealisticBokehEffect\", realistic_bokeh_default, {\n            blendFunction,\n            attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"focus\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focus)\n                ],\n                [\n                    \"focalLength\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focalLength)\n                ],\n                [\n                    \"fStop\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(fStop)\n                ],\n                [\n                    \"luminanceThreshold\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceThreshold)\n                ],\n                [\n                    \"luminanceGain\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceGain)\n                ],\n                [\n                    \"bias\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(bias)\n                ],\n                [\n                    \"fringe\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(fringe)\n                ],\n                [\n                    \"maxBlur\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxBlur)\n                ],\n                [\n                    \"dof\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.rings = rings;\n        this.samples = samples;\n        this.showFocus = showFocus;\n        this.manualDoF = manualDoF;\n        this.pentagon = pentagon;\n    }\n    /**\n   * The amount of blur iterations.\n   *\n   * @type {Number}\n   */ get rings() {\n        return Number.parseInt(this.defines.get(\"RINGS_INT\"));\n    }\n    set rings(value) {\n        const r = Math.floor(value);\n        this.defines.set(\"RINGS_INT\", r.toFixed(0));\n        this.defines.set(\"RINGS_FLOAT\", r.toFixed(1));\n        this.setChanged();\n    }\n    /**\n   * The amount of blur samples per ring.\n   *\n   * @type {Number}\n   */ get samples() {\n        return Number.parseInt(this.defines.get(\"SAMPLES_INT\"));\n    }\n    set samples(value) {\n        const s = Math.floor(value);\n        this.defines.set(\"SAMPLES_INT\", s.toFixed(0));\n        this.defines.set(\"SAMPLES_FLOAT\", s.toFixed(1));\n        this.setChanged();\n    }\n    /**\n   * Indicates whether the focal point will be highlighted.\n   *\n   * @type {Boolean}\n   */ get showFocus() {\n        return this.defines.has(\"SHOW_FOCUS\");\n    }\n    set showFocus(value) {\n        if (this.showFocus !== value) {\n            if (value) {\n                this.defines.set(\"SHOW_FOCUS\", \"1\");\n            } else {\n                this.defines.delete(\"SHOW_FOCUS\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether the Depth of Field should be calculated manually.\n   *\n   * If enabled, the Depth of Field can be adjusted via the `dof` uniform.\n   *\n   * @type {Boolean}\n   */ get manualDoF() {\n        return this.defines.has(\"MANUAL_DOF\");\n    }\n    set manualDoF(value) {\n        if (this.manualDoF !== value) {\n            if (value) {\n                this.defines.set(\"MANUAL_DOF\", \"1\");\n                this.uniforms.get(\"dof\").value = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0.2, 1, 0.2, 2);\n            } else {\n                this.defines.delete(\"MANUAL_DOF\");\n                this.uniforms.get(\"dof\").value = null;\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether the blur shape should be pentagonal.\n   *\n   * @type {Boolean}\n   */ get pentagon() {\n        return this.defines.has(\"PENTAGON\");\n    }\n    set pentagon(value) {\n        if (this.pentagon !== value) {\n            if (value) {\n                this.defines.set(\"PENTAGON\", \"1\");\n            } else {\n                this.defines.delete(\"PENTAGON\");\n            }\n            this.setChanged();\n        }\n    }\n};\n// src/effects/ScanlineEffect.js\n\n// src/effects/glsl/scanlines.frag\nvar scanlines_default = `uniform float count;\n#ifdef SCROLL\nuniform float scrollSpeed;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;\n#ifdef SCROLL\ny+=time*scrollSpeed;\n#endif\nvec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}`;\n// src/effects/ScanlineEffect.js\nvar ScanlineEffect = class extends Effect {\n    /**\n   * Constructs a new scanline effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.\n   * @param {Number} [options.density=1.25] - The scanline density.\n   * @param {Number} [options.scrollSpeed=0.0] - The scanline scroll speed.\n   */ constructor({ blendFunction = BlendFunction.OVERLAY, density = 1.25, scrollSpeed = 0 } = {}){\n        super(\"ScanlineEffect\", scanlines_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"count\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n                ],\n                [\n                    \"scrollSpeed\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n                ]\n            ])\n        });\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.d = density;\n        this.scrollSpeed = scrollSpeed;\n    }\n    /**\n   * The scanline density.\n   *\n   * @type {Number}\n   */ get density() {\n        return this.d;\n    }\n    set density(value) {\n        this.d = value;\n        this.setSize(this.resolution.width, this.resolution.height);\n    }\n    /**\n   * Returns the current scanline density.\n   *\n   * @deprecated Use density instead.\n   * @return {Number} The scanline density.\n   */ getDensity() {\n        return this.density;\n    }\n    /**\n   * Sets the scanline density.\n   *\n   * @deprecated Use density instead.\n   * @param {Number} value - The new scanline density.\n   */ setDensity(value) {\n        this.density = value;\n    }\n    /**\n   * The scanline scroll speed. Default is 0 (disabled).\n   *\n   * @type {Number}\n   */ get scrollSpeed() {\n        return this.uniforms.get(\"scrollSpeed\").value;\n    }\n    set scrollSpeed(value) {\n        this.uniforms.get(\"scrollSpeed\").value = value;\n        if (value === 0) {\n            if (this.defines.delete(\"SCROLL\")) {\n                this.setChanged();\n            }\n        } else if (!this.defines.has(\"SCROLL\")) {\n            this.defines.set(\"SCROLL\", \"1\");\n            this.setChanged();\n        }\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.resolution.set(width, height);\n        this.uniforms.get(\"count\").value = Math.round(height * this.density);\n    }\n};\n// src/effects/ShockWaveEffect.js\n\n// src/effects/glsl/shock-wave.frag\nvar shock_wave_default = `uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}`;\n// src/effects/glsl/shock-wave.vert\nvar shock_wave_default2 = `uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}`;\n// src/effects/ShockWaveEffect.js\nvar HALF_PI = Math.PI * 0.5;\nvar v2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar ab = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar ShockWaveEffect = class extends Effect {\n    /**\n   * Constructs a new shock wave effect.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {Vector3} [position] - The world position of the shock wave.\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.speed=2.0] - The animation speed.\n   * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.\n   * @param {Number} [options.waveSize=0.2] - The wave size.\n   * @param {Number} [options.amplitude=0.05] - The distortion amplitude.\n   */ constructor(camera, position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), { speed = 2, maxRadius = 1, waveSize = 0.2, amplitude = 0.05 } = {}){\n        super(\"ShockWaveEffect\", shock_wave_default, {\n            vertexShader: shock_wave_default2,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"active\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)\n                ],\n                [\n                    \"center\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.5, 0.5))\n                ],\n                [\n                    \"cameraDistance\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"size\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"radius\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(-waveSize)\n                ],\n                [\n                    \"maxRadius\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxRadius)\n                ],\n                [\n                    \"waveSize\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(waveSize)\n                ],\n                [\n                    \"amplitude\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(amplitude)\n                ]\n            ])\n        });\n        this.position = position;\n        this.speed = speed;\n        this.camera = camera;\n        this.screenPosition = this.uniforms.get(\"center\").value;\n        this.time = 0;\n        this.active = false;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n    }\n    /**\n   * The amplitude.\n   *\n   * @type {Number}\n   */ get amplitude() {\n        return this.uniforms.get(\"amplitude\").value;\n    }\n    set amplitude(value) {\n        this.uniforms.get(\"amplitude\").value = value;\n    }\n    /**\n   * The wave size.\n   *\n   * @type {Number}\n   */ get waveSize() {\n        return this.uniforms.get(\"waveSize\").value;\n    }\n    set waveSize(value) {\n        this.uniforms.get(\"waveSize\").value = value;\n    }\n    /**\n   * The maximum radius.\n   *\n   * @type {Number}\n   */ get maxRadius() {\n        return this.uniforms.get(\"maxRadius\").value;\n    }\n    set maxRadius(value) {\n        this.uniforms.get(\"maxRadius\").value = value;\n    }\n    /**\n   * The position of the shock wave.\n   *\n   * @type {Vector3}\n   * @deprecated Use position instead.\n   */ get epicenter() {\n        return this.position;\n    }\n    set epicenter(value) {\n        this.position = value;\n    }\n    /**\n   * Returns the position of the shock wave.\n   *\n   * @deprecated Use position instead.\n   * @return {Vector3} The position.\n   */ getPosition() {\n        return this.position;\n    }\n    /**\n   * Sets the position of the shock wave.\n   *\n   * @deprecated Use position instead.\n   * @param {Vector3} value - The position.\n   */ setPosition(value) {\n        this.position = value;\n    }\n    /**\n   * Returns the speed of the shock wave.\n   *\n   * @deprecated Use speed instead.\n   * @return {Number} The speed.\n   */ getSpeed() {\n        return this.speed;\n    }\n    /**\n   * Sets the speed of the shock wave.\n   *\n   * @deprecated Use speed instead.\n   * @param {Number} value - The speed.\n   */ setSpeed(value) {\n        this.speed = value;\n    }\n    /**\n   * Emits the shock wave.\n   */ explode() {\n        this.time = 0;\n        this.active = true;\n        this.uniforms.get(\"active\").value = true;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [delta] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, delta) {\n        const position = this.position;\n        const camera = this.camera;\n        const uniforms = this.uniforms;\n        const uActive = uniforms.get(\"active\");\n        if (this.active) {\n            const waveSize = uniforms.get(\"waveSize\").value;\n            camera.getWorldDirection(v2);\n            ab.copy(camera.position).sub(position);\n            uActive.value = v2.angleTo(ab) > HALF_PI;\n            if (uActive.value) {\n                uniforms.get(\"cameraDistance\").value = camera.position.distanceTo(position);\n                v2.copy(position).project(camera);\n                this.screenPosition.set((v2.x + 1) * 0.5, (v2.y + 1) * 0.5);\n            }\n            this.time += delta * this.speed;\n            const radius = this.time - waveSize;\n            uniforms.get(\"radius\").value = radius;\n            if (radius >= (uniforms.get(\"maxRadius\").value + waveSize) * 2) {\n                this.active = false;\n                uActive.value = false;\n            }\n        }\n    }\n};\n// src/effects/SelectiveBloomEffect.js\n\nvar SelectiveBloomEffect = class extends BloomEffect {\n    /**\n   * Constructs a new selective bloom effect.\n   *\n   * @param {Scene} scene - The main scene.\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options. See {@link BloomEffect} for details.\n   */ constructor(scene, camera, options){\n        super(options);\n        this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH);\n        this.camera = camera;\n        this.depthPass = new DepthPass(scene, camera);\n        this.clearPass = new ClearPass(true, false, false);\n        this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n        const depthMaskMaterial = this.depthMaskMaterial;\n        depthMaskMaterial.copyCameraSettings(camera);\n        depthMaskMaterial.depthBuffer1 = this.depthPass.texture;\n        depthMaskMaterial.depthPacking1 = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking;\n        depthMaskMaterial.depthMode = three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth;\n        this.renderTargetMasked = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetMasked.texture.name = \"Bloom.Masked\";\n        this.selection = new Selection();\n        this._inverted = false;\n        this._ignoreBackground = false;\n    }\n    set mainScene(value) {\n        this.depthPass.mainScene = value;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.depthPass.mainCamera = value;\n        this.depthMaskMaterial.copyCameraSettings(value);\n    }\n    /**\n   * Returns the selection.\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */ getSelection() {\n        return this.selection;\n    }\n    /**\n   * The depth mask material.\n   *\n   * @type {DepthMaskMaterial}\n   * @private\n   */ get depthMaskMaterial() {\n        return this.depthMaskPass.fullscreenMaterial;\n    }\n    /**\n   * Indicates whether the selection should be considered inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this._inverted;\n    }\n    set inverted(value) {\n        this._inverted = value;\n        this.depthMaskMaterial.depthMode = value ? three__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth : three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth;\n    }\n    /**\n   * Indicates whether the mask is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the mask is inverted.\n   */ isInverted() {\n        return this.inverted;\n    }\n    /**\n   * Enables or disable mask inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the mask should be inverted.\n   */ setInverted(value) {\n        this.inverted = value;\n    }\n    /**\n   * Indicates whether the background colors will be ignored.\n   *\n   * @type {Boolean}\n   */ get ignoreBackground() {\n        return this._ignoreBackground;\n    }\n    set ignoreBackground(value) {\n        this._ignoreBackground = value;\n        this.depthMaskMaterial.maxDepthStrategy = value ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH;\n    }\n    /**\n   * Indicates whether the background is disabled.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @return {Boolean} Whether the background is disabled.\n   */ isBackgroundDisabled() {\n        return this.ignoreBackground;\n    }\n    /**\n   * Enables or disables the background.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @param {Boolean} value - Whether the background should be disabled.\n   */ setBackgroundDisabled(value) {\n        this.ignoreBackground = value;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthMaskMaterial.depthBuffer0 = depthTexture;\n        this.depthMaskMaterial.depthPacking0 = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const camera = this.camera;\n        const selection = this.selection;\n        const inverted = this.inverted;\n        let renderTarget = inputBuffer;\n        if (this.ignoreBackground || !inverted || selection.size > 0) {\n            const mask = camera.layers.mask;\n            camera.layers.set(selection.layer);\n            this.depthPass.render(renderer);\n            camera.layers.mask = mask;\n            renderTarget = this.renderTargetMasked;\n            this.clearPass.render(renderer, renderTarget);\n            this.depthMaskPass.render(renderer, inputBuffer, renderTarget);\n        }\n        super.update(renderer, renderTarget, deltaTime);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        super.setSize(width, height);\n        this.renderTargetMasked.setSize(width, height);\n        this.depthPass.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        super.initialize(renderer, alpha, frameBufferType);\n        this.clearPass.initialize(renderer, alpha, frameBufferType);\n        this.depthPass.initialize(renderer, alpha, frameBufferType);\n        this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n        if (renderer !== null && renderer.capabilities.logarithmicDepthBuffer) {\n            this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = \"1\";\n        }\n        if (frameBufferType !== void 0) {\n            this.renderTargetMasked.texture.type = frameBufferType;\n            if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTargetMasked.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n};\n// src/effects/SepiaEffect.js\n\n// src/effects/glsl/sepia.frag\nvar sepia_default = `uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}`;\n// src/effects/SepiaEffect.js\nvar SepiaEffect = class extends Effect {\n    /**\n   * Constructs a new sepia effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.intensity=1.0] - The intensity of the effect.\n   */ constructor({ blendFunction, intensity = 1 } = {}){\n        super(\"SepiaEffect\", sepia_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"weightsR\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.393, 0.769, 0.189))\n                ],\n                [\n                    \"weightsG\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.349, 0.686, 0.168))\n                ],\n                [\n                    \"weightsB\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.272, 0.534, 0.131))\n                ]\n            ])\n        });\n    }\n    /**\n   * The intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @type {Number}\n   */ get intensity() {\n        return this.blendMode.opacity.value;\n    }\n    set intensity(value) {\n        this.blendMode.opacity.value = value;\n    }\n    /**\n   * Returns the current sepia intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @return {Number} The intensity.\n   */ getIntensity() {\n        return this.intensity;\n    }\n    /**\n   * Sets the sepia intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @param {Number} value - The intensity.\n   */ setIntensity(value) {\n        this.intensity = value;\n    }\n    /**\n   * The weights for the red channel. Default is `(0.393, 0.769, 0.189)`.\n   *\n   * @type {Vector3}\n   */ get weightsR() {\n        return this.uniforms.get(\"weightsR\").value;\n    }\n    /**\n   * The weights for the green channel. Default is `(0.349, 0.686, 0.168)`.\n   *\n   * @type {Vector3}\n   */ get weightsG() {\n        return this.uniforms.get(\"weightsG\").value;\n    }\n    /**\n   * The weights for the blue channel. Default is `(0.272, 0.534, 0.131)`.\n   *\n   * @type {Vector3}\n   */ get weightsB() {\n        return this.uniforms.get(\"weightsB\").value;\n    }\n};\n// src/effects/SMAAEffect.js\n\n// src/materials/EdgeDetectionMaterial.js\n\n// src/materials/glsl/edge-detection.frag\nvar edge_detection_default = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}`;\n// src/materials/glsl/edge-detection.vert\nvar edge_detection_default2 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/EdgeDetectionMaterial.js\nvar EdgeDetectionMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new edge detection material.\n   *\n   * TODO Remove parameters.\n   * @param {Vector2} [texelSize] - The screen texel size.\n   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.\n   */ constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), mode = EdgeDetectionMode.COLOR){\n        super({\n            name: \"EdgeDetectionMaterial\",\n            defines: {\n                THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"),\n                LOCAL_CONTRAST_ADAPTATION_FACTOR: \"2.0\",\n                EDGE_THRESHOLD: \"0.1\",\n                DEPTH_THRESHOLD: \"0.01\",\n                PREDICATION_MODE: \"0\",\n                PREDICATION_THRESHOLD: \"0.01\",\n                PREDICATION_SCALE: \"2.0\",\n                PREDICATION_STRENGTH: \"1.0\",\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                predicationBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(texelSize)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: edge_detection_default,\n            vertexShader: edge_detection_default2\n        });\n        this.edgeDetectionMode = mode;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * The edge detection mode.\n   *\n   * @type {EdgeDetectionMode}\n   */ get edgeDetectionMode() {\n        return Number(this.defines.EDGE_DETECTION_MODE);\n    }\n    set edgeDetectionMode(value) {\n        this.defines.EDGE_DETECTION_MODE = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the edge detection mode.\n   *\n   * @deprecated Use edgeDetectionMode instead.\n   * @return {EdgeDetectionMode} The mode.\n   */ getEdgeDetectionMode() {\n        return this.edgeDetectionMode;\n    }\n    /**\n   * Sets the edge detection mode.\n   *\n   * @deprecated Use edgeDetectionMode instead.\n   * @param {EdgeDetectionMode} value - The edge detection mode.\n   */ setEdgeDetectionMode(value) {\n        this.edgeDetectionMode = value;\n    }\n    /**\n   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.\n   *\n   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.\n   *\n   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a\n   * direction, the perceptual contrast in the other neighbors will be hidden.\n   *\n   * @type {Number}\n   */ get localContrastAdaptationFactor() {\n        return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);\n    }\n    set localContrastAdaptationFactor(value) {\n        this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the local contrast adaptation factor.\n   *\n   * @deprecated Use localContrastAdaptationFactor instead.\n   * @return {Number} The factor.\n   */ getLocalContrastAdaptationFactor() {\n        return this.localContrastAdaptationFactor;\n    }\n    /**\n   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.\n   *\n   * @deprecated Use localContrastAdaptationFactor instead.\n   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.\n   */ setLocalContrastAdaptationFactor(value) {\n        this.localContrastAdaptationFactor = value;\n    }\n    /**\n   * The edge detection threshold. Range: [0.0, 0.5].\n   *\n   * A lower value results in more edges being detected at the expense of performance.\n   *\n   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05\n   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.\n   *\n   * If depth-based edge detection is used, the threshold will depend on the scene depth.\n   *\n   * @type {Number}\n   */ get edgeDetectionThreshold() {\n        return Number(this.defines.EDGE_THRESHOLD);\n    }\n    set edgeDetectionThreshold(value) {\n        this.defines.EDGE_THRESHOLD = value.toFixed(\"6\");\n        this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the edge detection threshold.\n   *\n   * @deprecated Use edgeDetectionThreshold instead.\n   * @return {Number} The threshold.\n   */ getEdgeDetectionThreshold() {\n        return this.edgeDetectionThreshold;\n    }\n    /**\n   * Sets the edge detection threshold.\n   *\n   * @deprecated Use edgeDetectionThreshold instead.\n   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].\n   */ setEdgeDetectionThreshold(value) {\n        this.edgeDetectionThreshold = value;\n    }\n    /**\n   * The predication mode.\n   *\n   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional\n   * buffer such as a light accumulation or depth buffer.\n   *\n   * @type {PredicationMode}\n   */ get predicationMode() {\n        return Number(this.defines.PREDICATION_MODE);\n    }\n    set predicationMode(value) {\n        this.defines.PREDICATION_MODE = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the predication mode.\n   *\n   * @deprecated Use predicationMode instead.\n   * @return {PredicationMode} The mode.\n   */ getPredicationMode() {\n        return this.predicationMode;\n    }\n    /**\n   * Sets the predication mode.\n   *\n   * @deprecated Use predicationMode instead.\n   * @param {PredicationMode} value - The predication mode.\n   */ setPredicationMode(value) {\n        this.predicationMode = value;\n    }\n    /**\n   * The predication buffer.\n   *\n   * @type {Texture}\n   */ set predicationBuffer(value) {\n        this.uniforms.predicationBuffer.value = value;\n    }\n    /**\n   * Sets a custom predication buffer.\n   *\n   * @deprecated Use predicationBuffer instead.\n   * @param {Texture} value - The predication buffer.\n   */ setPredicationBuffer(value) {\n        this.uniforms.predicationBuffer.value = value;\n    }\n    /**\n   * The predication threshold.\n   *\n   * @type {Number}\n   */ get predicationThreshold() {\n        return Number(this.defines.PREDICATION_THRESHOLD);\n    }\n    set predicationThreshold(value) {\n        this.defines.PREDICATION_THRESHOLD = value.toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the predication threshold.\n   *\n   * @deprecated Use predicationThreshold instead.\n   * @return {Number} The threshold.\n   */ getPredicationThreshold() {\n        return this.predicationThreshold;\n    }\n    /**\n   * Sets the predication threshold.\n   *\n   * @deprecated Use predicationThreshold instead.\n   * @param {Number} value - The threshold.\n   */ setPredicationThreshold(value) {\n        this.predicationThreshold = value;\n    }\n    /**\n   * The predication scale. Range: [1.0, 5.0].\n   *\n   * Determines how much the edge detection threshold should be scaled when using predication.\n   *\n   * @type {Boolean|Texture|Number}\n   */ get predicationScale() {\n        return Number(this.defines.PREDICATION_SCALE);\n    }\n    set predicationScale(value) {\n        this.defines.PREDICATION_SCALE = value.toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the predication scale.\n   *\n   * @deprecated Use predicationScale instead.\n   * @return {Number} The scale.\n   */ getPredicationScale() {\n        return this.predicationScale;\n    }\n    /**\n   * Sets the predication scale.\n   *\n   * @deprecated Use predicationScale instead.\n   * @param {Number} value - The scale. Range: [1.0, 5.0].\n   */ setPredicationScale(value) {\n        this.predicationScale = value;\n    }\n    /**\n   * The predication strength. Range: [0.0, 1.0].\n   *\n   * Determines how much the edge detection threshold should be decreased locally when using predication.\n   *\n   * @type {Number}\n   */ get predicationStrength() {\n        return Number(this.defines.PREDICATION_STRENGTH);\n    }\n    set predicationStrength(value) {\n        this.defines.PREDICATION_STRENGTH = value.toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the predication strength.\n   *\n   * @deprecated Use predicationStrength instead.\n   * @return {Number} The strength.\n   */ getPredicationStrength() {\n        return this.predicationStrength;\n    }\n    /**\n   * Sets the predication strength.\n   *\n   * @deprecated Use predicationStrength instead.\n   * @param {Number} value - The strength. Range: [0.0, 1.0].\n   */ setPredicationStrength(value) {\n        this.predicationStrength = value;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/SMAAWeightsMaterial.js\n\n// src/materials/glsl/smaa-weights.frag\nvar smaa_weights_default = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`;\n// src/materials/glsl/smaa-weights.vert\nvar smaa_weights_default2 = `uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/SMAAWeightsMaterial.js\nvar SMAAWeightsMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new SMAA weights material.\n   *\n   * @param {Vector2} [texelSize] - The absolute screen texel size.\n   * @param {Vector2} [resolution] - The resolution.\n   */ constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()){\n        super({\n            name: \"SMAAWeightsMaterial\",\n            defines: {\n                // Configurable settings:\n                MAX_SEARCH_STEPS_INT: \"16\",\n                MAX_SEARCH_STEPS_FLOAT: \"16.0\",\n                MAX_SEARCH_STEPS_DIAG_INT: \"8\",\n                MAX_SEARCH_STEPS_DIAG_FLOAT: \"8.0\",\n                CORNER_ROUNDING: \"25\",\n                CORNER_ROUNDING_NORM: \"0.25\",\n                // Non-configurable settings:\n                AREATEX_MAX_DISTANCE: \"16.0\",\n                AREATEX_MAX_DISTANCE_DIAG: \"20.0\",\n                AREATEX_PIXEL_SIZE: \"(1.0 / vec2(160.0, 560.0))\",\n                AREATEX_SUBTEX_SIZE: \"(1.0 / 7.0)\",\n                SEARCHTEX_SIZE: \"vec2(66.0, 33.0)\",\n                SEARCHTEX_PACKED_SIZE: \"vec2(64.0, 16.0)\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                searchTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                areaTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(resolution),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(texelSize)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: smaa_weights_default,\n            vertexShader: smaa_weights_default2\n        });\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The search lookup texture.\n   *\n   * @type {Texture}\n   */ get searchTexture() {\n        return this.uniforms.searchTexture.value;\n    }\n    set searchTexture(value) {\n        this.uniforms.searchTexture.value = value;\n    }\n    /**\n   * The area lookup texture.\n   *\n   * @type {Texture}\n   */ get areaTexture() {\n        return this.uniforms.areaTexture.value;\n    }\n    set areaTexture(value) {\n        this.uniforms.areaTexture.value = value;\n    }\n    /**\n   * Sets the search and area lookup textures.\n   *\n   * @deprecated Use searchTexture and areaTexture instead.\n   * @param {Texture} search - The search lookup texture.\n   * @param {Texture} area - The area lookup texture.\n   */ setLookupTextures(search, area2) {\n        this.searchTexture = search;\n        this.areaTexture = area2;\n    }\n    /**\n   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.\n   * Range: [0, 112].\n   *\n   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is\n   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).\n   *\n   * @type {Number}\n   */ get orthogonalSearchSteps() {\n        return Number(this.defines.MAX_SEARCH_STEPS_INT);\n    }\n    set orthogonalSearchSteps(value) {\n        const s = Math.min(Math.max(value, 0), 112);\n        this.defines.MAX_SEARCH_STEPS_INT = s.toFixed(\"0\");\n        this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed(\"1\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.\n   *\n   * @deprecated Use orthogonalSearchSteps instead.\n   * @param {Number} value - The search steps. Range: [0, 112].\n   */ setOrthogonalSearchSteps(value) {\n        this.orthogonalSearchSteps = value;\n    }\n    /**\n   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search\n   * jumps one pixel at a time. Range: [0, 20].\n   *\n   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a\n   * significant impact on older machines.\n   *\n   * @type {Number}\n   */ get diagonalSearchSteps() {\n        return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);\n    }\n    set diagonalSearchSteps(value) {\n        const s = Math.min(Math.max(value, 0), 20);\n        this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed(\"0\");\n        this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed(\"1\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.\n   *\n   * @deprecated Use diagonalSearchSteps instead.\n   * @param {Number} value - The search steps. Range: [0, 20].\n   */ setDiagonalSearchSteps(value) {\n        this.diagonalSearchSteps = value;\n    }\n    /**\n   * Indicates whether diagonal pattern detection is enabled.\n   *\n   * @type {Boolean}\n   */ get diagonalDetection() {\n        return this.defines.DISABLE_DIAG_DETECTION === void 0;\n    }\n    set diagonalDetection(value) {\n        if (value) {\n            delete this.defines.DISABLE_DIAG_DETECTION;\n        } else {\n            this.defines.DISABLE_DIAG_DETECTION = \"1\";\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether diagonal pattern detection is enabled.\n   *\n   * @deprecated Use diagonalDetection instead.\n   * @return {Boolean} Whether diagonal pattern detection is enabled.\n   */ isDiagonalDetectionEnabled() {\n        return this.diagonalDetection;\n    }\n    /**\n   * Enables or disables diagonal pattern detection.\n   *\n   * @deprecated Use diagonalDetection instead.\n   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.\n   */ setDiagonalDetectionEnabled(value) {\n        this.diagonalDetection = value;\n    }\n    /**\n   * Specifies how much sharp corners will be rounded. Range: [0, 100].\n   *\n   * @type {Number}\n   */ get cornerRounding() {\n        return Number(this.defines.CORNER_ROUNDING);\n    }\n    set cornerRounding(value) {\n        const r = Math.min(Math.max(value, 0), 100);\n        this.defines.CORNER_ROUNDING = r.toFixed(\"4\");\n        this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed(\"4\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Specifies how much sharp corners will be rounded.\n   *\n   * @deprecated Use cornerRounding instead.\n   * @param {Number} value - The corner rounding amount. Range: [0, 100].\n   */ setCornerRounding(value) {\n        this.cornerRounding = value;\n    }\n    /**\n   * Indicates whether corner detection is enabled.\n   *\n   * @type {Number}\n   */ get cornerDetection() {\n        return this.defines.DISABLE_CORNER_DETECTION === void 0;\n    }\n    set cornerDetection(value) {\n        if (value) {\n            delete this.defines.DISABLE_CORNER_DETECTION;\n        } else {\n            this.defines.DISABLE_CORNER_DETECTION = \"1\";\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether corner rounding is enabled.\n   *\n   * @deprecated Use cornerDetection instead.\n   * @return {Boolean} Whether corner rounding is enabled.\n   */ isCornerRoundingEnabled() {\n        return this.cornerDetection;\n    }\n    /**\n   * Enables or disables corner rounding.\n   *\n   * @deprecated Use cornerDetection instead.\n   * @param {Boolean} value - Whether corner rounding should be enabled.\n   */ setCornerRoundingEnabled(value) {\n        this.cornerDetection = value;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const uniforms = this.uniforms;\n        uniforms.texelSize.value.set(1 / width, 1 / height);\n        uniforms.resolution.value.set(width, height);\n    }\n};\n// src/textures/smaa/searchImageDataURL.js\nvar searchImageDataURL_default = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC\";\n// src/textures/smaa/areaImageDataURL.js\nvar areaImageDataURL_default = \"data:image/png;base64,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\";\n// src/effects/glsl/smaa.frag\nvar smaa_default = `uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}`;\n// src/effects/glsl/smaa.vert\nvar smaa_default2 = `varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}`;\n// src/effects/SMAAEffect.js\nvar SMAAEffect = class extends Effect {\n    /**\n   * Constructs a new SMAA effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.\n   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.\n   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.\n   */ constructor({ blendFunction = BlendFunction.SRC, preset = SMAAPreset.MEDIUM, edgeDetectionMode = EdgeDetectionMode.COLOR, predicationMode = PredicationMode.DISABLED } = {}){\n        super(\"SMAAEffect\", smaa_default, {\n            vertexShader: smaa_default2,\n            blendFunction,\n            attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"weightMap\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        let searchImage, areaImage;\n        if (arguments.length > 1) {\n            searchImage = arguments[0];\n            areaImage = arguments[1];\n            if (arguments.length > 2) {\n                preset = arguments[2];\n            }\n            if (arguments.length > 3) {\n                edgeDetectionMode = arguments[3];\n            }\n        }\n        this.renderTargetEdges = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetEdges.texture.name = \"SMAA.Edges\";\n        this.renderTargetWeights = this.renderTargetEdges.clone();\n        this.renderTargetWeights.texture.name = \"SMAA.Weights\";\n        this.uniforms.get(\"weightMap\").value = this.renderTargetWeights.texture;\n        this.clearPass = new ClearPass(true, false, false);\n        this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.clearPass.overrideClearAlpha = 1;\n        this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());\n        this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;\n        this.edgeDetectionMaterial.predicationMode = predicationMode;\n        this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());\n        const loadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        loadingManager.onLoad = ()=>{\n            const searchTexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(searchImage);\n            searchTexture.name = \"SMAA.Search\";\n            searchTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            searchTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            searchTexture.generateMipmaps = false;\n            searchTexture.needsUpdate = true;\n            searchTexture.flipY = true;\n            this.weightsMaterial.searchTexture = searchTexture;\n            const areaTexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(areaImage);\n            areaTexture.name = \"SMAA.Area\";\n            areaTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            areaTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            areaTexture.generateMipmaps = false;\n            areaTexture.needsUpdate = true;\n            areaTexture.flipY = false;\n            this.weightsMaterial.areaTexture = areaTexture;\n            this.dispatchEvent({\n                type: \"load\"\n            });\n        };\n        loadingManager.itemStart(\"search\");\n        loadingManager.itemStart(\"area\");\n        if (searchImage !== void 0 && areaImage !== void 0) {\n            loadingManager.itemEnd(\"search\");\n            loadingManager.itemEnd(\"area\");\n        } else if (typeof Image !== \"undefined\") {\n            searchImage = new Image();\n            areaImage = new Image();\n            searchImage.addEventListener(\"load\", ()=>loadingManager.itemEnd(\"search\"));\n            areaImage.addEventListener(\"load\", ()=>loadingManager.itemEnd(\"area\"));\n            searchImage.src = searchImageDataURL_default;\n            areaImage.src = areaImageDataURL_default;\n        }\n        this.applyPreset(preset);\n    }\n    /**\n   * The edges texture.\n   *\n   * @type {Texture}\n   */ get edgesTexture() {\n        return this.renderTargetEdges.texture;\n    }\n    /**\n   * Returns the edges texture.\n   *\n   * @deprecated Use edgesTexture instead.\n   * @return {Texture} The texture.\n   */ getEdgesTexture() {\n        return this.edgesTexture;\n    }\n    /**\n   * The edge weights texture.\n   *\n   * @type {Texture}\n   */ get weightsTexture() {\n        return this.renderTargetWeights.texture;\n    }\n    /**\n   * Returns the edge weights texture.\n   *\n   * @deprecated Use weightsTexture instead.\n   * @return {Texture} The texture.\n   */ getWeightsTexture() {\n        return this.weightsTexture;\n    }\n    /**\n   * The edge detection material.\n   *\n   * @type {EdgeDetectionMaterial}\n   */ get edgeDetectionMaterial() {\n        return this.edgeDetectionPass.fullscreenMaterial;\n    }\n    /**\n   * The edge detection material.\n   *\n   * @type {EdgeDetectionMaterial}\n   * @deprecated Use edgeDetectionMaterial instead.\n   */ get colorEdgesMaterial() {\n        return this.edgeDetectionMaterial;\n    }\n    /**\n   * Returns the edge detection material.\n   *\n   * @deprecated Use edgeDetectionMaterial instead.\n   * @return {EdgeDetectionMaterial} The material.\n   */ getEdgeDetectionMaterial() {\n        return this.edgeDetectionMaterial;\n    }\n    /**\n   * The edge weights material.\n   *\n   * @type {SMAAWeightsMaterial}\n   */ get weightsMaterial() {\n        return this.weightsPass.fullscreenMaterial;\n    }\n    /**\n   * Returns the edge weights material.\n   *\n   * @deprecated Use weightsMaterial instead.\n   * @return {SMAAWeightsMaterial} The material.\n   */ getWeightsMaterial() {\n        return this.weightsMaterial;\n    }\n    /**\n   * Sets the edge detection sensitivity.\n   *\n   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.\n   *\n   * @deprecated Use edgeDetectionMaterial instead.\n   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].\n   */ setEdgeDetectionThreshold(threshold) {\n        this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;\n    }\n    /**\n   * Sets the maximum amount of horizontal/vertical search steps.\n   *\n   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.\n   *\n   * @deprecated Use weightsMaterial instead.\n   * @param {Number} steps - The search steps. Range: [0, 112].\n   */ setOrthogonalSearchSteps(steps) {\n        this.weightsMaterial.orthogonalSearchSteps = steps;\n    }\n    /**\n   * Applies the given quality preset.\n   *\n   * @param {SMAAPreset} preset - The preset.\n   */ applyPreset(preset) {\n        const edgeDetectionMaterial = this.edgeDetectionMaterial;\n        const weightsMaterial = this.weightsMaterial;\n        switch(preset){\n            case SMAAPreset.LOW:\n                edgeDetectionMaterial.edgeDetectionThreshold = 0.15;\n                weightsMaterial.orthogonalSearchSteps = 4;\n                weightsMaterial.diagonalDetection = false;\n                weightsMaterial.cornerDetection = false;\n                break;\n            case SMAAPreset.MEDIUM:\n                edgeDetectionMaterial.edgeDetectionThreshold = 0.1;\n                weightsMaterial.orthogonalSearchSteps = 8;\n                weightsMaterial.diagonalDetection = false;\n                weightsMaterial.cornerDetection = false;\n                break;\n            case SMAAPreset.HIGH:\n                edgeDetectionMaterial.edgeDetectionThreshold = 0.1;\n                weightsMaterial.orthogonalSearchSteps = 16;\n                weightsMaterial.diagonalSearchSteps = 8;\n                weightsMaterial.cornerRounding = 25;\n                weightsMaterial.diagonalDetection = true;\n                weightsMaterial.cornerDetection = true;\n                break;\n            case SMAAPreset.ULTRA:\n                edgeDetectionMaterial.edgeDetectionThreshold = 0.05;\n                weightsMaterial.orthogonalSearchSteps = 32;\n                weightsMaterial.diagonalSearchSteps = 16;\n                weightsMaterial.cornerRounding = 25;\n                weightsMaterial.diagonalDetection = true;\n                weightsMaterial.cornerDetection = true;\n                break;\n        }\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.edgeDetectionMaterial.depthBuffer = depthTexture;\n        this.edgeDetectionMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        this.clearPass.render(renderer, this.renderTargetEdges);\n        this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);\n        this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.edgeDetectionMaterial.setSize(width, height);\n        this.weightsMaterial.setSize(width, height);\n        this.renderTargetEdges.setSize(width, height);\n        this.renderTargetWeights.setSize(width, height);\n    }\n    /**\n   * Deletes internal render targets and textures.\n   */ dispose() {\n        const { searchTexture, areaTexture } = this.weightsMaterial;\n        if (searchTexture !== null && areaTexture !== null) {\n            searchTexture.dispose();\n            areaTexture.dispose();\n        }\n        super.dispose();\n    }\n    /**\n   * The SMAA search image, encoded as a base64 data URL.\n   *\n   * @type {String}\n   * @deprecated\n   */ static get searchImageDataURL() {\n        return searchImageDataURL_default;\n    }\n    /**\n   * The SMAA area image, encoded as a base64 data URL.\n   *\n   * @type {String}\n   * @deprecated\n   */ static get areaImageDataURL() {\n        return areaImageDataURL_default;\n    }\n};\n// src/effects/SSAOEffect.js\n\n// src/materials/SSAOMaterial.js\n\n// src/materials/glsl/ssao.frag\nvar ssao_default = `#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}`;\n// src/materials/glsl/ssao.vert\nvar ssao_default2 = `uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/SSAOMaterial.js\nvar SSAOMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new SSAO material.\n   *\n   * @param {Camera} camera - A camera.\n   */ constructor(camera){\n        super({\n            name: \"SSAOMaterial\",\n            defines: {\n                SAMPLES_INT: \"0\",\n                INV_SAMPLES_FLOAT: \"0.0\",\n                SPIRAL_TURNS: \"0.0\",\n                RADIUS: \"1.0\",\n                RADIUS_SQ: \"1.0\",\n                DISTANCE_SCALING: \"1\",\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                normalBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                normalDepthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                noiseTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                inverseProjectionMatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()),\n                projectionMatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                distanceCutoff: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                proximityCutoff: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                noiseScale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                minRadiusScale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.33),\n                intensity: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                fade: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.01),\n                bias: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: ssao_default,\n            vertexShader: ssao_default2\n        });\n        this.copyCameraSettings(camera);\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.r = 1;\n    }\n    /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get near() {\n        return this.uniforms.cameraNearFar.value.x;\n    }\n    /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get far() {\n        return this.uniforms.cameraNearFar.value.y;\n    }\n    /**\n   * A combined normal-depth buffer.\n   *\n   * @type {Texture}\n   */ set normalDepthBuffer(value) {\n        this.uniforms.normalDepthBuffer.value = value;\n        if (value !== null) {\n            this.defines.NORMAL_DEPTH = \"1\";\n        } else {\n            delete this.defines.NORMAL_DEPTH;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the combined normal-depth buffer.\n   *\n   * @deprecated Use normalDepthBuffer instead.\n   * @param {Number} value - The buffer.\n   */ setNormalDepthBuffer(value) {\n        this.normalDepthBuffer = value;\n    }\n    /**\n   * The normal buffer.\n   *\n   * @type {Texture}\n   */ set normalBuffer(value) {\n        this.uniforms.normalBuffer.value = value;\n    }\n    /**\n   * Sets the normal buffer.\n   *\n   * @deprecated Use normalBuffer instead.\n   * @param {Number} value - The buffer.\n   */ setNormalBuffer(value) {\n        this.uniforms.normalBuffer.value = value;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * The noise texture.\n   *\n   * @type {Texture}\n   */ set noiseTexture(value) {\n        this.uniforms.noiseTexture.value = value;\n    }\n    /**\n   * Sets the noise texture.\n   *\n   * @deprecated Use noiseTexture instead.\n   * @param {Number} value - The texture.\n   */ setNoiseTexture(value) {\n        this.uniforms.noiseTexture.value = value;\n    }\n    /**\n   * The sample count.\n   *\n   * @type {Number}\n   */ get samples() {\n        return Number(this.defines.SAMPLES_INT);\n    }\n    set samples(value) {\n        this.defines.SAMPLES_INT = value.toFixed(0);\n        this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the amount of occlusion samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @return {Number} The sample count.\n   */ getSamples() {\n        return this.samples;\n    }\n    /**\n   * Sets the amount of occlusion samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @param {Number} value - The sample count.\n   */ setSamples(value) {\n        this.samples = value;\n    }\n    /**\n   * The sampling spiral ring count.\n   *\n   * @type {Number}\n   */ get rings() {\n        return Number(this.defines.SPIRAL_TURNS);\n    }\n    set rings(value) {\n        this.defines.SPIRAL_TURNS = value.toFixed(1);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @deprecated Use rings instead.\n   * @return {Number} The radius.\n   */ getRings() {\n        return this.rings;\n    }\n    /**\n   * Sets the amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @deprecated Use rings instead.\n   * @param {Number} value - The radius.\n   */ setRings(value) {\n        this.rings = value;\n    }\n    /**\n   * The intensity.\n   *\n   * @type {Number}\n   * @deprecated Use SSAOEffect.intensity instead.\n   */ get intensity() {\n        return this.uniforms.intensity.value;\n    }\n    set intensity(value) {\n        this.uniforms.intensity.value = value;\n        if (this.defines.LEGACY_INTENSITY === void 0) {\n            this.defines.LEGACY_INTENSITY = \"1\";\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Returns the intensity.\n   *\n   * @deprecated Use SSAOEffect.intensity instead.\n   * @return {Number} The intensity.\n   */ getIntensity() {\n        return this.uniforms.intensity.value;\n    }\n    /**\n   * Sets the intensity.\n   *\n   * @deprecated Use SSAOEffect.intensity instead.\n   * @param {Number} value - The intensity.\n   */ setIntensity(value) {\n        this.uniforms.intensity.value = value;\n    }\n    /**\n   * The depth fade factor.\n   *\n   * @type {Number}\n   */ get fade() {\n        return this.uniforms.fade.value;\n    }\n    set fade(value) {\n        this.uniforms.fade.value = value;\n    }\n    /**\n   * Returns the depth fade factor.\n   *\n   * @deprecated Use fade instead.\n   * @return {Number} The fade factor.\n   */ getFade() {\n        return this.uniforms.fade.value;\n    }\n    /**\n   * Sets the depth fade factor.\n   *\n   * @deprecated Use fade instead.\n   * @param {Number} value - The fade factor.\n   */ setFade(value) {\n        this.uniforms.fade.value = value;\n    }\n    /**\n   * The depth bias. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get bias() {\n        return this.uniforms.bias.value;\n    }\n    set bias(value) {\n        this.uniforms.bias.value = value;\n    }\n    /**\n   * Returns the depth bias.\n   *\n   * @deprecated Use bias instead.\n   * @return {Number} The bias.\n   */ getBias() {\n        return this.uniforms.bias.value;\n    }\n    /**\n   * Sets the depth bias.\n   *\n   * @deprecated Use bias instead.\n   * @param {Number} value - The bias.\n   */ setBias(value) {\n        this.uniforms.bias.value = value;\n    }\n    /**\n   * The minimum radius scale for distance scaling. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get minRadiusScale() {\n        return this.uniforms.minRadiusScale.value;\n    }\n    set minRadiusScale(value) {\n        this.uniforms.minRadiusScale.value = value;\n    }\n    /**\n   * Returns the minimum radius scale for distance scaling.\n   *\n   * @deprecated Use minRadiusScale instead.\n   * @return {Number} The minimum radius scale.\n   */ getMinRadiusScale() {\n        return this.uniforms.minRadiusScale.value;\n    }\n    /**\n   * Sets the minimum radius scale for distance scaling.\n   *\n   * @deprecated Use minRadiusScale instead.\n   * @param {Number} value - The minimum radius scale.\n   */ setMinRadiusScale(value) {\n        this.uniforms.minRadiusScale.value = value;\n    }\n    /**\n   * Updates the absolute radius.\n   *\n   * @private\n   */ updateRadius() {\n        const radius = this.r * this.resolution.height;\n        this.defines.RADIUS = radius.toFixed(11);\n        this.defines.RADIUS_SQ = (radius * radius).toFixed(11);\n        this.needsUpdate = true;\n    }\n    /**\n   * The occlusion sampling radius. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get radius() {\n        return this.r;\n    }\n    set radius(value) {\n        this.r = Math.min(Math.max(value, 1e-6), 1);\n        this.updateRadius();\n    }\n    /**\n   * Returns the occlusion sampling radius.\n   *\n   * @deprecated Use radius instead.\n   * @return {Number} The radius.\n   */ getRadius() {\n        return this.radius;\n    }\n    /**\n   * Sets the occlusion sampling radius.\n   *\n   * @deprecated Use radius instead.\n   * @param {Number} value - The radius. Range [1e-6, 1.0].\n   */ setRadius(value) {\n        this.radius = value;\n    }\n    /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get distanceScaling() {\n        return true;\n    }\n    set distanceScaling(value) {}\n    /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @deprecated\n   * @return {Boolean} Whether distance scaling is enabled.\n   */ isDistanceScalingEnabled() {\n        return this.distanceScaling;\n    }\n    /**\n   * Enables or disables distance-based radius scaling.\n   *\n   * @deprecated\n   * @param {Boolean} value - Whether distance scaling should be enabled.\n   */ setDistanceScalingEnabled(value) {\n        this.distanceScaling = value;\n    }\n    /**\n   * The occlusion distance threshold. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get distanceThreshold() {\n        return this.uniforms.distanceCutoff.value.x;\n    }\n    set distanceThreshold(value) {\n        this.uniforms.distanceCutoff.value.set(Math.min(Math.max(value, 0), 1), Math.min(Math.max(value + this.distanceFalloff, 0), 1));\n    }\n    /**\n   * The occlusion distance threshold in world units.\n   *\n   * @type {Number}\n   */ get worldDistanceThreshold() {\n        return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);\n    }\n    set worldDistanceThreshold(value) {\n        this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * The occlusion distance falloff. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get distanceFalloff() {\n        return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;\n    }\n    set distanceFalloff(value) {\n        this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);\n    }\n    /**\n   * The occlusion distance falloff in world units.\n   *\n   * @type {Number}\n   */ get worldDistanceFalloff() {\n        return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);\n    }\n    set worldDistanceFalloff(value) {\n        this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * Sets the occlusion distance cutoff.\n   *\n   * @deprecated Use distanceThreshold and distanceFalloff instead.\n   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */ setDistanceCutoff(threshold, falloff) {\n        this.uniforms.distanceCutoff.value.set(Math.min(Math.max(threshold, 0), 1), Math.min(Math.max(threshold + falloff, 0), 1));\n    }\n    /**\n   * The occlusion proximity threshold. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get proximityThreshold() {\n        return this.uniforms.proximityCutoff.value.x;\n    }\n    set proximityThreshold(value) {\n        this.uniforms.proximityCutoff.value.set(Math.min(Math.max(value, 0), 1), Math.min(Math.max(value + this.proximityFalloff, 0), 1));\n    }\n    /**\n   * The occlusion proximity threshold in world units.\n   *\n   * @type {Number}\n   */ get worldProximityThreshold() {\n        return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);\n    }\n    set worldProximityThreshold(value) {\n        this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * The occlusion proximity falloff. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get proximityFalloff() {\n        return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;\n    }\n    set proximityFalloff(value) {\n        this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);\n    }\n    /**\n   * The occlusion proximity falloff in world units.\n   *\n   * @type {Number}\n   */ get worldProximityFalloff() {\n        return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);\n    }\n    set worldProximityFalloff(value) {\n        this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * Sets the occlusion proximity cutoff.\n   *\n   * @deprecated Use proximityThreshold and proximityFalloff instead.\n   * @param {Number} threshold - The range threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */ setProximityCutoff(threshold, falloff) {\n        this.uniforms.proximityCutoff.value.set(Math.min(Math.max(threshold, 0), 1), Math.min(Math.max(threshold + falloff, 0), 1));\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n            this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);\n            this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const uniforms = this.uniforms;\n        const noiseTexture = uniforms.noiseTexture.value;\n        if (noiseTexture !== null) {\n            uniforms.noiseScale.value.set(width / noiseTexture.image.width, height / noiseTexture.image.height);\n        }\n        uniforms.texelSize.value.set(1 / width, 1 / height);\n        this.resolution.set(width, height);\n        this.updateRadius();\n    }\n};\n// src/passes/DepthDownsamplingPass.js\n\n// src/materials/DepthDownsamplingMaterial.js\n\n// src/materials/glsl/depth-downsampling.frag\nvar depth_downsampling_default = `#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\n#else\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\n#endif\ngl_FragColor=vec4(n[index],d[index]);}`;\n// src/materials/glsl/depth-downsampling.vert\nvar depth_downsampling_default2 = `uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/DepthDownsamplingMaterial.js\nvar DepthDownsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new depth downsampling material.\n   */ constructor(){\n        super({\n            name: \"DepthDownsamplingMaterial\",\n            defines: {\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                normalBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: depth_downsampling_default,\n            vertexShader: depth_downsampling_default2\n        });\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * The normal buffer.\n   *\n   * @type {Texture}\n   */ set normalBuffer(value) {\n        this.uniforms.normalBuffer.value = value;\n        if (value !== null) {\n            this.defines.DOWNSAMPLE_NORMALS = \"1\";\n        } else {\n            delete this.defines.DOWNSAMPLE_NORMALS;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the normal buffer.\n   *\n   * @deprecated Use normalBuffer instead.\n   * @param {Texture} value - The normal buffer.\n   */ setNormalBuffer(value) {\n        this.normalBuffer = value;\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y);\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/passes/DepthDownsamplingPass.js\nvar DepthDownsamplingPass = class extends Pass {\n    /**\n   * Constructs a new depth downsampling pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor({ normalBuffer = null, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"DepthDownsamplingPass\");\n        const material = new DepthDownsamplingMaterial();\n        material.normalBuffer = normalBuffer;\n        this.fullscreenMaterial = material;\n        this.needsDepthTexture = true;\n        this.needsSwap = false;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            depthBuffer: false,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.FloatType\n        });\n        this.renderTarget.texture.name = \"DepthDownsamplingPass.Target\";\n        this.renderTarget.texture.generateMipmaps = false;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    /**\n   * The normal(RGB) + depth(A) texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the normal(RGB) + depth(A) texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.fullscreenMaterial.depthBuffer = depthTexture;\n        this.fullscreenMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Downsamples depth and scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n        this.fullscreenMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        const gl = renderer.getContext();\n        const renderable = gl.getExtension(\"EXT_color_buffer_float\") || gl.getExtension(\"EXT_color_buffer_half_float\");\n        if (!renderable) {\n            throw new Error(\"Rendering to float texture is not supported.\");\n        }\n    }\n};\n// src/effects/glsl/ssao.frag\nvar ssao_default3 = `uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}`;\n// src/effects/SSAOEffect.js\nvar NOISE_TEXTURE_SIZE = 64;\nvar SSAOEffect = class extends Effect {\n    /**\n   * Constructs a new SSAO effect.\n   *\n   * @todo Move normalBuffer to options.\n   * @param {Camera} [camera] - The main camera.\n   * @param {Texture} [normalBuffer] - A texture that contains the scene normals.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.\n   * @param {Boolean} [options.distanceScaling=true] - Deprecated.\n   * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.\n   * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.\n   * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.\n   * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.\n   * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.\n   * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.\n   * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.\n   * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.\n   * @param {Number} [options.distanceThreshold=0.97] - Deprecated.\n   * @param {Number} [options.distanceFalloff=0.03] - Deprecated.\n   * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.\n   * @param {Number} [options.rangeFalloff=0.001] - Deprecated.\n   * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.\n   * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.\n   * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].\n   * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.\n   * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.\n   * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.\n   * @param {Color} [options.color=null] - The color of the ambient occlusion.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(camera, normalBuffer, { blendFunction = BlendFunction.MULTIPLY, samples = 9, rings = 7, normalDepthBuffer = null, depthAwareUpsampling = true, worldDistanceThreshold, worldDistanceFalloff, worldProximityThreshold, worldProximityFalloff, distanceThreshold = 0.97, distanceFalloff = 0.03, rangeThreshold = 5e-4, rangeFalloff = 1e-3, minRadiusScale = 0.1, luminanceInfluence = 0.7, radius = 0.1825, intensity = 1, bias = 0.025, fade = 0.01, color: color2 = null, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"SSAOEffect\", ssao_default3, {\n            blendFunction,\n            attributes: EffectAttribute.DEPTH,\n            defines: /* @__PURE__ */ new Map([\n                [\n                    \"THRESHOLD\",\n                    \"0.997\"\n                ]\n            ]),\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"aoBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"normalDepthBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(normalDepthBuffer)\n                ],\n                [\n                    \"luminanceInfluence\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceInfluence)\n                ],\n                [\n                    \"color\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"intensity\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(intensity)\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n                ]\n            ])\n        });\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"AO.Target\";\n        this.uniforms.get(\"aoBuffer\").value = this.renderTarget.texture;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.camera = camera;\n        this.depthDownsamplingPass = new DepthDownsamplingPass({\n            normalBuffer,\n            resolutionScale\n        });\n        this.depthDownsamplingPass.enabled = normalDepthBuffer === null;\n        this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));\n        const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n        noiseTexture.wrapS = noiseTexture.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n        const ssaoMaterial = this.ssaoMaterial;\n        ssaoMaterial.normalBuffer = normalBuffer;\n        ssaoMaterial.noiseTexture = noiseTexture;\n        ssaoMaterial.minRadiusScale = minRadiusScale;\n        ssaoMaterial.samples = samples;\n        ssaoMaterial.radius = radius;\n        ssaoMaterial.rings = rings;\n        ssaoMaterial.fade = fade;\n        ssaoMaterial.bias = bias;\n        ssaoMaterial.distanceThreshold = distanceThreshold;\n        ssaoMaterial.distanceFalloff = distanceFalloff;\n        ssaoMaterial.proximityThreshold = rangeThreshold;\n        ssaoMaterial.proximityFalloff = rangeFalloff;\n        if (worldDistanceThreshold !== void 0) {\n            ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;\n        }\n        if (worldDistanceFalloff !== void 0) {\n            ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;\n        }\n        if (worldProximityThreshold !== void 0) {\n            ssaoMaterial.worldProximityThreshold = worldProximityThreshold;\n        }\n        if (worldProximityFalloff !== void 0) {\n            ssaoMaterial.worldProximityFalloff = worldProximityFalloff;\n        }\n        if (normalDepthBuffer !== null) {\n            this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;\n            this.defines.set(\"NORMAL_DEPTH\", \"1\");\n        }\n        this.depthAwareUpsampling = depthAwareUpsampling;\n        this.color = color2;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.ssaoMaterial.copyCameraSettings(value);\n    }\n    /**\n   * Sets the normal buffer.\n   *\n   * @type {Texture}\n   */ get normalBuffer() {\n        return this.ssaoMaterial.normalBuffer;\n    }\n    set normalBuffer(value) {\n        this.ssaoMaterial.normalBuffer = value;\n        this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = value;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * The SSAO material.\n   *\n   * @type {SSAOMaterial}\n   */ get ssaoMaterial() {\n        return this.ssaoPass.fullscreenMaterial;\n    }\n    /**\n   * Returns the SSAO material.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @return {SSAOMaterial} The material.\n   */ getSSAOMaterial() {\n        return this.ssaoMaterial;\n    }\n    /**\n   * The amount of occlusion samples per pixel.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.samples instead.\n   */ get samples() {\n        return this.ssaoMaterial.samples;\n    }\n    set samples(value) {\n        this.ssaoMaterial.samples = value;\n    }\n    /**\n   * The amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.rings instead.\n   */ get rings() {\n        return this.ssaoMaterial.rings;\n    }\n    set rings(value) {\n        this.ssaoMaterial.rings = value;\n    }\n    /**\n   * The occlusion sampling radius.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.radius instead.\n   */ get radius() {\n        return this.ssaoMaterial.radius;\n    }\n    set radius(value) {\n        this.ssaoMaterial.radius = value;\n    }\n    /**\n   * Indicates whether depth-aware upsampling is enabled.\n   *\n   * @type {Boolean}\n   */ get depthAwareUpsampling() {\n        return this.defines.has(\"DEPTH_AWARE_UPSAMPLING\");\n    }\n    set depthAwareUpsampling(value) {\n        if (this.depthAwareUpsampling !== value) {\n            if (value) {\n                this.defines.set(\"DEPTH_AWARE_UPSAMPLING\", \"1\");\n            } else {\n                this.defines.delete(\"DEPTH_AWARE_UPSAMPLING\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether depth-aware upsampling is enabled.\n   *\n   * @deprecated Use depthAwareUpsampling instead.\n   * @return {Boolean} Whether depth-aware upsampling is enabled.\n   */ isDepthAwareUpsamplingEnabled() {\n        return this.depthAwareUpsampling;\n    }\n    /**\n   * Enables or disables depth-aware upsampling.\n   *\n   * @deprecated Use depthAwareUpsampling instead.\n   * @param {Boolean} value - Whether depth-aware upsampling should be enabled.\n   */ setDepthAwareUpsamplingEnabled(value) {\n        this.depthAwareUpsampling = value;\n    }\n    /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get distanceScaling() {\n        return true;\n    }\n    set distanceScaling(value) {}\n    /**\n   * The color of the ambient occlusion. Set to `null` to disable.\n   *\n   * @type {Color}\n   */ get color() {\n        return this.uniforms.get(\"color\").value;\n    }\n    set color(value) {\n        const uniforms = this.uniforms;\n        const defines = this.defines;\n        if (value !== null) {\n            if (defines.has(\"COLORIZE\")) {\n                uniforms.get(\"color\").value.set(value);\n            } else {\n                defines.set(\"COLORIZE\", \"1\");\n                uniforms.get(\"color\").value = new three__WEBPACK_IMPORTED_MODULE_0__.Color(value);\n                this.setChanged();\n            }\n        } else if (defines.has(\"COLORIZE\")) {\n            defines.delete(\"COLORIZE\");\n            uniforms.get(\"color\").value = null;\n            this.setChanged();\n        }\n    }\n    /**\n   * The luminance influence factor. Range: [0.0, 1.0].\n   *\n   * @type {Boolean}\n   */ get luminanceInfluence() {\n        return this.uniforms.get(\"luminanceInfluence\").value;\n    }\n    set luminanceInfluence(value) {\n        this.uniforms.get(\"luminanceInfluence\").value = value;\n    }\n    /**\n   * The intensity.\n   *\n   * @type {Number}\n   */ get intensity() {\n        return this.uniforms.get(\"intensity\").value;\n    }\n    set intensity(value) {\n        this.uniforms.get(\"intensity\").value = value;\n    }\n    /**\n   * Returns the color of the ambient occlusion.\n   *\n   * @deprecated Use color instead.\n   * @return {Color} The color.\n   */ getColor() {\n        return this.color;\n    }\n    /**\n   * Sets the color of the ambient occlusion. Set to `null` to disable colorization.\n   *\n   * @deprecated Use color instead.\n   * @param {Color} value - The color.\n   */ setColor(value) {\n        this.color = value;\n    }\n    /**\n   * Sets the occlusion distance cutoff.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */ setDistanceCutoff(threshold, falloff) {\n        this.ssaoMaterial.distanceThreshold = threshold;\n        this.ssaoMaterial.distanceFalloff = falloff;\n    }\n    /**\n   * Sets the occlusion proximity cutoff.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */ setProximityCutoff(threshold, falloff) {\n        this.ssaoMaterial.proximityThreshold = threshold;\n        this.ssaoMaterial.proximityFalloff = falloff;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);\n        this.ssaoMaterial.depthBuffer = depthTexture;\n        this.ssaoMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const renderTarget = this.renderTarget;\n        if (this.depthDownsamplingPass.enabled) {\n            this.depthDownsamplingPass.render(renderer);\n        }\n        this.ssaoPass.render(renderer, null, renderTarget);\n    }\n    /**\n   * Sets the size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.ssaoMaterial.copyCameraSettings(this.camera);\n        this.ssaoMaterial.setSize(w, h);\n        this.renderTarget.setSize(w, h);\n        this.depthDownsamplingPass.resolution.scale = resolution.scale;\n        this.depthDownsamplingPass.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        try {\n            let normalDepthBuffer = this.uniforms.get(\"normalDepthBuffer\").value;\n            if (normalDepthBuffer === null) {\n                this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);\n                normalDepthBuffer = this.depthDownsamplingPass.texture;\n                this.uniforms.get(\"normalDepthBuffer\").value = normalDepthBuffer;\n                this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;\n                this.defines.set(\"NORMAL_DEPTH\", \"1\");\n            }\n        } catch (e) {\n            this.depthDownsamplingPass.enabled = false;\n        }\n    }\n};\n// src/effects/TextureEffect.js\n\n// src/effects/glsl/texture.frag\nvar texture_default = `#ifdef TEXTURE_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvarying vec2 vUv2;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#ifdef UV_TRANSFORM\nvec4 texel=texture2D(map,vUv2);\n#else\nvec4 texel=texture2D(map,uv);\n#endif\noutputColor=TEXEL;outputColor.a=max(inputColor.a,outputColor.a);}`;\n// src/effects/glsl/texture.vert\nvar texture_default2 = `#ifdef ASPECT_CORRECTION\nuniform float scale;\n#else\nuniform mat3 uvTransform;\n#endif\nvarying vec2 vUv2;void mainSupport(const in vec2 uv){\n#ifdef ASPECT_CORRECTION\nvUv2=uv*vec2(aspect,1.0)*scale;\n#else\nvUv2=(uvTransform*vec3(uv,1.0)).xy;\n#endif\n}`;\n// src/effects/TextureEffect.js\nvar TextureEffect = class extends Effect {\n    /**\n   * Constructs a new texture effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Texture} [options.texture] - A texture.\n   * @param {Boolean} [options.aspectCorrection=false] - Deprecated. Adjust the texture's offset, repeat and center instead.\n   */ constructor({ blendFunction, texture = null, aspectCorrection = false } = {}){\n        super(\"TextureEffect\", texture_default, {\n            blendFunction,\n            defines: /* @__PURE__ */ new Map([\n                [\n                    \"TEXEL\",\n                    \"texel\"\n                ]\n            ]),\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"map\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"uvTransform\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.texture = texture;\n        this.aspectCorrection = aspectCorrection;\n    }\n    /**\n   * The texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.uniforms.get(\"map\").value;\n    }\n    set texture(value) {\n        const prevTexture = this.texture;\n        const uniforms = this.uniforms;\n        const defines = this.defines;\n        if (prevTexture !== value) {\n            uniforms.get(\"map\").value = value;\n            uniforms.get(\"uvTransform\").value = value.matrix;\n            defines.delete(\"TEXTURE_PRECISION_HIGH\");\n            if (value !== null) {\n                if (value.matrixAutoUpdate) {\n                    defines.set(\"UV_TRANSFORM\", \"1\");\n                    this.setVertexShader(texture_default2);\n                } else {\n                    defines.delete(\"UV_TRANSFORM\");\n                    this.setVertexShader(null);\n                }\n                if (value.type !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                    defines.set(\"TEXTURE_PRECISION_HIGH\", \"1\");\n                }\n                if (prevTexture === null || prevTexture.type !== value.type || prevTexture.encoding !== value.encoding) {\n                    this.setChanged();\n                }\n            }\n        }\n    }\n    /**\n   * Returns the texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.texture;\n    }\n    /**\n   * Sets the texture.\n   *\n   * @deprecated Use texture instead.\n   * @param {Texture} value - The texture.\n   */ setTexture(value) {\n        this.texture = value;\n    }\n    /**\n   * Indicates whether aspect correction is enabled.\n   *\n   * @type {Number}\n   * @deprecated Adjust the texture's offset, repeat, rotation and center instead.\n   */ get aspectCorrection() {\n        return this.defines.has(\"ASPECT_CORRECTION\");\n    }\n    set aspectCorrection(value) {\n        if (this.aspectCorrection !== value) {\n            if (value) {\n                this.defines.set(\"ASPECT_CORRECTION\", \"1\");\n            } else {\n                this.defines.delete(\"ASPECT_CORRECTION\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether the texture UV coordinates will be transformed using the transformation matrix of the texture.\n   *\n   * @type {Boolean}\n   * @deprecated Use texture.matrixAutoUpdate instead.\n   */ get uvTransform() {\n        const texture = this.texture;\n        return texture !== null && texture.matrixAutoUpdate;\n    }\n    set uvTransform(value) {\n        const texture = this.texture;\n        if (texture !== null) {\n            texture.matrixAutoUpdate = value;\n        }\n    }\n    /**\n   * Sets the swizzles that will be applied to the components of a texel before it is written to the output color.\n   *\n   * @param {ColorChannel} r - The swizzle for the `r` component.\n   * @param {ColorChannel} [g=r] - The swizzle for the `g` component.\n   * @param {ColorChannel} [b=r] - The swizzle for the `b` component.\n   * @param {ColorChannel} [a=r] - The swizzle for the `a` component.\n   */ setTextureSwizzleRGBA(r, g = r, b = r, a = r) {\n        const rgba = \"rgba\";\n        let swizzle = \"\";\n        if (r !== ColorChannel.RED || g !== ColorChannel.GREEN || b !== ColorChannel.BLUE || a !== ColorChannel.ALPHA) {\n            swizzle = [\n                \".\",\n                rgba[r],\n                rgba[g],\n                rgba[b],\n                rgba[a]\n            ].join(\"\");\n        }\n        this.defines.set(\"TEXEL\", \"texel\" + swizzle);\n        this.setChanged();\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        if (this.texture.matrixAutoUpdate) {\n            this.texture.updateMatrix();\n        }\n    }\n};\n// src/effects/TiltShiftEffect.js\n\n// src/materials/TiltShiftBlurMaterial.js\n\n// src/materials/glsl/convolution.tilt-shift.frag\nvar convolution_tilt_shift_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}`;\n// src/materials/glsl/convolution.tilt-shift.vert\nvar convolution_tilt_shift_default2 = `uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/TiltShiftBlurMaterial.js\nvar TiltShiftBlurMaterial = class extends KawaseBlurMaterial {\n    /**\n   * Constructs a new tilt shift blur material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   */ constructor({ kernelSize = KernelSize.MEDIUM, offset = 0, rotation = 0, focusArea = 0.4, feather = 0.3 } = {}){\n        super();\n        this.fragmentShader = convolution_tilt_shift_default;\n        this.vertexShader = convolution_tilt_shift_default2;\n        this.kernelSize = kernelSize;\n        this.uniforms.aspect = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1);\n        this.uniforms.rotation = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        this.uniforms.maskParams = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4());\n        this._offset = offset;\n        this._focusArea = focusArea;\n        this._feather = feather;\n        this.rotation = rotation;\n        this.updateParams();\n    }\n    /**\n   * The relative offset of the focus area.\n   *\n   * @private\n   */ updateParams() {\n        const params = this.uniforms.maskParams.value;\n        const a = Math.max(this.focusArea, 0);\n        const b = Math.max(a - this.feather, 0);\n        params.set(this.offset - a, this.offset - b, this.offset + a, this.offset + b);\n    }\n    /**\n   * The rotation of the focus area in radians.\n   *\n   * @type {Number}\n   */ get rotation() {\n        return Math.acos(this.uniforms.rotation.value.x);\n    }\n    set rotation(value) {\n        this.uniforms.rotation.value.set(Math.cos(value), Math.sin(value));\n    }\n    /**\n   * The relative offset of the focus area.\n   *\n   * @type {Number}\n   */ get offset() {\n        return this._offset;\n    }\n    set offset(value) {\n        this._offset = value;\n        this.updateParams();\n    }\n    /**\n   * The relative size of the focus area.\n   *\n   * @type {Number}\n   */ get focusArea() {\n        return this._focusArea;\n    }\n    set focusArea(value) {\n        this._focusArea = value;\n        this.updateParams();\n    }\n    /**\n   * The softness of the focus area edges.\n   *\n   * @type {Number}\n   */ get feather() {\n        return this._feather;\n    }\n    set feather(value) {\n        this._feather = value;\n        this.updateParams();\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        super.setSize(width, height);\n        this.uniforms.aspect.value = width / height;\n    }\n};\n// src/passes/TiltShiftBlurPass.js\nvar TiltShiftBlurPass = class extends KawaseBlurPass {\n    /**\n   * Constructs a new Kawase blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */ constructor({ offset = 0, rotation = 0, focusArea = 0.4, feather = 0.3, kernelSize = KernelSize.MEDIUM, resolutionScale = 0.5, resolutionX = Resolution.AUTO_SIZE, resolutionY = Resolution.AUTO_SIZE } = {}){\n        super({\n            kernelSize,\n            resolutionScale,\n            resolutionX,\n            resolutionY\n        });\n        this.blurMaterial = new TiltShiftBlurMaterial({\n            kernelSize,\n            offset,\n            rotation,\n            focusArea,\n            feather\n        });\n    }\n};\n// src/effects/glsl/tilt-shift.frag\nvar tilt_shift_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}`;\n// src/effects/glsl/tilt-shift.vert\nvar tilt_shift_default2 = `uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}`;\n// src/effects/TiltShiftEffect.js\nvar TiltShiftEffect = class extends Effect {\n    /**\n   * Constructs a new tilt shift Effect\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   * @param {Number} [options.bias=0.06] - Deprecated.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */ constructor({ blendFunction, offset = 0, rotation = 0, focusArea = 0.4, feather = 0.3, kernelSize = KernelSize.MEDIUM, resolutionScale = 0.5, resolutionX = Resolution.AUTO_SIZE, resolutionY = Resolution.AUTO_SIZE } = {}){\n        super(\"TiltShiftEffect\", tilt_shift_default, {\n            vertexShader: tilt_shift_default2,\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"rotation\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"maskParams\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"map\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this._offset = offset;\n        this._focusArea = focusArea;\n        this._feather = feather;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"TiltShift.Target\";\n        this.uniforms.get(\"map\").value = this.renderTarget.texture;\n        this.blurPass = new TiltShiftBlurPass({\n            kernelSize,\n            resolutionScale,\n            resolutionX,\n            resolutionY,\n            offset,\n            rotation,\n            focusArea,\n            feather\n        });\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.rotation = rotation;\n        this.updateParams();\n    }\n    /**\n   * Updates the mask params.\n   *\n   * @private\n   */ updateParams() {\n        const params = this.uniforms.get(\"maskParams\").value;\n        const x = Math.max(this.focusArea - this.feather, 0);\n        params.set(this.offset - x, this.offset + x);\n    }\n    /**\n   * The rotation of the focus area in radians.\n   *\n   * @type {Number}\n   */ get rotation() {\n        return Math.acos(this.uniforms.get(\"rotation\").value.x);\n    }\n    set rotation(value) {\n        this.uniforms.get(\"rotation\").value.set(Math.cos(value), Math.sin(value));\n        this.blurPass.blurMaterial.rotation = value;\n    }\n    /**\n   * The relative offset of the focus area.\n   *\n   * @type {Number}\n   */ get offset() {\n        return this._offset;\n    }\n    set offset(value) {\n        this._offset = value;\n        this.blurPass.blurMaterial.offset = value;\n        this.updateParams();\n    }\n    /**\n   * The relative size of the focus area.\n   *\n   * @type {Number}\n   */ get focusArea() {\n        return this._focusArea;\n    }\n    set focusArea(value) {\n        this._focusArea = value;\n        this.blurPass.blurMaterial.focusArea = value;\n        this.updateParams();\n    }\n    /**\n   * The softness of the focus area edges.\n   *\n   * @type {Number}\n   */ get feather() {\n        return this._feather;\n    }\n    set feather(value) {\n        this._feather = value;\n        this.blurPass.blurMaterial.feather = value;\n        this.updateParams();\n    }\n    /**\n   * A blend bias.\n   *\n   * @type {Number}\n   * @deprecated\n   */ get bias() {\n        return 0;\n    }\n    set bias(value) {}\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        this.blurPass.render(renderer, inputBuffer, this.renderTarget);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n        this.blurPass.resolution.copy(resolution);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurPass.initialize(renderer, alpha, frameBufferType);\n        if (frameBufferType !== void 0) {\n            this.renderTarget.texture.type = frameBufferType;\n            if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n};\n// src/effects/ToneMappingEffect.js\n\n// src/passes/AdaptiveLuminancePass.js\n\n// src/materials/AdaptiveLuminanceMaterial.js\n\n// src/materials/glsl/adaptive-luminance.frag\nvar adaptive_luminance_default = `#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`;\n// src/materials/AdaptiveLuminanceMaterial.js\nvar AdaptiveLuminanceMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new adaptive luminance material.\n   */ constructor(){\n        super({\n            name: \"AdaptiveLuminanceMaterial\",\n            defines: {\n                MIP_LEVEL_1X1: \"0.0\"\n            },\n            uniforms: {\n                luminanceBuffer0: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                luminanceBuffer1: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                minLuminance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.01),\n                deltaTime: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n                tau: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            extensions: {\n                shaderTextureLOD: true\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: adaptive_luminance_default,\n            vertexShader: common_default\n        });\n    }\n    /**\n   * The primary luminance buffer that contains the downsampled average luminance.\n   *\n   * @type {Texture}\n   */ set luminanceBuffer0(value) {\n        this.uniforms.luminanceBuffer0.value = value;\n    }\n    /**\n   * Sets the primary luminance buffer that contains the downsampled average luminance.\n   *\n   * @deprecated Use luminanceBuffer0 instead.\n   * @param {Texture} value - The buffer.\n   */ setLuminanceBuffer0(value) {\n        this.uniforms.luminanceBuffer0.value = value;\n    }\n    /**\n   * The secondary luminance buffer.\n   *\n   * @type {Texture}\n   */ set luminanceBuffer1(value) {\n        this.uniforms.luminanceBuffer1.value = value;\n    }\n    /**\n   * Sets the secondary luminance buffer.\n   *\n   * @deprecated Use luminanceBuffer1 instead.\n   * @param {Texture} value - The buffer.\n   */ setLuminanceBuffer1(value) {\n        this.uniforms.luminanceBuffer1.value = value;\n    }\n    /**\n   * The 1x1 mipmap level.\n   *\n   * This level is used to identify the smallest mipmap of the primary luminance buffer.\n   *\n   * @type {Number}\n   */ set mipLevel1x1(value) {\n        this.defines.MIP_LEVEL_1X1 = value.toFixed(1);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the 1x1 mipmap level.\n   *\n   * @deprecated Use mipLevel1x1 instead.\n   * @param {Number} value - The level.\n   */ setMipLevel1x1(value) {\n        this.mipLevel1x1 = value;\n    }\n    /**\n   * The delta time.\n   *\n   * @type {Number}\n   */ set deltaTime(value) {\n        this.uniforms.deltaTime.value = value;\n    }\n    /**\n   * Sets the delta time.\n   *\n   * @deprecated Use deltaTime instead.\n   * @param {Number} value - The delta time.\n   */ setDeltaTime(value) {\n        this.uniforms.deltaTime.value = value;\n    }\n    /**\n   * The lowest possible luminance value.\n   *\n   * @type {Number}\n   */ get minLuminance() {\n        return this.uniforms.minLuminance.value;\n    }\n    set minLuminance(value) {\n        this.uniforms.minLuminance.value = value;\n    }\n    /**\n   * Returns the lowest possible luminance value.\n   *\n   * @deprecated Use minLuminance instead.\n   * @return {Number} The minimum luminance.\n   */ getMinLuminance() {\n        return this.uniforms.minLuminance.value;\n    }\n    /**\n   * Sets the minimum luminance.\n   *\n   * @deprecated Use minLuminance instead.\n   * @param {Number} value - The minimum luminance.\n   */ setMinLuminance(value) {\n        this.uniforms.minLuminance.value = value;\n    }\n    /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   */ get adaptationRate() {\n        return this.uniforms.tau.value;\n    }\n    set adaptationRate(value) {\n        this.uniforms.tau.value = value;\n    }\n    /**\n   * Returns the luminance adaptation rate.\n   *\n   * @deprecated Use adaptationRate instead.\n   * @return {Number} The adaptation rate.\n   */ getAdaptationRate() {\n        return this.uniforms.tau.value;\n    }\n    /**\n   * Sets the luminance adaptation rate.\n   *\n   * @deprecated Use adaptationRate instead.\n   * @param {Number} value - The adaptation rate.\n   */ setAdaptationRate(value) {\n        this.uniforms.tau.value = value;\n    }\n};\n// src/passes/AdaptiveLuminancePass.js\nvar AdaptiveLuminancePass = class extends Pass {\n    /**\n   * Constructs a new adaptive luminance pass.\n   *\n   * @param {Texture} luminanceBuffer - A buffer that contains the current scene luminance.\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.minLuminance=0.01] - The minimum luminance.\n   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.\n   */ constructor(luminanceBuffer, { minLuminance = 0.01, adaptationRate = 1 } = {}){\n        super(\"AdaptiveLuminancePass\");\n        this.fullscreenMaterial = new AdaptiveLuminanceMaterial();\n        this.needsSwap = false;\n        this.renderTargetPrevious = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            depthBuffer: false\n        });\n        this.renderTargetPrevious.texture.name = \"Luminance.Previous\";\n        const material = this.fullscreenMaterial;\n        material.luminanceBuffer0 = this.renderTargetPrevious.texture;\n        material.luminanceBuffer1 = luminanceBuffer;\n        material.minLuminance = minLuminance;\n        material.adaptationRate = adaptationRate;\n        this.renderTargetAdapted = this.renderTargetPrevious.clone();\n        this.renderTargetAdapted.texture.name = \"Luminance.Adapted\";\n        this.copyPass = new CopyPass(this.renderTargetPrevious, false);\n    }\n    /**\n   * The adaptive luminance texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTargetAdapted.texture;\n    }\n    /**\n   * Returns the adaptive 1x1 luminance texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTargetAdapted.texture;\n    }\n    /**\n   * Sets the 1x1 mipmap level.\n   *\n   * This level is used to identify the smallest mipmap of the main luminance texture which contains the downsampled\n   * average scene luminance.\n   *\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.mipLevel1x1 instead.\n   */ set mipLevel1x1(value) {\n        this.fullscreenMaterial.mipLevel1x1 = value;\n    }\n    /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.adaptationRate instead.\n   */ get adaptationRate() {\n        return this.fullscreenMaterial.adaptationRate;\n    }\n    /**\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.adaptationRate instead.\n   */ set adaptationRate(value) {\n        this.fullscreenMaterial.adaptationRate = value;\n    }\n    /**\n   * Renders the scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        this.fullscreenMaterial.deltaTime = deltaTime;\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted);\n        renderer.render(this.scene, this.camera);\n        this.copyPass.render(renderer, this.renderTargetAdapted);\n    }\n};\n// src/effects/glsl/tone-mapping.frag\nvar tone_mapping_default = `#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}`;\n// src/effects/ToneMappingEffect.js\nvar ToneMappingEffect = class extends Effect {\n    /**\n   * Constructs a new tone mapping effect.\n   *\n   * The additional parameters only affect the Reinhard2 operator.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.adaptive=false] - Deprecated. Use mode instead.\n   * @param {ToneMappingMode} [options.mode=ToneMappingMode.AGX] - The tone mapping mode.\n   * @param {Number} [options.resolution=256] - The resolution of the luminance texture. Must be a power of two.\n   * @param {Number} [options.maxLuminance=4.0] - Deprecated. Same as whitePoint.\n   * @param {Number} [options.whitePoint=4.0] - The white point.\n   * @param {Number} [options.middleGrey=0.6] - The middle grey factor.\n   * @param {Number} [options.minLuminance=0.01] - The minimum luminance. Prevents very high exposure in dark scenes.\n   * @param {Number} [options.averageLuminance=1.0] - The average luminance. Used for the non-adaptive Reinhard operator.\n   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.\n   */ constructor({ blendFunction = BlendFunction.SRC, adaptive = false, mode = adaptive ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.AGX, resolution = 256, maxLuminance = 4, whitePoint = maxLuminance, middleGrey = 0.6, minLuminance = 0.01, averageLuminance = 1, adaptationRate = 1 } = {}){\n        super(\"ToneMappingEffect\", tone_mapping_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"luminanceBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"maxLuminance\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxLuminance)\n                ],\n                // Unused\n                [\n                    \"whitePoint\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(whitePoint)\n                ],\n                [\n                    \"middleGrey\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(middleGrey)\n                ],\n                [\n                    \"averageLuminance\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(averageLuminance)\n                ]\n            ])\n        });\n        this.renderTargetLuminance = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter,\n            depthBuffer: false\n        });\n        this.renderTargetLuminance.texture.generateMipmaps = true;\n        this.renderTargetLuminance.texture.name = \"Luminance\";\n        this.luminancePass = new LuminancePass({\n            renderTarget: this.renderTargetLuminance\n        });\n        this.adaptiveLuminancePass = new AdaptiveLuminancePass(this.luminancePass.texture, {\n            minLuminance,\n            adaptationRate\n        });\n        this.uniforms.get(\"luminanceBuffer\").value = this.adaptiveLuminancePass.texture;\n        this.resolution = resolution;\n        this.mode = mode;\n    }\n    /**\n   * The tone mapping mode.\n   *\n   * @type {ToneMappingMode}\n   */ get mode() {\n        return Number(this.defines.get(\"TONE_MAPPING_MODE\"));\n    }\n    set mode(value) {\n        if (this.mode === value) {\n            return;\n        }\n        const revision = three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\");\n        const cineonToneMapping = revision >= 168 ? \"CineonToneMapping(texel)\" : \"OptimizedCineonToneMapping(texel)\";\n        this.defines.clear();\n        this.defines.set(\"TONE_MAPPING_MODE\", value.toFixed(0));\n        switch(value){\n            case ToneMappingMode.LINEAR:\n                this.defines.set(\"toneMapping(texel)\", \"LinearToneMapping(texel)\");\n                break;\n            case ToneMappingMode.REINHARD:\n                this.defines.set(\"toneMapping(texel)\", \"ReinhardToneMapping(texel)\");\n                break;\n            case ToneMappingMode.CINEON:\n            case ToneMappingMode.OPTIMIZED_CINEON:\n                this.defines.set(\"toneMapping(texel)\", cineonToneMapping);\n                break;\n            case ToneMappingMode.ACES_FILMIC:\n                this.defines.set(\"toneMapping(texel)\", \"ACESFilmicToneMapping(texel)\");\n                break;\n            case ToneMappingMode.AGX:\n                this.defines.set(\"toneMapping(texel)\", \"AgXToneMapping(texel)\");\n                break;\n            case ToneMappingMode.NEUTRAL:\n                this.defines.set(\"toneMapping(texel)\", \"NeutralToneMapping(texel)\");\n                break;\n            default:\n                this.defines.set(\"toneMapping(texel)\", \"texel\");\n                break;\n        }\n        this.adaptiveLuminancePass.enabled = value === ToneMappingMode.REINHARD2_ADAPTIVE;\n        this.setChanged();\n    }\n    /**\n   * Returns the current tone mapping mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {ToneMappingMode} The tone mapping mode.\n   */ getMode() {\n        return this.mode;\n    }\n    /**\n   * Sets the tone mapping mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {ToneMappingMode} value - The tone mapping mode.\n   */ setMode(value) {\n        this.mode = value;\n    }\n    /**\n   * The white point. Default is `4.0`.\n   *\n   * Only applies to Reinhard2 (Modified & Adaptive).\n   *\n   * @type {Number}\n   */ get whitePoint() {\n        return this.uniforms.get(\"whitePoint\").value;\n    }\n    set whitePoint(value) {\n        this.uniforms.get(\"whitePoint\").value = value;\n    }\n    /**\n   * The middle grey factor. Default is `0.6`.\n   *\n   * Only applies to Reinhard2 (Modified & Adaptive).\n   *\n   * @type {Number}\n   */ get middleGrey() {\n        return this.uniforms.get(\"middleGrey\").value;\n    }\n    set middleGrey(value) {\n        this.uniforms.get(\"middleGrey\").value = value;\n    }\n    /**\n   * The average luminance.\n   *\n   * Only applies to Reinhard2 (Modified).\n   *\n   * @type {Number}\n   */ get averageLuminance() {\n        return this.uniforms.get(\"averageLuminance\").value;\n    }\n    set averageLuminance(value) {\n        this.uniforms.get(\"averageLuminance\").value = value;\n    }\n    /**\n   * The adaptive luminance material.\n   *\n   * @type {AdaptiveLuminanceMaterial}\n   */ get adaptiveLuminanceMaterial() {\n        return this.adaptiveLuminancePass.fullscreenMaterial;\n    }\n    /**\n   * Returns the adaptive luminance material.\n   *\n   * @deprecated Use adaptiveLuminanceMaterial instead.\n   * @return {AdaptiveLuminanceMaterial} The material.\n   */ getAdaptiveLuminanceMaterial() {\n        return this.adaptiveLuminanceMaterial;\n    }\n    /**\n   * The resolution of the luminance texture. Must be a power of two.\n   *\n   * @type {Number}\n   */ get resolution() {\n        return this.luminancePass.resolution.width;\n    }\n    set resolution(value) {\n        const exponent = Math.max(0, Math.ceil(Math.log2(value)));\n        const size = Math.pow(2, exponent);\n        this.luminancePass.resolution.setPreferredSize(size, size);\n        this.adaptiveLuminanceMaterial.mipLevel1x1 = exponent;\n    }\n    /**\n   * Returns the resolution of the luminance texture.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Number} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Sets the resolution of the luminance texture. Must be a power of two.\n   *\n   * @deprecated Use resolution instead.\n   * @param {Number} value - The resolution.\n   */ setResolution(value) {\n        this.resolution = value;\n    }\n    /**\n   * Indicates whether this pass uses adaptive luminance.\n   *\n   * @type {Boolean}\n   * @deprecated Use mode instead.\n   */ get adaptive() {\n        return this.mode === ToneMappingMode.REINHARD2_ADAPTIVE;\n    }\n    set adaptive(value) {\n        this.mode = value ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2;\n    }\n    /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   * @deprecated Use adaptiveLuminanceMaterial.adaptationRate instead.\n   */ get adaptationRate() {\n        return this.adaptiveLuminanceMaterial.adaptationRate;\n    }\n    set adaptationRate(value) {\n        this.adaptiveLuminanceMaterial.adaptationRate = value;\n    }\n    /**\n   * @type {Number}\n   * @deprecated\n   */ get distinction() {\n        console.warn(this.name, \"distinction was removed.\");\n        return 1;\n    }\n    set distinction(value) {\n        console.warn(this.name, \"distinction was removed.\");\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        if (this.adaptiveLuminancePass.enabled) {\n            this.luminancePass.render(renderer, inputBuffer);\n            this.adaptiveLuminancePass.render(renderer, null, null, deltaTime);\n        }\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.adaptiveLuminancePass.initialize(renderer, alpha, frameBufferType);\n    }\n};\n// src/effects/VignetteEffect.js\n\n// src/effects/glsl/vignette.frag\nvar vignette_default = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}`;\n// src/effects/VignetteEffect.js\nvar VignetteEffect = class extends Effect {\n    /**\n   * Constructs a new Vignette effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {VignetteTechnique} [options.technique=VignetteTechnique.DEFAULT] - The Vignette technique.\n   * @param {Boolean} [options.eskil=false] - Deprecated. Use technique instead.\n   * @param {Number} [options.offset=0.5] - The Vignette offset.\n   * @param {Number} [options.darkness=0.5] - The Vignette darkness.\n   */ constructor({ blendFunction, eskil = false, technique = eskil ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT, offset = 0.5, darkness = 0.5 } = {}){\n        super(\"VignetteEffect\", vignette_default, {\n            blendFunction,\n            defines: /* @__PURE__ */ new Map([\n                [\n                    \"VIGNETTE_TECHNIQUE\",\n                    technique.toFixed(0)\n                ]\n            ]),\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"offset\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(offset)\n                ],\n                [\n                    \"darkness\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(darkness)\n                ]\n            ])\n        });\n    }\n    /**\n   * The Vignette technique.\n   *\n   * @type {VignetteTechnique}\n   */ get technique() {\n        return Number(this.defines.get(\"VIGNETTE_TECHNIQUE\"));\n    }\n    set technique(value) {\n        if (this.technique !== value) {\n            this.defines.set(\"VIGNETTE_TECHNIQUE\", value.toFixed(0));\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether Eskil's Vignette technique is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use technique instead.\n   */ get eskil() {\n        return this.technique === VignetteTechnique.ESKIL;\n    }\n    /**\n   * Indicates whether Eskil's Vignette technique is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use technique instead.\n   */ set eskil(value) {\n        this.technique = value ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT;\n    }\n    /**\n   * Returns the Vignette technique.\n   *\n   * @deprecated Use technique instead.\n   * @return {VignetteTechnique} The technique.\n   */ getTechnique() {\n        return this.technique;\n    }\n    /**\n   * Sets the Vignette technique.\n   *\n   * @deprecated Use technique instead.\n   * @param {VignetteTechnique} value - The technique.\n   */ setTechnique(value) {\n        this.technique = value;\n    }\n    /**\n   * The Vignette offset.\n   *\n   * @type {Number}\n   */ get offset() {\n        return this.uniforms.get(\"offset\").value;\n    }\n    set offset(value) {\n        this.uniforms.get(\"offset\").value = value;\n    }\n    /**\n   * Returns the Vignette offset.\n   *\n   * @deprecated Use offset instead.\n   * @return {Number} The offset.\n   */ getOffset() {\n        return this.offset;\n    }\n    /**\n   * Sets the Vignette offset.\n   *\n   * @deprecated Use offset instead.\n   * @param {Number} value - The offset.\n   */ setOffset(value) {\n        this.offset = value;\n    }\n    /**\n   * The Vignette darkness.\n   *\n   * @type {Number}\n   */ get darkness() {\n        return this.uniforms.get(\"darkness\").value;\n    }\n    set darkness(value) {\n        this.uniforms.get(\"darkness\").value = value;\n    }\n    /**\n   * Returns the Vignette darkness.\n   *\n   * @deprecated Use darkness instead.\n   * @return {Number} The darkness.\n   */ getDarkness() {\n        return this.darkness;\n    }\n    /**\n   * Sets the Vignette darkness.\n   *\n   * @deprecated Use darkness instead.\n   * @param {Number} value - The darkness.\n   */ setDarkness(value) {\n        this.darkness = value;\n    }\n};\n// src/loaders/LUT3dlLoader.js\n\nvar LUT3dlLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the 3dl-file.\n   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.\n   */ load(url, onLoad = ()=>{}, onProgress = ()=>{}, onError = null) {\n        const externalManager = this.manager;\n        const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(internalManager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"text\");\n        externalManager.itemStart(url);\n        loader.load(url, (data)=>{\n            try {\n                const result = this.parse(data);\n                externalManager.itemEnd(url);\n                onLoad(result);\n            } catch (e) {\n                internalManager.onError(url);\n                onError(e);\n            }\n        }, onProgress);\n    }\n    /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the 3dl-file.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.\n   */ loadAsync(url, onProgress = ()=>{}) {\n        const externalManager = this.manager;\n        const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        return new Promise((resolve, reject)=>{\n            internalManager.onError = (url2)=>{\n                externalManager.itemError(url2);\n                reject(`Failed to load ${url2}`);\n            };\n            this.load(url, resolve, onProgress);\n        });\n    }\n    /**\n   * Parses the given data.\n   *\n   * @param {String} input - The LUT data.\n   * @return {LookupTexture} The lookup texture.\n   * @throws {Error} Fails if the data is invalid.\n   */ parse(input) {\n        const regExpGridInfo = /^[\\d ]+$/m;\n        const regExpDataPoints = /^([\\d.e+-]+) +([\\d.e+-]+) +([\\d.e+-]+) *$/gm;\n        let result = regExpGridInfo.exec(input);\n        if (result === null) {\n            throw new Error(\"Missing grid information\");\n        }\n        const gridLines = result[0].trim().split(/\\s+/g).map((n)=>Number(n));\n        const gridStep = gridLines[1] - gridLines[0];\n        const size = gridLines.length;\n        const sizeSq = size ** 2;\n        for(let i = 1, l = gridLines.length; i < l; ++i){\n            if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n                throw new Error(\"Inconsistent grid size\");\n            }\n        }\n        const data = new Float32Array(size ** 3 * 4);\n        let maxValue = 0;\n        let index = 0;\n        while((result = regExpDataPoints.exec(input)) !== null){\n            const r = Number(result[1]);\n            const g = Number(result[2]);\n            const b = Number(result[3]);\n            maxValue = Math.max(maxValue, r, g, b);\n            const bLayer = index % size;\n            const gLayer = Math.floor(index / size) % size;\n            const rLayer = Math.floor(index / sizeSq) % size;\n            const d4 = (bLayer * sizeSq + gLayer * size + rLayer) * 4;\n            data[d4 + 0] = r;\n            data[d4 + 1] = g;\n            data[d4 + 2] = b;\n            data[d4 + 3] = 1;\n            ++index;\n        }\n        const bits = Math.ceil(Math.log2(maxValue));\n        const maxBitValue = Math.pow(2, bits);\n        for(let i = 0, l = data.length; i < l; i += 4){\n            data[i + 0] /= maxBitValue;\n            data[i + 1] /= maxBitValue;\n            data[i + 2] /= maxBitValue;\n        }\n        return new LookupTexture(data, size);\n    }\n};\n// src/loaders/LUTCubeLoader.js\n\nvar LUTCubeLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the CUBE-file.\n   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.\n   */ load(url, onLoad = ()=>{}, onProgress = ()=>{}, onError = null) {\n        const externalManager = this.manager;\n        const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(internalManager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"text\");\n        loader.load(url, (data)=>{\n            try {\n                const result = this.parse(data);\n                externalManager.itemEnd(url);\n                onLoad(result);\n            } catch (e) {\n                internalManager.onError(url);\n                onError(e);\n            }\n        }, onProgress);\n    }\n    /**\n   * Loads a LUT asynchronously.\n   *\n   * @param {String} url - The URL of the CUBE-file.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.\n   */ loadAsync(url, onProgress = ()=>{}) {\n        const externalManager = this.manager;\n        const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        return new Promise((resolve, reject)=>{\n            internalManager.onError = (url2)=>{\n                externalManager.itemError(url2);\n                reject(`Failed to load ${url2}`);\n            };\n            this.load(url, resolve, onProgress);\n        });\n    }\n    /**\n   * Parses the given data.\n   *\n   * @param {String} input - The LUT data.\n   * @return {LookupTexture} The lookup texture.\n   * @throws {Error} Fails if the data is invalid.\n   */ parse(input) {\n        const regExpTitle = /TITLE +\"([^\"]*)\"/;\n        const regExpSize = /LUT_3D_SIZE +(\\d+)/;\n        const regExpDomainMin = /DOMAIN_MIN +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n        const regExpDomainMax = /DOMAIN_MAX +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n        const regExpDataPoints = /^([\\d.e+-]+) +([\\d.e+-]+) +([\\d.e+-]+) *$/gm;\n        let result = regExpTitle.exec(input);\n        const title = result !== null ? result[1] : null;\n        result = regExpSize.exec(input);\n        if (result === null) {\n            throw new Error(\"Missing LUT_3D_SIZE information\");\n        }\n        const size = Number(result[1]);\n        const data = new Float32Array(size ** 3 * 4);\n        const domainMin = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        const domainMax = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        result = regExpDomainMin.exec(input);\n        if (result !== null) {\n            domainMin.set(Number(result[1]), Number(result[2]), Number(result[3]));\n        }\n        result = regExpDomainMax.exec(input);\n        if (result !== null) {\n            domainMax.set(Number(result[1]), Number(result[2]), Number(result[3]));\n        }\n        if (domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z) {\n            domainMin.set(0, 0, 0);\n            domainMax.set(1, 1, 1);\n            throw new Error(\"Invalid input domain\");\n        }\n        let i = 0;\n        while((result = regExpDataPoints.exec(input)) !== null){\n            data[i++] = Number(result[1]);\n            data[i++] = Number(result[2]);\n            data[i++] = Number(result[3]);\n            data[i++] = 1;\n        }\n        const lut = new LookupTexture(data, size);\n        lut.domainMin.copy(domainMin);\n        lut.domainMax.copy(domainMax);\n        if (title !== null) {\n            lut.name = title;\n        }\n        return lut;\n    }\n};\n// src/loaders/SMAAImageLoader.js\n\nvar SMAAImageLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n   * Loads the SMAA data images.\n   *\n   * @param {Function} [onLoad] - A callback that receives the search image and area image as a pair.\n   * @param {Function} [onError] - An error callback that receives the URL of the image that failed to load.\n   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.\n   */ load(onLoad = ()=>{}, onError = null) {\n        if (arguments.length === 4) {\n            onLoad = arguments[1];\n            onError = arguments[3];\n        } else if (arguments.length === 3 || typeof arguments[0] !== \"function\") {\n            onLoad = arguments[1];\n            onError = null;\n        }\n        const externalManager = this.manager;\n        const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        return new Promise((resolve, reject)=>{\n            const searchImage = new Image();\n            const areaImage = new Image();\n            internalManager.onError = (url)=>{\n                externalManager.itemError(url);\n                if (onError !== null) {\n                    onError(`Failed to load ${url}`);\n                    resolve();\n                } else {\n                    reject(`Failed to load ${url}`);\n                }\n            };\n            internalManager.onLoad = ()=>{\n                const result = [\n                    searchImage,\n                    areaImage\n                ];\n                onLoad(result);\n                resolve(result);\n            };\n            searchImage.addEventListener(\"error\", (e)=>{\n                internalManager.itemError(\"smaa-search\");\n            });\n            areaImage.addEventListener(\"error\", (e)=>{\n                internalManager.itemError(\"smaa-area\");\n            });\n            searchImage.addEventListener(\"load\", ()=>{\n                externalManager.itemEnd(\"smaa-search\");\n                internalManager.itemEnd(\"smaa-search\");\n            });\n            areaImage.addEventListener(\"load\", ()=>{\n                externalManager.itemEnd(\"smaa-area\");\n                internalManager.itemEnd(\"smaa-area\");\n            });\n            externalManager.itemStart(\"smaa-search\");\n            externalManager.itemStart(\"smaa-area\");\n            internalManager.itemStart(\"smaa-search\");\n            internalManager.itemStart(\"smaa-area\");\n            searchImage.src = searchImageDataURL_default;\n            areaImage.src = areaImageDataURL_default;\n        });\n    }\n};\n// src/materials/BoxBlurMaterial.js\n\n// src/materials/glsl/convolution.box.frag\nvar convolution_box_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef BILATERAL\n#include <packing>\nuniform vec2 cameraNearFar;\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nfloat getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}\n#ifdef PERSPECTIVE_CAMERA\n#define linearDepth(v) viewZToOrthographicDepth(getViewZ(readDepth(v)), cameraNearFar.x, cameraNearFar.y)\n#else\n#define linearDepth(v) readDepth(v)\n#endif\n#endif\n#define getTexel(v) texture2D(inputBuffer, v)\n#if KERNEL_SIZE == 3\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\n#else\nuniform vec2 texelSize;uniform float scale;varying vec2 vUv;\n#endif\nvoid main(){\n#if KERNEL_SIZE == 3\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08));\n#ifdef BILATERAL\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08));\n#endif\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08),getTexel(vUv09),getTexel(vUv10),getTexel(vUv11),getTexel(vUv12),getTexel(vUv13),getTexel(vUv14),getTexel(vUv15),getTexel(vUv16),getTexel(vUv17),getTexel(vUv18),getTexel(vUv19),getTexel(vUv20),getTexel(vUv21),getTexel(vUv22),getTexel(vUv23),getTexel(vUv24));\n#ifdef BILATERAL\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08),linearDepth(vUv09),linearDepth(vUv10),linearDepth(vUv11),linearDepth(vUv12),linearDepth(vUv13),linearDepth(vUv14),linearDepth(vUv15),linearDepth(vUv16),linearDepth(vUv17),linearDepth(vUv18),linearDepth(vUv19),linearDepth(vUv20),linearDepth(vUv21),linearDepth(vUv22),linearDepth(vUv23),linearDepth(vUv24));\n#endif\n#endif\nvec4 result=vec4(0.0);\n#ifdef BILATERAL\nfloat w=0.0;\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\nfloat centerDepth=z[KERNEL_SIZE_SQ_HALF];for(int i=0;i<KERNEL_SIZE_SQ;++i){float d=step(abs(z[i]-centerDepth),DISTANCE_THRESHOLD);result+=c[i]*d;w+=d;}\n#else\nfloat centerDepth=linearDepth(vUv);vec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){vec2 coords=vUv+vec2(x,y)*s;vec4 c=getTexel(coords);float z=(x==0&&y==0)?centerDepth:linearDepth(coords);float d=step(abs(z-centerDepth),DISTANCE_THRESHOLD);result+=c*d;w+=d;}}\n#endif\ngl_FragColor=result/max(w,1.0);\n#else\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\nfor(int i=0;i<KERNEL_SIZE_SQ;++i){result+=c[i];}\n#else\nvec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){result+=getTexel(uv+vec2(x,y)*s);}}\n#endif\ngl_FragColor=result*INV_KERNEL_SIZE_SQ;\n#endif\n}`;\n// src/materials/glsl/convolution.box.vert\nvar convolution_box_default2 = `uniform vec2 texelSize;uniform float scale;\n#if KERNEL_SIZE == 3\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\n#else\nvarying vec2 vUv;\n#endif\nvoid main(){vec2 uv=position.xy*0.5+0.5;\n#if KERNEL_SIZE == 3\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-1.0,-1.0);vUv01=uv+s*vec2(0.0,-1.0);vUv02=uv+s*vec2(1.0,-1.0);vUv03=uv+s*vec2(-1.0,0.0);vUv04=uv;vUv05=uv+s*vec2(1.0,0.0);vUv06=uv+s*vec2(-1.0,1.0);vUv07=uv+s*vec2(0.0,1.0);vUv08=uv+s*vec2(1.0,1.0);\n#elif KERNEL_SIZE == 5\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-2.0,-2.0);vUv01=uv+s*vec2(-1.0,-2.0);vUv02=uv+s*vec2(0.0,-2.0);vUv03=uv+s*vec2(1.0,-2.0);vUv04=uv+s*vec2(2.0,-2.0);vUv05=uv+s*vec2(-2.0,-1.0);vUv06=uv+s*vec2(-1.0,-1.0);vUv07=uv+s*vec2(0.0,-1.0);vUv08=uv+s*vec2(1.0,-1.0);vUv09=uv+s*vec2(2.0,-1.0);vUv10=uv+s*vec2(-2.0,0.0);vUv11=uv+s*vec2(-1.0,0.0);vUv12=uv;vUv13=uv+s*vec2(1.0,0.0);vUv14=uv+s*vec2(2.0,0.0);vUv15=uv+s*vec2(-2.0,1.0);vUv16=uv+s*vec2(-1.0,1.0);vUv17=uv+s*vec2(0.0,1.0);vUv18=uv+s*vec2(1.0,1.0);vUv19=uv+s*vec2(2.0,1.0);vUv20=uv+s*vec2(-2.0,2.0);vUv21=uv+s*vec2(-1.0,2.0);vUv22=uv+s*vec2(0.0,2.0);vUv23=uv+s*vec2(1.0,2.0);vUv24=uv+s*vec2(2.0,2.0);\n#else\nvUv=uv;\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/BoxBlurMaterial.js\nvar BoxBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new box blur material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.\n   * @param {Number} [options.kernelSize=5] - The kernel size.\n   */ constructor({ bilateral = false, kernelSize = 5 } = {}){\n        super({\n            name: \"BoxBlurMaterial\",\n            defines: {\n                DEPTH_PACKING: \"0\",\n                DISTANCE_THRESHOLD: \"0.1\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                normalDepthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_box_default,\n            vertexShader: convolution_box_default2\n        });\n        this.bilateral = bilateral;\n        this.kernelSize = kernelSize;\n        this.maxVaryingVectors = 8;\n    }\n    /**\n   * The maximum amount of varying vectors.\n   *\n   * Should be synced with `renderer.capabilities.maxVaryings`. Default is 8.\n   *\n   * @type {Number}\n   */ set maxVaryingVectors(value) {\n        this.defines.MAX_VARYING_VECTORS = value.toFixed(0);\n    }\n    /**\n   * The kernel size.\n   *\n   * - Must be an odd number\n   * - Kernel size 3 and 5 use optimized code paths\n   * - Default is 5\n   *\n   * @type {Number}\n   */ get kernelSize() {\n        return Number(this.defines.KERNEL_SIZE);\n    }\n    set kernelSize(value) {\n        if (value % 2 === 0) {\n            throw new Error(\"The kernel size must be an odd number\");\n        }\n        this.defines.KERNEL_SIZE = value.toFixed(0);\n        this.defines.KERNEL_SIZE_HALF = Math.floor(value / 2).toFixed(0);\n        this.defines.KERNEL_SIZE_SQ = (value ** 2).toFixed(0);\n        this.defines.KERNEL_SIZE_SQ_HALF = Math.floor(value ** 2 / 2).toFixed(0);\n        this.defines.INV_KERNEL_SIZE_SQ = (1 / value ** 2).toFixed(6);\n        this.needsUpdate = true;\n    }\n    /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get near() {\n        return this.uniforms.cameraNearFar.value.x;\n    }\n    /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get far() {\n        return this.uniforms.cameraNearFar.value.y;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * A combined normal-depth buffer. Overrides {@link depthBuffer} if set.\n   *\n   * @type {Texture}\n   */ set normalDepthBuffer(value) {\n        this.uniforms.normalDepthBuffer.value = value;\n        if (value !== null) {\n            this.defines.NORMAL_DEPTH = \"1\";\n        } else {\n            delete this.defines.NORMAL_DEPTH;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether bilateral filtering is enabled.\n   *\n   * @type {Boolean}\n   */ get bilateral() {\n        return this.defines.BILATERAL !== void 0;\n    }\n    set bilateral(value) {\n        if (value !== null) {\n            this.defines.BILATERAL = \"1\";\n        } else {\n            delete this.defines.BILATERAL;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * The bilateral filter distance threshold in world units.\n   *\n   * @type {Number}\n   */ get worldDistanceThreshold() {\n        return -orthographicDepthToViewZ(Number(this.defines.DISTANCE_THRESHOLD), this.near, this.far);\n    }\n    set worldDistanceThreshold(value) {\n        const threshold = viewZToOrthographicDepth(-value, this.near, this.far);\n        this.defines.DISTANCE_THRESHOLD = threshold.toFixed(12);\n        this.needsUpdate = true;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/DepthCopyMaterial.js\n\n// src/materials/glsl/depth-copy.frag\nvar depth_copy_default = `#include <packing>\nvarying vec2 vUv;\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\n#if INPUT_DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if INPUT_DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nvoid main(){\n#if INPUT_DEPTH_PACKING == OUTPUT_DEPTH_PACKING\ngl_FragColor=texture2D(depthBuffer,vUv);\n#else\nfloat depth=readDepth(vUv);\n#if OUTPUT_DEPTH_PACKING == 3201\ngl_FragColor=(depth==1.0)?vec4(1.0):packDepthToRGBA(depth);\n#else\ngl_FragColor=vec4(vec3(depth),1.0);\n#endif\n#endif\n}`;\n// src/materials/glsl/depth-copy.vert\nvar depth_copy_default2 = `varying vec2 vUv;\n#if DEPTH_COPY_MODE == 1\nuniform vec2 texelPosition;\n#endif\nvoid main(){\n#if DEPTH_COPY_MODE == 1\nvUv=texelPosition;\n#else\nvUv=position.xy*0.5+0.5;\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/DepthCopyMaterial.js\nvar DepthCopyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new depth copy material.\n   */ constructor(){\n        super({\n            name: \"DepthCopyMaterial\",\n            defines: {\n                INPUT_DEPTH_PACKING: \"0\",\n                OUTPUT_DEPTH_PACKING: \"0\",\n                DEPTH_COPY_MODE: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelPosition: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: depth_copy_default,\n            vertexShader: depth_copy_default2\n        });\n        this.depthCopyMode = DepthCopyMode.FULL;\n    }\n    /**\n   * The input depth buffer.\n   *\n   * @type {Texture}\n   */ get depthBuffer() {\n        return this.uniforms.depthBuffer.value;\n    }\n    set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The input depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set inputDepthPacking(value) {\n        this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * The output depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ get outputDepthPacking() {\n        return Number(this.defines.OUTPUT_DEPTH_PACKING);\n    }\n    set outputDepthPacking(value) {\n        this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the input depth buffer.\n   *\n   * @deprecated Use depthBuffer and inputDepthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.inputDepthPacking = depthPacking;\n    }\n    /**\n   * Returns the current input depth packing strategy.\n   *\n   * @deprecated\n   * @return {DepthPackingStrategies} The input depth packing strategy.\n   */ getInputDepthPacking() {\n        return Number(this.defines.INPUT_DEPTH_PACKING);\n    }\n    /**\n   * Sets the input depth packing strategy.\n   *\n   * @deprecated Use inputDepthPacking instead.\n   * @param {DepthPackingStrategies} value - The new input depth packing strategy.\n   */ setInputDepthPacking(value) {\n        this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the current output depth packing strategy.\n   *\n   * @deprecated Use outputDepthPacking instead.\n   * @return {DepthPackingStrategies} The output depth packing strategy.\n   */ getOutputDepthPacking() {\n        return Number(this.defines.OUTPUT_DEPTH_PACKING);\n    }\n    /**\n   * Sets the output depth packing strategy.\n   *\n   * @deprecated Use outputDepthPacking instead.\n   * @param {DepthPackingStrategies} value - The new output depth packing strategy.\n   */ setOutputDepthPacking(value) {\n        this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * The screen space position used for single-texel copy operations.\n   *\n   * @type {Vector2}\n   */ get texelPosition() {\n        return this.uniforms.texelPosition.value;\n    }\n    /**\n   * Returns the screen space position used for single-texel copy operations.\n   *\n   * @deprecated Use texelPosition instead.\n   * @return {Vector2} The position.\n   */ getTexelPosition() {\n        return this.uniforms.texelPosition.value;\n    }\n    /**\n   * Sets the screen space position used for single-texel copy operations.\n   *\n   * @deprecated\n   * @param {Vector2} value - The position.\n   */ setTexelPosition(value) {\n        this.uniforms.texelPosition.value = value;\n    }\n    /**\n   * The depth copy mode.\n   *\n   * @type {DepthCopyMode}\n   */ get mode() {\n        return this.depthCopyMode;\n    }\n    set mode(value) {\n        this.depthCopyMode = value;\n        this.defines.DEPTH_COPY_MODE = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the depth copy mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {DepthCopyMode} The depth copy mode.\n   */ getMode() {\n        return this.mode;\n    }\n    /**\n   * Sets the depth copy mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {DepthCopyMode} value - The new mode.\n   */ setMode(value) {\n        this.mode = value;\n    }\n};\n// src/materials/EffectMaterial.js\n\n// src/materials/glsl/effect.frag\nvar effect_default = `#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}`;\n// src/materials/glsl/effect.vert\nvar effect_default2 = `uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/EffectMaterial.js\nvar EffectMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new effect material.\n   *\n   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.\n   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.\n   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.\n   * @param {Camera} [camera] - A camera.\n   * @param {Boolean} [dithering=false] - Deprecated.\n   */ constructor(shaderParts, defines, uniforms, camera, dithering = false){\n        super({\n            name: \"EffectMaterial\",\n            defines: {\n                THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"),\n                DEPTH_PACKING: \"0\",\n                ENCODE_OUTPUT: \"1\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n                cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3),\n                aspect: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                time: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            dithering\n        });\n        if (shaderParts) {\n            this.setShaderParts(shaderParts);\n        }\n        if (defines) {\n            this.setDefines(defines);\n        }\n        if (uniforms) {\n            this.setUniforms(uniforms);\n        }\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ get depthBuffer() {\n        return this.uniforms.depthBuffer.value;\n    }\n    set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ get depthPacking() {\n        return Number(this.defines.DEPTH_PACKING);\n    }\n    set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * Sets the shader data.\n   *\n   * @param {EffectShaderData} data - The shader data.\n   * @return {EffectMaterial} This material.\n   */ setShaderData(data) {\n        this.setShaderParts(data.shaderParts);\n        this.setDefines(data.defines);\n        this.setUniforms(data.uniforms);\n        this.setExtensions(data.extensions);\n    }\n    /**\n   * Sets the shader parts.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.\n   * @return {EffectMaterial} This material.\n   */ setShaderParts(shaderParts) {\n        this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || \"\").replace(EffectShaderSection.FRAGMENT_MAIN_UV, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || \"\").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || \"\");\n        this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, shaderParts.get(EffectShaderSection.VERTEX_HEAD) || \"\").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || \"\");\n        this.needsUpdate = true;\n        return this;\n    }\n    /**\n   * Sets the shader macros.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.\n   * @return {EffectMaterial} This material.\n   */ setDefines(defines) {\n        for (const entry of defines.entries()){\n            this.defines[entry[0]] = entry[1];\n        }\n        this.needsUpdate = true;\n        return this;\n    }\n    /**\n   * Sets the shader uniforms.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.\n   * @return {EffectMaterial} This material.\n   */ setUniforms(uniforms) {\n        for (const entry of uniforms.entries()){\n            this.uniforms[entry[0]] = entry[1];\n        }\n        return this;\n    }\n    /**\n   * Sets the required shader extensions.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Set<WebGLExtension>} extensions - A collection of extensions.\n   * @return {EffectMaterial} This material.\n   */ setExtensions(extensions) {\n        this.extensions = {};\n        for (const extension of extensions){\n            this.extensions[extension] = true;\n        }\n        return this;\n    }\n    /**\n   * Indicates whether output encoding is enabled.\n   *\n   * @type {Boolean}\n   */ get encodeOutput() {\n        return this.defines.ENCODE_OUTPUT !== void 0;\n    }\n    set encodeOutput(value) {\n        if (this.encodeOutput !== value) {\n            if (value) {\n                this.defines.ENCODE_OUTPUT = \"1\";\n            } else {\n                delete this.defines.ENCODE_OUTPUT;\n            }\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Indicates whether output encoding is enabled.\n   *\n   * @deprecated Use encodeOutput instead.\n   * @return {Boolean} Whether output encoding is enabled.\n   */ isOutputEncodingEnabled(value) {\n        return this.encodeOutput;\n    }\n    /**\n   * Enables or disables output encoding.\n   *\n   * @deprecated Use encodeOutput instead.\n   * @param {Boolean} value - Whether output encoding should be enabled.\n   */ setOutputEncodingEnabled(value) {\n        this.encodeOutput = value;\n    }\n    /**\n   * The time in seconds.\n   *\n   * @type {Number}\n   */ get time() {\n        return this.uniforms.time.value;\n    }\n    set time(value) {\n        this.uniforms.time.value = value;\n    }\n    /**\n   * Sets the delta time.\n   *\n   * @deprecated Use time instead.\n   * @param {Number} value - The delta time in seconds.\n   */ setDeltaTime(value) {\n        this.uniforms.time.value += value;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNear.value = camera.near;\n            this.uniforms.cameraFar.value = camera.far;\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Sets the resolution.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const uniforms = this.uniforms;\n        uniforms.resolution.value.set(width, height);\n        uniforms.texelSize.value.set(1 / width, 1 / height);\n        uniforms.aspect.value = width / height;\n    }\n    /**\n   * An enumeration of shader code placeholders.\n   *\n   * @deprecated Use EffectShaderSection instead.\n   * @type {Object}\n   */ static get Section() {\n        return EffectShaderSection;\n    }\n};\n// src/materials/GaussianBlurMaterial.js\n\n// src/materials/glsl/convolution.gaussian.frag\nvar convolution_gaussian_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec2 kernel[STEPS];varying vec2 vOffset;varying vec2 vUv;void main(){vec4 result=texture2D(inputBuffer,vUv)*kernel[0].y;for(int i=1;i<STEPS;++i){vec2 offset=kernel[i].x*vOffset;vec4 c0=texture2D(inputBuffer,vUv+offset);vec4 c1=texture2D(inputBuffer,vUv-offset);result+=(c0+c1)*kernel[i].y;}gl_FragColor=result;\n#include <colorspace_fragment>\n}`;\n// src/materials/glsl/convolution.gaussian.vert\nvar convolution_gaussian_default2 = `uniform vec2 texelSize;uniform vec2 direction;uniform float scale;varying vec2 vOffset;varying vec2 vUv;void main(){vOffset=direction*texelSize*scale;vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}`;\n// src/materials/GaussianBlurMaterial.js\nvar GaussianBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new convolution material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=35] - The kernel size.\n   */ constructor({ kernelSize = 35 } = {}){\n        super({\n            name: \"GaussianBlurMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                direction: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                kernel: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_gaussian_default,\n            vertexShader: convolution_gaussian_default2\n        });\n        this._kernelSize = 0;\n        this.kernelSize = kernelSize;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The kernel size.\n   *\n   * @type {Number}\n   */ get kernelSize() {\n        return this._kernelSize;\n    }\n    set kernelSize(value) {\n        this._kernelSize = value;\n        this.generateKernel(value);\n    }\n    /**\n   * The blur direction.\n   *\n   * @type {Vector2}\n   */ get direction() {\n        return this.uniforms.direction.value;\n    }\n    /**\n   * The blur kernel scale. Values greater than 1.0 may introduce artifacts.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * Generates the Gauss kernel.\n   *\n   * @param {KernelSize} kernelSize - The kernel size. Should be an odd number.\n   * @private\n   */ generateKernel(kernelSize) {\n        const kernel = new GaussKernel(kernelSize);\n        const steps = kernel.linearSteps;\n        const kernelData = new Float64Array(steps * 2);\n        for(let i = 0, j = 0; i < steps; ++i){\n            kernelData[j++] = kernel.linearOffsets[i];\n            kernelData[j++] = kernel.linearWeights[i];\n        }\n        this.uniforms.kernel.value = kernelData;\n        this.defines.STEPS = steps.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/passes/BoxBlurPass.js\n\nvar BoxBlurPass = class extends Pass {\n    /**\n   * Constructs a new box blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=5] - Must be an odd number. The sizes 3 and 5 use optimized code paths.\n   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.\n   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */ constructor({ kernelSize = 5, iterations = 1, bilateral = false, resolutionScale = 1, resolutionX = Resolution.AUTO_SIZE, resolutionY = Resolution.AUTO_SIZE } = {}){\n        super(\"BoxBlurPass\");\n        this.needsDepthTexture = bilateral;\n        this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetA.texture.name = \"Blur.Target.A\";\n        this.renderTargetB = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetB.texture.name = \"Blur.Target.B\";\n        this.blurMaterial = new BoxBlurMaterial({\n            bilateral,\n            kernelSize\n        });\n        this.copyMaterial = new CopyMaterial();\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.iterations = iterations;\n    }\n    set mainCamera(value) {\n        this.blurMaterial.copyCameraSettings(value);\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.blurMaterial.depthBuffer = depthTexture;\n        this.blurMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const renderTargetA = this.renderTargetA;\n        const renderTargetB = this.renderTargetB;\n        const blurMaterial = this.blurMaterial;\n        this.fullscreenMaterial = blurMaterial;\n        let previousBuffer = inputBuffer;\n        for(let i = 0, l = Math.max(this.iterations, 1); i < l; ++i){\n            const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;\n            blurMaterial.inputBuffer = previousBuffer.texture;\n            renderer.setRenderTarget(buffer);\n            renderer.render(scene, camera);\n            previousBuffer = buffer;\n        }\n        this.copyMaterial.inputBuffer = previousBuffer.texture;\n        this.fullscreenMaterial = this.copyMaterial;\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(scene, camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.renderTargetA.setSize(w, h);\n        this.renderTargetB.setSize(w, h);\n        this.blurMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (renderer !== null) {\n            this.blurMaterial.maxVaryingVectors = renderer.capabilities.maxVaryings;\n        }\n        if (frameBufferType !== void 0) {\n            this.renderTargetA.texture.type = frameBufferType;\n            this.renderTargetB.texture.type = frameBufferType;\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTargetA.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.renderTargetB.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n};\n// src/passes/DepthPickingPass.js\n\n// src/passes/DepthCopyPass.js\n\nvar DepthCopyPass = class extends Pass {\n    /**\n   * Constructs a new depth save pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The output depth packing.\n   */ constructor({ depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking } = {}){\n        super(\"DepthCopyPass\");\n        const material = new DepthCopyMaterial();\n        material.outputDepthPacking = depthPacking;\n        this.fullscreenMaterial = material;\n        this.needsDepthTexture = true;\n        this.needsSwap = false;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            type: depthPacking === three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking ? three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType : three__WEBPACK_IMPORTED_MODULE_0__.FloatType,\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"DepthCopyPass.Target\";\n    }\n    /**\n   * The output depth texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the output depth texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * The output depth packing.\n   *\n   * @type {DepthPackingStrategies}\n   */ get depthPacking() {\n        return this.fullscreenMaterial.outputDepthPacking;\n    }\n    /**\n   * Returns the output depth packing.\n   *\n   * @deprecated Use depthPacking instead.\n   * @return {DepthPackingStrategies} The depth packing.\n   */ getDepthPacking() {\n        return this.fullscreenMaterial.outputDepthPacking;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.fullscreenMaterial.depthBuffer = depthTexture;\n        this.fullscreenMaterial.inputDepthPacking = depthPacking;\n    }\n    /**\n   * Copies depth from a depth texture.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.renderTarget.setSize(width, height);\n    }\n};\n// src/passes/DepthPickingPass.js\nvar threeRevision = Number(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\nvar unpackDownscale = 255 / 256;\nvar unpackFactorsLegacy = new Float32Array([\n    unpackDownscale / 256 ** 3,\n    unpackDownscale / 256 ** 2,\n    unpackDownscale / 256,\n    unpackDownscale\n]);\nvar unpackFactors = new Float32Array([\n    unpackDownscale,\n    unpackDownscale / 256,\n    unpackDownscale / 256 ** 2,\n    1 / 256 ** 3\n]);\nfunction unpackRGBAToDepth(packedDepth) {\n    const f = threeRevision >= 167 ? unpackFactors : unpackFactorsLegacy;\n    return (packedDepth[0] * f[0] + packedDepth[1] * f[1] + packedDepth[2] * f[2] + packedDepth[3] * f[3]) / 255;\n}\nvar DepthPickingPass = class extends DepthCopyPass {\n    /**\n   * Constructs a new depth picking pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The depth packing.\n   * @param {Number} [options.mode=DepthCopyMode.SINGLE] - The depth copy mode.\n   */ constructor({ depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking, mode = DepthCopyMode.SINGLE } = {}){\n        if (depthPacking !== three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking && depthPacking !== three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n            throw new Error(`Unsupported depth packing: ${depthPacking}`);\n        }\n        super({\n            depthPacking\n        });\n        this.name = \"DepthPickingPass\";\n        this.fullscreenMaterial.mode = mode;\n        this.pixelBuffer = depthPacking === three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking ? new Uint8Array(4) : new Float32Array(4);\n        this.callback = null;\n    }\n    /**\n   * Reads depth at a specific screen position.\n   *\n   * Only one depth value can be picked per frame. Calling this method multiple times per frame will overwrite the\n   * picking coordinates. Unresolved promises will be abandoned.\n   *\n   * @example\n   * const ndc = new Vector3();\n   * const clientRect = myViewport.getBoundingClientRect();\n   * const clientX = pointerEvent.clientX - clientRect.left;\n   * const clientY = pointerEvent.clientY - clientRect.top;\n   * ndc.x = (clientX / myViewport.clientWidth) * 2.0 - 1.0;\n   * ndc.y = -(clientY / myViewport.clientHeight) * 2.0 + 1.0;\n   * const depth = await depthPickingPass.readDepth(ndc);\n   * ndc.z = depth * 2.0 - 1.0;\n   *\n   * const worldPosition = ndc.unproject(camera);\n   *\n   * @param {Vector2|Vector3} ndc - Normalized device coordinates. Only X and Y are relevant.\n   * @return {Promise<Number>} A promise that returns the depth on the next frame.\n   */ readDepth(ndc) {\n        this.fullscreenMaterial.texelPosition.set(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);\n        return new Promise((resolve)=>{\n            this.callback = resolve;\n        });\n    }\n    /**\n   * Copies depth and resolves depth picking promises.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const material = this.fullscreenMaterial;\n        const mode = material.mode;\n        if (mode === DepthCopyMode.FULL) {\n            super.render(renderer);\n        }\n        if (this.callback !== null) {\n            const renderTarget = this.renderTarget;\n            const pixelBuffer = this.pixelBuffer;\n            const packed = renderTarget.texture.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n            let x = 0, y = 0;\n            if (mode === DepthCopyMode.SINGLE) {\n                super.render(renderer);\n            } else {\n                const texelPosition = material.texelPosition;\n                x = Math.round(texelPosition.x * renderTarget.width);\n                y = Math.round(texelPosition.y * renderTarget.height);\n            }\n            renderer.readRenderTargetPixels(renderTarget, x, y, 1, 1, pixelBuffer);\n            this.callback(packed ? unpackRGBAToDepth(pixelBuffer) : pixelBuffer[0]);\n            this.callback = null;\n        }\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        if (this.fullscreenMaterial.mode === DepthCopyMode.FULL) {\n            super.setSize(width, height);\n        }\n    }\n};\n// src/passes/EffectPass.js\n\nfunction prefixSubstrings(prefix, substrings, strings) {\n    for (const substring of substrings){\n        const prefixed = \"$1\" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);\n        const regExp = new RegExp(\"([^\\\\.])(\\\\b\" + substring + \"\\\\b)\", \"g\");\n        for (const entry of strings.entries()){\n            if (entry[1] !== null) {\n                strings.set(entry[0], entry[1].replace(regExp, prefixed));\n            }\n        }\n    }\n}\nfunction integrateEffect(prefix, effect, data) {\n    let fragmentShader = effect.getFragmentShader();\n    let vertexShader = effect.getVertexShader();\n    const mainImageExists = fragmentShader !== void 0 && /mainImage/.test(fragmentShader);\n    const mainUvExists = fragmentShader !== void 0 && /mainUv/.test(fragmentShader);\n    data.attributes |= effect.getAttributes();\n    if (fragmentShader === void 0) {\n        throw new Error(`Missing fragment shader (${effect.name})`);\n    } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {\n        throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);\n    } else if (!mainImageExists && !mainUvExists) {\n        throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);\n    } else {\n        const functionRegExp = /\\w+\\s+(\\w+)\\([\\w\\s,]*\\)\\s*{/g;\n        const shaderParts = data.shaderParts;\n        let fragmentHead = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || \"\";\n        let fragmentMainUv = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || \"\";\n        let fragmentMainImage = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || \"\";\n        let vertexHead = shaderParts.get(EffectShaderSection.VERTEX_HEAD) || \"\";\n        let vertexMainSupport = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || \"\";\n        const varyings = /* @__PURE__ */ new Set();\n        const names = /* @__PURE__ */ new Set();\n        if (mainUvExists) {\n            fragmentMainUv += `\t${prefix}MainUv(UV);\n`;\n            data.uvTransformation = true;\n        }\n        if (vertexShader !== null && /mainSupport/.test(vertexShader)) {\n            const needsUv = /mainSupport *\\([\\w\\s]*?uv\\s*?\\)/.test(vertexShader);\n            vertexMainSupport += `\t${prefix}MainSupport(`;\n            vertexMainSupport += needsUv ? \"vUv);\\n\" : \");\\n\";\n            for (const m2 of vertexShader.matchAll(/(?:varying\\s+\\w+\\s+([\\S\\s]*?);)/g)){\n                for (const n of m2[1].split(/\\s*,\\s*/)){\n                    data.varyings.add(n);\n                    varyings.add(n);\n                    names.add(n);\n                }\n            }\n            for (const m2 of vertexShader.matchAll(functionRegExp)){\n                names.add(m2[1]);\n            }\n        }\n        for (const m2 of fragmentShader.matchAll(functionRegExp)){\n            names.add(m2[1]);\n        }\n        for (const d of effect.defines.keys()){\n            names.add(d.replace(/\\([\\w\\s,]*\\)/g, \"\"));\n        }\n        for (const u of effect.uniforms.keys()){\n            names.add(u);\n        }\n        names.delete(\"while\");\n        names.delete(\"for\");\n        names.delete(\"if\");\n        effect.uniforms.forEach((val, key)=>data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));\n        effect.defines.forEach((val, key)=>data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));\n        const shaders = /* @__PURE__ */ new Map([\n            [\n                \"fragment\",\n                fragmentShader\n            ],\n            [\n                \"vertex\",\n                vertexShader\n            ]\n        ]);\n        prefixSubstrings(prefix, names, data.defines);\n        prefixSubstrings(prefix, names, shaders);\n        fragmentShader = shaders.get(\"fragment\");\n        vertexShader = shaders.get(\"vertex\");\n        const blendMode = effect.blendMode;\n        data.blendModes.set(blendMode.blendFunction, blendMode);\n        if (mainImageExists) {\n            if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {\n                fragmentMainImage += effect.inputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace ? \"color0 = sRGBTransferOETF(color0);\\n\t\" : \"color0 = sRGBToLinear(color0);\\n\t\";\n            }\n            if (effect.outputColorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace) {\n                data.colorSpace = effect.outputColorSpace;\n            } else if (effect.inputColorSpace !== null) {\n                data.colorSpace = effect.inputColorSpace;\n            }\n            const depthParamRegExp = /MainImage *\\([\\w\\s,]*?depth[\\w\\s,]*?\\)/;\n            fragmentMainImage += `${prefix}MainImage(color0, UV, `;\n            if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader)) {\n                fragmentMainImage += \"depth, \";\n                data.readDepth = true;\n            }\n            fragmentMainImage += \"color1);\\n\t\";\n            const blendOpacity = prefix + \"BlendOpacity\";\n            data.uniforms.set(blendOpacity, blendMode.opacity);\n            fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});\n\n\t`;\n            fragmentHead += `uniform float ${blendOpacity};\n\n`;\n        }\n        fragmentHead += fragmentShader + \"\\n\";\n        if (vertexShader !== null) {\n            vertexHead += vertexShader + \"\\n\";\n        }\n        shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);\n        shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);\n        shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);\n        shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);\n        shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);\n        if (effect.extensions !== null) {\n            for (const extension of effect.extensions){\n                data.extensions.add(extension);\n            }\n        }\n    }\n}\nvar EffectPass = class extends Pass {\n    /**\n   * Constructs a new effect pass.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {...Effect} effects - The effects that will be rendered by this pass.\n   */ constructor(camera, ...effects){\n        super(\"EffectPass\");\n        this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);\n        this.listener = (event)=>this.handleEvent(event);\n        this.effects = [];\n        this.setEffects(effects);\n        this.skipRendering = false;\n        this.minTime = 1;\n        this.maxTime = Number.POSITIVE_INFINITY;\n        this.timeScale = 1;\n    }\n    set mainScene(value) {\n        for (const effect of this.effects){\n            effect.mainScene = value;\n        }\n    }\n    set mainCamera(value) {\n        this.fullscreenMaterial.copyCameraSettings(value);\n        for (const effect of this.effects){\n            effect.mainCamera = value;\n        }\n    }\n    /**\n   * Indicates whether this pass encodes its output when rendering to screen.\n   *\n   * @type {Boolean}\n   * @deprecated Use fullscreenMaterial.encodeOutput instead.\n   */ get encodeOutput() {\n        return this.fullscreenMaterial.encodeOutput;\n    }\n    set encodeOutput(value) {\n        this.fullscreenMaterial.encodeOutput = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   */ get dithering() {\n        return this.fullscreenMaterial.dithering;\n    }\n    set dithering(value) {\n        const material = this.fullscreenMaterial;\n        material.dithering = value;\n        material.needsUpdate = true;\n    }\n    /**\n   * Sets the effects.\n   *\n   * @param {Effect[]} effects - The effects.\n   * @protected\n   */ setEffects(effects) {\n        for (const effect of this.effects){\n            effect.removeEventListener(\"change\", this.listener);\n        }\n        this.effects = effects.sort((a, b)=>b.attributes - a.attributes);\n        for (const effect of this.effects){\n            effect.addEventListener(\"change\", this.listener);\n        }\n    }\n    /**\n   * Updates the compound shader material.\n   *\n   * @protected\n   */ updateMaterial() {\n        const data = new EffectShaderData();\n        let id = 0;\n        for (const effect of this.effects){\n            if (effect.blendMode.blendFunction === BlendFunction.DST) {\n                data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;\n            } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {\n                throw new Error(`Convolution effects cannot be merged (${effect.name})`);\n            } else {\n                integrateEffect(\"e\" + id++, effect, data);\n            }\n        }\n        let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);\n        let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);\n        let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);\n        const blendRegExp = /\\bblend\\b/g;\n        for (const blendMode of data.blendModes.values()){\n            fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + \"\\n\";\n        }\n        if ((data.attributes & EffectAttribute.DEPTH) !== 0) {\n            if (data.readDepth) {\n                fragmentMainImage = \"float depth = readDepth(UV);\\n\\n\t\" + fragmentMainImage;\n            }\n            this.needsDepthTexture = this.getDepthTexture() === null;\n        } else {\n            this.needsDepthTexture = false;\n        }\n        if (data.colorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n            fragmentMainImage += \"color0 = sRGBToLinear(color0);\\n\t\";\n        }\n        if (data.uvTransformation) {\n            fragmentMainUv = \"vec2 transformedUv = vUv;\\n\" + fragmentMainUv;\n            data.defines.set(\"UV\", \"transformedUv\");\n        } else {\n            data.defines.set(\"UV\", \"vUv\");\n        }\n        data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);\n        data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);\n        data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);\n        for (const [key, value] of data.shaderParts){\n            if (value !== null) {\n                data.shaderParts.set(key, value.trim().replace(/^#/, \"\\n#\"));\n            }\n        }\n        this.skipRendering = id === 0;\n        this.needsSwap = !this.skipRendering;\n        this.fullscreenMaterial.setShaderData(data);\n    }\n    /**\n   * Rebuilds the shader material.\n   */ recompile() {\n        this.updateMaterial();\n    }\n    /**\n   * Returns the current depth texture.\n   *\n   * @return {Texture} The current depth texture, or null if there is none.\n   */ getDepthTexture() {\n        return this.fullscreenMaterial.depthBuffer;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.fullscreenMaterial.depthBuffer = depthTexture;\n        this.fullscreenMaterial.depthPacking = depthPacking;\n        for (const effect of this.effects){\n            effect.setDepthTexture(depthTexture, depthPacking);\n        }\n    }\n    /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        for (const effect of this.effects){\n            effect.update(renderer, inputBuffer, deltaTime);\n        }\n        if (!this.skipRendering || this.renderToScreen) {\n            const material = this.fullscreenMaterial;\n            material.inputBuffer = inputBuffer.texture;\n            material.time += deltaTime * this.timeScale;\n            renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n            renderer.render(this.scene, this.camera);\n        }\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.fullscreenMaterial.setSize(width, height);\n        for (const effect of this.effects){\n            effect.setSize(width, height);\n        }\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.renderer = renderer;\n        for (const effect of this.effects){\n            effect.initialize(renderer, alpha, frameBufferType);\n        }\n        this.updateMaterial();\n        if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        }\n    }\n    /**\n   * Deletes disposable objects.\n   */ dispose() {\n        super.dispose();\n        for (const effect of this.effects){\n            effect.removeEventListener(\"change\", this.listener);\n            effect.dispose();\n        }\n    }\n    /**\n   * Handles events.\n   *\n   * @param {Event} event - An event.\n   */ handleEvent(event) {\n        switch(event.type){\n            case \"change\":\n                this.recompile();\n                break;\n        }\n    }\n};\n// src/passes/GaussianBlurPass.js\n\nvar GaussianBlurPass = class extends Pass {\n    /**\n   * Constructs a new Gaussian blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=35] - The kernel size. Should be an odd number in the range [3, 1020].\n   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */ constructor({ kernelSize = 35, iterations = 1, resolutionScale = 1, resolutionX = Resolution.AUTO_SIZE, resolutionY = Resolution.AUTO_SIZE } = {}){\n        super(\"GaussianBlurPass\");\n        this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetA.texture.name = \"Blur.Target.A\";\n        this.renderTargetB = this.renderTargetA.clone();\n        this.renderTargetB.texture.name = \"Blur.Target.B\";\n        this.blurMaterial = new GaussianBlurMaterial({\n            kernelSize\n        });\n        this.copyMaterial = new CopyMaterial();\n        this.copyMaterial.inputBuffer = this.renderTargetB.texture;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.iterations = iterations;\n    }\n    /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const renderTargetA = this.renderTargetA;\n        const renderTargetB = this.renderTargetB;\n        const blurMaterial = this.blurMaterial;\n        this.fullscreenMaterial = blurMaterial;\n        let previousBuffer = inputBuffer;\n        for(let i = 0, l = Math.max(this.iterations, 1); i < l; ++i){\n            blurMaterial.direction.set(1, 0);\n            blurMaterial.inputBuffer = previousBuffer.texture;\n            renderer.setRenderTarget(renderTargetA);\n            renderer.render(scene, camera);\n            blurMaterial.direction.set(0, 1);\n            blurMaterial.inputBuffer = renderTargetA.texture;\n            renderer.setRenderTarget(renderTargetB);\n            renderer.render(scene, camera);\n            if (i === 0 && l > 1) {\n                previousBuffer = renderTargetB;\n            }\n        }\n        this.fullscreenMaterial = this.copyMaterial;\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(scene, camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.renderTargetA.setSize(w, h);\n        this.renderTargetB.setSize(w, h);\n        this.blurMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0) {\n            this.renderTargetA.texture.type = frameBufferType;\n            this.renderTargetB.texture.type = frameBufferType;\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n                this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n                this.renderTargetA.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n                this.renderTargetB.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n            }\n        }\n    }\n};\n// src/passes/LambdaPass.js\nvar LambdaPass = class extends Pass {\n    /**\n   * Constructs a new lambda pass.\n   *\n   * @param {Function} f - A function.\n   */ constructor(f){\n        super(\"LambdaPass\", null, null);\n        this.needsSwap = false;\n        this.f = f;\n    }\n    /**\n   * Executes the function.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        this.f();\n    }\n};\n// src/passes/NormalPass.js\n\nvar NormalPass = class extends Pass {\n    /**\n   * Constructs a new normal pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Object} [options] - The options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(scene, camera, { renderTarget, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"NormalPass\");\n        this.needsSwap = false;\n        this.renderPass = new RenderPass(scene, camera, new three__WEBPACK_IMPORTED_MODULE_0__.MeshNormalMaterial());\n        const renderPass = this.renderPass;\n        renderPass.ignoreBackground = true;\n        renderPass.skipShadowMapUpdate = true;\n        const clearPass = renderPass.getClearPass();\n        clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(7829503);\n        clearPass.overrideClearAlpha = 1;\n        this.renderTarget = renderTarget;\n        if (this.renderTarget === void 0) {\n            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter\n            });\n            this.renderTarget.texture.name = \"NormalPass.Target\";\n        }\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    set mainScene(value) {\n        this.renderPass.mainScene = value;\n    }\n    set mainCamera(value) {\n        this.renderPass.mainCamera = value;\n    }\n    /**\n   * The normal texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * The normal texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Renders the scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const renderTarget = this.renderToScreen ? null : this.renderTarget;\n        this.renderPass.render(renderer, renderTarget, renderTarget);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n};\n// src/textures/lut/TetrahedralUpscaler.js\nvar P = [\n    new Float32Array(3),\n    new Float32Array(3)\n];\nvar C = [\n    new Float32Array(3),\n    new Float32Array(3),\n    new Float32Array(3),\n    new Float32Array(3)\n];\nvar T = [\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            1,\n            0,\n            0\n        ]),\n        new Float32Array([\n            1,\n            1,\n            0\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            1,\n            0,\n            0\n        ]),\n        new Float32Array([\n            1,\n            0,\n            1\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            0,\n            0,\n            1\n        ]),\n        new Float32Array([\n            1,\n            0,\n            1\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            0,\n            1,\n            0\n        ]),\n        new Float32Array([\n            1,\n            1,\n            0\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            0,\n            1,\n            0\n        ]),\n        new Float32Array([\n            0,\n            1,\n            1\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            0,\n            0,\n            1\n        ]),\n        new Float32Array([\n            0,\n            1,\n            1\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ]\n];\nfunction calculateTetrahedronVolume(a, b, c2, d) {\n    const bcX = c2[0] - b[0];\n    const bcY = c2[1] - b[1];\n    const bcZ = c2[2] - b[2];\n    const baX = a[0] - b[0];\n    const baY = a[1] - b[1];\n    const baZ = a[2] - b[2];\n    const crossX = bcY * baZ - bcZ * baY;\n    const crossY = bcZ * baX - bcX * baZ;\n    const crossZ = bcX * baY - bcY * baX;\n    const length = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n    const triangleArea = length * 0.5;\n    const normalX = crossX / length;\n    const normalY = crossY / length;\n    const normalZ = crossZ / length;\n    const constant = -(a[0] * normalX + a[1] * normalY + a[2] * normalZ);\n    const dot = d[0] * normalX + d[1] * normalY + d[2] * normalZ;\n    const height = Math.abs(dot + constant);\n    return height * triangleArea / 3;\n}\nfunction sample(data, size, x, y, z, color2) {\n    const i4 = (x + y * size + z * size * size) * 4;\n    color2[0] = data[i4 + 0];\n    color2[1] = data[i4 + 1];\n    color2[2] = data[i4 + 2];\n}\nfunction tetrahedralSample(data, size, u, v3, w, color2) {\n    const px = u * (size - 1);\n    const py = v3 * (size - 1);\n    const pz = w * (size - 1);\n    const minX = Math.floor(px);\n    const minY = Math.floor(py);\n    const minZ = Math.floor(pz);\n    const maxX = Math.ceil(px);\n    const maxY = Math.ceil(py);\n    const maxZ = Math.ceil(pz);\n    const su = px - minX;\n    const sv = py - minY;\n    const sw = pz - minZ;\n    if (minX === px && minY === py && minZ === pz) {\n        sample(data, size, px, py, pz, color2);\n    } else {\n        let vertices;\n        if (su >= sv && sv >= sw) {\n            vertices = T[0];\n        } else if (su >= sw && sw >= sv) {\n            vertices = T[1];\n        } else if (sw >= su && su >= sv) {\n            vertices = T[2];\n        } else if (sv >= su && su >= sw) {\n            vertices = T[3];\n        } else if (sv >= sw && sw >= su) {\n            vertices = T[4];\n        } else if (sw >= sv && sv >= su) {\n            vertices = T[5];\n        }\n        const [P0, P1, P2, P3] = vertices;\n        const coords = P[0];\n        coords[0] = su;\n        coords[1] = sv;\n        coords[2] = sw;\n        const tmp = P[1];\n        const diffX = maxX - minX;\n        const diffY = maxY - minY;\n        const diffZ = maxZ - minZ;\n        tmp[0] = diffX * P0[0] + minX;\n        tmp[1] = diffY * P0[1] + minY;\n        tmp[2] = diffZ * P0[2] + minZ;\n        sample(data, size, tmp[0], tmp[1], tmp[2], C[0]);\n        tmp[0] = diffX * P1[0] + minX;\n        tmp[1] = diffY * P1[1] + minY;\n        tmp[2] = diffZ * P1[2] + minZ;\n        sample(data, size, tmp[0], tmp[1], tmp[2], C[1]);\n        tmp[0] = diffX * P2[0] + minX;\n        tmp[1] = diffY * P2[1] + minY;\n        tmp[2] = diffZ * P2[2] + minZ;\n        sample(data, size, tmp[0], tmp[1], tmp[2], C[2]);\n        tmp[0] = diffX * P3[0] + minX;\n        tmp[1] = diffY * P3[1] + minY;\n        tmp[2] = diffZ * P3[2] + minZ;\n        sample(data, size, tmp[0], tmp[1], tmp[2], C[3]);\n        const V0 = calculateTetrahedronVolume(P1, P2, P3, coords) * 6;\n        const V1 = calculateTetrahedronVolume(P0, P2, P3, coords) * 6;\n        const V2 = calculateTetrahedronVolume(P0, P1, P3, coords) * 6;\n        const V3 = calculateTetrahedronVolume(P0, P1, P2, coords) * 6;\n        C[0][0] *= V0;\n        C[0][1] *= V0;\n        C[0][2] *= V0;\n        C[1][0] *= V1;\n        C[1][1] *= V1;\n        C[1][2] *= V1;\n        C[2][0] *= V2;\n        C[2][1] *= V2;\n        C[2][2] *= V2;\n        C[3][0] *= V3;\n        C[3][1] *= V3;\n        C[3][2] *= V3;\n        color2[0] = C[0][0] + C[1][0] + C[2][0] + C[3][0];\n        color2[1] = C[0][1] + C[1][1] + C[2][1] + C[3][1];\n        color2[2] = C[0][2] + C[1][2] + C[2][2] + C[3][2];\n    }\n}\nvar TetrahedralUpscaler = class {\n    /**\n   * Expands the given data to the target size.\n   *\n   * @param {TypedArray} data - The input RGBA data. Assumed to be cubic.\n   * @param {Number} size - The target size.\n   * @return {TypedArray} The new data.\n   */ static expand(data, size) {\n        const originalSize = Math.cbrt(data.length / 4);\n        const rgb = new Float32Array(3);\n        const array = new data.constructor(size ** 3 * 4);\n        const maxValue = data instanceof Uint8Array ? 255 : 1;\n        const sizeSq = size ** 2;\n        const s = 1 / (size - 1);\n        for(let z = 0; z < size; ++z){\n            for(let y = 0; y < size; ++y){\n                for(let x = 0; x < size; ++x){\n                    const u = x * s;\n                    const v3 = y * s;\n                    const w = z * s;\n                    const i4 = Math.round(x + y * size + z * sizeSq) * 4;\n                    tetrahedralSample(data, originalSize, u, v3, w, rgb);\n                    array[i4 + 0] = rgb[0];\n                    array[i4 + 1] = rgb[1];\n                    array[i4 + 2] = rgb[2];\n                    array[i4 + 3] = maxValue;\n                }\n            }\n        }\n        return array;\n    }\n};\n// src/textures/smaa/SMAAAreaImageData.js\nvar area = [\n    new Float32Array(2),\n    new Float32Array(2)\n];\nvar ORTHOGONAL_SIZE = 16;\nvar DIAGONAL_SIZE = 20;\nvar DIAGONAL_SAMPLES = 30;\nvar SMOOTH_MAX_DISTANCE = 32;\nvar orthogonalSubsamplingOffsets = new Float32Array([\n    0,\n    -0.25,\n    0.25,\n    -0.125,\n    0.125,\n    -0.375,\n    0.375\n]);\nvar diagonalSubsamplingOffsets = [\n    new Float32Array([\n        0,\n        0\n    ]),\n    new Float32Array([\n        0.25,\n        -0.25\n    ]),\n    new Float32Array([\n        -0.25,\n        0.25\n    ]),\n    new Float32Array([\n        0.125,\n        -0.125\n    ]),\n    new Float32Array([\n        -0.125,\n        0.125\n    ])\n];\nvar orthogonalEdges = [\n    new Uint8Array([\n        0,\n        0\n    ]),\n    new Uint8Array([\n        3,\n        0\n    ]),\n    new Uint8Array([\n        0,\n        3\n    ]),\n    new Uint8Array([\n        3,\n        3\n    ]),\n    new Uint8Array([\n        1,\n        0\n    ]),\n    new Uint8Array([\n        4,\n        0\n    ]),\n    new Uint8Array([\n        1,\n        3\n    ]),\n    new Uint8Array([\n        4,\n        3\n    ]),\n    new Uint8Array([\n        0,\n        1\n    ]),\n    new Uint8Array([\n        3,\n        1\n    ]),\n    new Uint8Array([\n        0,\n        4\n    ]),\n    new Uint8Array([\n        3,\n        4\n    ]),\n    new Uint8Array([\n        1,\n        1\n    ]),\n    new Uint8Array([\n        4,\n        1\n    ]),\n    new Uint8Array([\n        1,\n        4\n    ]),\n    new Uint8Array([\n        4,\n        4\n    ])\n];\nvar diagonalEdges = [\n    new Uint8Array([\n        0,\n        0\n    ]),\n    new Uint8Array([\n        1,\n        0\n    ]),\n    new Uint8Array([\n        0,\n        2\n    ]),\n    new Uint8Array([\n        1,\n        2\n    ]),\n    new Uint8Array([\n        2,\n        0\n    ]),\n    new Uint8Array([\n        3,\n        0\n    ]),\n    new Uint8Array([\n        2,\n        2\n    ]),\n    new Uint8Array([\n        3,\n        2\n    ]),\n    new Uint8Array([\n        0,\n        1\n    ]),\n    new Uint8Array([\n        1,\n        1\n    ]),\n    new Uint8Array([\n        0,\n        3\n    ]),\n    new Uint8Array([\n        1,\n        3\n    ]),\n    new Uint8Array([\n        2,\n        1\n    ]),\n    new Uint8Array([\n        3,\n        1\n    ]),\n    new Uint8Array([\n        2,\n        3\n    ]),\n    new Uint8Array([\n        3,\n        3\n    ])\n];\nfunction lerp(a, b, p) {\n    return a + (b - a) * p;\n}\nfunction saturate(a) {\n    return Math.min(Math.max(a, 0), 1);\n}\nfunction smoothArea(d) {\n    const a1 = area[0];\n    const a2 = area[1];\n    const b1X = Math.sqrt(a1[0] * 2) * 0.5;\n    const b1Y = Math.sqrt(a1[1] * 2) * 0.5;\n    const b2X = Math.sqrt(a2[0] * 2) * 0.5;\n    const b2Y = Math.sqrt(a2[1] * 2) * 0.5;\n    const p = saturate(d / SMOOTH_MAX_DISTANCE);\n    a1[0] = lerp(b1X, a1[0], p);\n    a1[1] = lerp(b1Y, a1[1], p);\n    a2[0] = lerp(b2X, a2[0], p);\n    a2[1] = lerp(b2Y, a2[1], p);\n}\nfunction getOrthArea(p1X, p1Y, p2X, p2Y, x, result) {\n    const dX = p2X - p1X;\n    const dY = p2Y - p1Y;\n    const x1 = x;\n    const x2 = x + 1;\n    const y1 = p1Y + dY * (x1 - p1X) / dX;\n    const y2 = p1Y + dY * (x2 - p1X) / dX;\n    if (x1 >= p1X && x1 < p2X || x2 > p1X && x2 <= p2X) {\n        if (Math.sign(y1) === Math.sign(y2) || Math.abs(y1) < 1e-4 || Math.abs(y2) < 1e-4) {\n            const a = (y1 + y2) / 2;\n            if (a < 0) {\n                result[0] = Math.abs(a);\n                result[1] = 0;\n            } else {\n                result[0] = 0;\n                result[1] = Math.abs(a);\n            }\n        } else {\n            const t = -p1Y * dX / dY + p1X;\n            const tInt = Math.trunc(t);\n            const a1 = t > p1X ? y1 * (t - tInt) / 2 : 0;\n            const a2 = t < p2X ? y2 * (1 - (t - tInt)) / 2 : 0;\n            const a = Math.abs(a1) > Math.abs(a2) ? a1 : -a2;\n            if (a < 0) {\n                result[0] = Math.abs(a1);\n                result[1] = Math.abs(a2);\n            } else {\n                result[0] = Math.abs(a2);\n                result[1] = Math.abs(a1);\n            }\n        }\n    } else {\n        result[0] = 0;\n        result[1] = 0;\n    }\n    return result;\n}\nfunction getOrthAreaForPattern(pattern, left, right, offset, result) {\n    const a1 = area[0];\n    const a2 = area[1];\n    const o1 = 0.5 + offset;\n    const o2 = 0.5 + offset - 1;\n    const d = left + right + 1;\n    switch(pattern){\n        case 0:\n            {\n                result[0] = 0;\n                result[1] = 0;\n                break;\n            }\n        case 1:\n            {\n                if (left <= right) {\n                    getOrthArea(0, o2, d / 2, 0, left, result);\n                } else {\n                    result[0] = 0;\n                    result[1] = 0;\n                }\n                break;\n            }\n        case 2:\n            {\n                if (left >= right) {\n                    getOrthArea(d / 2, 0, d, o2, left, result);\n                } else {\n                    result[0] = 0;\n                    result[1] = 0;\n                }\n                break;\n            }\n        case 3:\n            {\n                getOrthArea(0, o2, d / 2, 0, left, a1);\n                getOrthArea(d / 2, 0, d, o2, left, a2);\n                smoothArea(d, area);\n                result[0] = a1[0] + a2[0];\n                result[1] = a1[1] + a2[1];\n                break;\n            }\n        case 4:\n            {\n                if (left <= right) {\n                    getOrthArea(0, o1, d / 2, 0, left, result);\n                } else {\n                    result[0] = 0;\n                    result[1] = 0;\n                }\n                break;\n            }\n        case 5:\n            {\n                result[0] = 0;\n                result[1] = 0;\n                break;\n            }\n        case 6:\n            {\n                if (Math.abs(offset) > 0) {\n                    getOrthArea(0, o1, d, o2, left, a1);\n                    getOrthArea(0, o1, d / 2, 0, left, a2);\n                    getOrthArea(d / 2, 0, d, o2, left, result);\n                    a2[0] = a2[0] + result[0];\n                    a2[1] = a2[1] + result[1];\n                    result[0] = (a1[0] + a2[0]) / 2;\n                    result[1] = (a1[1] + a2[1]) / 2;\n                } else {\n                    getOrthArea(0, o1, d, o2, left, result);\n                }\n                break;\n            }\n        case 7:\n            {\n                getOrthArea(0, o1, d, o2, left, result);\n                break;\n            }\n        case 8:\n            {\n                if (left >= right) {\n                    getOrthArea(d / 2, 0, d, o1, left, result);\n                } else {\n                    result[0] = 0;\n                    result[1] = 0;\n                }\n                break;\n            }\n        case 9:\n            {\n                if (Math.abs(offset) > 0) {\n                    getOrthArea(0, o2, d, o1, left, a1);\n                    getOrthArea(0, o2, d / 2, 0, left, a2);\n                    getOrthArea(d / 2, 0, d, o1, left, result);\n                    a2[0] = a2[0] + result[0];\n                    a2[1] = a2[1] + result[1];\n                    result[0] = (a1[0] + a2[0]) / 2;\n                    result[1] = (a1[1] + a2[1]) / 2;\n                } else {\n                    getOrthArea(0, o2, d, o1, left, result);\n                }\n                break;\n            }\n        case 10:\n            {\n                result[0] = 0;\n                result[1] = 0;\n                break;\n            }\n        case 11:\n            {\n                getOrthArea(0, o2, d, o1, left, result);\n                break;\n            }\n        case 12:\n            {\n                getOrthArea(0, o1, d / 2, 0, left, a1);\n                getOrthArea(d / 2, 0, d, o1, left, a2);\n                smoothArea(d, area);\n                result[0] = a1[0] + a2[0];\n                result[1] = a1[1] + a2[1];\n                break;\n            }\n        case 13:\n            {\n                getOrthArea(0, o2, d, o1, left, result);\n                break;\n            }\n        case 14:\n            {\n                getOrthArea(0, o1, d, o2, left, result);\n                break;\n            }\n        case 15:\n            {\n                result[0] = 0;\n                result[1] = 0;\n                break;\n            }\n    }\n    return result;\n}\nfunction isInsideArea(a1X, a1Y, a2X, a2Y, x, y) {\n    let result = a1X === a2X && a1Y === a2Y;\n    if (!result) {\n        const xm = (a1X + a2X) / 2;\n        const ym = (a1Y + a2Y) / 2;\n        const a = a2Y - a1Y;\n        const b = a1X - a2X;\n        const c2 = a * (x - xm) + b * (y - ym);\n        result = c2 > 0;\n    }\n    return result;\n}\nfunction getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, pX, pY) {\n    let n = 0;\n    for(let y = 0; y < DIAGONAL_SAMPLES; ++y){\n        for(let x = 0; x < DIAGONAL_SAMPLES; ++x){\n            const offsetX = x / (DIAGONAL_SAMPLES - 1);\n            const offsetY = y / (DIAGONAL_SAMPLES - 1);\n            if (isInsideArea(a1X, a1Y, a2X, a2Y, pX + offsetX, pY + offsetY)) {\n                ++n;\n            }\n        }\n    }\n    return n / (DIAGONAL_SAMPLES * DIAGONAL_SAMPLES);\n}\nfunction getDiagArea(pattern, a1X, a1Y, a2X, a2Y, left, offset, result) {\n    const e = diagonalEdges[pattern];\n    const e1 = e[0];\n    const e2 = e[1];\n    if (e1 > 0) {\n        a1X += offset[0];\n        a1Y += offset[1];\n    }\n    if (e2 > 0) {\n        a2X += offset[0];\n        a2Y += offset[1];\n    }\n    result[0] = 1 - getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 0 + left);\n    result[1] = getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 1 + left);\n    return result;\n}\nfunction getDiagAreaForPattern(pattern, left, right, offset, result) {\n    const a1 = area[0];\n    const a2 = area[1];\n    const d = left + right + 1;\n    switch(pattern){\n        case 0:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 1:\n            {\n                getDiagArea(pattern, 1, 0, 0 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 2:\n            {\n                getDiagArea(pattern, 0, 0, 1 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 3:\n            {\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, result);\n                break;\n            }\n        case 4:\n            {\n                getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 5:\n            {\n                getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 6:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, result);\n                break;\n            }\n        case 7:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 8:\n            {\n                getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 9:\n            {\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n                break;\n            }\n        case 10:\n            {\n                getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 11:\n            {\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 12:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, result);\n                break;\n            }\n        case 13:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 14:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 15:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n    }\n    return result;\n}\nfunction generatePatterns(patterns, offset, orthogonal) {\n    const result = new Float32Array(2);\n    for(let i = 0, l = patterns.length; i < l; ++i){\n        const pattern = patterns[i];\n        const data = pattern.data;\n        const size = pattern.width;\n        for(let y = 0; y < size; ++y){\n            for(let x = 0; x < size; ++x){\n                if (orthogonal) {\n                    getOrthAreaForPattern(i, x, y, offset, result);\n                } else {\n                    getDiagAreaForPattern(i, x, y, offset, result);\n                }\n                const c2 = (y * size + x) * 2;\n                data[c2] = result[0] * 255;\n                data[c2 + 1] = result[1] * 255;\n            }\n        }\n    }\n}\nfunction assemble(baseX, baseY, patterns, edges2, size, orthogonal, target) {\n    const dstData = target.data;\n    const dstWidth = target.width;\n    for(let i = 0, l = patterns.length; i < l; ++i){\n        const edge = edges2[i];\n        const pattern = patterns[i];\n        const srcData = pattern.data;\n        const srcWidth = pattern.width;\n        for(let y = 0; y < size; ++y){\n            for(let x = 0; x < size; ++x){\n                const pX = edge[0] * size + baseX + x;\n                const pY = edge[1] * size + baseY + y;\n                const c2 = (pY * dstWidth + pX) * 4;\n                const d = orthogonal ? (y * y * srcWidth + x * x) * 2 : (y * srcWidth + x) * 2;\n                dstData[c2] = srcData[d];\n                dstData[c2 + 1] = srcData[d + 1];\n                dstData[c2 + 2] = 0;\n                dstData[c2 + 3] = 255;\n            }\n        }\n    }\n}\nvar SMAAAreaImageData = class {\n    /**\n   * Creates a new area image.\n   *\n   * @return {RawImageData} The generated image data.\n   */ static generate() {\n        const width = 2 * 5 * ORTHOGONAL_SIZE;\n        const height = orthogonalSubsamplingOffsets.length * 5 * ORTHOGONAL_SIZE;\n        const data = new Uint8ClampedArray(width * height * 4);\n        const result = new RawImageData(width, height, data);\n        const orthPatternSize = Math.pow(ORTHOGONAL_SIZE - 1, 2) + 1;\n        const diagPatternSize = DIAGONAL_SIZE;\n        const orthogonalPatterns = [];\n        const diagonalPatterns = [];\n        for(let i = 3, l = data.length; i < l; i += 4){\n            data[i] = 255;\n        }\n        for(let i = 0; i < 16; ++i){\n            orthogonalPatterns.push(new RawImageData(orthPatternSize, orthPatternSize, new Uint8ClampedArray(orthPatternSize * orthPatternSize * 2), 2));\n            diagonalPatterns.push(new RawImageData(diagPatternSize, diagPatternSize, new Uint8ClampedArray(diagPatternSize * diagPatternSize * 2), 2));\n        }\n        for(let i = 0, l = orthogonalSubsamplingOffsets.length; i < l; ++i){\n            generatePatterns(orthogonalPatterns, orthogonalSubsamplingOffsets[i], true);\n            assemble(0, 5 * ORTHOGONAL_SIZE * i, orthogonalPatterns, orthogonalEdges, ORTHOGONAL_SIZE, true, result);\n        }\n        for(let i = 0, l = diagonalSubsamplingOffsets.length; i < l; ++i){\n            generatePatterns(diagonalPatterns, diagonalSubsamplingOffsets[i], false);\n            assemble(5 * ORTHOGONAL_SIZE, 4 * DIAGONAL_SIZE * i, diagonalPatterns, diagonalEdges, DIAGONAL_SIZE, false, result);\n        }\n        return result;\n    }\n};\n// src/textures/smaa/SMAAImageGenerator.js\n\n// temp/smaa/worker.txt\nvar worker_default2 = '\"use strict\";(()=>{function q(t,a,s){let e=document.createElement(\"canvas\"),n=e.getContext(\"2d\");if(e.width=t,e.height=a,s instanceof Image)n.drawImage(s,0,0);else{let r=n.createImageData(t,a);r.data.set(s),n.putImageData(r,0,0)}return e}var F=class t{constructor(a=0,s=0,e=null){this.width=a,this.height=s,this.data=e}toCanvas(){return typeof document==\"undefined\"?null:q(this.width,this.height,this.data)}static from(a){let{width:s,height:e}=a,n;if(a instanceof Image){let r=q(s,e,a);r!==null&&(n=r.getContext(\"2d\").getImageData(0,0,s,e).data)}else n=a.data;return new t(s,e,n)}};var M=[new Float32Array(2),new Float32Array(2)],D=16,W=20,I=30,j=32,v=new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),N=[new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125])],z=[new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4])],p=[new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3])];function C(t,a,s){return t+(a-t)*s}function B(t){return Math.min(Math.max(t,0),1)}function _(t){let a=M[0],s=M[1],e=Math.sqrt(a[0]*2)*.5,n=Math.sqrt(a[1]*2)*.5,r=Math.sqrt(s[0]*2)*.5,o=Math.sqrt(s[1]*2)*.5,c=B(t/j);a[0]=C(e,a[0],c),a[1]=C(n,a[1],c),s[0]=C(r,s[0],c),s[1]=C(o,s[1],c)}function d(t,a,s,e,n,r){let o=s-t,c=e-a,h=n,i=n+1,w=a+c*(h-t)/o,b=a+c*(i-t)/o;if(h>=t&&h<s||i>t&&i<=s)if(Math.sign(w)===Math.sign(b)||Math.abs(w)<1e-4||Math.abs(b)<1e-4){let g=(w+b)/2;g<0?(r[0]=Math.abs(g),r[1]=0):(r[0]=0,r[1]=Math.abs(g))}else{let g=-a*o/c+t,k=Math.trunc(g),m=g>t?w*(g-k)/2:0,U=g<s?b*(1-(g-k))/2:0;(Math.abs(m)>Math.abs(U)?m:-U)<0?(r[0]=Math.abs(m),r[1]=Math.abs(U)):(r[0]=Math.abs(U),r[1]=Math.abs(m))}else r[0]=0,r[1]=0;return r}function J(t,a,s,e,n){let r=M[0],o=M[1],c=.5+e,h=.5+e-1,i=a+s+1;switch(t){case 0:{n[0]=0,n[1]=0;break}case 1:{a<=s?d(0,h,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 2:{a>=s?d(i/2,0,i,h,a,n):(n[0]=0,n[1]=0);break}case 3:{d(0,h,i/2,0,a,r),d(i/2,0,i,h,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 4:{a<=s?d(0,c,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 5:{n[0]=0,n[1]=0;break}case 6:{Math.abs(e)>0?(d(0,c,i,h,a,r),d(0,c,i/2,0,a,o),d(i/2,0,i,h,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,c,i,h,a,n);break}case 7:{d(0,c,i,h,a,n);break}case 8:{a>=s?d(i/2,0,i,c,a,n):(n[0]=0,n[1]=0);break}case 9:{Math.abs(e)>0?(d(0,h,i,c,a,r),d(0,h,i/2,0,a,o),d(i/2,0,i,c,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,h,i,c,a,n);break}case 10:{n[0]=0,n[1]=0;break}case 11:{d(0,h,i,c,a,n);break}case 12:{d(0,c,i/2,0,a,r),d(i/2,0,i,c,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 13:{d(0,h,i,c,a,n);break}case 14:{d(0,c,i,h,a,n);break}case 15:{n[0]=0,n[1]=0;break}}return n}function K(t,a,s,e,n,r){let o=t===s&&a===e;if(!o){let c=(t+s)/2,h=(a+e)/2,i=e-a,w=t-s;o=i*(n-c)+w*(r-h)>0}return o}function G(t,a,s,e,n,r){let o=0;for(let c=0;c<I;++c)for(let h=0;h<I;++h){let i=h/(I-1),w=c/(I-1);K(t,a,s,e,n+i,r+w)&&++o}return o/(I*I)}function A(t,a,s,e,n,r,o,c){let h=p[t],i=h[0],w=h[1];return i>0&&(a+=o[0],s+=o[1]),w>0&&(e+=o[0],n+=o[1]),c[0]=1-G(a,s,e,n,1+r,0+r),c[1]=G(a,s,e,n,1+r,1+r),c}function Q(t,a,s,e,n){let r=M[0],o=M[1],c=a+s+1;switch(t){case 0:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 1:{A(t,1,0,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 2:{A(t,0,0,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 3:{A(t,1,0,1+c,0+c,a,e,n);break}case 4:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 5:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 6:{A(t,1,1,1+c,0+c,a,e,n);break}case 7:{A(t,1,1,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 8:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 9:{A(t,1,0,1+c,1+c,a,e,n),A(t,1,0,1+c,1+c,a,e,n);break}case 10:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 11:{A(t,1,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 12:{A(t,1,1,1+c,1+c,a,e,n);break}case 13:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 14:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 15:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}}return n}function R(t,a,s){let e=new Float32Array(2);for(let n=0,r=t.length;n<r;++n){let o=t[n],c=o.data,h=o.width;for(let i=0;i<h;++i)for(let w=0;w<h;++w){s?J(n,w,i,a,e):Q(n,w,i,a,e);let b=(i*h+w)*2;c[b]=e[0]*255,c[b+1]=e[1]*255}}}function T(t,a,s,e,n,r,o){let c=o.data,h=o.width;for(let i=0,w=s.length;i<w;++i){let b=e[i],g=s[i],k=g.data,m=g.width;for(let U=0;U<n;++U)for(let x=0;x<n;++x){let Z=b[0]*n+t+x,O=((b[1]*n+a+U)*h+Z)*4,L=r?(U*U*m+x*x)*2:(U*m+x)*2;c[O]=k[L],c[O+1]=k[L+1],c[O+2]=0,c[O+3]=255}}}var S=class{static generate(){let a=10*D,s=v.length*5*D,e=new Uint8ClampedArray(a*s*4),n=new F(a,s,e),r=Math.pow(D-1,2)+1,o=W,c=[],h=[];for(let i=3,w=e.length;i<w;i+=4)e[i]=255;for(let i=0;i<16;++i)c.push(new F(r,r,new Uint8ClampedArray(r*r*2),2)),h.push(new F(o,o,new Uint8ClampedArray(o*o*2),2));for(let i=0,w=v.length;i<w;++i)R(c,v[i],!0),T(0,5*D*i,c,z,D,!0,n);for(let i=0,w=N.length;i<w;++i)R(h,N[i],!1),T(5*D,4*W*i,h,p,W,!1,n);return n}};var P=new Map([[y(0,0,0,0),new Float32Array([0,0,0,0])],[y(0,0,0,1),new Float32Array([0,0,0,1])],[y(0,0,1,0),new Float32Array([0,0,1,0])],[y(0,0,1,1),new Float32Array([0,0,1,1])],[y(0,1,0,0),new Float32Array([0,1,0,0])],[y(0,1,0,1),new Float32Array([0,1,0,1])],[y(0,1,1,0),new Float32Array([0,1,1,0])],[y(0,1,1,1),new Float32Array([0,1,1,1])],[y(1,0,0,0),new Float32Array([1,0,0,0])],[y(1,0,0,1),new Float32Array([1,0,0,1])],[y(1,0,1,0),new Float32Array([1,0,1,0])],[y(1,0,1,1),new Float32Array([1,0,1,1])],[y(1,1,0,0),new Float32Array([1,1,0,0])],[y(1,1,0,1),new Float32Array([1,1,0,1])],[y(1,1,1,0),new Float32Array([1,1,1,0])],[y(1,1,1,1),new Float32Array([1,1,1,1])]]);function H(t,a,s){return t+(a-t)*s}function y(t,a,s,e){let n=H(t,a,.75),r=H(s,e,1-.25);return H(n,r,1-.125)}function V(t,a){let s=0;return a[3]===1&&(s+=1),s===1&&a[2]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s}function $(t,a){let s=0;return a[3]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s===1&&a[2]===1&&t[0]!==1&&t[2]!==1&&(s+=1),s}var E=class{static generate(){let o=new Uint8ClampedArray(2178),c=new Uint8ClampedArray(1024*4);for(let h=0;h<33;++h)for(let i=0;i<66;++i){let w=.03125*i,b=.03125*h;if(P.has(w)&&P.has(b)){let g=P.get(w),k=P.get(b),m=h*66+i;o[m]=127*V(g,k),o[m+33]=127*$(g,k)}}for(let h=0,i=17;i<33;++i)for(let w=0;w<64;++w,h+=4)c[h]=o[i*66+w],c[h+3]=255;return new F(64,16,c)}};self.addEventListener(\"message\",t=>{let a=S.generate(),s=E.generate();postMessage({areaImageData:a,searchImageData:s},[a.data.buffer,s.data.buffer]),close()});})();\\n';\n// src/textures/smaa/SMAAImageGenerator.js\nfunction generate(useCache = true) {\n    const workerURL = URL.createObjectURL(new Blob([\n        worker_default2\n    ], {\n        type: \"text/javascript\"\n    }));\n    const worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    return new Promise((resolve, reject)=>{\n        worker.addEventListener(\"error\", (event)=>reject(event.error));\n        worker.addEventListener(\"message\", (event)=>{\n            const searchImageData = RawImageData.from(event.data.searchImageData);\n            const areaImageData = RawImageData.from(event.data.areaImageData);\n            const urls = [\n                searchImageData.toCanvas().toDataURL(\"image/png\", 1),\n                areaImageData.toCanvas().toDataURL(\"image/png\", 1)\n            ];\n            if (useCache) {\n                localStorage.setItem(\"smaa-search\", urls[0]);\n                localStorage.setItem(\"smaa-area\", urls[1]);\n            }\n            resolve(urls);\n        });\n        worker.postMessage(null);\n    });\n}\nvar SMAAImageGenerator = class {\n    /**\n   * Constructs a new SMAA image generator.\n   */ constructor(){\n        this.disableCache = false;\n    }\n    /**\n   * Enables or disables caching via localStorage.\n   *\n   * @param {Boolean} value - Whether the cache should be enabled.\n   */ setCacheEnabled(value) {\n        this.disableCache = !value;\n    }\n    /**\n   * Generates the SMAA data images.\n   *\n   * @example\n   * SMAAImageGenerator.generate().then(([search, area]) => {\n   *   const smaaEffect = new SMAAEffect(search, area);\n   * });\n   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.\n   */ generate() {\n        const useCache = !this.disableCache && window.localStorage !== void 0;\n        const cachedURLs = useCache ? [\n            localStorage.getItem(\"smaa-search\"),\n            localStorage.getItem(\"smaa-area\")\n        ] : [\n            null,\n            null\n        ];\n        const promise = cachedURLs[0] !== null && cachedURLs[1] !== null ? Promise.resolve(cachedURLs) : generate(useCache);\n        return promise.then((urls)=>{\n            return new Promise((resolve, reject)=>{\n                const searchImage = new Image();\n                const areaImage = new Image();\n                const manager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n                manager.onLoad = ()=>resolve([\n                        searchImage,\n                        areaImage\n                    ]);\n                manager.onError = reject;\n                searchImage.addEventListener(\"error\", (e)=>manager.itemError(\"smaa-search\"));\n                areaImage.addEventListener(\"error\", (e)=>manager.itemError(\"smaa-area\"));\n                searchImage.addEventListener(\"load\", ()=>manager.itemEnd(\"smaa-search\"));\n                areaImage.addEventListener(\"load\", ()=>manager.itemEnd(\"smaa-area\"));\n                manager.itemStart(\"smaa-search\");\n                manager.itemStart(\"smaa-area\");\n                searchImage.src = urls[0];\n                areaImage.src = urls[1];\n            });\n        });\n    }\n};\n// src/textures/smaa/SMAASearchImageData.js\nvar edges = /* @__PURE__ */ new Map([\n    [\n        bilinear(0, 0, 0, 0),\n        new Float32Array([\n            0,\n            0,\n            0,\n            0\n        ])\n    ],\n    [\n        bilinear(0, 0, 0, 1),\n        new Float32Array([\n            0,\n            0,\n            0,\n            1\n        ])\n    ],\n    [\n        bilinear(0, 0, 1, 0),\n        new Float32Array([\n            0,\n            0,\n            1,\n            0\n        ])\n    ],\n    [\n        bilinear(0, 0, 1, 1),\n        new Float32Array([\n            0,\n            0,\n            1,\n            1\n        ])\n    ],\n    [\n        bilinear(0, 1, 0, 0),\n        new Float32Array([\n            0,\n            1,\n            0,\n            0\n        ])\n    ],\n    [\n        bilinear(0, 1, 0, 1),\n        new Float32Array([\n            0,\n            1,\n            0,\n            1\n        ])\n    ],\n    [\n        bilinear(0, 1, 1, 0),\n        new Float32Array([\n            0,\n            1,\n            1,\n            0\n        ])\n    ],\n    [\n        bilinear(0, 1, 1, 1),\n        new Float32Array([\n            0,\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        bilinear(1, 0, 0, 0),\n        new Float32Array([\n            1,\n            0,\n            0,\n            0\n        ])\n    ],\n    [\n        bilinear(1, 0, 0, 1),\n        new Float32Array([\n            1,\n            0,\n            0,\n            1\n        ])\n    ],\n    [\n        bilinear(1, 0, 1, 0),\n        new Float32Array([\n            1,\n            0,\n            1,\n            0\n        ])\n    ],\n    [\n        bilinear(1, 0, 1, 1),\n        new Float32Array([\n            1,\n            0,\n            1,\n            1\n        ])\n    ],\n    [\n        bilinear(1, 1, 0, 0),\n        new Float32Array([\n            1,\n            1,\n            0,\n            0\n        ])\n    ],\n    [\n        bilinear(1, 1, 0, 1),\n        new Float32Array([\n            1,\n            1,\n            0,\n            1\n        ])\n    ],\n    [\n        bilinear(1, 1, 1, 0),\n        new Float32Array([\n            1,\n            1,\n            1,\n            0\n        ])\n    ],\n    [\n        bilinear(1, 1, 1, 1),\n        new Float32Array([\n            1,\n            1,\n            1,\n            1\n        ])\n    ]\n]);\nfunction lerp2(a, b, p) {\n    return a + (b - a) * p;\n}\nfunction bilinear(e0, e1, e2, e3) {\n    const a = lerp2(e0, e1, 1 - 0.25);\n    const b = lerp2(e2, e3, 1 - 0.25);\n    return lerp2(a, b, 1 - 0.125);\n}\nfunction deltaLeft(left, top) {\n    let d = 0;\n    if (top[3] === 1) {\n        d += 1;\n    }\n    if (d === 1 && top[2] === 1 && left[1] !== 1 && left[3] !== 1) {\n        d += 1;\n    }\n    return d;\n}\nfunction deltaRight(left, top) {\n    let d = 0;\n    if (top[3] === 1 && left[1] !== 1 && left[3] !== 1) {\n        d += 1;\n    }\n    if (d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {\n        d += 1;\n    }\n    return d;\n}\nvar SMAASearchImageData = class {\n    /**\n   * Creates a new search image.\n   *\n   * @return {RawImageData} The generated image data.\n   */ static generate() {\n        const width = 66;\n        const height = 33;\n        const halfWidth = width / 2;\n        const croppedWidth = 64;\n        const croppedHeight = 16;\n        const data = new Uint8ClampedArray(width * height);\n        const croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);\n        for(let y = 0; y < height; ++y){\n            for(let x = 0; x < width; ++x){\n                const s = 0.03125 * x;\n                const t = 0.03125 * y;\n                if (edges.has(s) && edges.has(t)) {\n                    const e1 = edges.get(s);\n                    const e2 = edges.get(t);\n                    const i = y * width + x;\n                    data[i] = 127 * deltaLeft(e1, e2);\n                    data[i + halfWidth] = 127 * deltaRight(e1, e2);\n                }\n            }\n        }\n        for(let i = 0, y = height - croppedHeight; y < height; ++y){\n            for(let x = 0; x < croppedWidth; ++x, i += 4){\n                croppedData[i] = data[y * width + x];\n                croppedData[i + 3] = 255;\n            }\n        }\n        return new RawImageData(croppedWidth, croppedHeight, croppedData);\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3NpbmcvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVELGVBQWU7QUFDZixJQUFJQSxVQUFVO0FBRWQseUJBQXlCO0FBQ3pCLElBQUlDLGFBQWE7SUFDZjs7R0FFQyxHQUNEQyxVQUFVLENBQ1Y7QUFDRjtBQUVBLDZCQUE2QjtBQVdkO0FBRWYsb0JBQW9CO0FBQ3BCLElBQUljLDBCQUEwQixJQUFJO0FBQ2xDLElBQUlDLDBCQUEwQjtBQUM5QixJQUFJQyxRQUFRO0lBQ1Y7O0dBRUMsR0FDREMsYUFBYztRQUNaLElBQUksQ0FBQ0MsU0FBUyxHQUFHQyxZQUFZQyxHQUFHO1FBQ2hDLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsTUFBTTtRQUN6QixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLFVBQVUsR0FBRztJQUNwQjtJQUNBOzs7Ozs7OztHQVFDLEdBQ0QsSUFBSUMsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDRCxVQUFVO0lBQ3hCO0lBQ0EsSUFBSUMsVUFBVUMsS0FBSyxFQUFFO1FBQ25CLElBQUksT0FBT0MsYUFBYSxlQUFlQSxTQUFTQyxNQUFNLEtBQUssS0FBSyxHQUFHO1lBQ2pFLElBQUlGLE9BQU87Z0JBQ1RDLFNBQVNFLGdCQUFnQixDQUFDLG9CQUFvQixJQUFJO1lBQ3BELE9B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QUFDLEVBQUUsSUFBSTBDO1FBQ1gxQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTBDO1FBQ1gxQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTBDO1FBQ1gxQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTJDO1FBQ1gzQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTJDO1FBQ1gzQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTJDO1FBQ1gzQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTRDO1FBQ1g1QyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTRDO1FBQ1g1QyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTRDO1FBQ1g1QyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTZDO1FBQ1g3QyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTZDO1FBQ1g3QyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSTZDO1FBQ1h0ckQsTUFBTSxDQUFDLEVBQUUsR0FBR3lvRCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDakR6b0QsTUFBTSxDQUFDLEVBQUUsR0FBR3lvRCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDakR6b0QsTUFBTSxDQUFDLEVBQUUsR0FBR3lvRCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDbkQ7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LEdBQUcsQ0FBQzFMO29CQUNyQixNQUFNbW1ELEtBQUtvQyxNQUFNNzhDLEdBQUcsQ0FBQ2s1QztvQkFDckIsTUFBTXJsRCxJQUFJbkIsSUFBSTFLLFFBQVEySztvQkFDdEJ1a0IsSUFBSSxDQUFDcmpCLEVBQUUsR0FBRyxNQUFNcXBELFVBQVUxQyxJQUFJQztvQkFDOUJ2akMsSUFBSSxDQUFDcmpCLElBQUl5cEQsVUFBVSxHQUFHLE1BQU1GLFdBQVc1QyxJQUFJQztnQkFDN0M7WUFDRjtRQUNGO1FBQ0EsSUFBSyxJQUFJNW1ELElBQUksR0FBR25CLElBQUl6SyxTQUFTdTFELGVBQWU5cUQsSUFBSXpLLFFBQVEsRUFBRXlLLEVBQUc7WUFDM0QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUk0cUQsY0FBYyxFQUFFNXFELEdBQUdrQixLQUFLLEVBQUc7Z0JBQzdDNHBELFdBQVcsQ0FBQzVwRCxFQUFFLEdBQUdxakIsSUFBSSxDQUFDeGtCLElBQUkxSyxRQUFRMkssRUFBRTtnQkFDcEM4cUQsV0FBVyxDQUFDNXBELElBQUksRUFBRSxHQUFHO1lBQ3ZCO1FBQ0Y7UUFDQSxPQUFPLElBQUlreUIsYUFBYXczQixjQUFjQyxlQUFlQztJQUN2RDtBQUNGO0FBaUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VvLWF1ZGl0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9idWlsZC9pbmRleC5qcz85YjUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcG9zdHByb2Nlc3NpbmcgdjYuMzcuOCBidWlsZCBGcmkgU2VwIDEyIDIwMjVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcG9zdHByb2Nlc3NpbmdcbiAqIENvcHlyaWdodCAyMDE1LTIwMjUgUmFvdWwgdmFuIFLDvHNjaGVuXG4gKiBAbGljZW5zZSBabGliXG4gKi9cblxuLy8gcGFja2FnZS5qc29uXG52YXIgdmVyc2lvbiA9IFwiNi4zNy44XCI7XG5cbi8vIHNyYy9jb3JlL0Rpc3Bvc2FibGUuanNcbnZhciBEaXNwb3NhYmxlID0gY2xhc3Mge1xuICAvKipcbiAgICogRnJlZXMgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvRWZmZWN0Q29tcG9zZXIuanNcbmltcG9ydCB7XG4gIERlcHRoU3RlbmNpbEZvcm1hdCxcbiAgRGVwdGhUZXh0dXJlLFxuICBMaW5lYXJGaWx0ZXIgYXMgTGluZWFyRmlsdGVyMixcbiAgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2UyLFxuICBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUyLFxuICBVbnNpZ25lZEludFR5cGUsXG4gIFVuc2lnbmVkSW50MjQ4VHlwZSxcbiAgVmVjdG9yMixcbiAgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQzXG59IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvY29yZS9UaW1lci5qc1xudmFyIE1JTExJU0VDT05EU19UT19TRUNPTkRTID0gMSAvIDFlMztcbnZhciBTRUNPTkRTX1RPX01JTExJU0VDT05EUyA9IDFlMztcbnZhciBUaW1lciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdGltZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMucHJldmlvdXNUaW1lID0gMDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLl9kZWx0YSA9IDA7XG4gICAgdGhpcy5fZWxhcHNlZCA9IDA7XG4gICAgdGhpcy5fZml4ZWREZWx0YSA9IDFlMyAvIDYwO1xuICAgIHRoaXMudGltZXNjYWxlID0gMTtcbiAgICB0aGlzLnVzZUZpeGVkRGVsdGEgPSBmYWxzZTtcbiAgICB0aGlzLl9hdXRvUmVzZXQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhdXRvIHJlc2V0IGJhc2VkIG9uIHBhZ2UgdmlzaWJpbGl0eS5cbiAgICpcbiAgICogSWYgZW5hYmxlZCwgdGhlIHRpbWVyIHdpbGwgYmUgcmVzZXQgd2hlbiB0aGUgcGFnZSBiZWNvbWVzIHZpc2libGUuIFRoaXMgZWZmZWN0aXZlbHkgcGF1c2VzIHRoZSB0aW1lciB3aGVuIHRoZSBwYWdlXG4gICAqIGlzIGhpZGRlbi4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgQVBJIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QYWdlX1Zpc2liaWxpdHlfQVBJXG4gICAqL1xuICBnZXQgYXV0b1Jlc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvUmVzZXQ7XG4gIH1cbiAgc2V0IGF1dG9SZXNldCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuaGlkZGVuICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYXV0b1Jlc2V0ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBkZWx0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsdGEgKiBNSUxMSVNFQ09ORFNfVE9fU0VDT05EUztcbiAgfVxuICBnZXQgZml4ZWREZWx0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZml4ZWREZWx0YSAqIE1JTExJU0VDT05EU19UT19TRUNPTkRTO1xuICB9XG4gIHNldCBmaXhlZERlbHRhKHZhbHVlKSB7XG4gICAgdGhpcy5fZml4ZWREZWx0YSA9IHZhbHVlICogU0VDT05EU19UT19NSUxMSVNFQ09ORFM7XG4gIH1cbiAgZ2V0IGVsYXBzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsYXBzZWQgKiBNSUxMSVNFQ09ORFNfVE9fU0VDT05EUztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIHRpbWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0aW1lc3RhbXBdIC0gVGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUodGltZXN0YW1wKSB7XG4gICAgaWYgKHRoaXMudXNlRml4ZWREZWx0YSkge1xuICAgICAgdGhpcy5fZGVsdGEgPSB0aGlzLmZpeGVkRGVsdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJldmlvdXNUaW1lID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAodGltZXN0YW1wICE9PSB2b2lkIDAgPyB0aW1lc3RhbXAgOiBwZXJmb3JtYW5jZS5ub3coKSkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgIHRoaXMuX2RlbHRhID0gdGhpcy5jdXJyZW50VGltZSAtIHRoaXMucHJldmlvdXNUaW1lO1xuICAgIH1cbiAgICB0aGlzLl9kZWx0YSAqPSB0aGlzLnRpbWVzY2FsZTtcbiAgICB0aGlzLl9lbGFwc2VkICs9IHRoaXMuX2RlbHRhO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyB0aW1lci5cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX2RlbHRhID0gMDtcbiAgICB0aGlzLl9lbGFwc2VkID0gMDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgfVxuICBnZXREZWx0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWx0YTtcbiAgfVxuICBnZXRFbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLmVsYXBzZWQ7XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGlmICghZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmF1dG9SZXNldCA9IGZhbHNlO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL1Bhc3MuanNcbmltcG9ydCB7XG4gIEJhc2ljRGVwdGhQYWNraW5nLFxuICBCdWZmZXJBdHRyaWJ1dGUsXG4gIEJ1ZmZlckdlb21ldHJ5LFxuICBDYW1lcmEsXG4gIE1hdGVyaWFsLFxuICBNZXNoLFxuICBTY2VuZSxcbiAgVGV4dHVyZSxcbiAgV2ViR0xSZW5kZXJUYXJnZXRcbn0gZnJvbSBcInRocmVlXCI7XG52YXIgZnVsbHNjcmVlbkdlb21ldHJ5ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAwLCAzLCAtMSwgMCwgLTEsIDMsIDBdKTtcbiAgY29uc3QgdXZzID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMiwgMCwgMCwgMl0pO1xuICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG4gIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG4gIHJldHVybiBnZW9tZXRyeTtcbn0pKCk7XG52YXIgUGFzcyA9IGNsYXNzIF9QYXNzIHtcbiAgLyoqXG4gICAqIEEgc2hhcmVkIGZ1bGxzY3JlZW4gdHJpYW5nbGUuXG4gICAqXG4gICAqIFRoZSBzY3JlZW4gc2l6ZSBpcyAyeDIgdW5pdHMgKE5EQykuIEEgdHJpYW5nbGUgbmVlZHMgdG8gYmUgNHg0IHVuaXRzIHRvIGZpbGwgdGhlIHNjcmVlbi5cbiAgICogQHNlZSBodHRwczovL21pY2hhbGRyb2JvdC5jb20vMjAxNC8wNC8wMS9nY24tZXhlY3V0aW9uLXBhdHRlcm5zLWluLWZ1bGwtc2NyZWVuLXBhc3Nlcy9cbiAgICogQHR5cGUge0J1ZmZlckdlb21ldHJ5fVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBnZXQgZnVsbHNjcmVlbkdlb21ldHJ5KCkge1xuICAgIHJldHVybiBmdWxsc2NyZWVuR2VvbWV0cnk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy4gRG9lcyBub3QgaGF2ZSB0byBiZSB1bmlxdWUuXG4gICAqIEBwYXJhbSB7U2NlbmV9IFtzY2VuZV0gLSBUaGUgc2NlbmUgdG8gcmVuZGVyLiBUaGUgZGVmYXVsdCBzY2VuZSBjb250YWlucyBhIHNpbmdsZSBtZXNoIHRoYXQgZmlsbHMgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtIHtDYW1lcmF9IFtjYW1lcmFdIC0gQSBjYW1lcmEuIEZ1bGxzY3JlZW4gZWZmZWN0IHBhc3NlcyBkb24ndCByZXF1aXJlIGEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSA9IFwiUGFzc1wiLCBzY2VuZSA9IG5ldyBTY2VuZSgpLCBjYW1lcmEgPSBuZXcgQ2FtZXJhKCkpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy5ydHQgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyIHRvIHNjcmVlbiBmbGFnLlxuICAgKlxuICAgKiBJZiB0aGlzIGZsYWcgaXMgY2hhbmdlZCwgdGhlIGZ1bGxzY3JlZW4gbWF0ZXJpYWwgd2lsbCBiZSB1cGRhdGVkIGFzIHdlbGwuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHJlbmRlclRvU2NyZWVuKCkge1xuICAgIHJldHVybiAhdGhpcy5ydHQ7XG4gIH1cbiAgc2V0IHJlbmRlclRvU2NyZWVuKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucnR0ID09PSB2YWx1ZSkge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICAgIGlmIChtYXRlcmlhbCAhPT0gbnVsbCkge1xuICAgICAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJ0dCA9ICF2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1haW4gc2NlbmUuXG4gICAqXG4gICAqIEB0eXBlIHtTY2VuZX1cbiAgICovXG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFpbiBjYW1lcmEuXG4gICAqXG4gICAqIEB0eXBlIHtDYW1lcmF9XG4gICAqL1xuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXJlclxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcGFzcyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZW5hYmxlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoaXMgcGFzcyBpcyBlbmFibGVkLlxuICAgKi9cbiAgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZW5hYmxlZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgcGFzcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZ1bGxzY3JlZW4gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICovXG4gIGdldCBmdWxsc2NyZWVuTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuICE9PSBudWxsID8gdGhpcy5zY3JlZW4ubWF0ZXJpYWwgOiBudWxsO1xuICB9XG4gIHNldCBmdWxsc2NyZWVuTWF0ZXJpYWwodmFsdWUpIHtcbiAgICBsZXQgc2NyZWVuID0gdGhpcy5zY3JlZW47XG4gICAgaWYgKHNjcmVlbiAhPT0gbnVsbCkge1xuICAgICAgc2NyZWVuLm1hdGVyaWFsID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcmVlbiA9IG5ldyBNZXNoKF9QYXNzLmZ1bGxzY3JlZW5HZW9tZXRyeSwgdmFsdWUpO1xuICAgICAgc2NyZWVuLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnNjZW5lID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBuZXcgU2NlbmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NlbmUuYWRkKHNjcmVlbik7XG4gICAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZnVsbHNjcmVlbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtNYXRlcmlhbH0gVGhlIGN1cnJlbnQgZnVsbHNjcmVlbiBtYXRlcmlhbCwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lLlxuICAgKi9cbiAgZ2V0RnVsbHNjcmVlbk1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZnVsbHNjcmVlbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7TWF0ZXJpYWx9IHZhbHVlIC0gQSBmdWxsc2NyZWVuIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0RnVsbHNjcmVlbk1hdGVyaWFsKHZhbHVlKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAqL1xuICBnZXREZXB0aFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0uXG4gICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91ciBwYXNzIHJlbGllcyBvbiB0aGUgZGVwdGggaW5mb3JtYXRpb24gb2YgYSBwcmVjZWRpbmcge0BsaW5rIFJlbmRlclBhc3N9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVneX0gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nKSB7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBUaGlzIGlzIGFuIGFic3RyYWN0IG1ldGhvZCB0aGF0IG11c3QgYmUgb3ZlcnJpZGRlbi5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIG1ldGhvZCBpcyBub3Qgb3ZlcnJpZGRlbi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVuZGVyIG1ldGhvZCBub3QgaW1wbGVtZW50ZWQhXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplLlxuICAgKlxuICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSB3YW50IHRvIGJlIGluZm9ybWVkIGFib3V0IHRoZSBzaXplIG9mIHRoZSBiYWNrYnVmZmVyL2NhbnZhcy5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJlZm9yZSB7QGxpbmsgaW5pdGlhbGl6ZX0gYW5kIGV2ZXJ5IHRpbWUgdGhlIHNpemUgb2YgdGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0gY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhpcyBwYXNzIGlzIGFkZGVkIHRvIGFuIHtAbGluayBFZmZlY3RDb21wb3Nlcn0uXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgc2hhbGxvdyBzZWFyY2ggZm9yIGRpc3Bvc2FibGUgcHJvcGVydGllcyBhbmQgZGVsZXRlcyB0aGVtLlxuICAgKlxuICAgKiBUaGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjYWxscyB0aGlzIG1ldGhvZCB3aGVuIGl0IGlzIGJlaW5nIGRlc3Ryb3llZC4gWW91IGNhbiB1c2UgaXQgaW5kZXBlbmRlbnRseSB0byBmcmVlXG4gICAqIG1lbW9yeSB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgeW91IGRvbid0IG5lZWQgdGhpcyBwYXNzIGFueW1vcmUuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXNba2V5XTtcbiAgICAgIGNvbnN0IGlzRGlzcG9zYWJsZSA9IHByb3BlcnR5IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJUYXJnZXQgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBNYXRlcmlhbCB8fCBwcm9wZXJ0eSBpbnN0YW5jZW9mIFRleHR1cmUgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBfUGFzcztcbiAgICAgIGlmIChpc0Rpc3Bvc2FibGUpIHtcbiAgICAgICAgdGhpc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0NsZWFyTWFza1Bhc3MuanNcbnZhciBDbGVhck1hc2tQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY2xlYXIgbWFzayBwYXNzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJDbGVhck1hc2tQYXNzXCIsIG51bGwsIG51bGwpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBnbG9iYWwgc3RlbmNpbCB0ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBzdGVuY2lsID0gcmVuZGVyZXIuc3RhdGUuYnVmZmVycy5zdGVuY2lsO1xuICAgIHN0ZW5jaWwuc2V0TG9ja2VkKGZhbHNlKTtcbiAgICBzdGVuY2lsLnNldFRlc3QoZmFsc2UpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0NvcHlQYXNzLmpzXG5pbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIFNSR0JDb2xvclNwYWNlLCBVbnNpZ25lZEJ5dGVUeXBlLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9Db3B5TWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcsIFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb3B5LmZyYWdcbnZhciBjb3B5X2RlZmF1bHQgPSBgI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2ZWM0IHRleGVsPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpO2dsX0ZyYWdDb2xvcj1vcGFjaXR5KnRleGVsO1xuI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb21tb24udmVydFxudmFyIGNvbW1vbl9kZWZhdWx0ID0gYHZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9Db3B5TWF0ZXJpYWwuanNcbnZhciBDb3B5TWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY29weSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQ29weU1hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0obnVsbCksXG4gICAgICAgIG9wYWNpdHk6IG5ldyBVbmlmb3JtKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBjb3B5X2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wYWNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvcGFjaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG9wYWNpdHkuXG4gICAqL1xuICBnZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMub3BhY2l0eS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9wYWNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG9wYWNpdHkuXG4gICAqL1xuICBzZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQ29weVBhc3MuanNcbnZhciBDb3B5UGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNhdmUgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW3JlbmRlclRhcmdldF0gLSBBIHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2F1dG9SZXNpemU9dHJ1ZV0gLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNpemUgc2hvdWxkIGJlIHVwZGF0ZWQgYXV0b21hdGljYWxseS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlclRhcmdldCwgYXV0b1Jlc2l6ZSA9IHRydWUpIHtcbiAgICBzdXBlcihcIkNvcHlQYXNzXCIpO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgaWYgKHJlbmRlclRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIoMSwgMSwge1xuICAgICAgICBtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcbiAgICAgICAgbWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG4gICAgICAgIHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICBkZXB0aEJ1ZmZlcjogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJDb3B5UGFzcy5UYXJnZXRcIjtcbiAgICB9XG4gICAgdGhpcy5hdXRvUmVzaXplID0gYXV0b1Jlc2l6ZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhdXRvIHJlc2l6aW5nIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYXV0b1Jlc2l6ZSBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCByZXNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0b1Jlc2l6ZTtcbiAgfVxuICBzZXQgcmVzaXplKHZhbHVlKSB7XG4gICAgdGhpcy5hdXRvUmVzaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3V0cHV0IHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhdXRvIHJlc2l6aW5nIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYXV0b1Jlc2l6ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgcmVuZGVyIHRhcmdldCBzaXplIHNob3VsZCBiZSB1cGRhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAqL1xuICBzZXRBdXRvUmVzaXplRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IGlucHV0QnVmZmVyLnRleHR1cmU7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogdGhpcy5yZW5kZXJUYXJnZXQpO1xuICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSkge1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9DbGVhclBhc3MuanNcbmltcG9ydCB7IENvbG9yIH0gZnJvbSBcInRocmVlXCI7XG52YXIgY29sb3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IENvbG9yKCk7XG52YXIgQ2xlYXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY2xlYXIgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29sb3I9dHJ1ZV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbG9yIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVwdGg9dHJ1ZV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGRlcHRoIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbD1mYWxzZV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHN0ZW5jaWwgYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29sb3IyID0gdHJ1ZSwgZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gZmFsc2UpIHtcbiAgICBzdXBlcihcIkNsZWFyUGFzc1wiLCBudWxsLCBudWxsKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjI7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuc3RlbmNpbCA9IHN0ZW5jaWw7XG4gICAgdGhpcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBudWxsO1xuICAgIHRoaXMub3ZlcnJpZGVDbGVhckFscGhhID0gLTE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNsZWFyIGZsYWdzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9yIC0gV2hldGhlciB0aGUgY29sb3IgYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlcHRoIC0gV2hldGhlciB0aGUgZGVwdGggYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0ZW5jaWwgLSBXaGV0aGVyIHRoZSBzdGVuY2lsIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICovXG4gIHNldENsZWFyRmxhZ3MoY29sb3IyLCBkZXB0aCwgc3RlbmNpbCkge1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjI7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuc3RlbmNpbCA9IHN0ZW5jaWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG92ZXJyaWRlIGNsZWFyIGNvbG9yLiBEZWZhdWx0IGlzIG51bGwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZUNsZWFyQ29sb3IgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Q29sb3J9IFRoZSBjbGVhciBjb2xvci5cbiAgICovXG4gIGdldE92ZXJyaWRlQ2xlYXJDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVycmlkZUNsZWFyQ29sb3I7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG92ZXJyaWRlIGNsZWFyIGNvbG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVDbGVhckNvbG9yIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q29sb3J9IHZhbHVlIC0gVGhlIGNsZWFyIGNvbG9yLlxuICAgKi9cbiAgc2V0T3ZlcnJpZGVDbGVhckNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5vdmVycmlkZUNsZWFyQ29sb3IgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3ZlcnJpZGUgY2xlYXIgYWxwaGEuIERlZmF1bHQgaXMgLTEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZUNsZWFyQWxwaGEgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2xlYXIgYWxwaGEuXG4gICAqL1xuICBnZXRPdmVycmlkZUNsZWFyQWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcnJpZGVDbGVhckFscGhhO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvdmVycmlkZSBjbGVhciBhbHBoYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlQ2xlYXJBbHBoYSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgY2xlYXIgYWxwaGEuXG4gICAqL1xuICBzZXRPdmVycmlkZUNsZWFyQWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLm92ZXJyaWRlQ2xlYXJBbHBoYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGlucHV0IGJ1ZmZlciBvciB0aGUgc2NyZWVuLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBvdmVycmlkZUNsZWFyQ29sb3IgPSB0aGlzLm92ZXJyaWRlQ2xlYXJDb2xvcjtcbiAgICBjb25zdCBvdmVycmlkZUNsZWFyQWxwaGEgPSB0aGlzLm92ZXJyaWRlQ2xlYXJBbHBoYTtcbiAgICBjb25zdCBjbGVhckFscGhhID0gcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xuICAgIGNvbnN0IGhhc092ZXJyaWRlQ2xlYXJDb2xvciA9IG92ZXJyaWRlQ2xlYXJDb2xvciAhPT0gbnVsbDtcbiAgICBjb25zdCBoYXNPdmVycmlkZUNsZWFyQWxwaGEgPSBvdmVycmlkZUNsZWFyQWxwaGEgPj0gMDtcbiAgICBpZiAoaGFzT3ZlcnJpZGVDbGVhckNvbG9yKSB7XG4gICAgICByZW5kZXJlci5nZXRDbGVhckNvbG9yKGNvbG9yKTtcbiAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3Iob3ZlcnJpZGVDbGVhckNvbG9yLCBoYXNPdmVycmlkZUNsZWFyQWxwaGEgPyBvdmVycmlkZUNsZWFyQWxwaGEgOiBjbGVhckFscGhhKTtcbiAgICB9IGVsc2UgaWYgKGhhc092ZXJyaWRlQ2xlYXJBbHBoYSkge1xuICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJBbHBoYShvdmVycmlkZUNsZWFyQWxwaGEpO1xuICAgIH1cbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBpbnB1dEJ1ZmZlcik7XG4gICAgcmVuZGVyZXIuY2xlYXIodGhpcy5jb2xvciwgdGhpcy5kZXB0aCwgdGhpcy5zdGVuY2lsKTtcbiAgICBpZiAoaGFzT3ZlcnJpZGVDbGVhckNvbG9yKSB7XG4gICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKGNvbG9yLCBjbGVhckFscGhhKTtcbiAgICB9IGVsc2UgaWYgKGhhc092ZXJyaWRlQ2xlYXJBbHBoYSkge1xuICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJBbHBoYShjbGVhckFscGhhKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTWFza1Bhc3MuanNcbnZhciBNYXNrUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG1hc2sgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY2VuZSwgY2FtZXJhKSB7XG4gICAgc3VwZXIoXCJNYXNrUGFzc1wiLCBzY2VuZSwgY2FtZXJhKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyhmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuaW52ZXJzZSA9IGZhbHNlO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLnNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWFzayBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmludmVyc2U7XG4gIH1cbiAgc2V0IGludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnNlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcGFzcyBzaG91bGQgY2xlYXIgdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqL1xuICBnZXQgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzLmVuYWJsZWQ7XG4gIH1cbiAgc2V0IGNsZWFyKHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhclBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBjbGVhciBwYXNzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY2xlYXJQYXNzLmVuYWJsZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Q2xlYXJQYXNzfSBUaGUgY2xlYXIgcGFzcy5cbiAgICovXG4gIGdldENsZWFyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGVhclBhc3M7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtYXNrIGlzIGludmVydGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbWFzayBpcyBpbnZlcnRlZC5cbiAgICovXG4gIGlzSW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZSBtYXNrIGludmVyc2lvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBtYXNrIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICovXG4gIHNldEludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnRlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG4gICAgY29uc3QgYnVmZmVycyA9IHJlbmRlcmVyLnN0YXRlLmJ1ZmZlcnM7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IGNsZWFyUGFzcyA9IHRoaXMuY2xlYXJQYXNzO1xuICAgIGNvbnN0IHdyaXRlVmFsdWUgPSB0aGlzLmludmVydGVkID8gMCA6IDE7XG4gICAgY29uc3QgY2xlYXJWYWx1ZSA9IDEgLSB3cml0ZVZhbHVlO1xuICAgIGJ1ZmZlcnMuY29sb3Iuc2V0TWFzayhmYWxzZSk7XG4gICAgYnVmZmVycy5kZXB0aC5zZXRNYXNrKGZhbHNlKTtcbiAgICBidWZmZXJzLmNvbG9yLnNldExvY2tlZCh0cnVlKTtcbiAgICBidWZmZXJzLmRlcHRoLnNldExvY2tlZCh0cnVlKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0VGVzdCh0cnVlKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0T3AoY29udGV4dC5SRVBMQUNFLCBjb250ZXh0LlJFUExBQ0UsIGNvbnRleHQuUkVQTEFDRSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldEZ1bmMoY29udGV4dC5BTFdBWVMsIHdyaXRlVmFsdWUsIDQyOTQ5NjcyOTUpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRDbGVhcihjbGVhclZhbHVlKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0TG9ja2VkKHRydWUpO1xuICAgIGlmICh0aGlzLmNsZWFyUGFzcy5lbmFibGVkKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJUb1NjcmVlbikge1xuICAgICAgICBjbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyKTtcbiAgICAgICAgY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgb3V0cHV0QnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGlucHV0QnVmZmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChvdXRwdXRCdWZmZXIpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIH1cbiAgICBidWZmZXJzLmNvbG9yLnNldExvY2tlZChmYWxzZSk7XG4gICAgYnVmZmVycy5kZXB0aC5zZXRMb2NrZWQoZmFsc2UpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRMb2NrZWQoZmFsc2UpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRGdW5jKGNvbnRleHQuRVFVQUwsIDEsIDQyOTQ5NjcyOTUpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRPcChjb250ZXh0LktFRVAsIGNvbnRleHQuS0VFUCwgY29udGV4dC5LRUVQKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0TG9ja2VkKHRydWUpO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9FZmZlY3RDb21wb3Nlci5qc1xudmFyIEVmZmVjdENvbXBvc2VyID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QgY29tcG9zZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhhdCBzaG91bGQgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlcHRoQnVmZmVyPXRydWVdIC0gV2hldGhlciB0aGUgbWFpbiByZW5kZXIgdGFyZ2V0cyBzaG91bGQgaGF2ZSBhIGRlcHRoIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdGVuY2lsQnVmZmVyPWZhbHNlXSAtIFdoZXRoZXIgdGhlIG1haW4gcmVuZGVyIHRhcmdldHMgc2hvdWxkIGhhdmUgYSBzdGVuY2lsIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbHBoYV0gLSBEZXByZWNhdGVkLiBCdWZmZXJzIGFyZSBhbHdheXMgUkdCQSBzaW5jZSB0aHJlZSByMTM3LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlzYW1wbGluZz0wXSAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyB1c2VkIGZvciBtdWx0aXNhbXBsZSBhbnRpYWxpYXNpbmcuIFJlcXVpcmVzIFdlYkdMIDIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mcmFtZUJ1ZmZlclR5cGVdIC0gVGhlIHR5cGUgb2YgdGhlIGludGVybmFsIGZyYW1lIGJ1ZmZlcnMuIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIEhhbGZGbG9hdFR5cGUgaWYgcG9zc2libGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlciA9IG51bGwsIHtcbiAgICBkZXB0aEJ1ZmZlciA9IHRydWUsXG4gICAgc3RlbmNpbEJ1ZmZlciA9IGZhbHNlLFxuICAgIG11bHRpc2FtcGxpbmcgPSAwLFxuICAgIGZyYW1lQnVmZmVyVHlwZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmlucHV0QnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoZGVwdGhCdWZmZXIsIHN0ZW5jaWxCdWZmZXIsIGZyYW1lQnVmZmVyVHlwZSwgbXVsdGlzYW1wbGluZyk7XG4gICAgdGhpcy5vdXRwdXRCdWZmZXIgPSB0aGlzLmlucHV0QnVmZmVyLmNsb25lKCk7XG4gICAgdGhpcy5jb3B5UGFzcyA9IG5ldyBDb3B5UGFzcygpO1xuICAgIHRoaXMuZGVwdGhUZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLnBhc3NlcyA9IFtdO1xuICAgIHRoaXMudGltZXIgPSBuZXcgVGltZXIoKTtcbiAgICB0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbiA9IHRydWU7XG4gICAgdGhpcy5zZXRSZW5kZXJlcihyZW5kZXJlcik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGFtb3VudCBvZiBzYW1wbGVzIHVzZWQgZm9yIG11bHRpc2FtcGxlIGFudGktYWxpYXNpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbXVsdGlzYW1wbGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEJ1ZmZlci5zYW1wbGVzIHx8IDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFtb3VudCBvZiBNU0FBIHNhbXBsZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIFdlYkdMIDIuIFNldCB0byB6ZXJvIHRvIGRpc2FibGUgbXVsdGlzYW1wbGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBtdWx0aXNhbXBsaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5pbnB1dEJ1ZmZlcjtcbiAgICBjb25zdCBtdWx0aXNhbXBsaW5nID0gdGhpcy5tdWx0aXNhbXBsaW5nO1xuICAgIGlmIChtdWx0aXNhbXBsaW5nID4gMCAmJiB2YWx1ZSA+IDApIHtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuc2FtcGxlcyA9IHZhbHVlO1xuICAgICAgdGhpcy5vdXRwdXRCdWZmZXIuc2FtcGxlcyA9IHZhbHVlO1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLm91dHB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgfSBlbHNlIGlmIChtdWx0aXNhbXBsaW5nICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLm91dHB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoXG4gICAgICAgIGJ1ZmZlci5kZXB0aEJ1ZmZlcixcbiAgICAgICAgYnVmZmVyLnN0ZW5jaWxCdWZmZXIsXG4gICAgICAgIGJ1ZmZlci50ZXh0dXJlLnR5cGUsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kZXB0aFRleHR1cmUgPSB0aGlzLmRlcHRoVGV4dHVyZTtcbiAgICAgIHRoaXMub3V0cHV0QnVmZmVyID0gdGhpcy5pbnB1dEJ1ZmZlci5jbG9uZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgdGltZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVyfSBUaGUgdGltZXIuXG4gICAqL1xuICBnZXRUaW1lcigpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlci5cbiAgICovXG4gIGdldFJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICovXG4gIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IHJlbmRlcmVyLmdldFNpemUobmV3IFZlY3RvcjIoKSk7XG4gICAgICBjb25zdCBhbHBoYSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFscGhhO1xuICAgICAgY29uc3QgZnJhbWVCdWZmZXJUeXBlID0gdGhpcy5pbnB1dEJ1ZmZlci50ZXh0dXJlLnR5cGU7XG4gICAgICBpZiAoZnJhbWVCdWZmZXJUeXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlMiAmJiByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZTIpIHtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlci50ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTI7XG4gICAgICAgIHRoaXMub3V0cHV0QnVmZmVyLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMjtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub3V0cHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuICAgICAgdGhpcy5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgICBwYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuICAgKlxuICAgKiBUaGUgYXV0byBjbGVhciBtZWNoYW5pc20gb2YgdGhlIHByb3ZpZGVkIHJlbmRlcmVyIHdpbGwgYmUgZGlzYWJsZWQuIElmIHRoZSBuZXcgcmVuZGVyIHNpemUgZGlmZmVycyBmcm9tIHRoZVxuICAgKiBwcmV2aW91cyBvbmUsIGFsbCBwYXNzZXMgd2lsbCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIGN1cnJlbnQgcmVuZGVyZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IG5vZGUgYW5kIHRoZSBET01cbiAgICogZWxlbWVudCBvZiB0aGUgbmV3IHJlbmRlcmVyIHdpbGwgdGFrZSBpdHMgcGxhY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRSZW5kZXJlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIG5ldyByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSB1cGRhdGVET00gLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgb2xkIGNhbnZhcyBzaG91bGQgYmUgcmVwbGFjZWQgYnkgdGhlIG5ldyBvbmUgaW4gdGhlIERPTS5cbiAgICogQHJldHVybiB7V2ViR0xSZW5kZXJlcn0gVGhlIG9sZCByZW5kZXJlci5cbiAgICovXG4gIHJlcGxhY2VSZW5kZXJlcihyZW5kZXJlciwgdXBkYXRlRE9NID0gdHJ1ZSkge1xuICAgIGNvbnN0IG9sZFJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBwYXJlbnQgPSBvbGRSZW5kZXJlci5kb21FbGVtZW50LnBhcmVudE5vZGU7XG4gICAgdGhpcy5zZXRSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgaWYgKHVwZGF0ZURPTSAmJiBwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChvbGRSZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG9sZFJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVwdGggdGV4dHVyZSBhdHRhY2htZW50IHRoYXQgd2lsbCBiZSBwcm92aWRlZCB0byBhbGwgcGFzc2VzLlxuICAgKlxuICAgKiBOb3RlOiBXaGVuIGEgc2hhZGVyIHJlYWRzIGZyb20gYSBkZXB0aCB0ZXh0dXJlIGFuZCB3cml0ZXMgdG8gYSByZW5kZXIgdGFyZ2V0IHRoYXQgdXNlcyB0aGUgc2FtZSBkZXB0aCB0ZXh0dXJlXG4gICAqIGF0dGFjaG1lbnQsIHRoZSBkZXB0aCBpbmZvcm1hdGlvbiB3aWxsIGJlIGxvc3QuIFRoaXMgaGFwcGVucyBldmVuIGlmIGBkZXB0aFdyaXRlYCBpcyBkaXNhYmxlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7RGVwdGhUZXh0dXJlfSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICovXG4gIGNyZWF0ZURlcHRoVGV4dHVyZSgpIHtcbiAgICBjb25zdCBkZXB0aFRleHR1cmUgPSB0aGlzLmRlcHRoVGV4dHVyZSA9IG5ldyBEZXB0aFRleHR1cmUoKTtcbiAgICB0aGlzLmlucHV0QnVmZmVyLmRlcHRoVGV4dHVyZSA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmlucHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICBpZiAodGhpcy5pbnB1dEJ1ZmZlci5zdGVuY2lsQnVmZmVyKSB7XG4gICAgICBkZXB0aFRleHR1cmUuZm9ybWF0ID0gRGVwdGhTdGVuY2lsRm9ybWF0O1xuICAgICAgZGVwdGhUZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcHRoVGV4dHVyZS50eXBlID0gVW5zaWduZWRJbnRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGhUZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBjdXJyZW50IGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWxldGVEZXB0aFRleHR1cmUoKSB7XG4gICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgICBwYXNzLnNldERlcHRoVGV4dHVyZShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcmVuZGVyIHRhcmdldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgQ3JlYXRlIGJ1ZmZlcnMgbWFudWFsbHkgdmlhIFdlYkdMUmVuZGVyVGFyZ2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVwdGhCdWZmZXIgLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNob3VsZCBoYXZlIGEgZGVwdGggYnVmZmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0ZW5jaWxCdWZmZXIgLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNob3VsZCBoYXZlIGEgc3RlbmNpbCBidWZmZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIC0gVGhlIGZyYW1lIGJ1ZmZlciB0eXBlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbXVsdGlzYW1wbGluZyAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyB0byB1c2UgZm9yIGFudGlhbGlhc2luZy5cbiAgICogQHJldHVybiB7V2ViR0xSZW5kZXJUYXJnZXR9IEEgbmV3IHJlbmRlciB0YXJnZXQgdGhhdCBlcXVhbHMgdGhlIHJlbmRlcmVyJ3MgY2FudmFzLlxuICAgKi9cbiAgY3JlYXRlQnVmZmVyKGRlcHRoQnVmZmVyLCBzdGVuY2lsQnVmZmVyLCB0eXBlLCBtdWx0aXNhbXBsaW5nKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IHNpemUgPSByZW5kZXJlciA9PT0gbnVsbCA/IG5ldyBWZWN0b3IyKCkgOiByZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZShuZXcgVmVjdG9yMigpKTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIyLFxuICAgICAgbWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIyLFxuICAgICAgc3RlbmNpbEJ1ZmZlcixcbiAgICAgIGRlcHRoQnVmZmVyLFxuICAgICAgdHlwZVxuICAgIH07XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MyhzaXplLndpZHRoLCBzaXplLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgaWYgKG11bHRpc2FtcGxpbmcgPiAwKSB7XG4gICAgICByZW5kZXJUYXJnZXQuaWdub3JlRGVwdGhGb3JNdWx0aXNhbXBsZUNvcHkgPSBmYWxzZTtcbiAgICAgIHJlbmRlclRhcmdldC5zYW1wbGVzID0gbXVsdGlzYW1wbGluZztcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUyICYmIHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlMikge1xuICAgICAgcmVuZGVyVGFyZ2V0LnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMjtcbiAgICB9XG4gICAgcmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiRWZmZWN0Q29tcG9zZXIuQnVmZmVyXCI7XG4gICAgcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlbmRlclRhcmdldDtcbiAgfVxuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBtYWluIHNjZW5lIGZvciBhbGwgcmVnaXN0ZXJlZCBwYXNzZXMgYW5kIGVmZmVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIHNjZW5lLlxuICAgKi9cbiAgc2V0TWFpblNjZW5lKHNjZW5lKSB7XG4gICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICBwYXNzLm1haW5TY2VuZSA9IHNjZW5lO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBtYWluIGNhbWVyYSBmb3IgYWxsIHJlZ2lzdGVyZWQgcGFzc2VzIGFuZCBlZmZlY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYS5cbiAgICovXG4gIHNldE1haW5DYW1lcmEoY2FtZXJhKSB7XG4gICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICBwYXNzLm1haW5DYW1lcmEgPSBjYW1lcmE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcGFzcywgb3B0aW9uYWxseSBhdCBhIHNwZWNpZmljIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3N9IHBhc3MgLSBBIG5ldyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSAtIEFuIGluZGV4IGF0IHdoaWNoIHRoZSBwYXNzIHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICovXG4gIGFkZFBhc3MocGFzcywgaW5kZXgpIHtcbiAgICBjb25zdCBwYXNzZXMgPSB0aGlzLnBhc3NlcztcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgZHJhd2luZ0J1ZmZlclNpemUgPSByZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZShuZXcgVmVjdG9yMigpKTtcbiAgICBjb25zdCBhbHBoYSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFscGhhO1xuICAgIGNvbnN0IGZyYW1lQnVmZmVyVHlwZSA9IHRoaXMuaW5wdXRCdWZmZXIudGV4dHVyZS50eXBlO1xuICAgIHBhc3Muc2V0UmVuZGVyZXIocmVuZGVyZXIpO1xuICAgIHBhc3Muc2V0U2l6ZShkcmF3aW5nQnVmZmVyU2l6ZS53aWR0aCwgZHJhd2luZ0J1ZmZlclNpemUuaGVpZ2h0KTtcbiAgICBwYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIGlmICh0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbikge1xuICAgICAgaWYgKHBhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhc3Nlc1twYXNzZXMubGVuZ3RoIC0gMV0ucmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXNzLnJlbmRlclRvU2NyZWVuKSB7XG4gICAgICAgIHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXNzZXMuc3BsaWNlKGluZGV4LCAwLCBwYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFzc2VzLnB1c2gocGFzcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbikge1xuICAgICAgcGFzc2VzW3Bhc3Nlcy5sZW5ndGggLSAxXS5yZW5kZXJUb1NjcmVlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwYXNzLm5lZWRzRGVwdGhUZXh0dXJlIHx8IHRoaXMuZGVwdGhUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5kZXB0aFRleHR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZGVwdGhUZXh0dXJlID0gdGhpcy5jcmVhdGVEZXB0aFRleHR1cmUoKTtcbiAgICAgICAgZm9yIChwYXNzIG9mIHBhc3Nlcykge1xuICAgICAgICAgIHBhc3Muc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhc3Muc2V0RGVwdGhUZXh0dXJlKHRoaXMuZGVwdGhUZXh0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3N9IHBhc3MgLSBUaGUgcGFzcy5cbiAgICovXG4gIHJlbW92ZVBhc3MocGFzcykge1xuICAgIGNvbnN0IHBhc3NlcyA9IHRoaXMucGFzc2VzO1xuICAgIGNvbnN0IGluZGV4ID0gcGFzc2VzLmluZGV4T2YocGFzcyk7XG4gICAgY29uc3QgZXhpc3RzID0gaW5kZXggIT09IC0xO1xuICAgIGNvbnN0IHJlbW92ZWQgPSBleGlzdHMgJiYgcGFzc2VzLnNwbGljZShpbmRleCwgMSkubGVuZ3RoID4gMDtcbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJlZHVjZXIgPSAoYSwgYikgPT4gYSB8fCBiLm5lZWRzRGVwdGhUZXh0dXJlO1xuICAgICAgICBjb25zdCBkZXB0aFRleHR1cmVSZXF1aXJlZCA9IHBhc3Nlcy5yZWR1Y2UocmVkdWNlciwgZmFsc2UpO1xuICAgICAgICBpZiAoIWRlcHRoVGV4dHVyZVJlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHBhc3MuZ2V0RGVwdGhUZXh0dXJlKCkgPT09IHRoaXMuZGVwdGhUZXh0dXJlKSB7XG4gICAgICAgICAgICBwYXNzLnNldERlcHRoVGV4dHVyZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZWxldGVEZXB0aFRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gcGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIHBhc3MucmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICBpZiAocGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhc3Nlc1twYXNzZXMubGVuZ3RoIC0gMV0ucmVuZGVyVG9TY3JlZW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgcGFzc2VzLlxuICAgKi9cbiAgcmVtb3ZlQWxsUGFzc2VzKCkge1xuICAgIGNvbnN0IHBhc3NlcyA9IHRoaXMucGFzc2VzO1xuICAgIHRoaXMuZGVsZXRlRGVwdGhUZXh0dXJlKCk7XG4gICAgaWYgKHBhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgICAgcGFzc2VzW3Bhc3Nlcy5sZW5ndGggLSAxXS5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXNzZXMgPSBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgYWxsIGVuYWJsZWQgcGFzc2VzIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGZyYW1lIGluIHNlY29uZHMuXG4gICAqL1xuICByZW5kZXIoZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGNvcHlQYXNzID0gdGhpcy5jb3B5UGFzcztcbiAgICBsZXQgaW5wdXRCdWZmZXIgPSB0aGlzLmlucHV0QnVmZmVyO1xuICAgIGxldCBvdXRwdXRCdWZmZXIgPSB0aGlzLm91dHB1dEJ1ZmZlcjtcbiAgICBsZXQgc3RlbmNpbFRlc3QgPSBmYWxzZTtcbiAgICBsZXQgY29udGV4dCwgc3RlbmNpbCwgYnVmZmVyO1xuICAgIGlmIChkZWx0YVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50aW1lci51cGRhdGUoKTtcbiAgICAgIGRlbHRhVGltZSA9IHRoaXMudGltZXIuZ2V0RGVsdGEoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICBpZiAocGFzcy5lbmFibGVkKSB7XG4gICAgICAgIHBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KTtcbiAgICAgICAgaWYgKHBhc3MubmVlZHNTd2FwKSB7XG4gICAgICAgICAgaWYgKHN0ZW5jaWxUZXN0KSB7XG4gICAgICAgICAgICBjb3B5UGFzcy5yZW5kZXJUb1NjcmVlbiA9IHBhc3MucmVuZGVyVG9TY3JlZW47XG4gICAgICAgICAgICBjb250ZXh0ID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgc3RlbmNpbCA9IHJlbmRlcmVyLnN0YXRlLmJ1ZmZlcnMuc3RlbmNpbDtcbiAgICAgICAgICAgIHN0ZW5jaWwuc2V0RnVuYyhjb250ZXh0Lk5PVEVRVUFMLCAxLCA0Mjk0OTY3Mjk1KTtcbiAgICAgICAgICAgIGNvcHlQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCk7XG4gICAgICAgICAgICBzdGVuY2lsLnNldEZ1bmMoY29udGV4dC5FUVVBTCwgMSwgNDI5NDk2NzI5NSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlciA9IGlucHV0QnVmZmVyO1xuICAgICAgICAgIGlucHV0QnVmZmVyID0gb3V0cHV0QnVmZmVyO1xuICAgICAgICAgIG91dHB1dEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFzcyBpbnN0YW5jZW9mIE1hc2tQYXNzKSB7XG4gICAgICAgICAgc3RlbmNpbFRlc3QgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHBhc3MgaW5zdGFuY2VvZiBDbGVhck1hc2tQYXNzKSB7XG4gICAgICAgICAgc3RlbmNpbFRlc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVycywgcGFzc2VzIGFuZCB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VwZGF0ZVN0eWxlXSAtIERldGVybWluZXMgd2hldGhlciB0aGUgc3R5bGUgb2YgdGhlIGNhbnZhcyBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY3VycmVudFNpemUgPSByZW5kZXJlci5nZXRTaXplKG5ldyBWZWN0b3IyKCkpO1xuICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwIHx8IGhlaWdodCA9PT0gdm9pZCAwKSB7XG4gICAgICB3aWR0aCA9IGN1cnJlbnRTaXplLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gY3VycmVudFNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoY3VycmVudFNpemUud2lkdGggIT09IHdpZHRoIHx8IGN1cnJlbnRTaXplLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd2luZ0J1ZmZlclNpemUgPSByZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZShuZXcgVmVjdG9yMigpKTtcbiAgICB0aGlzLmlucHV0QnVmZmVyLnNldFNpemUoZHJhd2luZ0J1ZmZlclNpemUud2lkdGgsIGRyYXdpbmdCdWZmZXJTaXplLmhlaWdodCk7XG4gICAgdGhpcy5vdXRwdXRCdWZmZXIuc2V0U2l6ZShkcmF3aW5nQnVmZmVyU2l6ZS53aWR0aCwgZHJhd2luZ0J1ZmZlclNpemUuaGVpZ2h0KTtcbiAgICBmb3IgKGNvbnN0IHBhc3Mgb2YgdGhpcy5wYXNzZXMpIHtcbiAgICAgIHBhc3Muc2V0U2l6ZShkcmF3aW5nQnVmZmVyU2l6ZS53aWR0aCwgZHJhd2luZ0J1ZmZlclNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGlzIGNvbXBvc2VyIGJ5IGRlbGV0aW5nIGFsbCBwYXNzZXMgYW5kIGNyZWF0aW5nIG5ldyBidWZmZXJzLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5hdXRvUmVuZGVyVG9TY3JlZW4gPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIGNvbXBvc2VyIGFuZCBhbGwgcGFzc2VzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IHBhc3Mgb2YgdGhpcy5wYXNzZXMpIHtcbiAgICAgIHBhc3MuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLnBhc3NlcyA9IFtdO1xuICAgIGlmICh0aGlzLmlucHV0QnVmZmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3V0cHV0QnVmZmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm91dHB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuZGVsZXRlRGVwdGhUZXh0dXJlKCk7XG4gICAgdGhpcy5jb3B5UGFzcy5kaXNwb3NlKCk7XG4gICAgdGhpcy50aW1lci5kaXNwb3NlKCk7XG4gICAgUGFzcy5mdWxsc2NyZWVuR2VvbWV0cnkuZGlzcG9zZSgpO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9FZmZlY3RTaGFkZXJEYXRhLmpzXG5pbXBvcnQgeyBMaW5lYXJTUkdCQ29sb3JTcGFjZSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZW51bXMvRWZmZWN0QXR0cmlidXRlLmpzXG52YXIgRWZmZWN0QXR0cmlidXRlID0ge1xuICBOT05FOiAwLFxuICBERVBUSDogMSxcbiAgQ09OVk9MVVRJT046IDJcbn07XG5cbi8vIHNyYy9lbnVtcy9FZmZlY3RTaGFkZXJTZWN0aW9uLmpzXG52YXIgRWZmZWN0U2hhZGVyU2VjdGlvbiA9IHtcbiAgRlJBR01FTlRfSEVBRDogXCJGUkFHTUVOVF9IRUFEXCIsXG4gIEZSQUdNRU5UX01BSU5fVVY6IFwiRlJBR01FTlRfTUFJTl9VVlwiLFxuICBGUkFHTUVOVF9NQUlOX0lNQUdFOiBcIkZSQUdNRU5UX01BSU5fSU1BR0VcIixcbiAgVkVSVEVYX0hFQUQ6IFwiVkVSVEVYX0hFQURcIixcbiAgVkVSVEVYX01BSU5fU1VQUE9SVDogXCJWRVJURVhfTUFJTl9TVVBQT1JUXCJcbn07XG5cbi8vIHNyYy9jb3JlL0VmZmVjdFNoYWRlckRhdGEuanNcbnZhciBFZmZlY3RTaGFkZXJEYXRhID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBuZXcgc2hhZGVyIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNoYWRlclBhcnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgW0VmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCwgbnVsbF0sXG4gICAgICBbRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX1VWLCBudWxsXSxcbiAgICAgIFtFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fSU1BR0UsIG51bGxdLFxuICAgICAgW0VmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX0hFQUQsIG51bGxdLFxuICAgICAgW0VmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCwgbnVsbF1cbiAgICBdKTtcbiAgICB0aGlzLmRlZmluZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5pZm9ybXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuYmxlbmRNb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5leHRlbnNpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBFZmZlY3RBdHRyaWJ1dGUuTk9ORTtcbiAgICB0aGlzLnZhcnlpbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLnV2VHJhbnNmb3JtYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLnJlYWREZXB0aCA9IGZhbHNlO1xuICAgIHRoaXMuY29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9HYXVzc0tlcm5lbC5qc1xuZnVuY3Rpb24gZ2V0Q29lZmZpY2llbnRzKG4pIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKG4gPT09IDApIHtcbiAgICByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KDApO1xuICB9IGVsc2UgaWYgKG4gPT09IDEpIHtcbiAgICByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KFsxXSk7XG4gIH0gZWxzZSBpZiAobiA+IDEpIHtcbiAgICBsZXQgcm93MCA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgbGV0IHJvdzEgPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgIGZvciAobGV0IHkgPSAxOyB5IDw9IG47ICsreSkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB5OyArK3gpIHtcbiAgICAgICAgcm93MVt4XSA9IHggPT09IDAgfHwgeCA9PT0geSAtIDEgPyAxIDogcm93MFt4IC0gMV0gKyByb3cwW3hdO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcm93MTtcbiAgICAgIHJvdzEgPSByb3cwO1xuICAgICAgcm93MCA9IHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBHYXVzc0tlcm5lbCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgR2F1c3Mga2VybmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0ga2VybmVsU2l6ZSAtIFRoZSBrZXJuZWwgc2l6ZS4gU2hvdWxkIGJlIGFuIG9kZCBudW1iZXIgaW4gdGhlIHJhbmdlIFszLCAxMDIwXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlZGdlQmlhcz0yXSAtIERldGVybWluZXMgaG93IG1hbnkgZWRnZSBjb2VmZmljaWVudHMgc2hvdWxkIGJlIGN1dCBvZmYgZm9yIGluY3JlYXNlZCBhY2N1cmFjeS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGtlcm5lbFNpemUsIGVkZ2VCaWFzID0gMikge1xuICAgIHRoaXMud2VpZ2h0cyA9IG51bGw7XG4gICAgdGhpcy5vZmZzZXRzID0gbnVsbDtcbiAgICB0aGlzLmxpbmVhcldlaWdodHMgPSBudWxsO1xuICAgIHRoaXMubGluZWFyT2Zmc2V0cyA9IG51bGw7XG4gICAgdGhpcy5nZW5lcmF0ZShrZXJuZWxTaXplLCBlZGdlQmlhcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc3RlcHMgZm9yIGRpc2NyZXRlIHNhbXBsaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN0ZXBzKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldHMgPT09IG51bGwgPyAwIDogdGhpcy5vZmZzZXRzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzdGVwcyBmb3IgbGluZWFyIHNhbXBsaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxpbmVhclN0ZXBzKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVhck9mZnNldHMgPT09IG51bGwgPyAwIDogdGhpcy5saW5lYXJPZmZzZXRzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBrZXJuZWwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBrZXJuZWxTaXplIC0gVGhlIGtlcm5lbCBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZWRnZUJpYXMgLSBUaGUgYW1vdW50IG9mIGVkZ2UgY29lZmZpY2llbnRzIHRvIGlnbm9yZS5cbiAgICovXG4gIGdlbmVyYXRlKGtlcm5lbFNpemUsIGVkZ2VCaWFzKSB7XG4gICAgaWYgKGtlcm5lbFNpemUgPCAzIHx8IGtlcm5lbFNpemUgPiAxMDIwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUga2VybmVsIHNpemUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzMsIDEwMjBdXCIpO1xuICAgIH1cbiAgICBjb25zdCBuID0ga2VybmVsU2l6ZSArIGVkZ2VCaWFzICogMjtcbiAgICBjb25zdCBjb2VmZmljaWVudHMgPSBlZGdlQmlhcyA+IDAgPyBnZXRDb2VmZmljaWVudHMobikuc2xpY2UoZWRnZUJpYXMsIC1lZGdlQmlhcykgOiBnZXRDb2VmZmljaWVudHMobik7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigoY29lZmZpY2llbnRzLmxlbmd0aCAtIDEpIC8gMik7XG4gICAgY29uc3Qgc3VtID0gY29lZmZpY2llbnRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIGNvbnN0IHdlaWdodHMgPSBjb2VmZmljaWVudHMuc2xpY2UobWlkKTtcbiAgICBjb25zdCBvZmZzZXRzID0gWy4uLkFycmF5KG1pZCArIDEpLmtleXMoKV07XG4gICAgY29uc3QgbGluZWFyV2VpZ2h0cyA9IG5ldyBGbG9hdDY0QXJyYXkoTWF0aC5mbG9vcihvZmZzZXRzLmxlbmd0aCAvIDIpKTtcbiAgICBjb25zdCBsaW5lYXJPZmZzZXRzID0gbmV3IEZsb2F0NjRBcnJheShsaW5lYXJXZWlnaHRzLmxlbmd0aCk7XG4gICAgbGluZWFyV2VpZ2h0c1swXSA9IHdlaWdodHNbMF0gLyBzdW07XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAxLCBsID0gb2Zmc2V0cy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSAyLCArK2opIHtcbiAgICAgIGNvbnN0IG9mZnNldDAgPSBvZmZzZXRzW2ldLCBvZmZzZXQxID0gb2Zmc2V0c1tpICsgMV07XG4gICAgICBjb25zdCB3ZWlnaHQwID0gd2VpZ2h0c1tpXSwgd2VpZ2h0MSA9IHdlaWdodHNbaSArIDFdO1xuICAgICAgY29uc3QgdyA9IHdlaWdodDAgKyB3ZWlnaHQxO1xuICAgICAgY29uc3QgbyA9IChvZmZzZXQwICogd2VpZ2h0MCArIG9mZnNldDEgKiB3ZWlnaHQxKSAvIHc7XG4gICAgICBsaW5lYXJXZWlnaHRzW2pdID0gdyAvIHN1bTtcbiAgICAgIGxpbmVhck9mZnNldHNbal0gPSBvO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHdlaWdodHMubGVuZ3RoLCBzID0gMSAvIHN1bTsgaSA8IGw7ICsraSkge1xuICAgICAgd2VpZ2h0c1tpXSAqPSBzO1xuICAgIH1cbiAgICBjb25zdCBsaW5lYXJXZWlnaHRTdW0gPSAobGluZWFyV2VpZ2h0cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAtIGxpbmVhcldlaWdodHNbMF0gKiAwLjUpICogMjtcbiAgICBpZiAobGluZWFyV2VpZ2h0U3VtICE9PSAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpbmVhcldlaWdodHMubGVuZ3RoLCBzID0gMSAvIGxpbmVhcldlaWdodFN1bTsgaSA8IGw7ICsraSkge1xuICAgICAgICBsaW5lYXJXZWlnaHRzW2ldICo9IHM7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgdGhpcy53ZWlnaHRzID0gd2VpZ2h0cztcbiAgICB0aGlzLmxpbmVhck9mZnNldHMgPSBsaW5lYXJPZmZzZXRzO1xuICAgIHRoaXMubGluZWFyV2VpZ2h0cyA9IGxpbmVhcldlaWdodHM7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL0ltbXV0YWJsZVRpbWVyLmpzXG52YXIgSW1tdXRhYmxlVGltZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBkZWx0YSB0aW1lIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXREZWx0YSgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWxhcHNlZCB0aW1lIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRFbGFwc2VkKCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL0luaXRpYWxpemFibGUuanNcbnZhciBJbml0aWFsaXphYmxlID0gY2xhc3Mge1xuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL092ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyLmpzXG5pbXBvcnQgeyBCYWNrU2lkZSwgRG91YmxlU2lkZSwgRnJvbnRTaWRlLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDIgfSBmcm9tIFwidGhyZWVcIjtcbnZhciB3b3JrYXJvdW5kRW5hYmxlZCA9IGZhbHNlO1xudmFyIE92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBvdmVycmlkZSBtYXRlcmlhbCBtYW5hZ2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbbWF0ZXJpYWw9bnVsbF0gLSBBbiBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hdGVyaWFsID0gbnVsbCkge1xuICAgIHRoaXMub3JpZ2luYWxNYXRlcmlhbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzID0gbnVsbDtcbiAgICB0aGlzLm1hdGVyaWFsc0JhY2tTaWRlID0gbnVsbDtcbiAgICB0aGlzLm1hdGVyaWFsc0RvdWJsZVNpZGUgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZCA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkQmFja1NpZGUgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZERvdWJsZVNpZGUgPSBudWxsO1xuICAgIHRoaXMuc2V0TWF0ZXJpYWwobWF0ZXJpYWwpO1xuICAgIHRoaXMubWVzaENvdW50ID0gMDtcbiAgICB0aGlzLnJlcGxhY2VNYXRlcmlhbCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAobm9kZS5pc01lc2gpIHtcbiAgICAgICAgbGV0IG1hdGVyaWFscztcbiAgICAgICAgaWYgKG5vZGUubWF0ZXJpYWwuZmxhdFNoYWRpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5vZGUubWF0ZXJpYWwuc2lkZSkge1xuICAgICAgICAgICAgY2FzZSBEb3VibGVTaWRlOlxuICAgICAgICAgICAgICBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWREb3VibGVTaWRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmFja1NpZGU6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZEJhY2tTaWRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAobm9kZS5tYXRlcmlhbC5zaWRlKSB7XG4gICAgICAgICAgICBjYXNlIERvdWJsZVNpZGU6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzRG91YmxlU2lkZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJhY2tTaWRlOlxuICAgICAgICAgICAgICBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFsc0JhY2tTaWRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnaW5hbE1hdGVyaWFscy5zZXQobm9kZSwgbm9kZS5tYXRlcmlhbCk7XG4gICAgICAgIGlmIChub2RlLmlzU2tpbm5lZE1lc2gpIHtcbiAgICAgICAgICBub2RlLm1hdGVyaWFsID0gbWF0ZXJpYWxzWzJdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaXNJbnN0YW5jZWRNZXNoKSB7XG4gICAgICAgICAgbm9kZS5tYXRlcmlhbCA9IG1hdGVyaWFsc1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLm1hdGVyaWFsID0gbWF0ZXJpYWxzWzBdO1xuICAgICAgICB9XG4gICAgICAgICsrdGhpcy5tZXNoQ291bnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBnaXZlbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWwgLSBUaGUgbWF0ZXJpYWwuXG4gICAqIEByZXR1cm4ge01hdGVyaWFsfSBUaGUgY2xvbmVkIG1hdGVyaWFsLlxuICAgKi9cbiAgY2xvbmVNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgIGlmICghKG1hdGVyaWFsIGluc3RhbmNlb2YgU2hhZGVyTWF0ZXJpYWwyKSkge1xuICAgICAgcmV0dXJuIG1hdGVyaWFsLmNsb25lKCk7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgY29uc3QgdGV4dHVyZVVuaWZvcm1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB1bmlmb3Jtcykge1xuICAgICAgY29uc3QgdmFsdWUgPSB1bmlmb3Jtc1trZXldLnZhbHVlO1xuICAgICAgaWYgKHZhbHVlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSkge1xuICAgICAgICB1bmlmb3Jtc1trZXldLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGV4dHVyZVVuaWZvcm1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2xvbmUgPSBtYXRlcmlhbC5jbG9uZSgpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGV4dHVyZVVuaWZvcm1zKSB7XG4gICAgICB1bmlmb3Jtc1tlbnRyeVswXV0udmFsdWUgPSBlbnRyeVsxXTtcbiAgICAgIGNsb25lLnVuaWZvcm1zW2VudHJ5WzBdXS52YWx1ZSA9IGVudHJ5WzFdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbCAtIFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIHNldE1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gICAgdGhpcy5kaXNwb3NlTWF0ZXJpYWxzKCk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIGlmIChtYXRlcmlhbCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHMgPSBbXG4gICAgICAgIHRoaXMuY2xvbmVNYXRlcmlhbChtYXRlcmlhbCksXG4gICAgICAgIHRoaXMuY2xvbmVNYXRlcmlhbChtYXRlcmlhbCksXG4gICAgICAgIHRoaXMuY2xvbmVNYXRlcmlhbChtYXRlcmlhbClcbiAgICAgIF07XG4gICAgICBmb3IgKGNvbnN0IG0yIG9mIG1hdGVyaWFscykge1xuICAgICAgICBtMi51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgbTIuc2lkZSA9IEZyb250U2lkZTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsc1syXS5za2lubmluZyA9IHRydWU7XG4gICAgICB0aGlzLm1hdGVyaWFsc0JhY2tTaWRlID0gbWF0ZXJpYWxzLm1hcCgobTIpID0+IHtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLmNsb25lTWF0ZXJpYWwobTIpO1xuICAgICAgICBjMi51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgYzIuc2lkZSA9IEJhY2tTaWRlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWF0ZXJpYWxzRG91YmxlU2lkZSA9IG1hdGVyaWFscy5tYXAoKG0yKSA9PiB7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5jbG9uZU1hdGVyaWFsKG0yKTtcbiAgICAgICAgYzIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIGMyLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZCA9IG1hdGVyaWFscy5tYXAoKG0yKSA9PiB7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5jbG9uZU1hdGVyaWFsKG0yKTtcbiAgICAgICAgYzIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIGMyLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGMyO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWRCYWNrU2lkZSA9IG1hdGVyaWFscy5tYXAoKG0yKSA9PiB7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5jbG9uZU1hdGVyaWFsKG0yKTtcbiAgICAgICAgYzIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIGMyLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgYzIuc2lkZSA9IEJhY2tTaWRlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZERvdWJsZVNpZGUgPSBtYXRlcmlhbHMubWFwKChtMikgPT4ge1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuY2xvbmVNYXRlcmlhbChtMik7XG4gICAgICAgIGMyLnVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0ZXJpYWwudW5pZm9ybXMpO1xuICAgICAgICBjMi5mbGF0U2hhZGluZyA9IHRydWU7XG4gICAgICAgIGMyLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNjZW5lIHdpdGggdGhlIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIEEgc2NlbmUuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSkge1xuICAgIGNvbnN0IHNoYWRvd01hcEVuYWJsZWQgPSByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IGZhbHNlO1xuICAgIGlmICh3b3JrYXJvdW5kRW5hYmxlZCkge1xuICAgICAgY29uc3Qgb3JpZ2luYWxNYXRlcmlhbHMgPSB0aGlzLm9yaWdpbmFsTWF0ZXJpYWxzO1xuICAgICAgdGhpcy5tZXNoQ291bnQgPSAwO1xuICAgICAgc2NlbmUudHJhdmVyc2UodGhpcy5yZXBsYWNlTWF0ZXJpYWwpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBvcmlnaW5hbE1hdGVyaWFscykge1xuICAgICAgICBlbnRyeVswXS5tYXRlcmlhbCA9IGVudHJ5WzFdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVzaENvdW50ICE9PSBvcmlnaW5hbE1hdGVyaWFscy5zaXplKSB7XG4gICAgICAgIG9yaWdpbmFsTWF0ZXJpYWxzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xuICAgICAgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcbiAgICB9XG4gICAgcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSBzaGFkb3dNYXBFbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGNsb25lZCBvdmVycmlkZSBtYXRlcmlhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwb3NlTWF0ZXJpYWxzKCkge1xuICAgIGlmICh0aGlzLm1hdGVyaWFsICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFscy5jb25jYXQodGhpcy5tYXRlcmlhbHNCYWNrU2lkZSkuY29uY2F0KHRoaXMubWF0ZXJpYWxzRG91YmxlU2lkZSkuY29uY2F0KHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZCkuY29uY2F0KHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZEJhY2tTaWRlKS5jb25jYXQodGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkRG91YmxlU2lkZSk7XG4gICAgICBmb3IgKGNvbnN0IG0yIG9mIG1hdGVyaWFscykge1xuICAgICAgICBtMi5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBjbGVhbnVwIHRhc2tzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLm9yaWdpbmFsTWF0ZXJpYWxzLmNsZWFyKCk7XG4gICAgdGhpcy5kaXNwb3NlTWF0ZXJpYWxzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBvdmVycmlkZSBtYXRlcmlhbCB3b3JrYXJvdW5kIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCB3b3JrYXJvdW5kRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gd29ya2Fyb3VuZEVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIG92ZXJyaWRlIG1hdGVyaWFsIHdvcmthcm91bmQgZ2xvYmFsbHkuXG4gICAqXG4gICAqIFRoaXMgb25seSBhZmZlY3RzIHBvc3QgcHJvY2Vzc2luZyBwYXNzZXMgYW5kIGVmZmVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldCB3b3JrYXJvdW5kRW5hYmxlZCh2YWx1ZSkge1xuICAgIHdvcmthcm91bmRFbmFibGVkID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL1Jlc2l6YWJsZS5qc1xudmFyIFJlc2l6YWJsZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvUmVzb2x1dGlvbi5qc1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyLCBWZWN0b3IyIGFzIFZlY3RvcjIyIH0gZnJvbSBcInRocmVlXCI7XG52YXIgQVVUT19TSVpFID0gLTE7XG52YXIgUmVzb2x1dGlvbiA9IGNsYXNzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgcmVzb2x1dGlvbi5cbiAgICpcbiAgICogVE9ETyBSZW1vdmUgcmVzaXphYmxlIHBhcmFtLlxuICAgKiBAcGFyYW0ge1Jlc2l6YWJsZX0gcmVzaXphYmxlIC0gQSByZXNpemFibGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBwcmVmZXJyZWQgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBwcmVmZXJyZWQgaGVpZ2h0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTEuMF0gLSBBIHJlc29sdXRpb24gc2NhbGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNpemFibGUsIHdpZHRoID0gQVVUT19TSVpFLCBoZWlnaHQgPSBBVVRPX1NJWkUsIHNjYWxlID0gMSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZXNpemFibGUgPSByZXNpemFibGU7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IG5ldyBWZWN0b3IyMigxLCAxKTtcbiAgICB0aGlzLnByZWZlcnJlZFNpemUgPSBuZXcgVmVjdG9yMjIod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLnByZWZlcnJlZFNpemU7XG4gICAgdGhpcy5zID0gc2NhbGU7XG4gICAgdGhpcy5lZmZlY3RpdmVTaXplID0gbmV3IFZlY3RvcjIyKCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICgpID0+IHRoaXMudXBkYXRlRWZmZWN0aXZlU2l6ZSgpKTtcbiAgICB0aGlzLnVwZGF0ZUVmZmVjdGl2ZVNpemUoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZWZmZWN0aXZlIHNpemUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVFZmZlY3RpdmVTaXplKCkge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJhc2VTaXplO1xuICAgIGNvbnN0IHByZWZlcnJlZCA9IHRoaXMucHJlZmVycmVkU2l6ZTtcbiAgICBjb25zdCBlZmZlY3RpdmUgPSB0aGlzLmVmZmVjdGl2ZVNpemU7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGlmIChwcmVmZXJyZWQud2lkdGggIT09IEFVVE9fU0laRSkge1xuICAgICAgZWZmZWN0aXZlLndpZHRoID0gcHJlZmVycmVkLndpZHRoO1xuICAgIH0gZWxzZSBpZiAocHJlZmVycmVkLmhlaWdodCAhPT0gQVVUT19TSVpFKSB7XG4gICAgICBlZmZlY3RpdmUud2lkdGggPSBNYXRoLnJvdW5kKHByZWZlcnJlZC5oZWlnaHQgKiAoYmFzZS53aWR0aCAvIE1hdGgubWF4KGJhc2UuaGVpZ2h0LCAxKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3RpdmUud2lkdGggPSBNYXRoLnJvdW5kKGJhc2Uud2lkdGggKiBzY2FsZSk7XG4gICAgfVxuICAgIGlmIChwcmVmZXJyZWQuaGVpZ2h0ICE9PSBBVVRPX1NJWkUpIHtcbiAgICAgIGVmZmVjdGl2ZS5oZWlnaHQgPSBwcmVmZXJyZWQuaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAocHJlZmVycmVkLndpZHRoICE9PSBBVVRPX1NJWkUpIHtcbiAgICAgIGVmZmVjdGl2ZS5oZWlnaHQgPSBNYXRoLnJvdW5kKHByZWZlcnJlZC53aWR0aCAvIE1hdGgubWF4KGJhc2Uud2lkdGggLyBNYXRoLm1heChiYXNlLmhlaWdodCwgMSksIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWZmZWN0aXZlLmhlaWdodCA9IE1hdGgucm91bmQoYmFzZS5oZWlnaHQgKiBzY2FsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGUgZWZmZWN0aXZlIHdpZHRoLlxuICAgKlxuICAgKiBJZiB0aGUgcHJlZmVycmVkIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHNldCB0byB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9LCB0aGUgYmFzZSB3aWR0aCB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVmZmVjdGl2ZVNpemUud2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWZmZWN0aXZlIGhlaWdodC5cbiAgICpcbiAgICogSWYgdGhlIHByZWZlcnJlZCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBzZXQgdG8ge0BsaW5rIFJlc2l6ZXIuQVVUT19TSVpFfSwgdGhlIGJhc2UgaGVpZ2h0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVmZmVjdGl2ZVNpemUuaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnByZWZlcnJlZEhlaWdodCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgd2lkdGguXG4gICAqXG4gICAqIElmIHRoZSBwcmVmZXJyZWQgd2lkdGggYW5kIGhlaWdodCBhcmUgc2V0IHRvIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0sIHRoZSBiYXNlIHdpZHRoIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB3aWR0aCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBlZmZlY3RpdmUgd2lkdGguXG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIGhlaWdodC5cbiAgICpcbiAgICogSWYgdGhlIHByZWZlcnJlZCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBzZXQgdG8ge0BsaW5rIFJlc2l6ZXIuQVVUT19TSVpFfSwgdGhlIGJhc2UgaGVpZ2h0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBoZWlnaHQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZWZmZWN0aXZlIGhlaWdodC5cbiAgICovXG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnM7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMucyA9IHZhbHVlO1xuICAgICAgdGhpcy5wcmVmZXJyZWRTaXplLnNldFNjYWxhcihBVVRPX1NJWkUpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUuXG4gICAqL1xuICBnZXRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQWxzbyBzZXRzIHRoZSBwcmVmZXJyZWQgcmVzb2x1dGlvbiB0byB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNjYWxlLlxuICAgKi9cbiAgc2V0U2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIHdpZHRoLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJhc2VXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlU2l6ZS53aWR0aDtcbiAgfVxuICBzZXQgYmFzZVdpZHRoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuYmFzZVNpemUud2lkdGggIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmJhc2VTaXplLndpZHRoID0gdmFsdWU7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYXNlIHdpZHRoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmFzZVdpZHRoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJhc2Ugd2lkdGguXG4gICAqL1xuICBnZXRCYXNlV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBiYXNlIHdpZHRoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmFzZVdpZHRoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSB3aWR0aC5cbiAgICovXG4gIHNldEJhc2VXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuYmFzZVdpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGhlaWdodC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBiYXNlSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VTaXplLmhlaWdodDtcbiAgfVxuICBzZXQgYmFzZUhlaWdodCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmJhc2VTaXplLmhlaWdodCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuYmFzZVNpemUuaGVpZ2h0ID0gdmFsdWU7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYXNlIGhlaWdodC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJhc2VIZWlnaHQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYmFzZSBoZWlnaHQuXG4gICAqL1xuICBnZXRCYXNlSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VIZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhc2UgaGVpZ2h0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmFzZUhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0QmFzZUhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuYmFzZUhlaWdodCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBiYXNlIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMuYmFzZVNpemUud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuYmFzZVNpemUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgIHRoaXMuYmFzZVNpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIHByZWZlcnJlZCB3aWR0aC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwcmVmZXJyZWRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVmZXJyZWRTaXplLndpZHRoO1xuICB9XG4gIHNldCBwcmVmZXJyZWRXaWR0aCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZWZlcnJlZFNpemUud2lkdGggIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnByZWZlcnJlZFNpemUud2lkdGggPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWZlcnJlZCB3aWR0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlcnJlZFdpZHRoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHByZWZlcnJlZCB3aWR0aC5cbiAgICovXG4gIGdldFByZWZlcnJlZFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnByZWZlcnJlZFdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVmZXJyZWQgd2lkdGguXG4gICAqXG4gICAqIFVzZSB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9IHRvIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIHRoZSB3aWR0aCBiYXNlZCBvbiB0aGUgaGVpZ2h0IGFuZCBhc3BlY3QgcmF0aW8uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVmZXJyZWRXaWR0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgd2lkdGguXG4gICAqL1xuICBzZXRQcmVmZXJyZWRXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZmVycmVkV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByZWZlcnJlZCBoZWlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJlZmVycmVkSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnByZWZlcnJlZFNpemUuaGVpZ2h0O1xuICB9XG4gIHNldCBwcmVmZXJyZWRIZWlnaHQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcmVmZXJyZWRTaXplLmhlaWdodCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMucHJlZmVycmVkU2l6ZS5oZWlnaHQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWZlcnJlZCBoZWlnaHQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVmZXJyZWRIZWlnaHQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcHJlZmVycmVkIGhlaWdodC5cbiAgICovXG4gIGdldFByZWZlcnJlZEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVmZXJyZWRIZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByZWZlcnJlZCBoZWlnaHQuXG4gICAqXG4gICAqIFVzZSB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9IHRvIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIHRoZSBoZWlnaHQgYmFzZWQgb24gdGhlIHdpZHRoIGFuZCBhc3BlY3QgcmF0aW8uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVmZXJyZWRIZWlnaHQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFByZWZlcnJlZEhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZmVycmVkSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByZWZlcnJlZCBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0UHJlZmVycmVkU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMucHJlZmVycmVkU2l6ZS53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5wcmVmZXJyZWRTaXplLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICB0aGlzLnByZWZlcnJlZFNpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoZSBnaXZlbiByZXNvbHV0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1Jlc29sdXRpb259IHJlc29sdXRpb24gLSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGNvcHkocmVzb2x1dGlvbikge1xuICAgIHRoaXMucyA9IHJlc29sdXRpb24uc2NhbGU7XG4gICAgdGhpcy5iYXNlU2l6ZS5zZXQocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCk7XG4gICAgdGhpcy5wcmVmZXJyZWRTaXplLnNldChyZXNvbHV0aW9uLnByZWZlcnJlZFdpZHRoLCByZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogQW4gYXV0byBzaXppbmcgY29uc3RhbnQuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIHRoZSB3aWR0aCBvciBoZWlnaHQgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGFzcGVjdCByYXRpby5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgQVVUT19TSVpFKCkge1xuICAgIHJldHVybiBBVVRPX1NJWkU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9JZE1hbmFnZXIuanNcbnZhciBJZE1hbmFnZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IElEIG1hbmFnZXIuXG4gICAqXG4gICAqIEBwYXJhbSBpbml0aWFsSWQgLSBUaGUgZmlyc3QgSUQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsSWQgPSAwKSB7XG4gICAgdGhpcy5uZXh0SWQgPSBpbml0aWFsSWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgdW5pcXVlIElELlxuICAgKlxuICAgKiBAcmV0dXJuIFRoZSBJRC5cbiAgICovXG4gIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0SWQrKztcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBJRCBjb3VudGVyLlxuICAgKlxuICAgKiBAcGFyYW0gaW5pdGlhbElkIC0gVGhlIGZpcnN0IElELlxuICAgKiBAcmV0dXJuIFRoaXMgbWFuYWdlci5cbiAgICovXG4gIHJlc2V0KGluaXRpYWxJZCA9IDApIHtcbiAgICB0aGlzLm5leHRJZCA9IGluaXRpYWxJZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvU2VsZWN0aW9uLmpzXG52YXIgaWRNYW5hZ2VyID0gLyogQF9fUFVSRV9fICovIG5ldyBJZE1hbmFnZXIoMik7XG52YXIgU2VsZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBTZXQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8T2JqZWN0M0Q+fSBbaXRlcmFibGVdIC0gQSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhpcyBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbGF5ZXJdIC0gQSBkZWRpY2F0ZWQgcmVuZGVyIGxheWVyIGZvciBzZWxlY3RlZCBvYmplY3RzLiBSYW5nZSBpcyBgWzIsIDMxXWAuIFN0YXJ0cyBhdCAyIGlmIG9taXR0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpdGVyYWJsZSwgbGF5ZXIgPSBpZE1hbmFnZXIuZ2V0TmV4dElkKCkpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZXhjbHVzaXZlID0gZmFsc2U7XG4gICAgdGhpcy5fbGF5ZXIgPSBsYXllcjtcbiAgICBpZiAodGhpcy5fbGF5ZXIgPCAxIHx8IHRoaXMuX2xheWVyID4gMzEpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkxheWVyIG91dCBvZiByYW5nZSwgcmVzZXR0aW5nIHRvIDJcIik7XG4gICAgICBpZE1hbmFnZXIucmVzZXQoMik7XG4gICAgICB0aGlzLl9sYXllciA9IGlkTWFuYWdlci5nZXROZXh0SWQoKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuc2V0KGl0ZXJhYmxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZW5kZXIgbGF5ZXIgZm9yIHNlbGVjdGVkIG9iamVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVyO1xuICB9XG4gIHNldCBsYXllcih2YWx1ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IHRoaXMuX2xheWVyO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIHRoaXMpIHtcbiAgICAgIG9iamVjdC5sYXllcnMuZGlzYWJsZShjdXJyZW50TGF5ZXIpO1xuICAgICAgb2JqZWN0LmxheWVycy5lbmFibGUodmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl9sYXllciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlbmRlciBsYXllciBmb3Igc2VsZWN0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgbGF5ZXIgaXMgMi4gSWYgdGhpcyBjb2xsaWRlcyB3aXRoIHlvdXIgb3duIGN1c3RvbSBsYXllcnMsIHBsZWFzZSBjaGFuZ2UgaXQgYmVmb3JlIHJlbmRlcmluZyFcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxheWVyIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxheWVyLlxuICAgKi9cbiAgZ2V0TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlciBsYXllciBmb3Igc2VsZWN0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogVGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxheWVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBsYXllci4gUmFuZ2UgaXMgWzAsIDMxXS5cbiAgICovXG4gIHNldExheWVyKHZhbHVlKSB7XG4gICAgdGhpcy5sYXllciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3RzIHRoYXQgYXJlIGFkZGVkIHRvIHRoaXMgc2VsZWN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGFsbCBvdGhlciBsYXllcnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleGNsdXNpdmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBXaGV0aGVyIHRoaXMgc2VsZWN0aW9uIGlzIGV4Y2x1c2l2ZS4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICovXG4gIGlzRXhjbHVzaXZlKCkge1xuICAgIHJldHVybiB0aGlzLmV4Y2x1c2l2ZTtcbiAgfVxuICAvKipcbiAgICogQ29udHJvbHMgd2hldGhlciBvYmplY3RzIHRoYXQgYXJlIGFkZGVkIHRvIHRoaXMgc2VsZWN0aW9uIHNob3VsZCBiZSByZW1vdmVkIGZyb20gYWxsIG90aGVyIGxheWVycy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGV4Y2x1c2l2ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBXaGV0aGVyIHRoaXMgc2VsZWN0aW9uIHNob3VsZCBiZSBleGNsdXNpdmUuXG4gICAqL1xuICBzZXRFeGNsdXNpdmUodmFsdWUpIHtcbiAgICB0aGlzLmV4Y2x1c2l2ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhpcyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhpcyBzZWxlY3Rpb24uXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXI7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgdGhpcykge1xuICAgICAgb2JqZWN0LmxheWVycy5kaXNhYmxlKGxheWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNsZWFyKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGlzIHNlbGVjdGlvbiBhbmQgYWRkcyB0aGUgZ2l2ZW4gb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZTxPYmplY3QzRD59IG9iamVjdHMgLSBUaGUgb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGlzIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldChvYmplY3RzKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgIHRoaXMuYWRkKG9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBbiBhbGlhcyBmb3Ige0BsaW5rIGhhc30uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIEFuIG9iamVjdC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIDAgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQsIG9yIC0xIG90aGVyd2lzZS5cbiAgICogQGRlcHJlY2F0ZWQgQWRkZWQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkuXG4gICAqL1xuICBpbmRleE9mKG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLmhhcyhvYmplY3QpID8gMCA6IC0xO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIG9iamVjdCB0byB0aGlzIHNlbGVjdGlvbi5cbiAgICpcbiAgICogSWYge0BsaW5rIGV4Y2x1c2l2ZX0gaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG9iamVjdCB3aWxsIGFsc28gYmUgcmVtb3ZlZCBmcm9tIGFsbCBvdGhlciBsYXllcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQuXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhpcyBzZWxlY3Rpb24uXG4gICAqL1xuICBhZGQob2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuZXhjbHVzaXZlKSB7XG4gICAgICBvYmplY3QubGF5ZXJzLnNldCh0aGlzLmxheWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0LmxheWVycy5lbmFibGUodGhpcy5sYXllcik7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5hZGQob2JqZWN0KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBvYmplY3QgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0aGF0IHNob3VsZCBiZSBkZXNlbGVjdGVkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IGhhcyBzdWNjZXNzZnVsbHkgYmVlbiByZW1vdmVkIGZyb20gdGhpcyBzZWxlY3Rpb247IG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIGRlbGV0ZShvYmplY3QpIHtcbiAgICBpZiAodGhpcy5oYXMob2JqZWN0KSkge1xuICAgICAgb2JqZWN0LmxheWVycy5kaXNhYmxlKHRoaXMubGF5ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlKG9iamVjdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZXhpc3Rpbmcgb2JqZWN0IGZyb20gdGhlIHNlbGVjdGlvbi4gSWYgdGhlIG9iamVjdCBkb2Vzbid0IGV4aXN0IGl0J3MgYWRkZWQgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIG9iamVjdC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYWRkZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHRvZ2dsZShvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLmhhcyhvYmplY3QpKSB7XG4gICAgICB0aGlzLmRlbGV0ZShvYmplY3QpO1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG9iamVjdCk7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFsbCBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBlbmFibGVzIG9yIGRpc2FibGVzIHJlbmRlciBsYXllciAwIG9mIGFsbCBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgLSBXaGV0aGVyIHRoZSBzZWxlY3RlZCBvYmplY3RzIHNob3VsZCBiZSB2aXNpYmxlLlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFRoaXMgc2VsZWN0aW9uLlxuICAgKi9cbiAgc2V0VmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgdGhpcykge1xuICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgb2JqZWN0LmxheWVycy5lbmFibGUoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3QubGF5ZXJzLmRpc2FibGUoMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9CbGVuZE1vZGUuanNcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciBhcyBFdmVudERpc3BhdGNoZXIyLCBVbmlmb3JtIGFzIFVuaWZvcm0yIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lbnVtcy9CbGVuZEZ1bmN0aW9uLmpzXG52YXIgQmxlbmRGdW5jdGlvbiA9IHtcbiAgU0tJUDogOSxcbiAgU0VUOiAzMCxcbiAgQUREOiAwLFxuICBBTFBIQTogMSxcbiAgQVZFUkFHRTogMixcbiAgQ09MT1I6IDMsXG4gIENPTE9SX0JVUk46IDQsXG4gIENPTE9SX0RPREdFOiA1LFxuICBEQVJLRU46IDYsXG4gIERJRkZFUkVOQ0U6IDcsXG4gIERJVklERTogOCxcbiAgRFNUOiA5LFxuICBFWENMVVNJT046IDEwLFxuICBIQVJEX0xJR0hUOiAxMSxcbiAgSEFSRF9NSVg6IDEyLFxuICBIVUU6IDEzLFxuICBJTlZFUlQ6IDE0LFxuICBJTlZFUlRfUkdCOiAxNSxcbiAgTElHSFRFTjogMTYsXG4gIExJTkVBUl9CVVJOOiAxNyxcbiAgTElORUFSX0RPREdFOiAxOCxcbiAgTElORUFSX0xJR0hUOiAxOSxcbiAgTFVNSU5PU0lUWTogMjAsXG4gIE1VTFRJUExZOiAyMSxcbiAgTkVHQVRJT046IDIyLFxuICBOT1JNQUw6IDIzLFxuICBPVkVSTEFZOiAyNCxcbiAgUElOX0xJR0hUOiAyNSxcbiAgUkVGTEVDVDogMjYsXG4gIFNBVFVSQVRJT046IDI3LFxuICBTQ1JFRU46IDI4LFxuICBTT0ZUX0xJR0hUOiAyOSxcbiAgU1JDOiAzMCxcbiAgU1VCVFJBQ1Q6IDMxLFxuICBWSVZJRF9MSUdIVDogMzJcbn07XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvYWRkLmZyYWdcbnZhciBhZGRfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoeC5yZ2IreS5yZ2IseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9hbHBoYS5mcmFnXG52YXIgYWxwaGFfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHkseS5hKm9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2F2ZXJhZ2UuZnJhZ1xudmFyIGF2ZXJhZ2VfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoKHgucmdiK3kucmdiKSowLjUseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9jb2xvci5mcmFnXG52YXIgY29sb3JfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyB4SFNMPVJHQlRvSFNMKHgucmdiKTt2ZWMzIHlIU0w9UkdCVG9IU0woeS5yZ2IpO3ZlYzMgej1IU0xUb1JHQih2ZWMzKHlIU0wueHkseEhTTC56KSk7cmV0dXJuIG1peCh4LHZlYzQoeix5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2NvbG9yLWJ1cm4uZnJhZ1xudmFyIGNvbG9yX2J1cm5fZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyBhPXgucmdiLGI9eS5yZ2I7dmVjMyB6PW1peChzdGVwKDAuMCxiKSooMS4wLW1pbih2ZWMzKDEuMCksKDEuMC1hKS9iKSksdmVjMygxLjApLHN0ZXAoMS4wLGEpKTtyZXR1cm4gbWl4KHgsdmVjNCh6LHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvY29sb3ItZG9kZ2UuZnJhZ1xudmFyIGNvbG9yX2RvZGdlX2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgYT14LnJnYixiPXkucmdiO3ZlYzMgej1zdGVwKDAuMCxhKSptaXgobWluKHZlYzMoMS4wKSxhL21heCgxLjAtYiwxZS05KSksdmVjMygxLjApLHN0ZXAoMS4wLGIpKTtyZXR1cm4gbWl4KHgsdmVjNCh6LHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvZGFya2VuLmZyYWdcbnZhciBkYXJrZW5fZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQobWluKHgucmdiLHkucmdiKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2RpZmZlcmVuY2UuZnJhZ1xudmFyIGRpZmZlcmVuY2VfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoYWJzKHgucmdiLXkucmdiKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2RpdmlkZS5mcmFnXG52YXIgZGl2aWRlX2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx2ZWM0KHgucmdiL21heCh5LnJnYiwxZS0xMikseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9leGNsdXNpb24uZnJhZ1xudmFyIGV4Y2x1c2lvbl9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNCgoeC5yZ2IreS5yZ2ItMi4wKngucmdiKnkucmdiKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2hhcmQtbGlnaHQuZnJhZ1xudmFyIGhhcmRfbGlnaHRfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyBhPW1pbih4LnJnYiwxLjApO3ZlYzMgYj1taW4oeS5yZ2IsMS4wKTt2ZWMzIHo9bWl4KDIuMCphKmIsMS4wLTIuMCooMS4wLWEpKigxLjAtYiksc3RlcCgwLjUsYikpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9oYXJkLW1peC5mcmFnXG52YXIgaGFyZF9taXhfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoc3RlcCgxLjAseC5yZ2IreS5yZ2IpLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvaHVlLmZyYWdcbnZhciBodWVfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyB4SFNMPVJHQlRvSFNMKHgucmdiKTt2ZWMzIHlIU0w9UkdCVG9IU0woeS5yZ2IpO3ZlYzMgej1IU0xUb1JHQih2ZWMzKHlIU0wueCx4SFNMLnl6KSk7cmV0dXJuIG1peCh4LHZlYzQoeix5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2ludmVydC5mcmFnXG52YXIgaW52ZXJ0X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx2ZWM0KDEuMC15LnJnYix5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2ludmVydC1yZ2IuZnJhZ1xudmFyIGludmVydF9yZ2JfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoeS5yZ2IqKDEuMC14LnJnYikseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9saWdodGVuLmZyYWdcbnZhciBsaWdodGVuX2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx2ZWM0KG1heCh4LnJnYix5LnJnYikseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9saW5lYXItYnVybi5mcmFnXG52YXIgbGluZWFyX2J1cm5fZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoY2xhbXAoeS5yZ2IreC5yZ2ItMS4wLDAuMCwxLjApLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbGluZWFyLWRvZGdlLmZyYWdcbnZhciBsaW5lYXJfZG9kZ2VfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQobWluKHgucmdiK3kucmdiLDEuMCkseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9saW5lYXItbGlnaHQuZnJhZ1xudmFyIGxpbmVhcl9saWdodF9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNChjbGFtcCgyLjAqeS5yZ2IreC5yZ2ItMS4wLDAuMCwxLjApLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbHVtaW5vc2l0eS5mcmFnXG52YXIgbHVtaW5vc2l0eV9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHhIU0w9UkdCVG9IU0woeC5yZ2IpO3ZlYzMgeUhTTD1SR0JUb0hTTCh5LnJnYik7dmVjMyB6PUhTTFRvUkdCKHZlYzMoeEhTTC54eSx5SFNMLnopKTtyZXR1cm4gbWl4KHgsdmVjNCh6LHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbXVsdGlwbHkuZnJhZ1xudmFyIG11bHRpcGx5X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx2ZWM0KHgucmdiKnkucmdiLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbmVnYXRpb24uZnJhZ1xudmFyIG5lZ2F0aW9uX2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx2ZWM0KDEuMC1hYnMoMS4wLXgucmdiLXkucmdiKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL25vcm1hbC5mcmFnXG52YXIgbm9ybWFsX2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx5LG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL292ZXJsYXkuZnJhZ1xudmFyIG92ZXJsYXlfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyB6PW1peCgyLjAqeS5yZ2IqeC5yZ2IsMS4wLTIuMCooMS4wLXkucmdiKSooMS4wLXgucmdiKSxzdGVwKDAuNSx4LnJnYikpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9waW4tbGlnaHQuZnJhZ1xudmFyIHBpbl9saWdodF9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHkyPTIuMCp5LnJnYjt2ZWMzIHo9bWl4KG1peCh5Mix4LnJnYixzdGVwKDAuNSp4LnJnYix5LnJnYikpLG1heCh5Mi0xLjAsdmVjMygwLjApKSxzdGVwKHgucmdiLHkyLTEuMCkpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9yZWZsZWN0LmZyYWdcbnZhciByZWZsZWN0X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgej1taXgobWluKHgucmdiKngucmdiL21heCgxLjAteS5yZ2IsMWUtMTIpLDEuMCkseS5yZ2Isc3RlcCgxLjAseS5yZ2IpKTtyZXR1cm4gbWl4KHgsdmVjNCh6LHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvc2F0dXJhdGlvbi5mcmFnXG52YXIgc2F0dXJhdGlvbl9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHhIU0w9UkdCVG9IU0woeC5yZ2IpO3ZlYzMgeUhTTD1SR0JUb0hTTCh5LnJnYik7dmVjMyB6PUhTTFRvUkdCKHZlYzMoeEhTTC54LHlIU0wueSx4SFNMLnopKTtyZXR1cm4gbWl4KHgsdmVjNCh6LHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvc2NyZWVuLmZyYWdcbnZhciBzY3JlZW5fZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoeC5yZ2IreS5yZ2ItbWluKHgucmdiKnkucmdiLDEuMCkseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9zb2Z0LWxpZ2h0LmZyYWdcbnZhciBzb2Z0X2xpZ2h0X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgYT14LnJnYjt2ZWMzIGI9eS5yZ2I7dmVjMyB5Mj0yLjAqYjt2ZWMzIHc9c3RlcCgwLjUsYik7dmVjMyBjPWEtKDEuMC15MikqYSooMS4wLWEpO3ZlYzMgZD1taXgoYSsoeTItMS4wKSooc3FydChhKS1hKSxhKyh5Mi0xLjApKmEqKCgxNi4wKmEtMTIuMCkqYSszLjApLHcqKDEuMC1zdGVwKDAuMjUsYSkpKTt2ZWMzIHo9bWl4KGMsZCx3KTtyZXR1cm4gbWl4KHgsdmVjNCh6LHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvc3JjLmZyYWdcbnZhciBzcmNfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIHk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvc3VidHJhY3QuZnJhZ1xudmFyIHN1YnRyYWN0X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx2ZWM0KG1heCh4LnJnYit5LnJnYi0xLjAsMC4wKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3ZpdmlkLWxpZ2h0LmZyYWdcbnZhciB2aXZpZF9saWdodF9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHo9bWl4KG1heCgxLjAtbWluKCgxLjAteC5yZ2IpLygyLjAqeS5yZ2IpLDEuMCksMC4wKSxtaW4oeC5yZ2IvKDIuMCooMS4wLXkucmdiKSksMS4wKSxzdGVwKDAuNSx5LnJnYikpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvQmxlbmRNb2RlLmpzXG52YXIgYmxlbmRGdW5jdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtCbGVuZEZ1bmN0aW9uLkFERCwgYWRkX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5BTFBIQSwgYWxwaGFfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkFWRVJBR0UsIGF2ZXJhZ2VfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkNPTE9SLCBjb2xvcl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uQ09MT1JfQlVSTiwgY29sb3JfYnVybl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uQ09MT1JfRE9ER0UsIGNvbG9yX2RvZGdlX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5EQVJLRU4sIGRhcmtlbl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uRElGRkVSRU5DRSwgZGlmZmVyZW5jZV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uRElWSURFLCBkaXZpZGVfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkRTVCwgbnVsbF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkVYQ0xVU0lPTiwgZXhjbHVzaW9uX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5IQVJEX0xJR0hULCBoYXJkX2xpZ2h0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5IQVJEX01JWCwgaGFyZF9taXhfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkhVRSwgaHVlX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5JTlZFUlQsIGludmVydF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uSU5WRVJUX1JHQiwgaW52ZXJ0X3JnYl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTElHSFRFTiwgbGlnaHRlbl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTElORUFSX0JVUk4sIGxpbmVhcl9idXJuX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5MSU5FQVJfRE9ER0UsIGxpbmVhcl9kb2RnZV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTElORUFSX0xJR0hULCBsaW5lYXJfbGlnaHRfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkxVTUlOT1NJVFksIGx1bWlub3NpdHlfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLk1VTFRJUExZLCBtdWx0aXBseV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTkVHQVRJT04sIG5lZ2F0aW9uX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5OT1JNQUwsIG5vcm1hbF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uT1ZFUkxBWSwgb3ZlcmxheV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uUElOX0xJR0hULCBwaW5fbGlnaHRfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlJFRkxFQ1QsIHJlZmxlY3RfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlNBVFVSQVRJT04sIHNhdHVyYXRpb25fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlNDUkVFTiwgc2NyZWVuX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5TT0ZUX0xJR0hULCBzb2Z0X2xpZ2h0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5TUkMsIHNyY19kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uU1VCVFJBQ1QsIHN1YnRyYWN0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5WSVZJRF9MSUdIVCwgdml2aWRfbGlnaHRfZGVmYXVsdF1cbl0pO1xudmFyIEJsZW5kTW9kZSA9IGNsYXNzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyMiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJsZW5kIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gYmxlbmRGdW5jdGlvbiAtIFRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wYWNpdHkgLSBUaGUgb3BhY2l0eSBvZiB0aGUgY29sb3IgdGhhdCB3aWxsIGJlIGJsZW5kZWQgd2l0aCB0aGUgYmFzZSBjb2xvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJsZW5kRnVuY3Rpb24sIG9wYWNpdHkgPSAxKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9ibGVuZEZ1bmN0aW9uID0gYmxlbmRGdW5jdGlvbjtcbiAgICB0aGlzLm9wYWNpdHkgPSBuZXcgVW5pZm9ybTIob3BhY2l0eSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wYWNpdHkuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG9wYWNpdHkuXG4gICAqL1xuICBnZXRPcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9wYWNpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBvcGFjaXR5LlxuICAgKi9cbiAgc2V0T3BhY2l0eSh2YWx1ZSkge1xuICAgIHRoaXMub3BhY2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmxlbmQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEB0eXBlIHtCbGVuZEZ1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IGJsZW5kRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsZW5kRnVuY3Rpb247XG4gIH1cbiAgc2V0IGJsZW5kRnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLl9ibGVuZEZ1bmN0aW9uID0gdmFsdWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmxlbmQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibGVuZEZ1bmN0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0JsZW5kRnVuY3Rpb259IFRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICovXG4gIGdldEJsZW5kRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxlbmRGdW5jdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmxlbmQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibGVuZEZ1bmN0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gdmFsdWUgLSBUaGUgYmxlbmQgZnVuY3Rpb24uXG4gICAqL1xuICBzZXRCbGVuZEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5ibGVuZEZ1bmN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsZW5kIGZ1bmN0aW9uIHNoYWRlciBjb2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBibGVuZCBmdW5jdGlvbiBzaGFkZXIgY29kZS5cbiAgICovXG4gIGdldFNoYWRlckNvZGUoKSB7XG4gICAgcmV0dXJuIGJsZW5kRnVuY3Rpb25zLmdldCh0aGlzLmJsZW5kRnVuY3Rpb24pO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9BU0NJSUVmZmVjdC5qc1xuaW1wb3J0IHsgQ29sb3IgYXMgQ29sb3IyLCBVbmlmb3JtIGFzIFVuaWZvcm0zLCBWZWN0b3IyIGFzIFZlY3RvcjIzLCBWZWN0b3I0IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy90ZXh0dXJlcy9BU0NJSVRleHR1cmUuanNcbmltcG9ydCB7IENhbnZhc1RleHR1cmUsIFJlcGVhdFdyYXBwaW5nIH0gZnJvbSBcInRocmVlXCI7XG52YXIgQVNDSUlUZXh0dXJlID0gY2xhc3MgZXh0ZW5kcyBDYW52YXNUZXh0dXJlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgQVNDSUkgdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2hhcmFjdGVyc10gLSBUaGUgY2hhcmFjdGVyIHNldCB0byByZW5kZXIuIERlZmF1bHRzIHRvIGEgY29tbW9uIEFTQ0lJIGFydCBjaGFyc2V0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9udD1cIkFyaWFsXCJdIC0gVGhlIGZvbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb250U2l6ZT01NF0gLSBUaGUgZm9udCBzaXplIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNpemU9MTAyNF0gLSBUaGUgdGV4dHVyZSBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2VsbENvdW50PTE2XSAtIFRoZSBjZWxsIGNvdW50IGFsb25nIGVhY2ggc2lkZSBvZiB0aGUgdGV4dHVyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaGFyYWN0ZXJzID0gXCIgLjosJy1ePSorPyF8MCNYJVdNQFwiLFxuICAgIGZvbnQgPSBcIkFyaWFsXCIsXG4gICAgZm9udFNpemUgPSA1NCxcbiAgICBzaXplID0gMTAyNCxcbiAgICBjZWxsQ291bnQgPSAxNlxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcbiAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICB2b2lkIDAsXG4gICAgICBSZXBlYXRXcmFwcGluZyxcbiAgICAgIFJlcGVhdFdyYXBwaW5nXG4gICAgKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmltYWdlO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGNvbnN0IGNlbGxTaXplID0gc2l6ZSAvIGNlbGxDb3VudDtcbiAgICBjb250ZXh0LmZvbnQgPSBgJHtmb250U2l6ZX1weCAke2ZvbnR9YDtcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGFyYWN0ZXJzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJhY3RlcnNbaV07XG4gICAgICBjb25zdCB4ID0gaSAlIGNlbGxDb3VudDtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGkgLyBjZWxsQ291bnQpO1xuICAgICAgY29udGV4dC5maWxsVGV4dChjaGFyLCB4ICogY2VsbFNpemUgKyBjZWxsU2l6ZSAvIDIsIHkgKiBjZWxsU2l6ZSArIGNlbGxTaXplIC8gMik7XG4gICAgfVxuICAgIHRoaXMuY2hhcmFjdGVyQ291bnQgPSBjaGFyYWN0ZXJzLmxlbmd0aDtcbiAgICB0aGlzLmNlbGxDb3VudCA9IGNlbGxDb3VudDtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvRWZmZWN0LmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzIsXG4gIEV2ZW50RGlzcGF0Y2hlciBhcyBFdmVudERpc3BhdGNoZXIzLFxuICBMaW5lYXJTUkdCQ29sb3JTcGFjZSBhcyBMaW5lYXJTUkdCQ29sb3JTcGFjZTIsXG4gIE1hdGVyaWFsIGFzIE1hdGVyaWFsMixcbiAgTm9Db2xvclNwYWNlLFxuICBUZXh0dXJlIGFzIFRleHR1cmUyLFxuICBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDRcbn0gZnJvbSBcInRocmVlXCI7XG52YXIgRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoaXMgZWZmZWN0LiBEb2Vzbid0IGhhdmUgdG8gYmUgdW5pcXVlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJhZ21lbnRTaGFkZXIgLSBUaGUgZnJhZ21lbnQgc2hhZGVyLiBUaGlzIHNoYWRlciBpcyByZXF1aXJlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtFZmZlY3RBdHRyaWJ1dGV9IFtvcHRpb25zLmF0dHJpYnV0ZXM9RWZmZWN0QXR0cmlidXRlLk5PTkVdIC0gVGhlIGVmZmVjdCBhdHRyaWJ1dGVzIHRoYXQgZGV0ZXJtaW5lIHRoZSBleGVjdXRpb24gcHJpb3JpdHkgYW5kIHJlc291cmNlIHJlcXVpcmVtZW50cy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uTk9STUFMXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBTdHJpbmc+fSBbb3B0aW9ucy5kZWZpbmVzXSAtIEN1c3RvbSBwcmVwcm9jZXNzb3IgbWFjcm8gZGVmaW5pdGlvbnMuIEtleXMgYXJlIG5hbWVzIGFuZCB2YWx1ZXMgYXJlIGNvZGUuXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgVW5pZm9ybT59IFtvcHRpb25zLnVuaWZvcm1zXSAtIEN1c3RvbSBzaGFkZXIgdW5pZm9ybXMuIEtleXMgYXJlIG5hbWVzIGFuZCB2YWx1ZXMgYXJlIHVuaWZvcm1zLlxuICAgKiBAcGFyYW0ge1NldDxXZWJHTEV4dGVuc2lvbj59IFtvcHRpb25zLmV4dGVuc2lvbnNdIC0gV2ViR0wgZXh0ZW5zaW9ucy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnZlcnRleFNoYWRlcj1udWxsXSAtIFRoZSB2ZXJ0ZXggc2hhZGVyLiBNb3N0IGVmZmVjdHMgZG9uJ3QgbmVlZCBvbmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lLCBmcmFnbWVudFNoYWRlciwge1xuICAgIGF0dHJpYnV0ZXMgPSBFZmZlY3RBdHRyaWJ1dGUuTk9ORSxcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5OT1JNQUwsXG4gICAgZGVmaW5lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgdW5pZm9ybXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIGV4dGVuc2lvbnMgPSBudWxsLFxuICAgIHZlcnRleFNoYWRlciA9IG51bGxcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xuICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xuICAgIHRoaXMuZGVmaW5lcyA9IGRlZmluZXM7XG4gICAgdGhpcy51bmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBuZXcgQmxlbmRNb2RlKGJsZW5kRnVuY3Rpb24pO1xuICAgIHRoaXMuYmxlbmRNb2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGV2ZW50KSA9PiB0aGlzLnNldENoYW5nZWQoKSk7XG4gICAgdGhpcy5faW5wdXRDb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2UyO1xuICAgIHRoaXMuX291dHB1dENvbG9yU3BhY2UgPSBOb0NvbG9yU3BhY2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBjb2xvciBzcGFjZS5cbiAgICpcbiAgICogQHR5cGUge0NvbG9yU3BhY2V9XG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGdldCBpbnB1dENvbG9yU3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0Q29sb3JTcGFjZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0NvbG9yU3BhY2V9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0IGlucHV0Q29sb3JTcGFjZSh2YWx1ZSkge1xuICAgIHRoaXMuX2lucHV0Q29sb3JTcGFjZSA9IHZhbHVlO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IGNvbG9yIHNwYWNlLlxuICAgKlxuICAgKiBTaG91bGQgb25seSBiZSBjaGFuZ2VkIGlmIHRoaXMgZWZmZWN0IGNvbnZlcnRzIHRoZSBpbnB1dCBjb2xvcnMgdG8gYSBkaWZmZXJlbnQgY29sb3Igc3BhY2UuXG4gICAqXG4gICAqIEB0eXBlIHtDb2xvclNwYWNlfVxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBnZXQgb3V0cHV0Q29sb3JTcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0Q29sb3JTcGFjZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0NvbG9yU3BhY2V9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0IG91dHB1dENvbG9yU3BhY2UodmFsdWUpIHtcbiAgICB0aGlzLl9vdXRwdXRDb2xvclNwYWNlID0gdmFsdWU7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1haW4gc2NlbmUuXG4gICAqXG4gICAqIEB0eXBlIHtTY2VuZX1cbiAgICovXG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFpbiBjYW1lcmEuXG4gICAqXG4gICAqIEB0eXBlIHtDYW1lcmF9XG4gICAqL1xuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbmFtZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lLlxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICovXG4gIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmVwcm9jZXNzb3IgbWFjcm8gZGVmaW5pdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZWZpbmVzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge01hcDxTdHJpbmcsIFN0cmluZz59IFRoZSBleHRlbnNpb25zLlxuICAgKi9cbiAgZ2V0RGVmaW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmlmb3JtcyBvZiB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHVuaWZvcm1zIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge01hcDxTdHJpbmcsIFVuaWZvcm0+fSBUaGUgZXh0ZW5zaW9ucy5cbiAgICovXG4gIGdldFVuaWZvcm1zKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBXZWJHTCBleHRlbnNpb25zIHRoYXQgYXJlIHJlcXVpcmVkIGJ5IHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXh0ZW5zaW9ucyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTZXQ8V2ViR0xFeHRlbnNpb24+fSBUaGUgZXh0ZW5zaW9ucy5cbiAgICovXG4gIGdldEV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmxlbmQgbW9kZS5cbiAgICpcbiAgICogVGhlIHJlc3VsdCBvZiB0aGlzIGVmZmVjdCB3aWxsIGJlIGJsZW5kZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBlZmZlY3QgdXNpbmcgdGhpcyBibGVuZCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmxlbmRNb2RlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0JsZW5kTW9kZX0gVGhlIGJsZW5kIG1vZGUuXG4gICAqL1xuICBnZXRCbGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxlbmRNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZmZlY3QgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7RWZmZWN0QXR0cmlidXRlfSBUaGUgYXR0cmlidXRlcy5cbiAgICovXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWZmZWN0IGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEVmZmVjdHMgdGhhdCBoYXZlIHRoZSBzYW1lIGF0dHJpYnV0ZXMgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIHJlZ2lzdGVyZWQuIFNvbWUgYXR0cmlidXRlc1xuICAgKiBpbXBseSBhIGhpZ2hlciBwcmlvcml0eS5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge0VmZmVjdEF0dHJpYnV0ZX0gYXR0cmlidXRlcyAtIFRoZSBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqL1xuICBnZXRGcmFnbWVudFNoYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFNoYWRlcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnbWVudFNoYWRlciAtIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqL1xuICBzZXRGcmFnbWVudFNoYWRlcihmcmFnbWVudFNoYWRlcikge1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmVydGV4IHNoYWRlci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgdmVydGV4IHNoYWRlci5cbiAgICovXG4gIGdldFZlcnRleFNoYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXhTaGFkZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnRleFNoYWRlciAtIFRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKi9cbiAgc2V0VmVydGV4U2hhZGVyKHZlcnRleFNoYWRlcikge1xuICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBJbmZvcm1zIHRoZSBhc3NvY2lhdGVkIHtAbGluayBFZmZlY3RQYXNzfSB0aGF0IHRoaXMgZWZmZWN0IHJlcXVpcmVzIGEgc2hhZGVyIHJlY29tcGlsYXRpb24uXG4gICAqXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgY2hhbmdpbmcgbWFjcm9zIG9yIGV4dGVuc2lvbnMgYW5kIGFmdGVyIGFkZGluZy9yZW1vdmluZyB1bmlmb3Jtcy5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0Q2hhbmdlZCgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdXIgZWZmZWN0IHJlcXVpcmVzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIGRlcHRoIHRleHR1cmUgdGhhdCBpcyBib3VuZCB0byB0aGVcbiAgICogYXNzb2NpYXRlZCB7QGxpbmsgRWZmZWN0UGFzc30uXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzIpIHtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdCBieSBwZXJmb3JtaW5nIHN1cHBvcnRpbmcgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSB7QGxpbmsgRWZmZWN0UGFzc30gcmlnaHQgYmVmb3JlIHRoZSBtYWluIGZ1bGxzY3JlZW4gcmVuZGVyIG9wZXJhdGlvbiwgZXZlbiBpZiB0aGVcbiAgICogYmxlbmQgZnVuY3Rpb24gaXMgc2V0IHRvIGBTS0lQYC5cbiAgICpcbiAgICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3UgbmVlZCB0byB1cGRhdGUgY3VzdG9tIHVuaWZvcm1zIG9yIHJlbmRlciBhZGRpdGlvbmFsIG9mZi1zY3JlZW4gdGV4dHVyZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSB3YW50IHRvIGJlIGluZm9ybWVkIGFib3V0IHRoZSBzaXplIG9mIHRoZSBiYWNrYnVmZmVyL2NhbnZhcy5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJlZm9yZSB7QGxpbmsgaW5pdGlhbGl6ZX0gYW5kIGV2ZXJ5IHRpbWUgdGhlIHNpemUgb2YgdGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0gY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQge0BsaW5rIEVmZmVjdFBhc3N9IGlzIGFkZGVkIHRvIGFuIHtAbGluayBFZmZlY3RDb21wb3Nlcn0uXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqIEBleGFtcGxlIGlmKCFhbHBoYSAmJiBmcmFtZUJ1ZmZlclR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUpIHsgdGhpcy5teVJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDsgfVxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIHNoYWxsb3cgc2VhcmNoIGZvciBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIGEgZGlzcG9zZSBtZXRob2QgYW5kIGRlbGV0ZXMgdGhlbS5cbiAgICpcbiAgICogVGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0gY2FsbHMgdGhpcyBtZXRob2Qgd2hlbiBpdCBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXNba2V5XTtcbiAgICAgIGNvbnN0IGlzRGlzcG9zYWJsZSA9IHByb3BlcnR5IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJUYXJnZXQ0IHx8IHByb3BlcnR5IGluc3RhbmNlb2YgTWF0ZXJpYWwyIHx8IHByb3BlcnR5IGluc3RhbmNlb2YgVGV4dHVyZTIgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBQYXNzO1xuICAgICAgaWYgKGlzRGlzcG9zYWJsZSkge1xuICAgICAgICB0aGlzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9hc2NpaS5mcmFnXG52YXIgYXNjaWlfZGVmYXVsdCA9IGB1bmlmb3JtIHNhbXBsZXIyRCBhc2NpaVRleHR1cmU7dW5pZm9ybSB2ZWM0IGNlbGxDb3VudDtcbiNpZmRlZiBVU0VfQ09MT1JcbnVuaWZvcm0gdmVjMyBjb2xvcjtcbiNlbmRpZlxudm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzIgcGl4ZWxpemVkVXY9Y2VsbENvdW50Lnp3KigwLjUrZmxvb3IodXYqY2VsbENvdW50Lnh5KSk7dmVjNCB0ZXhlbD10ZXh0dXJlKGlucHV0QnVmZmVyLHBpeGVsaXplZFV2KTtmbG9hdCBsdW09bWluKGx1bWluYW5jZSh0ZXhlbC5yZ2IpLDEuMCk7XG4jaWZkZWYgSU5WRVJURURcbmx1bT0xLjAtbHVtO1xuI2VuZGlmXG5mbG9hdCBjaGFyYWN0ZXJJbmRleD1mbG9vcihDSEFSX0NPVU5UX01JTlVTX09ORSpsdW0pO3ZlYzIgY2hhcmFjdGVyUG9zaXRpb249dmVjMihtb2QoY2hhcmFjdGVySW5kZXgsVEVYX0NFTExfQ09VTlQpLGZsb29yKGNoYXJhY3RlckluZGV4KklOVl9URVhfQ0VMTF9DT1VOVCkpO3ZlYzIgb2Zmc2V0PXZlYzIoY2hhcmFjdGVyUG9zaXRpb24ueCwtY2hhcmFjdGVyUG9zaXRpb24ueSkqSU5WX1RFWF9DRUxMX0NPVU5UO3ZlYzIgY2hhcmFjdGVyVXY9bW9kKHV2KihjZWxsQ291bnQueHkqSU5WX1RFWF9DRUxMX0NPVU5UKSxJTlZfVEVYX0NFTExfQ09VTlQpO2NoYXJhY3RlclV2PWNoYXJhY3RlclV2LXZlYzIoMC4wLElOVl9URVhfQ0VMTF9DT1VOVCkrb2Zmc2V0O2Zsb2F0IGFzY2lpQ2hhcmFjdGVyPXRleHR1cmUoYXNjaWlUZXh0dXJlLGNoYXJhY3RlclV2KS5yO1xuI2lmZGVmIFVTRV9DT0xPUlxub3V0cHV0Q29sb3I9dmVjNChjb2xvciphc2NpaUNoYXJhY3RlcixpbnB1dENvbG9yLmEpO1xuI2Vsc2Vcbm91dHB1dENvbG9yPXZlYzQodGV4ZWwucmdiKmFzY2lpQ2hhcmFjdGVyLGlucHV0Q29sb3IuYSk7XG4jZW5kaWZcbn1gO1xuXG4vLyBzcmMvZWZmZWN0cy9BU0NJSUVmZmVjdC5qc1xudmFyIEFTQ0lJRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBBU0NJSSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtBU0NJSVRleHR1cmV9IFtvcHRpb25zLmFzY2lpVGV4dHVyZV0gLSBBbiBBU0NJSSBjaGFyYWN0ZXIgbG9va3VwIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jZWxsU2l6ZT0xNl0gLSBUaGUgY2VsbCBzaXplLiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBldmVuIG51bWJlcnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2xvcj1udWxsXSAtIEEgY29sb3IgdG8gdXNlIGluc3RlYWQgb2YgdGhlIHNjZW5lIGNvbG9ycy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbnZlcnRlZD1mYWxzZV0gLSBJbnZlcnRzIHRoZSBlZmZlY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYXNjaWlUZXh0dXJlID0gbmV3IEFTQ0lJVGV4dHVyZSgpLFxuICAgIGNlbGxTaXplID0gMTYsXG4gICAgY29sb3I6IGNvbG9yMiA9IG51bGwsXG4gICAgaW52ZXJ0ZWQgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkFTQ0lJRWZmZWN0XCIsIGFzY2lpX2RlZmF1bHQsIHtcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImFzY2lpVGV4dHVyZVwiLCBuZXcgVW5pZm9ybTMobnVsbCldLFxuICAgICAgICBbXCJjZWxsQ291bnRcIiwgbmV3IFVuaWZvcm0zKG5ldyBWZWN0b3I0KCkpXSxcbiAgICAgICAgW1wiY29sb3JcIiwgbmV3IFVuaWZvcm0zKG5ldyBDb2xvcjIoKSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuX2NlbGxTaXplID0gLTE7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIzKCk7XG4gICAgdGhpcy5hc2NpaVRleHR1cmUgPSBhc2NpaVRleHR1cmU7XG4gICAgdGhpcy5jZWxsU2l6ZSA9IGNlbGxTaXplO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjI7XG4gICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBBU0NJSSBsb29rdXAgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge0FTQ0lJVGV4dHVyZX1cbiAgICovXG4gIGdldCBhc2NpaVRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiYXNjaWlUZXh0dXJlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBhc2NpaVRleHR1cmUodmFsdWUpIHtcbiAgICBjb25zdCBjdXJyZW50VGV4dHVyZSA9IHRoaXMudW5pZm9ybXMuZ2V0KFwiYXNjaWlUZXh0dXJlXCIpLnZhbHVlO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYXNjaWlUZXh0dXJlXCIpLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKGN1cnJlbnRUZXh0dXJlICE9PSBudWxsICYmIGN1cnJlbnRUZXh0dXJlICE9PSB2YWx1ZSkge1xuICAgICAgY3VycmVudFRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNlbGxDb3VudCA9IHZhbHVlLmNlbGxDb3VudDtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJDSEFSX0NPVU5UX01JTlVTX09ORVwiLCAodmFsdWUuY2hhcmFjdGVyQ291bnQgLSAxKS50b0ZpeGVkKDEpKTtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJURVhfQ0VMTF9DT1VOVFwiLCBjZWxsQ291bnQudG9GaXhlZCgxKSk7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiSU5WX1RFWF9DRUxMX0NPVU5UXCIsICgxIC8gY2VsbENvdW50KS50b0ZpeGVkKDkpKTtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQSBjb2xvciB0aGF0IG92ZXJyaWRlcyB0aGUgc2NlbmUgY29sb3JzLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3IgfCBTdHJpbmcgfCBOdW1iZXIgfCBudWxsfVxuICAgKi9cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImNvbG9yXCIpLnZhbHVlO1xuICB9XG4gIHNldCBjb2xvcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJjb2xvclwiKS52YWx1ZS5zZXQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWZpbmVzLmhhcyhcIlVTRV9DT0xPUlwiKSAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlVTRV9DT0xPUlwiKTtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZGVmaW5lcy5oYXMoXCJVU0VfQ09MT1JcIikgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJVU0VfQ09MT1JcIiwgXCIxXCIpO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb250cm9scyB3aGV0aGVyIHRoZSBlZmZlY3Qgc2hvdWxkIGJlIGludmVydGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIklOVkVSVEVEXCIpO1xuICB9XG4gIHNldCBpbnZlcnRlZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmludmVydGVkICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJJTlZFUlRFRFwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiSU5WRVJURURcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjZWxsIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY2VsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NlbGxTaXplO1xuICB9XG4gIHNldCBjZWxsU2l6ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9jZWxsU2l6ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2NlbGxTaXplID0gdmFsdWU7XG4gICAgICB0aGlzLnVwZGF0ZUNlbGxDb3VudCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2VsbCBjb3VudCB1bmlmb3JtLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlQ2VsbENvdW50KCkge1xuICAgIGNvbnN0IGNlbGxDb3VudCA9IHRoaXMudW5pZm9ybXMuZ2V0KFwiY2VsbENvdW50XCIpLnZhbHVlO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgY2VsbENvdW50LnggPSByZXNvbHV0aW9uLndpZHRoIC8gdGhpcy5jZWxsU2l6ZTtcbiAgICBjZWxsQ291bnQueSA9IHJlc29sdXRpb24uaGVpZ2h0IC8gdGhpcy5jZWxsU2l6ZTtcbiAgICBjZWxsQ291bnQueiA9IDEgLyBjZWxsQ291bnQueDtcbiAgICBjZWxsQ291bnQudyA9IDEgLyBjZWxsQ291bnQueTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMudXBkYXRlQ2VsbENvdW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMgYW5kIHRleHR1cmVzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5hc2NpaVRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYXNjaWlUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9CbG9vbUVmZmVjdC5qc1xuaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2U1LCBVbmlmb3JtIGFzIFVuaWZvcm04LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDggfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VudW1zL0tlcm5lbFNpemUuanNcbnZhciBLZXJuZWxTaXplID0ge1xuICBWRVJZX1NNQUxMOiAwLFxuICBTTUFMTDogMSxcbiAgTUVESVVNOiAyLFxuICBMQVJHRTogMyxcbiAgVkVSWV9MQVJHRTogNCxcbiAgSFVHRTogNVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9LYXdhc2VCbHVyUGFzcy5qc1xuaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2UzLCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUzLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9LYXdhc2VCbHVyTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzIsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMywgVW5pZm9ybSBhcyBVbmlmb3JtNCwgVmVjdG9yNCBhcyBWZWN0b3I0MiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24ua2F3YXNlLmZyYWdcbnZhciBjb252b2x1dGlvbl9rYXdhc2VfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbmRpZlxudmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dm9pZCBtYWluKCl7dmVjNCBzdW09dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjApO3N1bSs9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpO3N1bSs9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjIpO3N1bSs9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjMpO2dsX0ZyYWdDb2xvcj1zdW0qMC4yNTtcbiNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5rYXdhc2UudmVydFxudmFyIGNvbnZvbHV0aW9uX2thd2FzZV9kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzQgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQga2VybmVsO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dm9pZCBtYWluKCl7dmVjMiB1dj1wb3NpdGlvbi54eSowLjUrMC41O3ZlYzIgZFV2PSh0ZXhlbFNpemUueHkqdmVjMihrZXJuZWwpK3RleGVsU2l6ZS56dykqc2NhbGU7dlV2MD12ZWMyKHV2LngtZFV2LngsdXYueStkVXYueSk7dlV2MT12ZWMyKHV2LngrZFV2LngsdXYueStkVXYueSk7dlV2Mj12ZWMyKHV2LngrZFV2LngsdXYueS1kVXYueSk7dlV2Mz12ZWMyKHV2LngtZFV2LngsdXYueS1kVXYueSk7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9LYXdhc2VCbHVyTWF0ZXJpYWwuanNcbnZhciBrZXJuZWxQcmVzZXRzID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDFdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMl0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAyLCAyLCAzXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDIsIDMsIDQsIDQsIDVdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMiwgMywgNCwgNSwgNywgOCwgOSwgMTBdKVxuXTtcbnZhciBLYXdhc2VCbHVyTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbnZvbHV0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBUT0RPIFJlbW92ZSB0ZXhlbFNpemUgcGFyYW0uXG4gICAqIEBwYXJhbSB7VmVjdG9yNH0gW3RleGVsU2l6ZV0gLSBEZXByZWNhdGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjQyKCkpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkthd2FzZUJsdXJNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNChudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTQobmV3IFZlY3RvcjQyKCkpLFxuICAgICAgICBzY2FsZTogbmV3IFVuaWZvcm00KDEpLFxuICAgICAgICBrZXJuZWw6IG5ldyBVbmlmb3JtNCgwKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMixcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGNvbnZvbHV0aW9uX2thd2FzZV9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb252b2x1dGlvbl9rYXdhc2VfZGVmYXVsdDJcbiAgICB9KTtcbiAgICB0aGlzLnNldFRleGVsU2l6ZSh0ZXhlbFNpemUueCwgdGV4ZWxTaXplLnkpO1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuTUVESVVNO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMuaW5wdXRCdWZmZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGtlcm5lbCBzZXF1ZW5jZSBmb3IgdGhlIGN1cnJlbnQga2VybmVsIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gICAqL1xuICBnZXQga2VybmVsU2VxdWVuY2UoKSB7XG4gICAgcmV0dXJuIGtlcm5lbFByZXNldHNbdGhpcy5rZXJuZWxTaXplXTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUuXG4gICAqL1xuICBnZXRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgLSBUaGUgc2NhbGUuXG4gICAqL1xuICBzZXRTY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2VybmVsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IFRoZSBrZXJuZWwuXG4gICAqIEBkZXByZWNhdGVkIEltcGxlbWVudGF0aW9uIGRldGFpbCwgcmVtb3ZlZCB3aXRoIG5vIHJlcGxhY2VtZW50LlxuICAgKi9cbiAgZ2V0S2VybmVsKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBrZXJuZWwuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQga2VybmVsKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmtlcm5lbC52YWx1ZTtcbiAgfVxuICBzZXQga2VybmVsKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5rZXJuZWwudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBrZXJuZWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBrZXJuZWwgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGtlcm5lbC5cbiAgICovXG4gIHNldEtlcm5lbCh2YWx1ZSkge1xuICAgIHRoaXMua2VybmVsID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleGVsIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRTaXplKCkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgdGV4ZWwgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHRleGVsIGhlaWdodC5cbiAgICovXG4gIHNldFRleGVsU2l6ZSh4LCB5KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KHgsIHksIHggKiAwLjUsIHkgKiAwLjUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgeCA9IDEgLyB3aWR0aCwgeSA9IDEgLyBoZWlnaHQ7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KHgsIHksIHggKiAwLjUsIHkgKiAwLjUpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0thd2FzZUJsdXJQYXNzLmpzXG52YXIgS2F3YXNlQmx1clBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBLYXdhc2UgYmx1ciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLk1FRElVTV0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU0sXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkthd2FzZUJsdXJQYXNzXCIpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDUoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQVwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QS5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLm5hbWUgPSBcIkJsdXIuVGFyZ2V0LkJcIjtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLl9ibHVyTWF0ZXJpYWwgPSBuZXcgS2F3YXNlQmx1ck1hdGVyaWFsKCk7XG4gICAgdGhpcy5fYmx1ck1hdGVyaWFsLmtlcm5lbFNpemUgPSBrZXJuZWxTaXplO1xuICAgIHRoaXMuY29weU1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtLYXdhc2VCbHVyTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgYmx1ck1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLl9ibHVyTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7S2F3YXNlQmx1ck1hdGVyaWFsfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXQgYmx1ck1hdGVyaWFsKHZhbHVlKSB7XG4gICAgdGhpcy5fYmx1ck1hdGVyaWFsID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRpdGhlcmluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlNYXRlcmlhbC5kaXRoZXJpbmcgaW5zdGVhZC5cbiAgICovXG4gIGdldCBkaXRoZXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29weU1hdGVyaWFsLmRpdGhlcmluZztcbiAgfVxuICBzZXQgZGl0aGVyaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5jb3B5TWF0ZXJpYWwuZGl0aGVyaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0tlcm5lbFNpemV9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwua2VybmVsU2l6ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGtlcm5lbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1ck1hdGVyaWFsLmtlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5rZXJuZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ud2lkdGggaW5zdGVhZC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXIgd2lkdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLnByZWZlcnJlZFdpZHRoIGluc3RlYWQuXG4gICAqL1xuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24uaGVpZ2h0IGluc3RlYWQuXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXIgaGVpZ2h0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwuc2NhbGUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyTWF0ZXJpYWwuc2NhbGU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1ck1hdGVyaWFsLnNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNjYWxlLlxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1ck1hdGVyaWFsLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1ck1hdGVyaWFsLnNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwua2VybmVsU2l6ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtLZXJuZWxTaXplfSBUaGUga2VybmVsIHNpemUuXG4gICAqL1xuICBnZXRLZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmtlcm5lbFNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBMYXJnZXIga2VybmVscyByZXF1aXJlIG1vcmUgcHJvY2Vzc2luZyBwb3dlciBidXQgc2NhbGUgd2VsbCB3aXRoIGxhcmdlciByZW5kZXIgcmVzb2x1dGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwua2VybmVsU2l6ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IHZhbHVlIC0gVGhlIGtlcm5lbCBzaXplLlxuICAgKi9cbiAgc2V0S2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIG5ldyByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvblNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnNjYWxlID0gc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGJsdXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRBID0gdGhpcy5yZW5kZXJUYXJnZXRBO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEIgPSB0aGlzLnJlbmRlclRhcmdldEI7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmJsdXJNYXRlcmlhbDtcbiAgICBjb25zdCBrZXJuZWxTZXF1ZW5jZSA9IG1hdGVyaWFsLmtlcm5lbFNlcXVlbmNlO1xuICAgIGxldCBwcmV2aW91c0J1ZmZlciA9IGlucHV0QnVmZmVyO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXJuZWxTZXF1ZW5jZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IChpICYgMSkgPT09IDAgPyByZW5kZXJUYXJnZXRBIDogcmVuZGVyVGFyZ2V0QjtcbiAgICAgIG1hdGVyaWFsLmtlcm5lbCA9IGtlcm5lbFNlcXVlbmNlW2ldO1xuICAgICAgbWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBwcmV2aW91c0J1ZmZlci50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGJ1ZmZlcik7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBwcmV2aW91c0J1ZmZlciA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB0aGlzLmNvcHlNYXRlcmlhbDtcbiAgICB0aGlzLmNvcHlNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogb3V0cHV0QnVmZmVyKTtcbiAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUzKSB7XG4gICAgICAgIHRoaXMuYmx1ck1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgICAgdGhpcy5jb3B5TWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgfSBlbHNlIGlmIChyZW5kZXJlciAhPT0gbnVsbCAmJiByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZTMpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMztcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFuIGF1dG8gc2l6aW5nIGZsYWcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgUmVzb2x1dGlvbi5BVVRPX1NJWkV9IGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgZ2V0IEFVVE9fU0laRSgpIHtcbiAgICByZXR1cm4gUmVzb2x1dGlvbi5BVVRPX1NJWkU7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTHVtaW5hbmNlUGFzcy5qc1xuaW1wb3J0IHsgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlNCwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQ2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvTHVtaW5hbmNlTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzMsIFJFVklTSU9OLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDQsIFVuaWZvcm0gYXMgVW5pZm9ybTUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2x1bWluYW5jZS5mcmFnXG52YXIgbHVtaW5hbmNlX2RlZmF1bHQgPSBgI2luY2x1ZGUgPGNvbW1vbj5cbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG4jaWZkZWYgUkFOR0VcbnVuaWZvcm0gdmVjMiByYW5nZTtcbiNlbGlmIGRlZmluZWQoVEhSRVNIT0xEKVxudW5pZm9ybSBmbG9hdCB0aHJlc2hvbGQ7dW5pZm9ybSBmbG9hdCBzbW9vdGhpbmc7XG4jZW5kaWZcbnZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtmbG9hdCBsPWx1bWluYW5jZSh0ZXhlbC5yZ2IpO2Zsb2F0IG1hc2s9MS4wO1xuI2lmZGVmIFJBTkdFXG5mbG9hdCBsb3c9c3RlcChyYW5nZS54LGwpO2Zsb2F0IGhpZ2g9c3RlcChsLHJhbmdlLnkpO21hc2s9bG93KmhpZ2g7XG4jZWxpZiBkZWZpbmVkKFRIUkVTSE9MRClcbm1hc2s9c21vb3Roc3RlcCh0aHJlc2hvbGQsdGhyZXNob2xkK3Ntb290aGluZyxsKTtcbiNlbmRpZlxuI2lmZGVmIENPTE9SXG5nbF9GcmFnQ29sb3I9dGV4ZWwqbWFzaztcbiNlbHNlXG5nbF9GcmFnQ29sb3I9dmVjNChsKm1hc2spO1xuI2VuZGlmXG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9MdW1pbmFuY2VNYXRlcmlhbC5qc1xudmFyIEx1bWluYW5jZU1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbG9yT3V0cHV0PWZhbHNlXSAtIERlZmluZXMgd2hldGhlciB0aGUgc2hhZGVyIHNob3VsZCBvdXRwdXQgY29sb3JzIHNjYWxlZCB3aXRoIHRoZWlyIGx1bWluYW5jZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbbHVtaW5hbmNlUmFuZ2VdIC0gSWYgcHJvdmlkZWQsIHRoZSBzaGFkZXIgd2lsbCBtYXNrIG91dCB0ZXhlbHMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNwZWNpZmllZCBsdW1pbmFuY2UgcmFuZ2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2xvck91dHB1dCA9IGZhbHNlLCBsdW1pbmFuY2VSYW5nZSA9IG51bGwpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkx1bWluYW5jZU1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIFRIUkVFX1JFVklTSU9OOiBSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csIFwiXCIpXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNShudWxsKSxcbiAgICAgICAgdGhyZXNob2xkOiBuZXcgVW5pZm9ybTUoMCksXG4gICAgICAgIHNtb290aGluZzogbmV3IFVuaWZvcm01KDEpLFxuICAgICAgICByYW5nZTogbmV3IFVuaWZvcm01KG51bGwpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmczLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogbHVtaW5hbmNlX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gICAgdGhpcy5jb2xvck91dHB1dCA9IGNvbG9yT3V0cHV0O1xuICAgIHRoaXMubHVtaW5hbmNlUmFuZ2UgPSBsdW1pbmFuY2VSYW5nZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50aHJlc2hvbGQudmFsdWU7XG4gIH1cbiAgc2V0IHRocmVzaG9sZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnNtb290aGluZyA+IDAgfHwgdmFsdWUgPiAwKSB7XG4gICAgICB0aGlzLmRlZmluZXMuVEhSRVNIT0xEID0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuVEhSRVNIT0xEO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLnRocmVzaG9sZC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhyZXNob2xkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIGdldFRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGx1bWluYW5jZSB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aHJlc2hvbGQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIHNldFRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMudGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgdGhyZXNob2xkIHNtb290aGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzbW9vdGhpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc21vb3RoaW5nLnZhbHVlO1xuICB9XG4gIHNldCBzbW9vdGhpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy50aHJlc2hvbGQgPiAwIHx8IHZhbHVlID4gMCkge1xuICAgICAgdGhpcy5kZWZpbmVzLlRIUkVTSE9MRCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlRIUkVTSE9MRDtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5zbW9vdGhpbmcudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbHVtaW5hbmNlIHRocmVzaG9sZCBzbW9vdGhpbmcgZmFjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc21vb3RoaW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNtb290aGluZyBmYWN0b3IuXG4gICAqL1xuICBnZXRTbW9vdGhpbmdGYWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc21vb3RoaW5nO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkIHNtb290aGluZyBmYWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzbW9vdGhpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNtb290aGluZyBmYWN0b3IuXG4gICAqL1xuICBzZXRTbW9vdGhpbmdGYWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnNtb290aGluZyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbHVtaW5hbmNlIHRocmVzaG9sZCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgQWRqdXN0IHRoZSB0aHJlc2hvbGQgb3Igc21vb3RoaW5nIGZhY3RvciBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHVzZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aHJlc2hvbGQgPiAwIHx8IHRoaXMuc21vb3RoaW5nID4gMDtcbiAgfVxuICBzZXQgdXNlVGhyZXNob2xkKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvbG9yIG91dHB1dCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBjb2xvck91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLkNPTE9SICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGNvbG9yT3V0cHV0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuQ09MT1IgPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5DT0xPUjtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvbG9yIG91dHB1dCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JPdXRwdXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBjb2xvciBvdXRwdXQgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzQ29sb3JPdXRwdXRFbmFibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JPdXRwdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgY29sb3Igb3V0cHV0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JPdXRwdXQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgY29sb3Igb3V0cHV0IHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0Q29sb3JPdXRwdXRFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvck91dHB1dCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBsdW1pbmFuY2UgbWFza2luZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCB1c2VSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VSYW5nZSAhPT0gbnVsbDtcbiAgfVxuICBzZXQgdXNlUmFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLmx1bWluYW5jZVJhbmdlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSByYW5nZS4gU2V0IHRvIG51bGwgdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgbHVtaW5hbmNlUmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmFuZ2UudmFsdWU7XG4gIH1cbiAgc2V0IGx1bWluYW5jZVJhbmdlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlZmluZXMuUkFOR0UgPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5SQU5HRTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5yYW5nZS52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGx1bWluYW5jZSByYW5nZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1bWluYW5jZVJhbmdlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBsdW1pbmFuY2UgcmFuZ2UuXG4gICAqL1xuICBnZXRMdW1pbmFuY2VSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VSYW5nZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIGx1bWluYW5jZSByYW5nZS4gU2V0IHRvIG51bGwgdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1bWluYW5jZVJhbmdlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdmFsdWUgLSBUaGUgbHVtaW5hbmNlIHJhbmdlLlxuICAgKi9cbiAgc2V0THVtaW5hbmNlUmFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLmx1bWluYW5jZVJhbmdlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTHVtaW5hbmNlUGFzcy5qc1xudmFyIEx1bWluYW5jZVBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBsdW1pbmFuY2UgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLiBTZWUge0BsaW5rIEx1bWluYW5jZU1hdGVyaWFsfSBmb3IgYWRkaXRpb25hbCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBbb3B0aW9ucy5yZW5kZXJUYXJnZXRdIC0gQSBjdXN0b20gcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZW5kZXJUYXJnZXQsXG4gICAgbHVtaW5hbmNlUmFuZ2UsXG4gICAgY29sb3JPdXRwdXQsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJMdW1pbmFuY2VQYXNzXCIpO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbmV3IEx1bWluYW5jZU1hdGVyaWFsKGNvbG9yT3V0cHV0LCBsdW1pbmFuY2VSYW5nZSk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICBpZiAodGhpcy5yZW5kZXJUYXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQ2KDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJMdW1pbmFuY2VQYXNzLlRhcmdldFwiO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgIG1hdGVyaWFsLmlucHV0QnVmZmVyID0gaW5wdXRCdWZmZXIudGV4dHVyZTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCAmJiBmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGU0KSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL01pcG1hcEJsdXJQYXNzLmpzXG5pbXBvcnQgeyBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTQsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTUsIFZlY3RvcjIgYXMgVmVjdG9yMjYsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0NyB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0Rvd25zYW1wbGluZ01hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc0LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDUsIFVuaWZvcm0gYXMgVW5pZm9ybTYsIFZlY3RvcjIgYXMgVmVjdG9yMjQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmRvd25zYW1wbGluZy5mcmFnXG52YXIgY29udm9sdXRpb25fZG93bnNhbXBsaW5nX2RlZmF1bHQgPSBgI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbiNkZWZpbmUgV0VJR0hUX0lOTkVSIDAuMTI1XG4jZGVmaW5lIFdFSUdIVF9PVVRFUiAwLjA1NTU1NTVcbnZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjAwO3ZhcnlpbmcgdmVjMiB2VXYwMTt2YXJ5aW5nIHZlYzIgdlV2MDI7dmFyeWluZyB2ZWMyIHZVdjAzO3ZhcnlpbmcgdmVjMiB2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2O3ZhcnlpbmcgdmVjMiB2VXYwNzt2YXJ5aW5nIHZlYzIgdlV2MDg7dmFyeWluZyB2ZWMyIHZVdjA5O3ZhcnlpbmcgdmVjMiB2VXYxMDt2YXJ5aW5nIHZlYzIgdlV2MTE7ZmxvYXQgY2xhbXBUb0JvcmRlcihjb25zdCBpbiB2ZWMyIHV2KXtyZXR1cm4gZmxvYXQodXYucz49MC4wJiZ1di5zPD0xLjAmJnV2LnQ+PTAuMCYmdXYudDw9MS4wKTt9dm9pZCBtYWluKCl7dmVjNCBjPXZlYzQoMC4wKTt2ZWM0IHc9V0VJR0hUX0lOTkVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwMCksY2xhbXBUb0JvcmRlcih2VXYwMSksY2xhbXBUb0JvcmRlcih2VXYwMiksY2xhbXBUb0JvcmRlcih2VXYwMykpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDApO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDEpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDIpO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDMpO3c9V0VJR0hUX09VVEVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwNCksY2xhbXBUb0JvcmRlcih2VXYwNSksY2xhbXBUb0JvcmRlcih2VXYwNiksY2xhbXBUb0JvcmRlcih2VXYwNykpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDQpO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDUpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDYpO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDcpO3c9V0VJR0hUX09VVEVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwOCksY2xhbXBUb0JvcmRlcih2VXYwOSksY2xhbXBUb0JvcmRlcih2VXYxMCksY2xhbXBUb0JvcmRlcih2VXYxMSkpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDgpO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDkpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MTApO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MTEpO2MrPVdFSUdIVF9PVVRFUip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9YztcbiNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5kb3duc2FtcGxpbmcudmVydFxudmFyIGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjAwO3ZhcnlpbmcgdmVjMiB2VXYwMTt2YXJ5aW5nIHZlYzIgdlV2MDI7dmFyeWluZyB2ZWMyIHZVdjAzO3ZhcnlpbmcgdmVjMiB2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2O3ZhcnlpbmcgdmVjMiB2VXYwNzt2YXJ5aW5nIHZlYzIgdlV2MDg7dmFyeWluZyB2ZWMyIHZVdjA5O3ZhcnlpbmcgdmVjMiB2VXYxMDt2YXJ5aW5nIHZlYzIgdlV2MTE7dm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dlV2MDA9dlV2K3RleGVsU2l6ZSp2ZWMyKC0xLjAsMS4wKTt2VXYwMT12VXYrdGV4ZWxTaXplKnZlYzIoMS4wLDEuMCk7dlV2MDI9dlV2K3RleGVsU2l6ZSp2ZWMyKC0xLjAsLTEuMCk7dlV2MDM9dlV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwtMS4wKTt2VXYwND12VXYrdGV4ZWxTaXplKnZlYzIoLTIuMCwyLjApO3ZVdjA1PXZVdit0ZXhlbFNpemUqdmVjMigwLjAsMi4wKTt2VXYwNj12VXYrdGV4ZWxTaXplKnZlYzIoMi4wLDIuMCk7dlV2MDc9dlV2K3RleGVsU2l6ZSp2ZWMyKC0yLjAsMC4wKTt2VXYwOD12VXYrdGV4ZWxTaXplKnZlYzIoMi4wLDAuMCk7dlV2MDk9dlV2K3RleGVsU2l6ZSp2ZWMyKC0yLjAsLTIuMCk7dlV2MTA9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwtMi4wKTt2VXYxMT12VXYrdGV4ZWxTaXplKnZlYzIoMi4wLC0yLjApO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRG93bnNhbXBsaW5nTWF0ZXJpYWwuanNcbnZhciBEb3duc2FtcGxpbmdNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWw1IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZG93bnNhbXBsaW5nIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJEb3duc2FtcGxpbmdNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNihudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTYobmV3IFZlY3RvcjI0KCkpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc0LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fZG93bnNhbXBsaW5nX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1Vwc2FtcGxpbmdNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nNSwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWw2LCBVbmlmb3JtIGFzIFVuaWZvcm03LCBWZWN0b3IyIGFzIFZlY3RvcjI1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi51cHNhbXBsaW5nLmZyYWdcbnZhciBjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQgPSBgI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO3VuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgc3VwcG9ydEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO3VuaWZvcm0gbG93cCBzYW1wbGVyMkQgc3VwcG9ydEJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSBmbG9hdCByYWRpdXM7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2YXJ5aW5nIHZlYzIgdlV2NDt2YXJ5aW5nIHZlYzIgdlV2NTt2YXJ5aW5nIHZlYzIgdlV2Njt2YXJ5aW5nIHZlYzIgdlV2Nzt2b2lkIG1haW4oKXt2ZWM0IGM9dmVjNCgwLjApO2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjMpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpKjAuMjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjQpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY1KSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjYpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY3KSowLjA2MjU7dmVjNCBiYXNlQ29sb3I9dGV4dHVyZTJEKHN1cHBvcnRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9bWl4KGJhc2VDb2xvcixjLHJhZGl1cyk7XG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24udXBzYW1wbGluZy52ZXJ0XG52YXIgY29udm9sdXRpb25fdXBzYW1wbGluZ19kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dmFyeWluZyB2ZWMyIHZVdjQ7dmFyeWluZyB2ZWMyIHZVdjU7dmFyeWluZyB2ZWMyIHZVdjY7dmFyeWluZyB2ZWMyIHZVdjc7dm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dlV2MD12VXYrdGV4ZWxTaXplKnZlYzIoLTEuMCwxLjApO3ZVdjE9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwxLjApO3ZVdjI9dlV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwxLjApO3ZVdjM9dlV2K3RleGVsU2l6ZSp2ZWMyKC0xLjAsMC4wKTt2VXY0PXZVdit0ZXhlbFNpemUqdmVjMigxLjAsMC4wKTt2VXY1PXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLC0xLjApO3ZVdjY9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwtMS4wKTt2VXY3PXZVdit0ZXhlbFNpemUqdmVjMigxLjAsLTEuMCk7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9VcHNhbXBsaW5nTWF0ZXJpYWwuanNcbnZhciBVcHNhbXBsaW5nTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHVwc2FtcGxpbmcgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIlVwc2FtcGxpbmdNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNyhudWxsKSxcbiAgICAgICAgc3VwcG9ydEJ1ZmZlcjogbmV3IFVuaWZvcm03KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNyhuZXcgVmVjdG9yMjUoKSksXG4gICAgICAgIHJhZGl1czogbmV3IFVuaWZvcm03KDAuODUpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc1LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fdXBzYW1wbGluZ19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQyXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBIHN1cHBvcnQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBzdXBwb3J0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zdXBwb3J0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIHJhZGl1cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmFkaXVzLnZhbHVlO1xuICB9XG4gIHNldCByYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTWlwbWFwQmx1clBhc3MuanNcbnZhciBNaXBtYXBCbHVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG1pcG1hcCBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiTWlwbWFwQmx1clBhc3NcIik7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDcoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJVcHNhbXBsaW5nLk1pcG1hcDBcIjtcbiAgICB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMgPSBbXTtcbiAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzID0gW107XG4gICAgdGhpcy5kb3duc2FtcGxpbmdNYXRlcmlhbCA9IG5ldyBEb3duc2FtcGxpbmdNYXRlcmlhbCgpO1xuICAgIHRoaXMudXBzYW1wbGluZ01hdGVyaWFsID0gbmV3IFVwc2FtcGxpbmdNYXRlcmlhbCgpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyNigpO1xuICB9XG4gIC8qKlxuICAgKiBBIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgYmx1cnJlZCByZXN1bHQuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNSVAgbGV2ZWxzLiBEZWZhdWx0IGlzIDguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMubGVuZ3RoO1xuICB9XG4gIHNldCBsZXZlbHModmFsdWUpIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgIT09IHZhbHVlKSB7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzID0gW107XG4gICAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlOyArK2kpIHtcbiAgICAgICAgY29uc3QgbWlwbWFwID0gcmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgICAgIG1pcG1hcC50ZXh0dXJlLm5hbWUgPSBcIkRvd25zYW1wbGluZy5NaXBtYXBcIiArIGk7XG4gICAgICAgIHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwcy5wdXNoKG1pcG1hcCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzLnB1c2gocmVuZGVyVGFyZ2V0KTtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gdmFsdWUgLSAxOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1pcG1hcCA9IHJlbmRlclRhcmdldC5jbG9uZSgpO1xuICAgICAgICBtaXBtYXAudGV4dHVyZS5uYW1lID0gXCJVcHNhbXBsaW5nLk1pcG1hcFwiICsgaTtcbiAgICAgICAgdGhpcy51cHNhbXBsaW5nTWlwbWFwcy5wdXNoKG1pcG1hcCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLngsIHRoaXMucmVzb2x1dGlvbi55KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIHJhZGl1cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBzYW1wbGluZ01hdGVyaWFsLnJhZGl1cztcbiAgfVxuICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy51cHNhbXBsaW5nTWF0ZXJpYWwucmFkaXVzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGJsdXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHsgc2NlbmUsIGNhbWVyYSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGRvd25zYW1wbGluZ01hdGVyaWFsLCB1cHNhbXBsaW5nTWF0ZXJpYWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBkb3duc2FtcGxpbmdNaXBtYXBzLCB1cHNhbXBsaW5nTWlwbWFwcyB9ID0gdGhpcztcbiAgICBsZXQgcHJldmlvdXNCdWZmZXIgPSBpbnB1dEJ1ZmZlcjtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IGRvd25zYW1wbGluZ01hdGVyaWFsO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZG93bnNhbXBsaW5nTWlwbWFwcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGNvbnN0IG1pcG1hcCA9IGRvd25zYW1wbGluZ01pcG1hcHNbaV07XG4gICAgICBkb3duc2FtcGxpbmdNYXRlcmlhbC5zZXRTaXplKHByZXZpb3VzQnVmZmVyLndpZHRoLCBwcmV2aW91c0J1ZmZlci5oZWlnaHQpO1xuICAgICAgZG93bnNhbXBsaW5nTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBwcmV2aW91c0J1ZmZlci50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG1pcG1hcCk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBwcmV2aW91c0J1ZmZlciA9IG1pcG1hcDtcbiAgICB9XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB1cHNhbXBsaW5nTWF0ZXJpYWw7XG4gICAgZm9yIChsZXQgaSA9IHVwc2FtcGxpbmdNaXBtYXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBtaXBtYXAgPSB1cHNhbXBsaW5nTWlwbWFwc1tpXTtcbiAgICAgIHVwc2FtcGxpbmdNYXRlcmlhbC5zZXRTaXplKHByZXZpb3VzQnVmZmVyLndpZHRoLCBwcmV2aW91c0J1ZmZlci5oZWlnaHQpO1xuICAgICAgdXBzYW1wbGluZ01hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICAgIHVwc2FtcGxpbmdNYXRlcmlhbC5zdXBwb3J0QnVmZmVyID0gZG93bnNhbXBsaW5nTWlwbWFwc1tpXS50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG1pcG1hcCk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBwcmV2aW91c0J1ZmZlciA9IG1pcG1hcDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBsZXQgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIHcgPSBNYXRoLnJvdW5kKHcgKiAwLjUpO1xuICAgICAgaCA9IE1hdGgucm91bmQoaCAqIDAuNSk7XG4gICAgICB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHNbaV0uc2V0U2l6ZSh3LCBoKTtcbiAgICAgIGlmIChpIDwgdGhpcy51cHNhbXBsaW5nTWlwbWFwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cHNhbXBsaW5nTWlwbWFwc1tpXS5zZXRTaXplKHcsIGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBtaXBtYXBzID0gdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzLmNvbmNhdCh0aGlzLnVwc2FtcGxpbmdNaXBtYXBzKTtcbiAgICAgIGZvciAoY29uc3QgbWlwbWFwIG9mIG1pcG1hcHMpIHtcbiAgICAgICAgbWlwbWFwLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGU1KSB7XG4gICAgICAgIHRoaXMuZG93bnNhbXBsaW5nTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgICB0aGlzLnVwc2FtcGxpbmdNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlNCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1pcG1hcCBvZiBtaXBtYXBzKSB7XG4gICAgICAgICAgbWlwbWFwLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cyBhbmQgdGV4dHVyZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1pcG1hcCBvZiB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMuY29uY2F0KHRoaXMudXBzYW1wbGluZ01pcG1hcHMpKSB7XG4gICAgICBtaXBtYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9ibG9vbS5mcmFnXG52YXIgYmxvb21fZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFwO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xuI2VuZGlmXG51bmlmb3JtIGZsb2F0IGludGVuc2l0eTt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjNCB0ZXhlbD10ZXh0dXJlMkQobWFwLHV2KTtvdXRwdXRDb2xvcj12ZWM0KHRleGVsLnJnYippbnRlbnNpdHksbWF4KGlucHV0Q29sb3IuYSx0ZXhlbC5hKSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0Jsb29tRWZmZWN0LmpzXG52YXIgQmxvb21FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJsb29tIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TQ1JFRU5dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlVGhyZXNob2xkPTEuMF0gLSBUaGUgbHVtaW5hbmNlIHRocmVzaG9sZC4gUmFpc2UgdGhpcyB2YWx1ZSB0byBtYXNrIG91dCBkYXJrZXIgZWxlbWVudHMgaW4gdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlU21vb3RoaW5nPTAuMDNdIC0gQ29udHJvbHMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGx1bWluYW5jZSB0aHJlc2hvbGQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWlwbWFwQmx1cj10cnVlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgbWlwbWFwIGJsdXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbnRlbnNpdHk9MS4wXSAtIFRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MC44NV0gLSBUaGUgYmx1ciByYWRpdXMuIE9ubHkgYXBwbGllcyB0byBtaXBtYXAgYmx1ci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxldmVscz04XSAtIFRoZSBhbW91bnQgb2YgTUlQIGxldmVscy4gT25seSBhcHBsaWVzIHRvIG1pcG1hcCBibHVyLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5MQVJHRV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIG1pcG1hcEJsdXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU0NSRUVOLFxuICAgIGx1bWluYW5jZVRocmVzaG9sZCA9IDEsXG4gICAgbHVtaW5hbmNlU21vb3RoaW5nID0gMC4wMyxcbiAgICBtaXBtYXBCbHVyID0gdHJ1ZSxcbiAgICBpbnRlbnNpdHkgPSAxLFxuICAgIHJhZGl1cyA9IDAuODUsXG4gICAgbGV2ZWxzID0gOCxcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5MQVJHRSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQmxvb21FZmZlY3RcIiwgYmxvb21fZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTgobnVsbCldLFxuICAgICAgICBbXCJpbnRlbnNpdHlcIiwgbmV3IFVuaWZvcm04KGludGVuc2l0eSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0OCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkJsb29tLlRhcmdldFwiO1xuICAgIHRoaXMuYmx1clBhc3MgPSBuZXcgS2F3YXNlQmx1clBhc3MoeyBrZXJuZWxTaXplIH0pO1xuICAgIHRoaXMubHVtaW5hbmNlUGFzcyA9IG5ldyBMdW1pbmFuY2VQYXNzKHsgY29sb3JPdXRwdXQ6IHRydWUgfSk7XG4gICAgdGhpcy5sdW1pbmFuY2VNYXRlcmlhbC50aHJlc2hvbGQgPSBsdW1pbmFuY2VUaHJlc2hvbGQ7XG4gICAgdGhpcy5sdW1pbmFuY2VNYXRlcmlhbC5zbW9vdGhpbmcgPSBsdW1pbmFuY2VTbW9vdGhpbmc7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcyA9IG5ldyBNaXBtYXBCbHVyUGFzcygpO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCA9IG1pcG1hcEJsdXI7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5sZXZlbHMgPSBsZXZlbHM7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWUgPSBtaXBtYXBCbHVyID8gdGhpcy5taXBtYXBCbHVyUGFzcy50ZXh0dXJlIDogdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICAvKipcbiAgICogQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIGludGVybWVkaWF0ZSByZXN1bHQgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCA/IHRoaXMubWlwbWFwQmx1clBhc3MudGV4dHVyZSA6IHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBibG9vbSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbHVtaW5hbmNlIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VQYXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0x1bWluYW5jZVBhc3N9IFRoZSBsdW1pbmFuY2UgcGFzcy5cbiAgICovXG4gIGdldEx1bWluYW5jZVBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlUGFzcztcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0x1bWluYW5jZU1hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGx1bWluYW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtMdW1pbmFuY2VNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0THVtaW5hbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXRoZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBFZmZlY3RQYXNzLmRpdGhlcmluZyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5kaXRoZXJpbmc7XG4gIH1cbiAgc2V0IGRpdGhlcmluZyh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZGl0aGVyaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7S2VybmVsU2l6ZX1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBkaXN0aW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4odGhpcy5uYW1lLCBcImRpc3RpbmN0aW9uIHdhcyByZW1vdmVkXCIpO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHNldCBkaXN0aW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnNvbGUud2Fybih0aGlzLm5hbWUsIFwiZGlzdGluY3Rpb24gd2FzIHJlbW92ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImludGVuc2l0eVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgaW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJpbnRlbnNpdHlcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsb29tIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBnZXRJbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZW5zaXR5O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGludGVuc2l0eS5cbiAgICovXG4gIHNldEludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMuaW50ZW5zaXR5ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgY29uc3QgbHVtaW5hbmNlUGFzcyA9IHRoaXMubHVtaW5hbmNlUGFzcztcbiAgICBpZiAobHVtaW5hbmNlUGFzcy5lbmFibGVkKSB7XG4gICAgICBsdW1pbmFuY2VQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIpO1xuICAgICAgaWYgKHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLm1pcG1hcEJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgbHVtaW5hbmNlUGFzcy5yZW5kZXJUYXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGx1bWluYW5jZVBhc3MucmVuZGVyVGFyZ2V0LCByZW5kZXJUYXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5taXBtYXBCbHVyUGFzcy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMubWlwbWFwQmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHJlbmRlclRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICAgIHRoaXMuYmx1clBhc3MucmVzb2x1dGlvbi5jb3B5KHJlc29sdXRpb24pO1xuICAgIHRoaXMubHVtaW5hbmNlUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmx1bWluYW5jZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCAmJiByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZTUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U1O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvQm9rZWhFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTkgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9ib2tlaC5mcmFnXG52YXIgYm9rZWhfZGVmYXVsdCA9IGB1bmlmb3JtIGZsb2F0IGZvY3VzO3VuaWZvcm0gZmxvYXQgZG9mO3VuaWZvcm0gZmxvYXQgYXBlcnR1cmU7dW5pZm9ybSBmbG9hdCBtYXhCbHVyO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMyIGFzcGVjdENvcnJlY3Rpb249dmVjMigxLjAsYXNwZWN0KTtcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcbmZsb2F0IHZpZXdaPXBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtmbG9hdCBsaW5lYXJEZXB0aD12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xuI2Vsc2VcbmZsb2F0IGxpbmVhckRlcHRoPWRlcHRoO1xuI2VuZGlmXG5mbG9hdCBmb2N1c05lYXI9Y2xhbXAoZm9jdXMtZG9mLDAuMCwxLjApO2Zsb2F0IGZvY3VzRmFyPWNsYW1wKGZvY3VzK2RvZiwwLjAsMS4wKTtmbG9hdCBsb3c9c3RlcChsaW5lYXJEZXB0aCxmb2N1c05lYXIpO2Zsb2F0IGhpZ2g9c3RlcChmb2N1c0ZhcixsaW5lYXJEZXB0aCk7ZmxvYXQgZmFjdG9yPShsaW5lYXJEZXB0aC1mb2N1c05lYXIpKmxvdysobGluZWFyRGVwdGgtZm9jdXNGYXIpKmhpZ2g7dmVjMiBkb2ZCbHVyPXZlYzIoY2xhbXAoZmFjdG9yKmFwZXJ0dXJlLC1tYXhCbHVyLG1heEJsdXIpKTt2ZWMyIGRvZmJsdXI5PWRvZkJsdXIqMC45O3ZlYzIgZG9mYmx1cjc9ZG9mQmx1ciowLjc7dmVjMiBkb2ZibHVyND1kb2ZCbHVyKjAuNDt2ZWM0IGNvbG9yPWlucHV0Q29sb3I7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjAsMC40KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjI5LDAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjQwLDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjM3LC0wLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLC0wLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwwLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4zNywtMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjE1LC0wLjM3KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4zNywtMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjE1LDAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsLTAuMTUpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC40MCwwLjApKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMCwtMC40KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNyk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwwLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNyk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMCwwLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLC0wLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI0KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjI5LDAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI0KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjQsMC4wKSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNCk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLDAuNCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO291dHB1dENvbG9yPWNvbG9yLzQxLjA7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0Jva2VoRWZmZWN0LmpzXG52YXIgQm9rZWhFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXM9MC41XSAtIFRoZSBmb2N1cyBkaXN0YW5jZSByYXRpbywgcmFuZ2luZyBmcm9tIDAuMCB0byAxLjAuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kb2Y9MC4wMl0gLSBEZXB0aCBvZiBmaWVsZC4gQW4gYXJlYSBpbiBmcm9udCBvZiBhbmQgYmVoaW5kIHRoZSBmb2NhbCBwb2ludCB0aGF0IHN0aWxsIGFwcGVhcnMgc2hhcnAuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hcGVydHVyZT0wLjAxNV0gLSBDYW1lcmEgYXBlcnR1cmUgc2NhbGUuIEJpZ2dlciB2YWx1ZXMgZm9yIHN0cm9uZ2VyIGJsdXIgYW5kIHNoYWxsb3dlciBkZXB0aCBvZiBmaWVsZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEJsdXI9MS4wXSAtIFRoZSBtYXhpbXVtIGJsdXIgc3RyZW5ndGguXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbixcbiAgICBmb2N1cyA9IDAuNSxcbiAgICBkb2YgPSAwLjAyLFxuICAgIGFwZXJ0dXJlID0gMC4wMTUsXG4gICAgbWF4Qmx1ciA9IDFcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJCb2tlaEVmZmVjdFwiLCBib2tlaF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OIHwgRWZmZWN0QXR0cmlidXRlLkRFUFRILFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZm9jdXNcIiwgbmV3IFVuaWZvcm05KGZvY3VzKV0sXG4gICAgICAgIFtcImRvZlwiLCBuZXcgVW5pZm9ybTkoZG9mKV0sXG4gICAgICAgIFtcImFwZXJ0dXJlXCIsIG5ldyBVbmlmb3JtOShhcGVydHVyZSldLFxuICAgICAgICBbXCJtYXhCbHVyXCIsIG5ldyBVbmlmb3JtOShtYXhCbHVyKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0JyaWdodG5lc3NDb250cmFzdEVmZmVjdC5qc1xuaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2U2LCBVbmlmb3JtIGFzIFVuaWZvcm0xMCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2JyaWdodG5lc3MtY29udHJhc3QuZnJhZ1xudmFyIGJyaWdodG5lc3NfY29udHJhc3RfZGVmYXVsdCA9IGB1bmlmb3JtIGZsb2F0IGJyaWdodG5lc3M7dW5pZm9ybSBmbG9hdCBjb250cmFzdDt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBjb2xvcj1pbnB1dENvbG9yLnJnYit2ZWMzKGJyaWdodG5lc3MtMC41KTtpZihjb250cmFzdD4wLjApe2NvbG9yLz12ZWMzKDEuMC1jb250cmFzdCk7fWVsc2V7Y29sb3IqPXZlYzMoMS4wK2NvbnRyYXN0KTt9b3V0cHV0Q29sb3I9dmVjNChjb2xvcit2ZWMzKDAuNSksaW5wdXRDb2xvci5hKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0LmpzXG52YXIgQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBicmlnaHRuZXNzL2NvbnRyYXN0IGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnJpZ2h0bmVzcz0wLjBdIC0gVGhlIGJyaWdodG5lc3MgZmFjdG9yLCByYW5naW5nIGZyb20gLTEgdG8gMSwgd2hlcmUgMCBtZWFucyBubyBjaGFuZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb250cmFzdD0wLjBdIC0gVGhlIGNvbnRyYXN0IGZhY3RvciwgcmFuZ2luZyBmcm9tIC0xIHRvIDEsIHdoZXJlIDAgbWVhbnMgbm8gY2hhbmdlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsIGJyaWdodG5lc3MgPSAwLCBjb250cmFzdCA9IDAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJCcmlnaHRuZXNzQ29udHJhc3RFZmZlY3RcIiwgYnJpZ2h0bmVzc19jb250cmFzdF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYnJpZ2h0bmVzc1wiLCBuZXcgVW5pZm9ybTEwKGJyaWdodG5lc3MpXSxcbiAgICAgICAgW1wiY29udHJhc3RcIiwgbmV3IFVuaWZvcm0xMChjb250cmFzdCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuaW5wdXRDb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U2O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBicmlnaHRuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImJyaWdodG5lc3NcIikudmFsdWU7XG4gIH1cbiAgc2V0IGJyaWdodG5lc3ModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImJyaWdodG5lc3NcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJyaWdodG5lc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYnJpZ2h0bmVzcy5cbiAgICovXG4gIGdldEJyaWdodG5lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJpZ2h0bmVzcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJyaWdodG5lc3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGJyaWdodG5lc3MuXG4gICAqL1xuICBzZXRCcmlnaHRuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5icmlnaHRuZXNzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb250cmFzdC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb250cmFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJjb250cmFzdFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgY29udHJhc3QodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImNvbnRyYXN0XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRyYXN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29udHJhc3QgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY29udHJhc3QuXG4gICAqL1xuICBnZXRDb250cmFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFzdDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29udHJhc3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb250cmFzdCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgY29udHJhc3QuXG4gICAqL1xuICBzZXRDb250cmFzdCh2YWx1ZSkge1xuICAgIHRoaXMuY29udHJhc3QgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9jb2xvci1hdmVyYWdlLmZyYWdcbnZhciBjb2xvcl9hdmVyYWdlX2RlZmF1bHQgPSBgdm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPXZlYzQodmVjMyhhdmVyYWdlKGlucHV0Q29sb3IucmdiKSksaW5wdXRDb2xvci5hKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvQ29sb3JBdmVyYWdlRWZmZWN0LmpzXG52YXIgQ29sb3JBdmVyYWdlRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb2xvciBhdmVyYWdlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihibGVuZEZ1bmN0aW9uKSB7XG4gICAgc3VwZXIoXCJDb2xvckF2ZXJhZ2VFZmZlY3RcIiwgY29sb3JfYXZlcmFnZV9kZWZhdWx0LCB7IGJsZW5kRnVuY3Rpb24gfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0NvbG9yRGVwdGhFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTExIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvY29sb3ItZGVwdGguZnJhZ1xudmFyIGNvbG9yX2RlcHRoX2RlZmF1bHQgPSBgdW5pZm9ybSBmbG9hdCBmYWN0b3I7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPXZlYzQoZmxvb3IoaW5wdXRDb2xvci5yZ2IqZmFjdG9yKzAuNSkvZmFjdG9yLGlucHV0Q29sb3IuYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0NvbG9yRGVwdGhFZmZlY3QuanNcbnZhciBDb2xvckRlcHRoRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb2xvciBkZXB0aCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpdHM9MTZdIC0gVGhlIGNvbG9yIGJpdCBkZXB0aC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiwgYml0cyA9IDE2IH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQ29sb3JEZXB0aEVmZmVjdFwiLCBjb2xvcl9kZXB0aF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZmFjdG9yXCIsIG5ldyBVbmlmb3JtMTEoMSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuYml0cyA9IDA7XG4gICAgdGhpcy5iaXREZXB0aCA9IGJpdHM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB2aXJ0dWFsIGFtb3VudCBvZiBjb2xvciBiaXRzLlxuICAgKlxuICAgKiBFYWNoIGNvbG9yIGNoYW5uZWwgZWZmZWN0aXZlbHkgdXNlcyBhIGZvdXJ0aCBvZiB0aGUgdG90YWwgYW1vdW50IG9mIGJpdHMuIEFscGhhIHJlbWFpbnMgdW5hZmZlY3RlZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBiaXREZXB0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5iaXRzO1xuICB9XG4gIHNldCBiaXREZXB0aCh2YWx1ZSkge1xuICAgIHRoaXMuYml0cyA9IHZhbHVlO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZmFjdG9yXCIpLnZhbHVlID0gTWF0aC5wb3coMiwgdmFsdWUgLyAzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb2xvciBiaXQgZGVwdGguXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJpdCBkZXB0aC5cbiAgICovXG4gIGdldEJpdERlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLmJpdERlcHRoO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2aXJ0dWFsIGFtb3VudCBvZiBjb2xvciBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYml0IGRlcHRoLlxuICAgKi9cbiAgc2V0Qml0RGVwdGgodmFsdWUpIHtcbiAgICB0aGlzLmJpdERlcHRoID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0Nocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTEyLCBWZWN0b3IyIGFzIFZlY3RvcjI3IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvY2hyb21hdGljLWFiZXJyYXRpb24uZnJhZ1xudmFyIGNocm9tYXRpY19hYmVycmF0aW9uX2RlZmF1bHQgPSBgI2lmZGVmIFJBRElBTF9NT0RVTEFUSU9OXG51bmlmb3JtIGZsb2F0IG1vZHVsYXRpb25PZmZzZXQ7XG4jZW5kaWZcbnZhcnlpbmcgZmxvYXQgdkFjdGl2ZTt2YXJ5aW5nIHZlYzIgdlV2Ujt2YXJ5aW5nIHZlYzIgdlV2Qjt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMiByYT1pbnB1dENvbG9yLnJhO3ZlYzIgYmE9aW5wdXRDb2xvci5iYTtcbiNpZmRlZiBSQURJQUxfTU9EVUxBVElPTlxuY29uc3QgdmVjMiBjZW50ZXI9dmVjMigwLjUpO2Zsb2F0IGQ9ZGlzdGFuY2UodXYsY2VudGVyKSoyLjA7ZD1tYXgoZC1tb2R1bGF0aW9uT2Zmc2V0LDAuMCk7aWYodkFjdGl2ZT4wLjAmJmQ+MC4wKXtyYT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsbWl4KHV2LHZVdlIsZCkpLnJhO2JhPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixtaXgodXYsdlV2QixkKSkuYmE7fVxuI2Vsc2VcbmlmKHZBY3RpdmU+MC4wKXtyYT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2UikucmE7YmE9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdkIpLmJhO31cbiNlbmRpZlxub3V0cHV0Q29sb3I9dmVjNChyYS54LGlucHV0Q29sb3IuZyxiYS54LG1heChtYXgocmEueSxiYS55KSxpbnB1dENvbG9yLmEpKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9jaHJvbWF0aWMtYWJlcnJhdGlvbi52ZXJ0XG52YXIgY2hyb21hdGljX2FiZXJyYXRpb25fZGVmYXVsdDIgPSBgdW5pZm9ybSB2ZWMyIG9mZnNldDt2YXJ5aW5nIGZsb2F0IHZBY3RpdmU7dmFyeWluZyB2ZWMyIHZVdlI7dmFyeWluZyB2ZWMyIHZVdkI7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXt2ZWMyIHNoaWZ0PW9mZnNldCp2ZWMyKDEuMCxhc3BlY3QpO3ZBY3RpdmU9KHNoaWZ0LnghPTAuMHx8c2hpZnQueSE9MC4wKT8xLjA6MC4wO3ZVdlI9dXYrc2hpZnQ7dlV2Qj11di1zaGlmdDt9YDtcblxuLy8gc3JjL2VmZmVjdHMvQ2hyb21hdGljQWJlcnJhdGlvbkVmZmVjdC5qc1xudmFyIENocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNocm9tYXRpYyBhYmVycmF0aW9uIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLm9mZnNldF0gLSBUaGUgY29sb3Igb2Zmc2V0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhZGlhbE1vZHVsYXRpb249ZmFsc2VdIC0gV2hldGhlciB0aGUgZWZmZWN0IHNob3VsZCBiZSBtb2R1bGF0ZWQgd2l0aCBhIHJhZGlhbCBncmFkaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1vZHVsYXRpb25PZmZzZXQ9MC4xNV0gLSBUaGUgbW9kdWxhdGlvbiBvZmZzZXQuIE9ubHkgYXBwbGllcyBpZiBgcmFkaWFsTW9kdWxhdGlvbmAgaXMgZW5hYmxlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvZmZzZXQgPSBuZXcgVmVjdG9yMjcoMWUtMywgNWUtNCksXG4gICAgcmFkaWFsTW9kdWxhdGlvbiA9IGZhbHNlLFxuICAgIG1vZHVsYXRpb25PZmZzZXQgPSAwLjE1XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQ2hyb21hdGljQWJlcnJhdGlvbkVmZmVjdFwiLCBjaHJvbWF0aWNfYWJlcnJhdGlvbl9kZWZhdWx0LCB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNocm9tYXRpY19hYmVycmF0aW9uX2RlZmF1bHQyLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wib2Zmc2V0XCIsIG5ldyBVbmlmb3JtMTIob2Zmc2V0KV0sXG4gICAgICAgIFtcIm1vZHVsYXRpb25PZmZzZXRcIiwgbmV3IFVuaWZvcm0xMihtb2R1bGF0aW9uT2Zmc2V0KV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yYWRpYWxNb2R1bGF0aW9uID0gcmFkaWFsTW9kdWxhdGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mZnNldC5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm9mZnNldFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJvZmZzZXRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgcmFkaWFsIG1vZHVsYXRpb24gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogV2hlbiBlbmFibGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgd2Vha2VyIGluIHRoZSBtaWRkbGUgYW5kIHN0cm9uZ2VyIHRvd2FyZHMgdGhlIHNjcmVlbiBlZGdlcy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgcmFkaWFsTW9kdWxhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIlJBRElBTF9NT0RVTEFUSU9OXCIpO1xuICB9XG4gIHNldCByYWRpYWxNb2R1bGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiUkFESUFMX01PRFVMQVRJT05cIiwgXCIxXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiUkFESUFMX01PRFVMQVRJT05cIik7XG4gICAgfVxuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbW9kdWxhdGlvbiBvZmZzZXQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbW9kdWxhdGlvbk9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJtb2R1bGF0aW9uT2Zmc2V0XCIpLnZhbHVlO1xuICB9XG4gIHNldCBtb2R1bGF0aW9uT2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtb2R1bGF0aW9uT2Zmc2V0XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbG9yIG9mZnNldCB2ZWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvZmZzZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIG9mZnNldC5cbiAgICovXG4gIGdldE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbG9yIG9mZnNldCB2ZWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvZmZzZXQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2YWx1ZSAtIFRoZSBvZmZzZXQuXG4gICAqL1xuICBzZXRPZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldCA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2RlcHRoLmZyYWdcbnZhciBkZXB0aF9kZWZhdWx0ID0gYHZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXtcbiNpZmRlZiBJTlZFUlRFRFxudmVjMyBjb2xvcj12ZWMzKDEuMC1kZXB0aCk7XG4jZWxzZVxudmVjMyBjb2xvcj12ZWMzKGRlcHRoKTtcbiNlbmRpZlxub3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9EZXB0aEVmZmVjdC5qc1xudmFyIERlcHRoRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbnZlcnRlZD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBkZXB0aCBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQywgaW52ZXJ0ZWQgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBzdXBlcihcIkRlcHRoRWZmZWN0XCIsIGRlcHRoX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuREVQVEhcbiAgICB9KTtcbiAgICB0aGlzLmludmVydGVkID0gaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRlcHRoIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJJTlZFUlRFRFwiKTtcbiAgfVxuICBzZXQgaW52ZXJ0ZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZlcnRlZCAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiSU5WRVJURURcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIklOVkVSVEVEXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVuZGVyZWQgZGVwdGggaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJlZCBkZXB0aCBpcyBpbnZlcnRlZC5cbiAgICovXG4gIGlzSW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGVwdGggaW52ZXJzaW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgZGVwdGggc2hvdWxkIGJlIGludmVydGVkLlxuICAgKi9cbiAgc2V0SW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLmludmVydGVkID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0RlcHRoT2ZGaWVsZEVmZmVjdC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmc0LCBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTcsIFVuaWZvcm0gYXMgVW5pZm9ybTE2LCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU4LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDkgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VudW1zL0NvbG9yQ2hhbm5lbC5qc1xudmFyIENvbG9yQ2hhbm5lbCA9IHtcbiAgUkVEOiAwLFxuICBHUkVFTjogMSxcbiAgQkxVRTogMixcbiAgQUxQSEE6IDNcbn07XG5cbi8vIHNyYy9lbnVtcy9NYXNrRnVuY3Rpb24uanNcbnZhciBNYXNrRnVuY3Rpb24gPSB7XG4gIERJU0NBUkQ6IDAsXG4gIE1VTFRJUExZOiAxLFxuICBNVUxUSVBMWV9SR0JfU0VUX0FMUEhBOiAyLFxuICBNVUxUSVBMWV9SR0I6IDNcbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvQm9rZWhNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nNiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWw3LCBVbmlmb3JtIGFzIFVuaWZvcm0xMywgVmVjdG9yMiBhcyBWZWN0b3IyOCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uYm9rZWguZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2Jva2VoX2RlZmF1bHQgPSBgI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbiNpZiBQQVNTID09IDFcbnVuaWZvcm0gdmVjNCBrZXJuZWw2NFszMl07XG4jZWxzZVxudW5pZm9ybSB2ZWM0IGtlcm5lbDE2WzhdO1xuI2VuZGlmXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGNvY0J1ZmZlcjt1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXtcbiNpZmRlZiBGT1JFR1JPVU5EXG52ZWMyIGNvY05lYXJGYXI9dGV4dHVyZTJEKGNvY0J1ZmZlcix2VXYpLnJnKnNjYWxlO2Zsb2F0IGNvYz1jb2NOZWFyRmFyLng7XG4jZWxzZVxuZmxvYXQgY29jPXRleHR1cmUyRChjb2NCdWZmZXIsdlV2KS5nKnNjYWxlO1xuI2VuZGlmXG5pZihjb2M9PTAuMCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpO31lbHNle1xuI2lmZGVmIEZPUkVHUk9VTkRcbnZlYzIgc3RlcD10ZXhlbFNpemUqbWF4KGNvY05lYXJGYXIueCxjb2NOZWFyRmFyLnkpO1xuI2Vsc2VcbnZlYzIgc3RlcD10ZXhlbFNpemUqY29jO1xuI2VuZGlmXG4jaWYgUEFTUyA9PSAxXG52ZWM0IGFjYz12ZWM0KDAuMCk7Zm9yKGludCBpPTA7aTwzMjsrK2kpe3ZlYzQga2VybmVsPWtlcm5lbDY0W2ldO3ZlYzIgdXY9c3RlcCprZXJuZWwueHkrdlV2O2FjYys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2KTt1dj1zdGVwKmtlcm5lbC56dyt2VXY7YWNjKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYpO31nbF9GcmFnQ29sb3I9YWNjLzY0LjA7XG4jZWxzZVxudmVjNCBtYXhWYWx1ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtmb3IoaW50IGk9MDtpPDg7KytpKXt2ZWM0IGtlcm5lbD1rZXJuZWwxNltpXTt2ZWMyIHV2PXN0ZXAqa2VybmVsLnh5K3ZVdjttYXhWYWx1ZT1tYXgodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2KSxtYXhWYWx1ZSk7dXY9c3RlcCprZXJuZWwuencrdlV2O21heFZhbHVlPW1heCh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYpLG1heFZhbHVlKTt9Z2xfRnJhZ0NvbG9yPW1heFZhbHVlO1xuI2VuZGlmXG59fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQm9rZWhNYXRlcmlhbC5qc1xudmFyIEJva2VoTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmaWxsPWZhbHNlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGJva2VoIGhpZ2hsaWdodCBmaWxsIG1vZGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmVncm91bmQ9ZmFsc2VdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgbWF0ZXJpYWwgd2lsbCBiZSBhcHBsaWVkIHRvIGZvcmVncm91bmQgY29sb3JzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsbCA9IGZhbHNlLCBmb3JlZ3JvdW5kID0gZmFsc2UpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkJva2VoTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgUEFTUzogZmlsbCA/IFwiMlwiIDogXCIxXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0xMyhudWxsKSxcbiAgICAgICAgY29jQnVmZmVyOiBuZXcgVW5pZm9ybTEzKG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMTMobmV3IFZlY3RvcjI4KCkpLFxuICAgICAgICBrZXJuZWw2NDogbmV3IFVuaWZvcm0xMyhudWxsKSxcbiAgICAgICAga2VybmVsMTY6IG5ldyBVbmlmb3JtMTMobnVsbCksXG4gICAgICAgIHNjYWxlOiBuZXcgVW5pZm9ybTEzKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc2LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fYm9rZWhfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgICBpZiAoZm9yZWdyb3VuZCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkZPUkVHUk9VTkQgPSBcIjFcIjtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0ZUtlcm5lbCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBjb2NCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmNvY0J1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvY0J1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGJ1ZmZlci5cbiAgICovXG4gIHNldENvQ0J1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuY29jQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNjYWxlLlxuICAgKi9cbiAgZ2V0U2NhbGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5zY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGJsdXIga2VybmVsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2VuZXJhdGVLZXJuZWwoKSB7XG4gICAgY29uc3QgR09MREVOX0FOR0xFID0gMi4zOTk5NjMyMztcbiAgICBjb25zdCBwb2ludHM2NCA9IG5ldyBGbG9hdDY0QXJyYXkoMTI4KTtcbiAgICBjb25zdCBwb2ludHMxNiA9IG5ldyBGbG9hdDY0QXJyYXkoMzIpO1xuICAgIGxldCBpNjQgPSAwLCBpMTYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcXJ0ODAgPSBNYXRoLnNxcnQoODApOyBpIDwgODA7ICsraSkge1xuICAgICAgY29uc3QgdGhldGEgPSBpICogR09MREVOX0FOR0xFO1xuICAgICAgY29uc3QgciA9IE1hdGguc3FydChpKSAvIHNxcnQ4MDtcbiAgICAgIGNvbnN0IHUgPSByICogTWF0aC5jb3ModGhldGEpLCB2MyA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICBpZiAoaSAlIDUgPT09IDApIHtcbiAgICAgICAgcG9pbnRzMTZbaTE2KytdID0gdTtcbiAgICAgICAgcG9pbnRzMTZbaTE2KytdID0gdjM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludHM2NFtpNjQrK10gPSB1O1xuICAgICAgICBwb2ludHM2NFtpNjQrK10gPSB2MztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5rZXJuZWw2NC52YWx1ZSA9IHBvaW50czY0O1xuICAgIHRoaXMudW5pZm9ybXMua2VybmVsMTYudmFsdWUgPSBwb2ludHMxNjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9DaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzMsIE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzcsIFBlcnNwZWN0aXZlQ2FtZXJhLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDgsIFVuaWZvcm0gYXMgVW5pZm9ybTE0IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy91dGlscy9vcnRob2dyYXBoaWNEZXB0aFRvVmlld1ouanNcbmZ1bmN0aW9uIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCwgbmVhciwgZmFyKSB7XG4gIHJldHVybiBkZXB0aCAqIChuZWFyIC0gZmFyKSAtIG5lYXI7XG59XG5cbi8vIHNyYy91dGlscy92aWV3WlRvT3J0aG9ncmFwaGljRGVwdGguanNcbmZ1bmN0aW9uIHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WiwgbmVhciwgZmFyKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCgodmlld1ogKyBuZWFyKSAvIChuZWFyIC0gZmFyKSwgMCksIDEpO1xufVxuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY2lyY2xlLW9mLWNvbmZ1c2lvbi5mcmFnXG52YXIgY2lyY2xlX29mX2NvbmZ1c2lvbl9kZWZhdWx0ID0gYCNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8cGFja2luZz5cbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSBmbG9hdCBmb2N1c0Rpc3RhbmNlO3VuaWZvcm0gZmxvYXQgZm9jdXNSYW5nZTt1bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7dmFyeWluZyB2ZWMyIHZVdjtmbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXG5mbG9hdCBkZXB0aD11bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcbiNlbHNlXG5mbG9hdCBkZXB0aD10ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XG4jZW5kaWZcbiNpZmRlZiBMT0dfREVQVEhcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aCpsb2cyKGNhbWVyYUZhcisxLjApKS0xLjA7ZmxvYXQgYT1jYW1lcmFGYXIvKGNhbWVyYUZhci1jYW1lcmFOZWFyKTtmbG9hdCBiPWNhbWVyYUZhcipjYW1lcmFOZWFyLyhjYW1lcmFOZWFyLWNhbWVyYUZhcik7ZGVwdGg9YStiL2Q7XG4jZW5kaWZcbnJldHVybiBkZXB0aDt9dm9pZCBtYWluKCl7ZmxvYXQgZGVwdGg9cmVhZERlcHRoKHZVdik7XG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5mbG9hdCB2aWV3Wj1wZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyLGNhbWVyYUZhcik7ZmxvYXQgbGluZWFyRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcbiNlbHNlXG5mbG9hdCBsaW5lYXJEZXB0aD1kZXB0aDtcbiNlbmRpZlxuZmxvYXQgc2lnbmVkRGlzdGFuY2U9bGluZWFyRGVwdGgtZm9jdXNEaXN0YW5jZTtmbG9hdCBtYWduaXR1ZGU9c21vb3Roc3RlcCgwLjAsZm9jdXNSYW5nZSxhYnMoc2lnbmVkRGlzdGFuY2UpKTtnbF9GcmFnQ29sb3Iucmc9bWFnbml0dWRlKnZlYzIoc3RlcChzaWduZWREaXN0YW5jZSwwLjApLHN0ZXAoMC4wLHNpZ25lZERpc3RhbmNlKSk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQ2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbC5qc1xudmFyIENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsOCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvQyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMTQobnVsbCksXG4gICAgICAgIGZvY3VzRGlzdGFuY2U6IG5ldyBVbmlmb3JtMTQoMCksXG4gICAgICAgIGZvY3VzUmFuZ2U6IG5ldyBVbmlmb3JtMTQoMCksXG4gICAgICAgIGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtMTQoMC4zKSxcbiAgICAgICAgY2FtZXJhRmFyOiBuZXcgVW5pZm9ybTE0KDFlMylcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzcsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBjaXJjbGVfb2ZfY29uZnVzaW9uX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2NhbExlbmd0aCA9IHRoaXMudW5pZm9ybXMuZm9jdXNSYW5nZTtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBuZWFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgbmVhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBmYXIgcGxhbmUgc2V0dGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBmYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMykge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyBkaXN0YW5jZS4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mb2N1c0Rpc3RhbmNlLnZhbHVlO1xuICB9XG4gIHNldCBmb2N1c0Rpc3RhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2N1c0Rpc3RhbmNlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZEZvY3VzRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5mb2N1c0Rpc3RhbmNlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRGb2N1c0Rpc3RhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c0Rpc3RhbmNlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvY3VzIGRpc3RhbmNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9jdXNEaXN0YW5jZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIGdldEZvY3VzRGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZvY3VzRGlzdGFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZm9jdXMgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2N1c0Rpc3RhbmNlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIHNldEZvY3VzRGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZvY3VzRGlzdGFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBmb2N1c1JhbmdlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZvY2FsTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzUmFuZ2U7XG4gIH1cbiAgc2V0IGZvY2FsTGVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c1JhbmdlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyByYW5nZS4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mb2N1c1JhbmdlLnZhbHVlO1xuICB9XG4gIHNldCBmb2N1c1JhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2N1c1JhbmdlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyByYW5nZSBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZEZvY3VzUmFuZ2UoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5mb2N1c1JhbmdlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRGb2N1c1JhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c1JhbmdlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvY2FsIGxlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZvY3VzUmFuZ2UgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZm9jYWwgbGVuZ3RoLlxuICAgKi9cbiAgZ2V0Rm9jYWxMZW5ndGgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c1JhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmb2NhbCBsZW5ndGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2N1c1JhbmdlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmb2NhbCBsZW5ndGguXG4gICAqL1xuICBzZXRGb2NhbExlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuZm9jdXNSYW5nZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9NYXNrTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzgsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsOSwgVW5pZm9ybSBhcyBVbmlmb3JtMTUsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTYgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL21hc2suZnJhZ1xudmFyIG1hc2tfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbmRpZlxuI2lmZGVmIE1BU0tfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFza1RleHR1cmU7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBtYXNrVGV4dHVyZTtcbiNlbmRpZlxuI2lmIE1BU0tfRlVOQ1RJT04gIT0gMFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcbiNlbmRpZlxudmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXtcbiNpZiBDT0xPUl9DSEFOTkVMID09IDBcbmZsb2F0IG1hc2s9dGV4dHVyZTJEKG1hc2tUZXh0dXJlLHZVdikucjtcbiNlbGlmIENPTE9SX0NIQU5ORUwgPT0gMVxuZmxvYXQgbWFzaz10ZXh0dXJlMkQobWFza1RleHR1cmUsdlV2KS5nO1xuI2VsaWYgQ09MT1JfQ0hBTk5FTCA9PSAyXG5mbG9hdCBtYXNrPXRleHR1cmUyRChtYXNrVGV4dHVyZSx2VXYpLmI7XG4jZWxzZVxuZmxvYXQgbWFzaz10ZXh0dXJlMkQobWFza1RleHR1cmUsdlV2KS5hO1xuI2VuZGlmXG4jaWYgTUFTS19GVU5DVElPTiA9PSAwXG4jaWZkZWYgSU5WRVJURURcbm1hc2s9c3RlcChtYXNrLDAuMCk7XG4jZWxzZVxubWFzaz0xLjAtc3RlcChtYXNrLDAuMCk7XG4jZW5kaWZcbiNlbHNlXG5tYXNrPWNsYW1wKG1hc2sqc3RyZW5ndGgsMC4wLDEuMCk7XG4jaWZkZWYgSU5WRVJURURcbm1hc2s9MS4wLW1hc2s7XG4jZW5kaWZcbiNlbmRpZlxuI2lmIE1BU0tfRlVOQ1RJT04gPT0gM1xudmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9dmVjNChtYXNrKnRleGVsLnJnYix0ZXhlbC5hKTtcbiNlbGlmIE1BU0tfRlVOQ1RJT04gPT0gMlxuZ2xfRnJhZ0NvbG9yPXZlYzQobWFzayp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KS5yZ2IsbWFzayk7XG4jZWxzZVxuZ2xfRnJhZ0NvbG9yPW1hc2sqdGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdik7XG4jZW5kaWZcbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL01hc2tNYXRlcmlhbC5qc1xudmFyIE1hc2tNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWw5IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbWFzayBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbbWFza1RleHR1cmVdIC0gVGhlIG1hc2sgdGV4dHVyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hc2tUZXh0dXJlID0gbnVsbCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiTWFza01hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBtYXNrVGV4dHVyZTogbmV3IFVuaWZvcm0xNShtYXNrVGV4dHVyZSksXG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE1KG51bGwpLFxuICAgICAgICBzdHJlbmd0aDogbmV3IFVuaWZvcm0xNSgxKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nOCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IG1hc2tfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yQ2hhbm5lbCA9IENvbG9yQ2hhbm5lbC5SRUQ7XG4gICAgdGhpcy5tYXNrRnVuY3Rpb24gPSBNYXNrRnVuY3Rpb24uRElTQ0FSRDtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXNrIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG1hc2tUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrVGV4dHVyZS52YWx1ZSA9IHZhbHVlO1xuICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuTUFTS19QUkVDSVNJT05fSElHSDtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTYpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5NQVNLX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXNrIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXNrVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBzZXRNYXNrVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMubWFza1RleHR1cmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29sb3IgY2hhbm5lbCB0byB1c2UgZm9yIG1hc2tpbmcuIERlZmF1bHQgaXMgYENvbG9yQ2hhbm5lbC5SRURgLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3JDaGFubmVsfVxuICAgKi9cbiAgc2V0IGNvbG9yQ2hhbm5lbCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5DT0xPUl9DSEFOTkVMID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29sb3IgY2hhbm5lbCB0byB1c2UgZm9yIG1hc2tpbmcuIERlZmF1bHQgaXMgYENvbG9yQ2hhbm5lbC5SRURgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JDaGFubmVsIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q29sb3JDaGFubmVsfSB2YWx1ZSAtIFRoZSBjaGFubmVsLlxuICAgKi9cbiAgc2V0Q29sb3JDaGFubmVsKHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvckNoYW5uZWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hc2tpbmcgdGVjaG5pcXVlLiBEZWZhdWx0IGlzIGBNYXNrRnVuY3Rpb24uRElTQ0FSRGAuXG4gICAqXG4gICAqIEB0eXBlIHtNYXNrRnVuY3Rpb259XG4gICAqL1xuICBzZXQgbWFza0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk1BU0tfRlVOQ1RJT04gPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXNraW5nIHRlY2huaXF1ZS4gRGVmYXVsdCBpcyBgTWFza0Z1bmN0aW9uLkRJU0NBUkRgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWFza0Z1bmN0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFza0Z1bmN0aW9ufSB2YWx1ZSAtIFRoZSBmdW5jdGlvbi5cbiAgICovXG4gIHNldE1hc2tGdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMubWFza0Z1bmN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtYXNraW5nIGlzIGludmVydGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLklOVkVSVEVEICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGludmVydGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52ZXJ0ZWQgJiYgIXZhbHVlKSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLklOVkVSVEVEO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5JTlZFUlRFRCA9IFwiMVwiO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1hc2tpbmcgaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBtYXNraW5nIGlzIGludmVydGVkLlxuICAgKi9cbiAgaXNJbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZlcnRlZDtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtYXNraW5nIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBtYXNraW5nIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICovXG4gIHNldEludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnRlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBtYXNrIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBJbmRpdmlkdWFsIG1hc2sgdmFsdWVzIHdpbGwgYmUgY2xhbXBlZCB0byBbMC4wLCAxLjBdLiBIYXMgbm8gZWZmZWN0IHdoZW4gdGhlIG1hc2sgZnVuY3Rpb24gaXMgc2V0IHRvIGBESVNDQVJEYC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZTtcbiAgfVxuICBzZXQgc3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWFzayBzdHJlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1hc2sgc3RyZW5ndGguXG4gICAqL1xuICBnZXRTdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFzayBzdHJlbmd0aC5cbiAgICpcbiAgICogSGFzIG5vIGVmZmVjdCB3aGVuIHRoZSBtYXNrIGZ1bmN0aW9uIGlzIHNldCB0byBgRElTQ0FSRGAuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWFzayBzdHJlbmd0aC5cbiAgICovXG4gIHNldFN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL1NoYWRlclBhc3MuanNcbmltcG9ydCB7IFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTcgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBTaGFkZXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgc2hhZGVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhZGVyTWF0ZXJpYWx9IG1hdGVyaWFsIC0gQSBzaGFkZXIgbWF0ZXJpYWwuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbaW5wdXQ9XCJpbnB1dEJ1ZmZlclwiXSAtIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBidWZmZXIgdW5pZm9ybS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hdGVyaWFsLCBpbnB1dCA9IFwiaW5wdXRCdWZmZXJcIikge1xuICAgIHN1cGVyKFwiU2hhZGVyUGFzc1wiKTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgYnVmZmVyIHVuaWZvcm0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCAtIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBidWZmZXIgdW5pZm9ybS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0IGluc3RlYWQuXG4gICAqL1xuICBzZXRJbnB1dChpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLnVuaWZvcm1zO1xuICAgIGlmIChpbnB1dEJ1ZmZlciAhPT0gbnVsbCAmJiB1bmlmb3JtcyAhPT0gdm9pZCAwICYmIHVuaWZvcm1zW3RoaXMuaW5wdXRdICE9PSB2b2lkIDApIHtcbiAgICAgIHVuaWZvcm1zW3RoaXMuaW5wdXRdLnZhbHVlID0gaW5wdXRCdWZmZXIudGV4dHVyZTtcbiAgICB9XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogb3V0cHV0QnVmZmVyKTtcbiAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDAgJiYgZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlNykge1xuICAgICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9kZXB0aC1vZi1maWVsZC5mcmFnXG52YXIgZGVwdGhfb2ZfZmllbGRfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbmVhckNvbG9yQnVmZmVyO3VuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZmFyQ29sb3JCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBuZWFyQ29sb3JCdWZmZXI7dW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBmYXJDb2xvckJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBuZWFyQ29DQnVmZmVyO3VuaWZvcm0gbG93cCBzYW1wbGVyMkQgZmFyQ29DQnVmZmVyO3VuaWZvcm0gZmxvYXQgc2NhbGU7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gZmxvYXQgZGVwdGgsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzQgY29sb3JOZWFyPXRleHR1cmUyRChuZWFyQ29sb3JCdWZmZXIsdXYpO3ZlYzQgY29sb3JGYXI9dGV4dHVyZTJEKGZhckNvbG9yQnVmZmVyLHV2KTtcbiNpZiBNQVNLX0ZVTkNUSU9OID09IDFcbnZlYzIgY29jTmVhckZhcj12ZWMyKHRleHR1cmUyRChuZWFyQ29DQnVmZmVyLHV2KS5yLGNvbG9yRmFyLmEpO2NvY05lYXJGYXIueD1taW4oY29jTmVhckZhci54KnNjYWxlLDEuMCk7XG4jZWxzZVxudmVjMiBjb2NOZWFyRmFyPXZlYzIodGV4dHVyZTJEKG5lYXJDb0NCdWZmZXIsdXYpLnIsdGV4dHVyZTJEKGZhckNvQ0J1ZmZlcix1dikuZyk7Y29jTmVhckZhcj1taW4oY29jTmVhckZhcipzY2FsZSwxLjApO1xuI2VuZGlmXG52ZWM0IHJlc3VsdD1pbnB1dENvbG9yKigxLjAtY29jTmVhckZhci55KStjb2xvckZhcjtyZXN1bHQ9bWl4KHJlc3VsdCxjb2xvck5lYXIsY29jTmVhckZhci54KTtvdXRwdXRDb2xvcj1yZXN1bHQ7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0RlcHRoT2ZGaWVsZEVmZmVjdC5qc1xudmFyIERlcHRoT2ZGaWVsZEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggb2YgZmllbGQgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZEZvY3VzRGlzdGFuY2VdIC0gVGhlIGZvY3VzIGRpc3RhbmNlIGluIHdvcmxkIHVuaXRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud29ybGRGb2N1c1JhbmdlXSAtIFRoZSBmb2N1cyBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzRGlzdGFuY2U9MC4wXSAtIFRoZSBub3JtYWxpemVkIGZvY3VzIGRpc3RhbmNlLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNSYW5nZT0wLjFdIC0gVGhlIGZvY3VzIHJhbmdlLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jYWxMZW5ndGg9MC4xXSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ib2tlaFNjYWxlPTEuMF0gLSBUaGUgc2NhbGUgb2YgdGhlIGJva2VoIGJsdXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIHtcbiAgICBibGVuZEZ1bmN0aW9uLFxuICAgIHdvcmxkRm9jdXNEaXN0YW5jZSxcbiAgICB3b3JsZEZvY3VzUmFuZ2UsXG4gICAgZm9jdXNEaXN0YW5jZSA9IDAsXG4gICAgZm9jYWxMZW5ndGggPSAwLjEsXG4gICAgZm9jdXNSYW5nZSA9IGZvY2FsTGVuZ3RoLFxuICAgIGJva2VoU2NhbGUgPSAxLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRGVwdGhPZkZpZWxkRWZmZWN0XCIsIGRlcHRoX29mX2ZpZWxkX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuREVQVEgsXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJuZWFyQ29sb3JCdWZmZXJcIiwgbmV3IFVuaWZvcm0xNihudWxsKV0sXG4gICAgICAgIFtcImZhckNvbG9yQnVmZmVyXCIsIG5ldyBVbmlmb3JtMTYobnVsbCldLFxuICAgICAgICBbXCJuZWFyQ29DQnVmZmVyXCIsIG5ldyBVbmlmb3JtMTYobnVsbCldLFxuICAgICAgICBbXCJmYXJDb0NCdWZmZXJcIiwgbmV3IFVuaWZvcm0xNihudWxsKV0sXG4gICAgICAgIFtcInNjYWxlXCIsIG5ldyBVbmlmb3JtMTYoMSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0OSgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkRvRi5JbnRlcm1lZGlhdGVcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZCA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZS5uYW1lID0gXCJEb0YuTWFza2VkLkZhclwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TmVhciA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXROZWFyLnRleHR1cmUubmFtZSA9IFwiRG9GLkJva2VoLk5lYXJcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm5lYXJDb2xvckJ1ZmZlclwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0TmVhci50ZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0RmFyID0gdGhpcy5yZW5kZXJUYXJnZXQuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEZhci50ZXh0dXJlLm5hbWUgPSBcIkRvRi5Cb2tlaC5GYXJcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImZhckNvbG9yQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRGYXIudGV4dHVyZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldENvQyA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0MudGV4dHVyZS5uYW1lID0gXCJEb0YuQ29DXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJmYXJDb0NCdWZmZXJcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldENvQy50ZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZCA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmUubmFtZSA9IFwiRG9GLkNvQy5CbHVycmVkXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJuZWFyQ29DQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmU7XG4gICAgdGhpcy5jb2NQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwoY2FtZXJhKSk7XG4gICAgY29uc3QgY29jTWF0ZXJpYWwgPSB0aGlzLmNvY01hdGVyaWFsO1xuICAgIGNvY01hdGVyaWFsLmZvY3VzRGlzdGFuY2UgPSBmb2N1c0Rpc3RhbmNlO1xuICAgIGNvY01hdGVyaWFsLmZvY3VzUmFuZ2UgPSBmb2N1c1JhbmdlO1xuICAgIGlmICh3b3JsZEZvY3VzRGlzdGFuY2UgIT09IHZvaWQgMCkge1xuICAgICAgY29jTWF0ZXJpYWwud29ybGRGb2N1c0Rpc3RhbmNlID0gd29ybGRGb2N1c0Rpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAod29ybGRGb2N1c1JhbmdlICE9PSB2b2lkIDApIHtcbiAgICAgIGNvY01hdGVyaWFsLndvcmxkRm9jdXNSYW5nZSA9IHdvcmxkRm9jdXNSYW5nZTtcbiAgICB9XG4gICAgdGhpcy5ibHVyUGFzcyA9IG5ldyBLYXdhc2VCbHVyUGFzcyh7IHJlc29sdXRpb25TY2FsZSwgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCBrZXJuZWxTaXplOiBLZXJuZWxTaXplLk1FRElVTSB9KTtcbiAgICB0aGlzLm1hc2tQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IE1hc2tNYXRlcmlhbCh0aGlzLnJlbmRlclRhcmdldENvQy50ZXh0dXJlKSk7XG4gICAgY29uc3QgbWFza01hdGVyaWFsID0gdGhpcy5tYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgbWFza01hdGVyaWFsLmNvbG9yQ2hhbm5lbCA9IENvbG9yQ2hhbm5lbC5HUkVFTjtcbiAgICB0aGlzLm1hc2tGdW5jdGlvbiA9IE1hc2tGdW5jdGlvbi5NVUxUSVBMWV9SR0I7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBCb2tlaE1hdGVyaWFsKGZhbHNlLCB0cnVlKSk7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuY29jQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmU7XG4gICAgdGhpcy5ib2tlaE5lYXJGaWxsUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBCb2tlaE1hdGVyaWFsKHRydWUsIHRydWUpKTtcbiAgICB0aGlzLmJva2VoTmVhckZpbGxQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5jb2NCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldENvQ0JsdXJyZWQudGV4dHVyZTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgQm9rZWhNYXRlcmlhbChmYWxzZSwgZmFsc2UpKTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmNvY0J1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLnRleHR1cmU7XG4gICAgdGhpcy5ib2tlaEZhckZpbGxQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IEJva2VoTWF0ZXJpYWwodHJ1ZSwgZmFsc2UpKTtcbiAgICB0aGlzLmJva2VoRmFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmNvY0J1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLnRleHR1cmU7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuYm9rZWhTY2FsZSA9IGJva2VoU2NhbGU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuY29jTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgY29jVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRDb0MudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hc2sgZnVuY3Rpb24uIERlZmF1bHQgaXMgYE1VTFRJUExZX1JHQmAuXG4gICAqXG4gICAqIEB0eXBlIHtNYXNrRnVuY3Rpb259XG4gICAqL1xuICBnZXQgbWFza0Z1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5tYXNrRnVuY3Rpb247XG4gIH1cbiAgc2V0IG1hc2tGdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1hc2tGdW5jdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJNQVNLX0ZVTkNUSU9OXCIsIHZhbHVlLnRvRml4ZWQoMCkpO1xuICAgICAgdGhpcy5tYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwubWFza0Z1bmN0aW9uID0gdmFsdWU7XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH1cbiAgICovXG4gIGdldCBjb2NNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2NQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2NNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH1cbiAgICovXG4gIGdldCBjaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmNvY01hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29jTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2NNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFzcyB0aGF0IGJsdXJzIHRoZSBmb3JlZ3JvdW5kIENvQyBidWZmZXIgdG8gc29mdGVuIGVkZ2VzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGJva2VoIHNjYWxlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJva2VoU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwic2NhbGVcIikudmFsdWU7XG4gIH1cbiAgc2V0IGJva2VoU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLmJva2VoTmVhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICAgIHRoaXMuYm9rZWhOZWFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNjYWxlID0gdmFsdWU7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zdHJlbmd0aCA9IHZhbHVlO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwic2NhbGVcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBib2tlaCBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJva2VoU2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUuXG4gICAqL1xuICBnZXRCb2tlaFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmJva2VoU2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJva2VoIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYm9rZWhTY2FsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2NhbGUuXG4gICAqL1xuICBzZXRCb2tlaFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5ib2tlaFNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXV0byBmb2N1cyB0YXJnZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0YXJnZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yM30gVGhlIHRhcmdldC5cbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF1dG8gZm9jdXMgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGFyZ2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdmFsdWUgLSBUaGUgdGFyZ2V0LlxuICAgKi9cbiAgc2V0VGFyZ2V0KHZhbHVlKSB7XG4gICAgdGhpcy50YXJnZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZm9jdXMgZGlzdGFuY2UgZnJvbSB0aGUgY2FtZXJhIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBub3JtYWxpemVkIGZvY3VzIGRpc3RhbmNlLlxuICAgKi9cbiAgY2FsY3VsYXRlRm9jdXNEaXN0YW5jZSh0YXJnZXQpIHtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldCk7XG4gICAgcmV0dXJuIHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCgtZGlzdGFuY2UsIGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nNCkge1xuICAgIHRoaXMuY29jTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5jb2NNYXRlcmlhbC5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIGNvbnN0IHJlbmRlclRhcmdldENvQyA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldENvQ0JsdXJyZWQgPSB0aGlzLnJlbmRlclRhcmdldENvQ0JsdXJyZWQ7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0TWFza2VkID0gdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQ7XG4gICAgaWYgKHRoaXMudGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRm9jdXNEaXN0YW5jZSh0aGlzLnRhcmdldCk7XG4gICAgICB0aGlzLmNvY01hdGVyaWFsLmZvY3VzRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9XG4gICAgdGhpcy5jb2NQYXNzLnJlbmRlcihyZW5kZXJlciwgbnVsbCwgcmVuZGVyVGFyZ2V0Q29DKTtcbiAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0Q29DLCByZW5kZXJUYXJnZXRDb0NCbHVycmVkKTtcbiAgICB0aGlzLm1hc2tQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHJlbmRlclRhcmdldE1hc2tlZCk7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0TWFza2VkLCByZW5kZXJUYXJnZXQpO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgdGhpcy5yZW5kZXJUYXJnZXRGYXIpO1xuICAgIHRoaXMuYm9rZWhOZWFyQmFzZVBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgcmVuZGVyVGFyZ2V0KTtcbiAgICB0aGlzLmJva2VoTmVhckZpbGxQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCB0aGlzLnJlbmRlclRhcmdldE5lYXIpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5jb2NQYXNzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5ibHVyUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMubWFza1Bhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEZhci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TmVhci5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZC5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMuYm9rZWhOZWFyQmFzZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5ib2tlaE5lYXJGaWxsUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5ib2tlaEZhckZpbGxQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0aGlzLmNvY1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5tYXNrUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmJva2VoTmVhckJhc2VQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuYm9rZWhOZWFyRmlsbFBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmJsdXJQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBVbnNpZ25lZEJ5dGVUeXBlOCk7XG4gICAgaWYgKHJlbmRlcmVyLmNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSB7XG4gICAgICB0aGlzLmNvY1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuTE9HX0RFUFRIID0gXCIxXCI7XG4gICAgfVxuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXROZWFyLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0RmFyLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCAmJiByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZTcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U3O1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldE5lYXIudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U3O1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEZhci50ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTc7XG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlNztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0RvdFNjcmVlbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMTcsIFZlY3RvcjIgYXMgVmVjdG9yMjkgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9kb3Qtc2NyZWVuLmZyYWdcbnZhciBkb3Rfc2NyZWVuX2RlZmF1bHQgPSBgdW5pZm9ybSB2ZWMyIGFuZ2xlO3VuaWZvcm0gZmxvYXQgc2NhbGU7ZmxvYXQgcGF0dGVybihjb25zdCBpbiB2ZWMyIHV2KXt2ZWMyIHBvaW50PXNjYWxlKnZlYzIoZG90KGFuZ2xlLnl4LHZlYzIodXYueCwtdXYueSkpLGRvdChhbmdsZSx1dikpO3JldHVybihzaW4ocG9pbnQueCkqc2luKHBvaW50LnkpKSo0LjA7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMzIGNvbG9yPXZlYzMoaW5wdXRDb2xvci5yZ2IqMTAuMC01LjArcGF0dGVybih1dipyZXNvbHV0aW9uKSk7b3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9Eb3RTY3JlZW5FZmZlY3QuanNcbnZhciBEb3RTY3JlZW5FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRvdCBzY3JlZW4gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZT0xLjU3XSAtIFRoZSBhbmdsZSBvZiB0aGUgZG90IHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZT0xLjBdIC0gVGhlIHNjYWxlIG9mIHRoZSBkb3QgcGF0dGVybi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiwgYW5nbGUgPSBNYXRoLlBJICogMC41LCBzY2FsZSA9IDEgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEb3RTY3JlZW5FZmZlY3RcIiwgZG90X3NjcmVlbl9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYW5nbGVcIiwgbmV3IFVuaWZvcm0xNyhuZXcgVmVjdG9yMjkoKSldLFxuICAgICAgICBbXCJzY2FsZVwiLCBuZXcgVW5pZm9ybTE3KHNjYWxlKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW5nbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYW5nbGUoKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLnVuaWZvcm1zLmdldChcImFuZ2xlXCIpLnZhbHVlLnkpO1xuICB9XG4gIHNldCBhbmdsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYW5nbGVcIikudmFsdWUuc2V0KE1hdGguc2luKHZhbHVlKSwgTWF0aC5jb3ModmFsdWUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGF0dGVybiBhbmdsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFuZ2xlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqL1xuICBnZXRBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcGF0dGVybiBhbmdsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFuZ2xlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgc2V0QW5nbGUodmFsdWUpIHtcbiAgICB0aGlzLmFuZ2xlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInNjYWxlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZnhhYS5mcmFnXG52YXIgZnhhYV9kZWZhdWx0ID0gYCNkZWZpbmUgUVVBTElUWShxKSAoKHEpIDwgNSA/IDEuMCA6ICgocSkgPiA1ID8gKChxKSA8IDEwID8gMi4wIDogKChxKSA8IDExID8gNC4wIDogOC4wKSkgOiAxLjUpKVxuI2RlZmluZSBPTkVfT1ZFUl9UV0VMVkUgMC4wODMzMzMzMzMzMzMzMzMzM1xudmFyeWluZyB2ZWMyIHZVdkRvd247dmFyeWluZyB2ZWMyIHZVdlVwO3ZhcnlpbmcgdmVjMiB2VXZMZWZ0O3ZhcnlpbmcgdmVjMiB2VXZSaWdodDt2YXJ5aW5nIHZlYzIgdlV2RG93bkxlZnQ7dmFyeWluZyB2ZWMyIHZVdlVwUmlnaHQ7dmFyeWluZyB2ZWMyIHZVdlVwTGVmdDt2YXJ5aW5nIHZlYzIgdlV2RG93blJpZ2h0O3ZlYzQgZnhhYShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dil7ZmxvYXQgbHVtYUNlbnRlcj1sdW1pbmFuY2UoaW5wdXRDb2xvci5yZ2IpO2Zsb2F0IGx1bWFEb3duPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2RG93bikucmdiKTtmbG9hdCBsdW1hVXA9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZVcCkucmdiKTtmbG9hdCBsdW1hTGVmdD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdkxlZnQpLnJnYik7ZmxvYXQgbHVtYVJpZ2h0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2UmlnaHQpLnJnYik7ZmxvYXQgbHVtYU1pbj1taW4obHVtYUNlbnRlcixtaW4obWluKGx1bWFEb3duLGx1bWFVcCksbWluKGx1bWFMZWZ0LGx1bWFSaWdodCkpKTtmbG9hdCBsdW1hTWF4PW1heChsdW1hQ2VudGVyLG1heChtYXgobHVtYURvd24sbHVtYVVwKSxtYXgobHVtYUxlZnQsbHVtYVJpZ2h0KSkpO2Zsb2F0IGx1bWFSYW5nZT1sdW1hTWF4LWx1bWFNaW47aWYobHVtYVJhbmdlPG1heChFREdFX1RIUkVTSE9MRF9NSU4sbHVtYU1heCpFREdFX1RIUkVTSE9MRF9NQVgpKXtyZXR1cm4gaW5wdXRDb2xvcjt9ZmxvYXQgbHVtYURvd25MZWZ0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2RG93bkxlZnQpLnJnYik7ZmxvYXQgbHVtYVVwUmlnaHQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZVcFJpZ2h0KS5yZ2IpO2Zsb2F0IGx1bWFVcExlZnQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZVcExlZnQpLnJnYik7ZmxvYXQgbHVtYURvd25SaWdodD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdkRvd25SaWdodCkucmdiKTtmbG9hdCBsdW1hRG93blVwPWx1bWFEb3duK2x1bWFVcDtmbG9hdCBsdW1hTGVmdFJpZ2h0PWx1bWFMZWZ0K2x1bWFSaWdodDtmbG9hdCBsdW1hTGVmdENvcm5lcnM9bHVtYURvd25MZWZ0K2x1bWFVcExlZnQ7ZmxvYXQgbHVtYURvd25Db3JuZXJzPWx1bWFEb3duTGVmdCtsdW1hRG93blJpZ2h0O2Zsb2F0IGx1bWFSaWdodENvcm5lcnM9bHVtYURvd25SaWdodCtsdW1hVXBSaWdodDtmbG9hdCBsdW1hVXBDb3JuZXJzPWx1bWFVcFJpZ2h0K2x1bWFVcExlZnQ7ZmxvYXQgZWRnZUhvcml6b250YWw9KGFicygtMi4wKmx1bWFMZWZ0K2x1bWFMZWZ0Q29ybmVycykrYWJzKC0yLjAqbHVtYUNlbnRlcitsdW1hRG93blVwKSoyLjArYWJzKC0yLjAqbHVtYVJpZ2h0K2x1bWFSaWdodENvcm5lcnMpKTtmbG9hdCBlZGdlVmVydGljYWw9KGFicygtMi4wKmx1bWFVcCtsdW1hVXBDb3JuZXJzKSthYnMoLTIuMCpsdW1hQ2VudGVyK2x1bWFMZWZ0UmlnaHQpKjIuMCthYnMoLTIuMCpsdW1hRG93bitsdW1hRG93bkNvcm5lcnMpKTtib29sIGlzSG9yaXpvbnRhbD0oZWRnZUhvcml6b250YWw+PWVkZ2VWZXJ0aWNhbCk7ZmxvYXQgc3RlcExlbmd0aD1pc0hvcml6b250YWw/dGV4ZWxTaXplLnk6dGV4ZWxTaXplLng7ZmxvYXQgbHVtYTE9aXNIb3Jpem9udGFsP2x1bWFEb3duOmx1bWFMZWZ0O2Zsb2F0IGx1bWEyPWlzSG9yaXpvbnRhbD9sdW1hVXA6bHVtYVJpZ2h0O2Zsb2F0IGdyYWRpZW50MT1hYnMobHVtYTEtbHVtYUNlbnRlcik7ZmxvYXQgZ3JhZGllbnQyPWFicyhsdW1hMi1sdW1hQ2VudGVyKTtib29sIGlzMVN0ZWVwZXN0PWdyYWRpZW50MT49Z3JhZGllbnQyO2Zsb2F0IGdyYWRpZW50U2NhbGVkPTAuMjUqbWF4KGdyYWRpZW50MSxncmFkaWVudDIpO2Zsb2F0IGx1bWFMb2NhbEF2ZXJhZ2U9MC4wO2lmKGlzMVN0ZWVwZXN0KXtzdGVwTGVuZ3RoPS1zdGVwTGVuZ3RoO2x1bWFMb2NhbEF2ZXJhZ2U9MC41KihsdW1hMStsdW1hQ2VudGVyKTt9ZWxzZXtsdW1hTG9jYWxBdmVyYWdlPTAuNSoobHVtYTIrbHVtYUNlbnRlcik7fXZlYzIgY3VycmVudFV2PXV2O2lmKGlzSG9yaXpvbnRhbCl7Y3VycmVudFV2LnkrPXN0ZXBMZW5ndGgqMC41O31lbHNle2N1cnJlbnRVdi54Kz1zdGVwTGVuZ3RoKjAuNTt9dmVjMiBvZmZzZXQ9aXNIb3Jpem9udGFsP3ZlYzIodGV4ZWxTaXplLngsMC4wKTp2ZWMyKDAuMCx0ZXhlbFNpemUueSk7dmVjMiB1djE9Y3VycmVudFV2LW9mZnNldCpRVUFMSVRZKDApO3ZlYzIgdXYyPWN1cnJlbnRVditvZmZzZXQqUVVBTElUWSgwKTtmbG9hdCBsdW1hRW5kMT1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2MSkucmdiKTtmbG9hdCBsdW1hRW5kMj1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2MikucmdiKTtsdW1hRW5kMS09bHVtYUxvY2FsQXZlcmFnZTtsdW1hRW5kMi09bHVtYUxvY2FsQXZlcmFnZTtib29sIHJlYWNoZWQxPWFicyhsdW1hRW5kMSk+PWdyYWRpZW50U2NhbGVkO2Jvb2wgcmVhY2hlZDI9YWJzKGx1bWFFbmQyKT49Z3JhZGllbnRTY2FsZWQ7Ym9vbCByZWFjaGVkQm90aD1yZWFjaGVkMSYmcmVhY2hlZDI7aWYoIXJlYWNoZWQxKXt1djEtPW9mZnNldCpRVUFMSVRZKDEpO31pZighcmVhY2hlZDIpe3V2Mis9b2Zmc2V0KlFVQUxJVFkoMSk7fWlmKCFyZWFjaGVkQm90aCl7Zm9yKGludCBpPTI7aTxTQU1QTEVTOysraSl7aWYoIXJlYWNoZWQxKXtsdW1hRW5kMT1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2MSkucmdiKTtsdW1hRW5kMT1sdW1hRW5kMS1sdW1hTG9jYWxBdmVyYWdlO31pZighcmVhY2hlZDIpe2x1bWFFbmQyPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYyKS5yZ2IpO2x1bWFFbmQyPWx1bWFFbmQyLWx1bWFMb2NhbEF2ZXJhZ2U7fXJlYWNoZWQxPWFicyhsdW1hRW5kMSk+PWdyYWRpZW50U2NhbGVkO3JlYWNoZWQyPWFicyhsdW1hRW5kMik+PWdyYWRpZW50U2NhbGVkO3JlYWNoZWRCb3RoPXJlYWNoZWQxJiZyZWFjaGVkMjtpZighcmVhY2hlZDEpe3V2MS09b2Zmc2V0KlFVQUxJVFkoaSk7fWlmKCFyZWFjaGVkMil7dXYyKz1vZmZzZXQqUVVBTElUWShpKTt9aWYocmVhY2hlZEJvdGgpe2JyZWFrO319fWZsb2F0IGRpc3RhbmNlMT1pc0hvcml6b250YWw/KHV2LngtdXYxLngpOih1di55LXV2MS55KTtmbG9hdCBkaXN0YW5jZTI9aXNIb3Jpem9udGFsPyh1djIueC11di54KToodXYyLnktdXYueSk7Ym9vbCBpc0RpcmVjdGlvbjE9ZGlzdGFuY2UxPGRpc3RhbmNlMjtmbG9hdCBkaXN0YW5jZUZpbmFsPW1pbihkaXN0YW5jZTEsZGlzdGFuY2UyKTtmbG9hdCBlZGdlVGhpY2tuZXNzPShkaXN0YW5jZTErZGlzdGFuY2UyKTtib29sIGlzTHVtYUNlbnRlclNtYWxsZXI9bHVtYUNlbnRlcjxsdW1hTG9jYWxBdmVyYWdlO2Jvb2wgY29ycmVjdFZhcmlhdGlvbjE9KGx1bWFFbmQxPDAuMCkhPWlzTHVtYUNlbnRlclNtYWxsZXI7Ym9vbCBjb3JyZWN0VmFyaWF0aW9uMj0obHVtYUVuZDI8MC4wKSE9aXNMdW1hQ2VudGVyU21hbGxlcjtib29sIGNvcnJlY3RWYXJpYXRpb249aXNEaXJlY3Rpb24xP2NvcnJlY3RWYXJpYXRpb24xOmNvcnJlY3RWYXJpYXRpb24yO2Zsb2F0IHBpeGVsT2Zmc2V0PS1kaXN0YW5jZUZpbmFsL2VkZ2VUaGlja25lc3MrMC41O2Zsb2F0IGZpbmFsT2Zmc2V0PWNvcnJlY3RWYXJpYXRpb24/cGl4ZWxPZmZzZXQ6MC4wO2Zsb2F0IGx1bWFBdmVyYWdlPU9ORV9PVkVSX1RXRUxWRSooMi4wKihsdW1hRG93blVwK2x1bWFMZWZ0UmlnaHQpK2x1bWFMZWZ0Q29ybmVycytsdW1hUmlnaHRDb3JuZXJzKTtmbG9hdCBzdWJQaXhlbE9mZnNldDE9Y2xhbXAoYWJzKGx1bWFBdmVyYWdlLWx1bWFDZW50ZXIpL2x1bWFSYW5nZSwwLjAsMS4wKTtmbG9hdCBzdWJQaXhlbE9mZnNldDI9KC0yLjAqc3ViUGl4ZWxPZmZzZXQxKzMuMCkqc3ViUGl4ZWxPZmZzZXQxKnN1YlBpeGVsT2Zmc2V0MTtmbG9hdCBzdWJQaXhlbE9mZnNldEZpbmFsPXN1YlBpeGVsT2Zmc2V0MipzdWJQaXhlbE9mZnNldDIqU1VCUElYRUxfUVVBTElUWTtmaW5hbE9mZnNldD1tYXgoZmluYWxPZmZzZXQsc3ViUGl4ZWxPZmZzZXRGaW5hbCk7dmVjMiBmaW5hbFV2PXV2O2lmKGlzSG9yaXpvbnRhbCl7ZmluYWxVdi55Kz1maW5hbE9mZnNldCpzdGVwTGVuZ3RoO31lbHNle2ZpbmFsVXYueCs9ZmluYWxPZmZzZXQqc3RlcExlbmd0aDt9cmV0dXJuIHRleHR1cmUyRChpbnB1dEJ1ZmZlcixmaW5hbFV2KTt9dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPWZ4YWEoaW5wdXRDb2xvcix1dik7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZnhhYS52ZXJ0XG52YXIgZnhhYV9kZWZhdWx0MiA9IGB2YXJ5aW5nIHZlYzIgdlV2RG93bjt2YXJ5aW5nIHZlYzIgdlV2VXA7dmFyeWluZyB2ZWMyIHZVdkxlZnQ7dmFyeWluZyB2ZWMyIHZVdlJpZ2h0O3ZhcnlpbmcgdmVjMiB2VXZEb3duTGVmdDt2YXJ5aW5nIHZlYzIgdlV2VXBSaWdodDt2YXJ5aW5nIHZlYzIgdlV2VXBMZWZ0O3ZhcnlpbmcgdmVjMiB2VXZEb3duUmlnaHQ7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXt2VXZEb3duPXV2K3ZlYzIoMC4wLC0xLjApKnRleGVsU2l6ZTt2VXZVcD11dit2ZWMyKDAuMCwxLjApKnRleGVsU2l6ZTt2VXZSaWdodD11dit2ZWMyKDEuMCwwLjApKnRleGVsU2l6ZTt2VXZMZWZ0PXV2K3ZlYzIoLTEuMCwwLjApKnRleGVsU2l6ZTt2VXZEb3duTGVmdD11dit2ZWMyKC0xLjAsLTEuMCkqdGV4ZWxTaXplO3ZVdlVwUmlnaHQ9dXYrdmVjMigxLjAsMS4wKSp0ZXhlbFNpemU7dlV2VXBMZWZ0PXV2K3ZlYzIoLTEuMCwxLjApKnRleGVsU2l6ZTt2VXZEb3duUmlnaHQ9dXYrdmVjMigxLjAsLTEuMCkqdGV4ZWxTaXplO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9GWEFBRWZmZWN0LmpzXG52YXIgRlhBQUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgRlhBQSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRlhBQUVmZmVjdFwiLCBmeGFhX2RlZmF1bHQsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogZnhhYV9kZWZhdWx0MixcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBkZWZpbmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIkVER0VfVEhSRVNIT0xEX01JTlwiLCBcIjAuMDMxMlwiXSxcbiAgICAgICAgW1wiRURHRV9USFJFU0hPTERfTUFYXCIsIFwiMC4xMjVcIl0sXG4gICAgICAgIFtcIlNVQlBJWEVMX1FVQUxJVFlcIiwgXCIwLjc1XCJdLFxuICAgICAgICBbXCJTQU1QTEVTXCIsIFwiMTJcIl1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC4gUmFuZ2UgaXMgWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaW5FZGdlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLmdldChcIkVER0VfVEhSRVNIT0xEX01JTlwiKSk7XG4gIH1cbiAgc2V0IG1pbkVkZ2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiRURHRV9USFJFU0hPTERfTUlOXCIsIHZhbHVlLnRvRml4ZWQoMTIpKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1heEVkZ2VUaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuZ2V0KFwiRURHRV9USFJFU0hPTERfTUFYXCIpKTtcbiAgfVxuICBzZXQgbWF4RWRnZVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJFREdFX1RIUkVTSE9MRF9NQVhcIiwgdmFsdWUudG9GaXhlZCgxMikpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3VicGl4ZWwgYmxlbmQgcXVhbGl0eS4gUmFuZ2UgaXMgWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdWJwaXhlbFF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuZ2V0KFwiU1VCUElYRUxfUVVBTElUWVwiKSk7XG4gIH1cbiAgc2V0IHN1YnBpeGVsUXVhbGl0eSh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTVUJQSVhFTF9RVUFMSVRZXCIsIHZhbHVlLnRvRml4ZWQoMTIpKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIGVkZ2UgZGV0ZWN0aW9uIHNhbXBsZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJTQU1QTEVTXCIpKTtcbiAgfVxuICBzZXQgc2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTQU1QTEVTXCIsIHZhbHVlLnRvRml4ZWQoMCkpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9HYW1tYUNvcnJlY3Rpb25FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTE4IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZ2FtbWEtY29ycmVjdGlvbi5mcmFnXG52YXIgZ2FtbWFfY29ycmVjdGlvbl9kZWZhdWx0ID0gYHVuaWZvcm0gZmxvYXQgZ2FtbWE7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPUxpbmVhclRvR2FtbWEobWF4KGlucHV0Q29sb3IsMC4wKSxnYW1tYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0dhbW1hQ29ycmVjdGlvbkVmZmVjdC5qc1xudmFyIEdhbW1hQ29ycmVjdGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ2FtbWEgY29ycmVjdGlvbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhbW1hPTIuMF0gLSBUaGUgZ2FtbWEgZmFjdG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsIGdhbW1hID0gMiB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdhbW1hQ29ycmVjdGlvbkVmZmVjdFwiLCBnYW1tYV9jb3JyZWN0aW9uX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJnYW1tYVwiLCBuZXcgVW5pZm9ybTE4KGdhbW1hKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0dsaXRjaEVmZmVjdC5qc1xuaW1wb3J0IHsgTmVhcmVzdEZpbHRlciwgUmVwZWF0V3JhcHBpbmcgYXMgUmVwZWF0V3JhcHBpbmcyLCBSR0JBRm9ybWF0IGFzIFJHQkFGb3JtYXQyLCBVbmlmb3JtIGFzIFVuaWZvcm0xOSwgVmVjdG9yMiBhcyBWZWN0b3IyMTAgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VudW1zL0dsaXRjaE1vZGUuanNcbnZhciBHbGl0Y2hNb2RlID0ge1xuICBESVNBQkxFRDogMCxcbiAgU1BPUkFESUM6IDEsXG4gIENPTlNUQU5UX01JTEQ6IDIsXG4gIENPTlNUQU5UX1dJTEQ6IDNcbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9Ob2lzZVRleHR1cmUuanNcbmltcG9ydCB7XG4gIERhdGFUZXh0dXJlLFxuICBSZWRGb3JtYXQsXG4gIFJHRm9ybWF0LFxuICBSR0JBRm9ybWF0LFxuICBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU5XG59IGZyb20gXCJ0aHJlZVwiO1xuZnVuY3Rpb24gZ2V0Tm9pc2Uoc2l6ZSwgZm9ybWF0LCB0eXBlKSB7XG4gIGNvbnN0IGNoYW5uZWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgIFtSZWRGb3JtYXQsIDFdLFxuICAgIFtSR0Zvcm1hdCwgMl0sXG4gICAgW1JHQkFGb3JtYXQsIDRdXG4gIF0pO1xuICBsZXQgZGF0YTtcbiAgaWYgKCFjaGFubmVscy5oYXMoZm9ybWF0KSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG5vaXNlIHRleHR1cmUgZm9ybWF0XCIpO1xuICB9XG4gIGlmICh0eXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlOSkge1xuICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogY2hhbm5lbHMuZ2V0KGZvcm1hdCkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBNYXRoLnJhbmRvbSgpICogMjU1ICsgMC41O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogY2hhbm5lbHMuZ2V0KGZvcm1hdCkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbnZhciBOb2lzZVRleHR1cmUgPSBjbGFzcyBleHRlbmRzIERhdGFUZXh0dXJlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbm9pc2UgdGV4dHVyZS5cbiAgICpcbiAgICogU3VwcG9ydGVkIGZvcm1hdHMgYXJlIGBSR0JBRm9ybWF0YCwgYFJlZEZvcm1hdGAgYW5kIGBSR0Zvcm1hdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZm9ybWF0PVJlZEZvcm1hdF0gLSBUaGUgdGV4dHVyZSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdHlwZT1VbnNpZ25lZEJ5dGVUeXBlXSAtIFRoZSB0ZXh0dXJlIHR5cGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBmb3JtYXQgPSBSZWRGb3JtYXQsIHR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlOSkge1xuICAgIHN1cGVyKGdldE5vaXNlKHdpZHRoICogaGVpZ2h0LCBmb3JtYXQsIHR5cGUpLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2dsaXRjaC5mcmFnXG52YXIgZ2xpdGNoX2RlZmF1bHQgPSBgdW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBwZXJ0dXJiYXRpb25NYXA7dW5pZm9ybSBib29sIGFjdGl2ZTt1bmlmb3JtIGZsb2F0IGNvbHVtbnM7dW5pZm9ybSBmbG9hdCByYW5kb207dW5pZm9ybSB2ZWMyIHNlZWRzO3VuaWZvcm0gdmVjMiBkaXN0b3J0aW9uO3ZvaWQgbWFpblV2KGlub3V0IHZlYzIgdXYpe2lmKGFjdGl2ZSl7aWYodXYueTxkaXN0b3J0aW9uLngrY29sdW1ucyYmdXYueT5kaXN0b3J0aW9uLngtY29sdW1ucypyYW5kb20pe2Zsb2F0IHN4PWNsYW1wKGNlaWwoc2VlZHMueCksMC4wLDEuMCk7dXYueT1zeCooMS4wLSh1di55K2Rpc3RvcnRpb24ueSkpKygxLjAtc3gpKmRpc3RvcnRpb24ueTt9aWYodXYueDxkaXN0b3J0aW9uLnkrY29sdW1ucyYmdXYueD5kaXN0b3J0aW9uLnktY29sdW1ucypyYW5kb20pe2Zsb2F0IHN5PWNsYW1wKGNlaWwoc2VlZHMueSksMC4wLDEuMCk7dXYueD1zeSpkaXN0b3J0aW9uLngrKDEuMC1zeSkqKDEuMC0odXYueCtkaXN0b3J0aW9uLngpKTt9dmVjMiBub3JtYWw9dGV4dHVyZTJEKHBlcnR1cmJhdGlvbk1hcCx1dipyYW5kb20qcmFuZG9tKS5yZzt1dis9bm9ybWFsKnNlZWRzKihyYW5kb20qMC4yKTt9fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0dsaXRjaEVmZmVjdC5qc1xudmFyIHRleHR1cmVUYWcgPSBcIkdsaXRjaC5HZW5lcmF0ZWRcIjtcbmZ1bmN0aW9uIHJhbmRvbUZsb2F0KGxvdywgaGlnaCkge1xuICByZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KTtcbn1cbnZhciBHbGl0Y2hFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGdsaXRjaCBlZmZlY3QuXG4gICAqXG4gICAqIFRPRE8gQ2hhbmdlIHJhdGlvIHRvIDAuMTUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5jaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0XSAtIEEgY2hyb21hdGljIGFiZXJyYXRpb24gb2Zmc2V0LiBJZiBwcm92aWRlZCwgdGhlIGdsaXRjaCBlZmZlY3Qgd2lsbCBpbmZsdWVuY2UgdGhpcyBvZmZzZXQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbnMuZGVsYXldIC0gVGhlIG1pbmltdW0gYW5kIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5kdXJhdGlvbl0gLSBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBkdXJhdGlvbiBvZiBhIGdsaXRjaCBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLnN0cmVuZ3RoXSAtIFRoZSBzdHJlbmd0aCBvZiB3ZWFrIGFuZCBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW29wdGlvbnMucGVydHVyYmF0aW9uTWFwXSAtIEEgcGVydHVyYmF0aW9uIG1hcC4gSWYgbm9uZSBpcyBwcm92aWRlZCwgYSBub2lzZSB0ZXh0dXJlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR0U2l6ZT02NF0gLSBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIG5vaXNlIG1hcC4gV2lsbCBiZSBpZ25vcmVkIGlmIGEgcGVydHVyYmF0aW9uIG1hcCBpcyBwcm92aWRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbHVtbnM9MC4wNV0gLSBUaGUgc2NhbGUgb2YgdGhlIGJsb2NreSBnbGl0Y2ggY29sdW1ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhdGlvPTAuODVdIC0gVGhlIHRocmVzaG9sZCBmb3Igc3Ryb25nIGdsaXRjaGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSBudWxsLFxuICAgIGRlbGF5ID0gbmV3IFZlY3RvcjIxMCgxLjUsIDMuNSksXG4gICAgZHVyYXRpb24gPSBuZXcgVmVjdG9yMjEwKDAuNiwgMSksXG4gICAgc3RyZW5ndGggPSBuZXcgVmVjdG9yMjEwKDAuMywgMSksXG4gICAgY29sdW1ucyA9IDAuMDUsXG4gICAgcmF0aW8gPSAwLjg1LFxuICAgIHBlcnR1cmJhdGlvbk1hcCA9IG51bGwsXG4gICAgZHRTaXplID0gNjRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJHbGl0Y2hFZmZlY3RcIiwgZ2xpdGNoX2RlZmF1bHQsIHtcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcInBlcnR1cmJhdGlvbk1hcFwiLCBuZXcgVW5pZm9ybTE5KG51bGwpXSxcbiAgICAgICAgW1wiY29sdW1uc1wiLCBuZXcgVW5pZm9ybTE5KGNvbHVtbnMpXSxcbiAgICAgICAgW1wiYWN0aXZlXCIsIG5ldyBVbmlmb3JtMTkoZmFsc2UpXSxcbiAgICAgICAgW1wicmFuZG9tXCIsIG5ldyBVbmlmb3JtMTkoMSldLFxuICAgICAgICBbXCJzZWVkc1wiLCBuZXcgVW5pZm9ybTE5KG5ldyBWZWN0b3IyMTAoKSldLFxuICAgICAgICBbXCJkaXN0b3J0aW9uXCIsIG5ldyBVbmlmb3JtMTkobmV3IFZlY3RvcjIxMCgpKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgaWYgKHBlcnR1cmJhdGlvbk1hcCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE5vaXNlVGV4dHVyZShkdFNpemUsIGR0U2l6ZSwgUkdCQUZvcm1hdDIpO1xuICAgICAgbWFwLm5hbWUgPSB0ZXh0dXJlVGFnO1xuICAgICAgdGhpcy5wZXJ0dXJiYXRpb25NYXAgPSBtYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVydHVyYmF0aW9uTWFwID0gcGVydHVyYmF0aW9uTWFwO1xuICAgIH1cbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuZGlzdG9ydGlvbiA9IHRoaXMudW5pZm9ybXMuZ2V0KFwiZGlzdG9ydGlvblwiKS52YWx1ZTtcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuYnJlYWtQb2ludCA9IG5ldyBWZWN0b3IyMTAoXG4gICAgICByYW5kb21GbG9hdCh0aGlzLmRlbGF5LngsIHRoaXMuZGVsYXkueSksXG4gICAgICByYW5kb21GbG9hdCh0aGlzLmR1cmF0aW9uLngsIHRoaXMuZHVyYXRpb24ueSlcbiAgICApO1xuICAgIHRoaXMuc3RyZW5ndGggPSBzdHJlbmd0aDtcbiAgICB0aGlzLm1vZGUgPSBHbGl0Y2hNb2RlLlNQT1JBRElDO1xuICAgIHRoaXMucmF0aW8gPSByYXRpbztcbiAgICB0aGlzLmNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSBjaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0O1xuICB9XG4gIC8qKlxuICAgKiBSYW5kb20gbnVtYmVyIHNlZWRzLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBzZWVkcygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzZWVkc1wiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdsaXRjaCBlZmZlY3QgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImFjdGl2ZVwiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdsaXRjaCBlZmZlY3QgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFjdGl2ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBnbGl0Y2ggZWZmZWN0IGlzIGFjdGl2ZS5cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluRGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXkueDtcbiAgfVxuICBzZXQgbWluRGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWluaW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkRlbGF5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gZGVsYXkgaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1pbkRlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGF5Lng7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5EZWxheSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBkZWxheSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWluRGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4RGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXkueTtcbiAgfVxuICBzZXQgbWF4RGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heERlbGF5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gZGVsYXkgaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1heERlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGF5Lnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZWxheSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWF4aW11bSBkZWxheSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWF4RGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24ueDtcbiAgfVxuICBzZXQgbWluRHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWluaW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkR1cmF0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1pbkR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uLng7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5EdXJhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWluRHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24ueTtcbiAgfVxuICBzZXQgbWF4RHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heER1cmF0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1heER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uLnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEdXJhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWF4aW11bSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWF4RHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN0cmVuZ3RoIG9mIHdlYWsgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueDtcbiAgfVxuICBzZXQgbWluU3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyZW5ndGggb2Ygd2VhayBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pblN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHN0cmVuZ3RoLlxuICAgKi9cbiAgZ2V0TWluU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RyZW5ndGggb2Ygd2VhayBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pblN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzdHJlbmd0aC5cbiAgICovXG4gIHNldE1pblN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5zdHJlbmd0aC54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdHJlbmd0aCBvZiBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4U3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueTtcbiAgfVxuICBzZXQgbWF4U3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyZW5ndGggb2Ygc3Ryb25nIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWF4U3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBnZXRNYXhTdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aC55O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhTdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBzZXRNYXhTdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuc3RyZW5ndGgueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGdsaXRjaCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtHbGl0Y2hNb2RlfSBUaGUgbW9kZS5cbiAgICovXG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBnbGl0Y2ggbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtHbGl0Y2hNb2RlfSB2YWx1ZSAtIFRoZSBtb2RlLlxuICAgKi9cbiAgc2V0TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMubW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnbGl0Y2ggcmF0aW8uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByYXRpbyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYXRpby5cbiAgICovXG4gIGdldEdsaXRjaFJhdGlvKCkge1xuICAgIHJldHVybiAxIC0gdGhpcy5yYXRpbztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmF0aW8gb2Ygd2VhayAoMC4wKSBhbmQgc3Ryb25nICgxLjApIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmF0aW8gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJhdGlvLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0R2xpdGNoUmF0aW8odmFsdWUpIHtcbiAgICB0aGlzLnJhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMSAtIHZhbHVlLCAwKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJjb2x1bW5zXCIpLnZhbHVlO1xuICB9XG4gIHNldCBjb2x1bW5zKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJjb2x1bW5zXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdsaXRjaCBjb2x1bW4gc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvbHVtbnMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ2xpdGNoIGNvbHVtbiBzaXplLlxuICAgKi9cbiAgZ2V0R2xpdGNoQ29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5zO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2x1bW5zIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqL1xuICBzZXRHbGl0Y2hDb2x1bW5zKHZhbHVlKSB7XG4gICAgdGhpcy5jb2x1bW5zID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNocm9tYXRpYyBhYmVycmF0aW9uIG9mZnNldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIG9mZnNldC5cbiAgICovXG4gIGdldENocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY2hyb21hdGljIGFiZXJyYXRpb24gb2Zmc2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZhbHVlIC0gVGhlIG9mZnNldC5cbiAgICovXG4gIHNldENocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLmNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBlcnR1cmJhdGlvbiBtYXAuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHBlcnR1cmJhdGlvbk1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJwZXJ0dXJiYXRpb25NYXBcIikudmFsdWU7XG4gIH1cbiAgc2V0IHBlcnR1cmJhdGlvbk1hcCh2YWx1ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRNYXAgPSB0aGlzLnBlcnR1cmJhdGlvbk1hcDtcbiAgICBpZiAoY3VycmVudE1hcCAhPT0gbnVsbCAmJiBjdXJyZW50TWFwLm5hbWUgPT09IHRleHR1cmVUYWcpIHtcbiAgICAgIGN1cnJlbnRNYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB2YWx1ZS5taW5GaWx0ZXIgPSB2YWx1ZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuICAgIHZhbHVlLndyYXBTID0gdmFsdWUud3JhcFQgPSBSZXBlYXRXcmFwcGluZzI7XG4gICAgdmFsdWUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJwZXJ0dXJiYXRpb25NYXBcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwZXJ0dXJiYXRpb24gbWFwLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcGVydHVyYmF0aW9uTWFwIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSBjdXJyZW50IHBlcnR1cmJhdGlvbiBtYXAuXG4gICAqL1xuICBnZXRQZXJ0dXJiYXRpb25NYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVydHVyYmF0aW9uTWFwO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBwZXJ0dXJiYXRpb24gbWFwIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgICpcbiAgICogVGhlIGN1cnJlbnQgbWFwIHdpbGwgYmUgZGlzcG9zZWQgaWYgaXQgd2FzIGdlbmVyYXRlZCBieSB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBlcnR1cmJhdGlvbk1hcCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIG5ldyBwZXJ0dXJiYXRpb24gbWFwLlxuICAgKi9cbiAgc2V0UGVydHVyYmF0aW9uTWFwKHZhbHVlKSB7XG4gICAgdGhpcy5wZXJ0dXJiYXRpb25NYXAgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcGVydHVyYmF0aW9uIG1hcC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIE5vaXNlVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ZhbHVlPTY0XSAtIFRoZSB0ZXh0dXJlIHNpemUuXG4gICAqIEByZXR1cm4ge0RhdGFUZXh0dXJlfSBUaGUgcGVydHVyYmF0aW9uIG1hcC5cbiAgICovXG4gIGdlbmVyYXRlUGVydHVyYmF0aW9uTWFwKHZhbHVlID0gNjQpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTm9pc2VUZXh0dXJlKHZhbHVlLCB2YWx1ZSwgUkdCQUZvcm1hdDIpO1xuICAgIG1hcC5uYW1lID0gdGV4dHVyZVRhZztcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlO1xuICAgIGNvbnN0IGJyZWFrUG9pbnQgPSB0aGlzLmJyZWFrUG9pbnQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0O1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0cmVuZ3RoO1xuICAgIGxldCB0aW1lID0gdGhpcy50aW1lO1xuICAgIGxldCBhY3RpdmUgPSBmYWxzZTtcbiAgICBsZXQgciA9IDAsIGEgPSAwO1xuICAgIGxldCB0cmlnZ2VyO1xuICAgIGlmIChtb2RlICE9PSBHbGl0Y2hNb2RlLkRJU0FCTEVEKSB7XG4gICAgICBpZiAobW9kZSA9PT0gR2xpdGNoTW9kZS5TUE9SQURJQykge1xuICAgICAgICB0aW1lICs9IGRlbHRhVGltZTtcbiAgICAgICAgdHJpZ2dlciA9IHRpbWUgPiBicmVha1BvaW50Lng7XG4gICAgICAgIGlmICh0aW1lID49IGJyZWFrUG9pbnQueCArIGJyZWFrUG9pbnQueSkge1xuICAgICAgICAgIGJyZWFrUG9pbnQuc2V0KFxuICAgICAgICAgICAgcmFuZG9tRmxvYXQodGhpcy5kZWxheS54LCB0aGlzLmRlbGF5LnkpLFxuICAgICAgICAgICAgcmFuZG9tRmxvYXQodGhpcy5kdXJhdGlvbi54LCB0aGlzLmR1cmF0aW9uLnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgciA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0aGlzLnVuaWZvcm1zLmdldChcInJhbmRvbVwiKS52YWx1ZSA9IHI7XG4gICAgICBpZiAodHJpZ2dlciAmJiByID4gdGhpcy5yYXRpbyB8fCBtb2RlID09PSBHbGl0Y2hNb2RlLkNPTlNUQU5UX1dJTEQpIHtcbiAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgciAqPSBzLnkgKiAwLjAzO1xuICAgICAgICBhID0gcmFuZG9tRmxvYXQoLU1hdGguUEksIE1hdGguUEkpO1xuICAgICAgICB0aGlzLnNlZWRzLnNldChyYW5kb21GbG9hdCgtcy55LCBzLnkpLCByYW5kb21GbG9hdCgtcy55LCBzLnkpKTtcbiAgICAgICAgdGhpcy5kaXN0b3J0aW9uLnNldChyYW5kb21GbG9hdCgwLCAxKSwgcmFuZG9tRmxvYXQoMCwgMSkpO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyIHx8IG1vZGUgPT09IEdsaXRjaE1vZGUuQ09OU1RBTlRfTUlMRCkge1xuICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICByICo9IHMueCAqIDAuMDM7XG4gICAgICAgIGEgPSByYW5kb21GbG9hdCgtTWF0aC5QSSwgTWF0aC5QSSk7XG4gICAgICAgIHRoaXMuc2VlZHMuc2V0KHJhbmRvbUZsb2F0KC1zLngsIHMueCksIHJhbmRvbUZsb2F0KC1zLngsIHMueCkpO1xuICAgICAgICB0aGlzLmRpc3RvcnRpb24uc2V0KHJhbmRvbUZsb2F0KDAsIDEpLCByYW5kb21GbG9hdCgwLCAxKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIG9mZnNldC5zZXQoTWF0aC5jb3MoYSksIE1hdGguc2luKGEpKS5tdWx0aXBseVNjYWxhcihyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldC5zZXQoMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYWN0aXZlXCIpLnZhbHVlID0gYWN0aXZlO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGdlbmVyYXRlZCByZXNvdXJjZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMucGVydHVyYmF0aW9uTWFwO1xuICAgIGlmIChtYXAgIT09IG51bGwgJiYgbWFwLm5hbWUgPT09IHRleHR1cmVUYWcpIHtcbiAgICAgIG1hcC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9Hb2RSYXlzRWZmZWN0LmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzYsXG4gIENvbG9yIGFzIENvbG9yMyxcbiAgRGVwdGhUZXh0dXJlIGFzIERlcHRoVGV4dHVyZTIsXG4gIE1hdHJpeDQsXG4gIFNjZW5lIGFzIFNjZW5lMixcbiAgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2U4LFxuICBVbmlmb3JtIGFzIFVuaWZvcm0yMixcbiAgVmVjdG9yMiBhcyBWZWN0b3IyMTIsXG4gIFZlY3RvcjMsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTBcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhNYXNrTWF0ZXJpYWwuanNcbmltcG9ydCB7XG4gIEFsd2F5c0RlcHRoLFxuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzUsXG4gIEVxdWFsRGVwdGgsXG4gIEdyZWF0ZXJEZXB0aCxcbiAgR3JlYXRlckVxdWFsRGVwdGgsXG4gIExlc3NEZXB0aCxcbiAgTGVzc0VxdWFsRGVwdGgsXG4gIE5ldmVyRGVwdGgsXG4gIE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzksXG4gIE5vdEVxdWFsRGVwdGgsXG4gIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhMixcbiAgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxMCxcbiAgVW5pZm9ybSBhcyBVbmlmb3JtMjAsXG4gIFZlY3RvcjIgYXMgVmVjdG9yMjExXG59IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZW51bXMvRGVwdGhUZXN0U3RyYXRlZ3kuanNcbnZhciBEZXB0aFRlc3RTdHJhdGVneSA9IHtcbiAgREVGQVVMVDogMCxcbiAgS0VFUF9NQVhfREVQVEg6IDEsXG4gIERJU0NBUkRfTUFYX0RFUFRIOiAyXG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZGVwdGgtbWFzay5mcmFnXG52YXIgZGVwdGhfbWFza19kZWZhdWx0ID0gYCNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8cGFja2luZz5cbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXIwO3VuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyMTtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyMDt1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyMTtcbiNlbmRpZlxudW5pZm9ybSBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7dW5pZm9ybSB2ZWMyIGNhbWVyYU5lYXJGYXI7ZmxvYXQgZ2V0Vmlld1ooY29uc3QgaW4gZmxvYXQgZGVwdGgpe1xuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xuI2Vsc2VcbnJldHVybiBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XG4jZW5kaWZcbn12YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe3ZlYzIgZGVwdGg7XG4jaWYgREVQVEhfUEFDS0lOR18wID09IDMyMDFcbmRlcHRoLng9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyMCx2VXYpKTtcbiNlbHNlXG5kZXB0aC54PXRleHR1cmUyRChkZXB0aEJ1ZmZlcjAsdlV2KS5yO1xuI2lmZGVmIExPR19ERVBUSFxuZmxvYXQgZD1wb3coMi4wLGRlcHRoLngqbG9nMihjYW1lcmFOZWFyRmFyLnkrMS4wKSktMS4wO2Zsb2F0IGE9Y2FtZXJhTmVhckZhci55LyhjYW1lcmFOZWFyRmFyLnktY2FtZXJhTmVhckZhci54KTtmbG9hdCBiPWNhbWVyYU5lYXJGYXIueSpjYW1lcmFOZWFyRmFyLngvKGNhbWVyYU5lYXJGYXIueC1jYW1lcmFOZWFyRmFyLnkpO2RlcHRoLng9YStiL2Q7XG4jZW5kaWZcbiNlbmRpZlxuI2lmIERFUFRIX1BBQ0tJTkdfMSA9PSAzMjAxXG5kZXB0aC55PXVucGFja1JHQkFUb0RlcHRoKHRleHR1cmUyRChkZXB0aEJ1ZmZlcjEsdlV2KSk7XG4jZWxzZVxuZGVwdGgueT10ZXh0dXJlMkQoZGVwdGhCdWZmZXIxLHZVdikucjtcbiNpZmRlZiBMT0dfREVQVEhcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aC55KmxvZzIoY2FtZXJhTmVhckZhci55KzEuMCkpLTEuMDtmbG9hdCBhPWNhbWVyYU5lYXJGYXIueS8oY2FtZXJhTmVhckZhci55LWNhbWVyYU5lYXJGYXIueCk7ZmxvYXQgYj1jYW1lcmFOZWFyRmFyLnkqY2FtZXJhTmVhckZhci54LyhjYW1lcmFOZWFyRmFyLngtY2FtZXJhTmVhckZhci55KTtkZXB0aC55PWErYi9kO1xuI2VuZGlmXG4jZW5kaWZcbmJvb2wgaXNNYXhEZXB0aD0oZGVwdGgueD09MS4wKTtcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcbmRlcHRoLng9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKGdldFZpZXdaKGRlcHRoLngpLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO2RlcHRoLnk9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKGdldFZpZXdaKGRlcHRoLnkpLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xuI2VuZGlmXG4jaWYgREVQVEhfVEVTVF9TVFJBVEVHWSA9PSAwXG5ib29sIGtlZXA9ZGVwdGhUZXN0KGRlcHRoLngsZGVwdGgueSk7XG4jZWxpZiBERVBUSF9URVNUX1NUUkFURUdZID09IDFcbmJvb2wga2VlcD1pc01heERlcHRofHxkZXB0aFRlc3QoZGVwdGgueCxkZXB0aC55KTtcbiNlbHNlXG5ib29sIGtlZXA9IWlzTWF4RGVwdGgmJmRlcHRoVGVzdChkZXB0aC54LGRlcHRoLnkpO1xuI2VuZGlmXG5pZihrZWVwKXtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdik7fWVsc2V7ZGlzY2FyZDt9fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhNYXNrTWF0ZXJpYWwuanNcbnZhciBEZXB0aE1hc2tNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxMCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIG1hc2sgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkRlcHRoTWFza01hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX0VQU0lMT046IFwiMC4wMDAxXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkdfMDogXCIwXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkdfMTogXCIwXCIsXG4gICAgICAgIERFUFRIX1RFU1RfU1RSQVRFR1k6IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMjAobnVsbCksXG4gICAgICAgIGRlcHRoQnVmZmVyMDogbmV3IFVuaWZvcm0yMChudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXIxOiBuZXcgVW5pZm9ybTIwKG51bGwpLFxuICAgICAgICBjYW1lcmFOZWFyRmFyOiBuZXcgVW5pZm9ybTIwKG5ldyBWZWN0b3IyMTEoMSwgMSkpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc5LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfbWFza19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIHRoaXMuZGVwdGhNb2RlID0gTGVzc0RlcHRoO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJpbWFyeSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyMCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIwLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmltYXJ5IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZzAodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lOR18wID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlcjAgYW5kIGRlcHRoUGFja2luZzAgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIwKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc1KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlcjAgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcwID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2Vjb25kYXJ5IGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIxKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlcjEudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlY29uZGFyeSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcxKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkdfMSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlciB0aGF0IHdpbGwgYmUgY29tcGFyZWQgd2l0aCB0aGUgYmFzZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlcjEgYW5kIGRlcHRoUGFja2luZzEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIxKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc1KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlcjEgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcxID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIG1heGltdW0gZGVwdGguXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFRlc3RTdHJhdGVneX1cbiAgICovXG4gIGdldCBtYXhEZXB0aFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX1RFU1RfU1RSQVRFR1kpO1xuICB9XG4gIHNldCBtYXhEZXB0aFN0cmF0ZWd5KHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1RFU1RfU1RSQVRFR1kgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBtYXhpbXVtIGRlcHRoIHZhbHVlcyBzaG91bGQgYmUgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heERlcHRoU3RyYXRlZ3kgaW5zdGVhZC5cbiAgICovXG4gIGdldCBrZWVwRmFyKCkge1xuICAgIHJldHVybiB0aGlzLm1heERlcHRoU3RyYXRlZ3k7XG4gIH1cbiAgc2V0IGtlZXBGYXIodmFsdWUpIHtcbiAgICB0aGlzLm1heERlcHRoU3RyYXRlZ3kgPSB2YWx1ZSA/IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIIDogRGVwdGhUZXN0U3RyYXRlZ3kuRElTQ0FSRF9NQVhfREVQVEg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmF0ZWd5IGZvciBkZWFsaW5nIHdpdGggbWF4aW11bSBkZXB0aCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZXB0aFN0cmF0ZWd5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0RlcHRoVGVzdFN0cmF0ZWd5fSBUaGUgc3RyYXRlZ3kuXG4gICAqL1xuICBnZXRNYXhEZXB0aFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiB0aGlzLm1heERlcHRoU3RyYXRlZ3k7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cmF0ZWd5IGZvciBkZWFsaW5nIHdpdGggbWF4aW11bSBkZXB0aCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZXB0aFN0cmF0ZWd5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhUZXN0U3RyYXRlZ3l9IHZhbHVlIC0gVGhlIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0TWF4RGVwdGhTdHJhdGVneSh2YWx1ZSkge1xuICAgIHRoaXMubWF4RGVwdGhTdHJhdGVneSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBIHNtYWxsIGVycm9yIHRocmVzaG9sZCB0aGF0IGlzIHVzZWQgZm9yIGBFcXVhbERlcHRoYCBhbmQgYE5vdEVxdWFsRGVwdGhgIHRlc3RzLiBEZWZhdWx0IGlzIGAxZS00YC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBlcHNpbG9uKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX0VQU0lMT04pO1xuICB9XG4gIHNldCBlcHNpbG9uKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX0VQU0lMT04gPSB2YWx1ZS50b0ZpeGVkKDE2KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBlcnJvciB0aHJlc2hvbGQgZm9yIGRlcHRoIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXBzaWxvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBlcnJvciB0aHJlc2hvbGQuXG4gICAqL1xuICBnZXRFcHNpbG9uKCkge1xuICAgIHJldHVybiB0aGlzLmVwc2lsb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGNvbXBhcmlzb24gZXJyb3IgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXBzaWxvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IGVycm9yIHRocmVzaG9sZC5cbiAgICovXG4gIHNldEVwc2lsb24odmFsdWUpIHtcbiAgICB0aGlzLmVwc2lsb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIG1vZGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vY29uc3RhbnRzL01hdGVyaWFsc1xuICAgKiBAdHlwZSB7RGVwdGhNb2Rlc31cbiAgICovXG4gIGdldCBkZXB0aE1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuREVQVEhfTU9ERSk7XG4gIH1cbiAgc2V0IGRlcHRoTW9kZSh2YWx1ZSkge1xuICAgIGxldCBkZXB0aFRlc3Q7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBOZXZlckRlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImZhbHNlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbHdheXNEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJ0cnVlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcXVhbERlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImFicyhkMSAtIGQwKSA8PSBERVBUSF9FUFNJTE9OXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOb3RFcXVhbERlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImFicyhkMSAtIGQwKSA+IERFUFRIX0VQU0lMT05cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlc3NEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJkMCA+IGQxXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZXNzRXF1YWxEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJkMCA+PSBkMVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XG4gICAgICAgIGRlcHRoVGVzdCA9IFwiZDAgPD0gZDFcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyZWF0ZXJEZXB0aDpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGRlcHRoVGVzdCA9IFwiZDAgPCBkMVwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lc1tcImRlcHRoVGVzdChkMCwgZDEpXCJdID0gZGVwdGhUZXN0O1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlcHRoIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aE1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RGVwdGhNb2Rlc30gVGhlIGRlcHRoIG1vZGUuIERlZmF1bHQgaXMgYExlc3NEZXB0aGAuXG4gICAqL1xuICBnZXREZXB0aE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGhNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhNb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhNb2Rlc30gbW9kZSAtIFRoZSBkZXB0aCBtb2RlLlxuICAgKi9cbiAgc2V0RGVwdGhNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmRlcHRoTW9kZSA9IG1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlDYW1lcmFTZXR0aW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS5zZXQoY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIpO1xuICAgICAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhMikge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Hb2RSYXlzTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzEwLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDExLCBVbmlmb3JtIGFzIFVuaWZvcm0yMSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uZ29kLXJheXMuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2dvZF9yYXlzX2RlZmF1bHQgPSBgI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG51bmlmb3JtIHZlYzIgbGlnaHRQb3NpdGlvbjt1bmlmb3JtIGZsb2F0IGV4cG9zdXJlO3VuaWZvcm0gZmxvYXQgZGVjYXk7dW5pZm9ybSBmbG9hdCBkZW5zaXR5O3VuaWZvcm0gZmxvYXQgd2VpZ2h0O3VuaWZvcm0gZmxvYXQgY2xhbXBNYXg7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2ZWMyIGNvb3JkPXZVdjt2ZWMyIGRlbHRhPWxpZ2h0UG9zaXRpb24tY29vcmQ7ZGVsdGEqPTEuMC9TQU1QTEVTX0ZMT0FUKmRlbnNpdHk7ZmxvYXQgaWxsdW1pbmF0aW9uRGVjYXk9MS4wO3ZlYzQgY29sb3I9dmVjNCgwLjApO2ZvcihpbnQgaT0wO2k8U0FNUExFU19JTlQ7KytpKXtjb29yZCs9ZGVsdGE7dmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmQpO3RleGVsKj1pbGx1bWluYXRpb25EZWNheSp3ZWlnaHQ7Y29sb3IrPXRleGVsO2lsbHVtaW5hdGlvbkRlY2F5Kj1kZWNheTt9Z2xfRnJhZ0NvbG9yPWNsYW1wKGNvbG9yKmV4cG9zdXJlLDAuMCxjbGFtcE1heCk7XG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvR29kUmF5c01hdGVyaWFsLmpzXG52YXIgR29kUmF5c01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDExIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ29kIHJheXMgbWF0ZXJpYWwuXG4gICAqXG4gICAqIFRPRE8gUmVtb3ZlIGxpZ2h0UG9zaXRpb24gcGFyYW0uXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gbGlnaHRQb3NpdGlvbiAtIERlcHJlY2F0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsaWdodFBvc2l0aW9uKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJHb2RSYXlzTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgU0FNUExFU19JTlQ6IFwiNjBcIixcbiAgICAgICAgU0FNUExFU19GTE9BVDogXCI2MC4wXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0yMShudWxsKSxcbiAgICAgICAgbGlnaHRQb3NpdGlvbjogbmV3IFVuaWZvcm0yMShsaWdodFBvc2l0aW9uKSxcbiAgICAgICAgZGVuc2l0eTogbmV3IFVuaWZvcm0yMSgxKSxcbiAgICAgICAgZGVjYXk6IG5ldyBVbmlmb3JtMjEoMSksXG4gICAgICAgIHdlaWdodDogbmV3IFVuaWZvcm0yMSgxKSxcbiAgICAgICAgZXhwb3N1cmU6IG5ldyBVbmlmb3JtMjEoMSksXG4gICAgICAgIGNsYW1wTWF4OiBuZXcgVW5pZm9ybTIxKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxMCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGNvbnZvbHV0aW9uX2dvZF9yYXlzX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IGxpZ2h0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubGlnaHRQb3NpdGlvbi52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsaWdodFBvc2l0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIGdldExpZ2h0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubGlnaHRQb3NpdGlvbi52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsaWdodFBvc2l0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdmFsdWUgLSBUaGUgcG9zaXRpb24uXG4gICAqL1xuICBzZXRMaWdodFBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5saWdodFBvc2l0aW9uLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGVuc2l0eS52YWx1ZTtcbiAgfVxuICBzZXQgZGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkZW5zaXR5LlxuICAgKi9cbiAgZ2V0RGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kZW5zaXR5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZGVuc2l0eS5cbiAgICovXG4gIHNldERlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlbnNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlY2F5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRlY2F5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlY2F5LnZhbHVlO1xuICB9XG4gIHNldCBkZWNheSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVjYXkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVjYXkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZWNheSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkZWNheS5cbiAgICovXG4gIGdldERlY2F5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlY2F5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWNheS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlY2F5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkZWNheS5cbiAgICovXG4gIHNldERlY2F5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWNheS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2VpZ2h0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy53ZWlnaHQudmFsdWU7XG4gIH1cbiAgc2V0IHdlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMud2VpZ2h0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdlaWdodC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3ZWlnaHQuXG4gICAqL1xuICBnZXRXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMud2VpZ2h0LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB3ZWlnaHQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB3ZWlnaHQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHdlaWdodC5cbiAgICovXG4gIHNldFdlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMud2VpZ2h0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBleHBvc3VyZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBleHBvc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5leHBvc3VyZS52YWx1ZTtcbiAgfVxuICBzZXQgZXhwb3N1cmUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmV4cG9zdXJlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4cG9zdXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXhwb3N1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZXhwb3N1cmUuXG4gICAqL1xuICBnZXRFeHBvc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5leHBvc3VyZS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZXhwb3N1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleHBvc3VyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZXhwb3N1cmUuXG4gICAqL1xuICBzZXRFeHBvc3VyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZXhwb3N1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gbGlnaHQgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1heEludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jbGFtcE1heC52YWx1ZTtcbiAgfVxuICBzZXQgbWF4SW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5jbGFtcE1heC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGxpZ2h0IGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heEludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtYXhpbXVtIGxpZ2h0IGludGVuc2l0eS5cbiAgICovXG4gIGdldE1heEludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jbGFtcE1heC52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBsaWdodCBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhJbnRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG1heGltdW0gbGlnaHQgaW50ZW5zaXR5LlxuICAgKi9cbiAgc2V0TWF4SW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5jbGFtcE1heC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuU0FNUExFU19JTlQpO1xuICB9XG4gIHNldCBzYW1wbGVzKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIHRoaXMuZGVmaW5lcy5TQU1QTEVTX0lOVCA9IHMudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuU0FNUExFU19GTE9BVCA9IHMudG9GaXhlZCgxKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2FtcGxlcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzYW1wbGUgY291bnQuXG4gICAqL1xuICBnZXRTYW1wbGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNhbXBsZXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFtb3VudCBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNhbXBsZXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNhbXBsZSBjb3VudC5cbiAgICovXG4gIHNldFNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLnNhbXBsZXMgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9SZW5kZXJQYXNzLmpzXG52YXIgUmVuZGVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJlbmRlciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRvIHVzZSB0byByZW5kZXIgdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbb3ZlcnJpZGVNYXRlcmlhbD1udWxsXSAtIEFuIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCA9IG51bGwpIHtcbiAgICBzdXBlcihcIlJlbmRlclBhc3NcIiwgc2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyUGFzcyA9IG5ldyBDbGVhclBhc3MoKTtcbiAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gbnVsbCA/IG51bGwgOiBuZXcgT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIob3ZlcnJpZGVNYXRlcmlhbCk7XG4gICAgdGhpcy5pZ25vcmVCYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5za2lwU2hhZG93TWFwVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLnNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIGdldCByZW5kZXJUb1NjcmVlbigpIHtcbiAgICByZXR1cm4gc3VwZXIucmVuZGVyVG9TY3JlZW47XG4gIH1cbiAgc2V0IHJlbmRlclRvU2NyZWVuKHZhbHVlKSB7XG4gICAgc3VwZXIucmVuZGVyVG9TY3JlZW4gPSB2YWx1ZTtcbiAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXJUb1NjcmVlbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IG92ZXJyaWRlTWF0ZXJpYWwoKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXI7XG4gICAgcmV0dXJuIG1hbmFnZXIgIT09IG51bGwgPyBtYW5hZ2VyLm1hdGVyaWFsIDogbnVsbDtcbiAgfVxuICBzZXQgb3ZlcnJpZGVNYXRlcmlhbCh2YWx1ZSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgICAgbWFuYWdlci5zZXRNYXRlcmlhbCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyID0gbmV3IE92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgIG1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsTWFuYWdlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0T3ZlcnJpZGVNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVycmlkZU1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TWF0ZXJpYWx9IHZhbHVlIC0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0T3ZlcnJpZGVNYXRlcmlhbCh2YWx1ZSkge1xuICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0IGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqL1xuICBnZXQgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzLmVuYWJsZWQ7XG4gIH1cbiAgc2V0IGNsZWFyKHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhclBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3Rpb24uIERlZmF1bHQgaXMgYG51bGxgIChubyByZXN0cmljdGlvbikuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGUgc2VsZWN0aW9uLlxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0aW9uLiBTZXQgdG8gYG51bGxgIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHZhbHVlIC0gVGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldFNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzY2VuZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaWdub3JlQmFja2dyb3VuZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzY2VuZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgaXNCYWNrZ3JvdW5kRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWdub3JlQmFja2dyb3VuZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2NlbmUgYmFja2dyb3VuZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlnbm9yZUJhY2tncm91bmQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIHNjZW5lIGJhY2tncm91bmQgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0QmFja2dyb3VuZERpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pZ25vcmVCYWNrZ3JvdW5kID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzaGFkb3cgbWFwIGF1dG8gdXBkYXRlIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2tpcFNoYWRvd01hcFVwZGF0ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzaGFkb3cgbWFwIHVwZGF0ZSBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGlzU2hhZG93TWFwRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcFNoYWRvd01hcFVwZGF0ZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93IG1hcCBhdXRvIHVwZGF0ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNraXBTaGFkb3dNYXBVcGRhdGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIHNoYWRvdyBtYXAgYXV0byB1cGRhdGUgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0U2hhZG93TWFwRGlzYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLnNraXBTaGFkb3dNYXBVcGRhdGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xlYXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0NsZWFyUGFzc30gVGhlIGNsZWFyIHBhc3MuXG4gICAqL1xuICBnZXRDbGVhclBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzY2VuZS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIGNvbnN0IG1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2s7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG4gICAgY29uc3Qgc2hhZG93TWFwQXV0b1VwZGF0ZSA9IHJlbmRlcmVyLnNoYWRvd01hcC5hdXRvVXBkYXRlO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogaW5wdXRCdWZmZXI7XG4gICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgY2FtZXJhLmxheWVycy5zZXQoc2VsZWN0aW9uLmdldExheWVyKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2lwU2hhZG93TWFwVXBkYXRlKSB7XG4gICAgICByZW5kZXJlci5zaGFkb3dNYXAuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVCYWNrZ3JvdW5kIHx8IHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciAhPT0gbnVsbCkge1xuICAgICAgc2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNsZWFyUGFzcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyKTtcbiAgICB9XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIucmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIH1cbiAgICBjYW1lcmEubGF5ZXJzLm1hc2sgPSBtYXNrO1xuICAgIHNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIHJlbmRlcmVyLnNoYWRvd01hcC5hdXRvVXBkYXRlID0gc2hhZG93TWFwQXV0b1VwZGF0ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9nb2QtcmF5cy5mcmFnXG52YXIgZ29kX3JheXNfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFwO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9dGV4dHVyZTJEKG1hcCx1dik7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0dvZFJheXNFZmZlY3QuanNcbnZhciB2ID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG52YXIgbSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWF0cml4NCgpO1xudmFyIEdvZFJheXNFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGdvZCByYXlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IFtjYW1lcmFdIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge01lc2h8UG9pbnRzfSBbbGlnaHRTb3VyY2VdIC0gVGhlIGxpZ2h0IHNvdXJjZS4gTXVzdCBub3Qgd3JpdGUgZGVwdGggYW5kIGhhcyB0byBiZSBmbGFnZ2VkIGFzIHRyYW5zcGFyZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNDUkVFTl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYW1wbGVzPTYwLjBdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbnNpdHk9MC45Nl0gLSBUaGUgZGVuc2l0eSBvZiB0aGUgbGlnaHQgcmF5cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlY2F5PTAuOV0gLSBBbiBpbGx1bWluYXRpb24gZGVjYXkgZmFjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2VpZ2h0PTAuNF0gLSBBIGxpZ2h0IHJheSB3ZWlnaHQgZmFjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZXhwb3N1cmU9MC42XSAtIEEgY29uc3RhbnQgYXR0ZW51YXRpb24gY29lZmZpY2llbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGFtcE1heD0xLjBdIC0gQW4gdXBwZXIgYm91bmQgZm9yIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBvdmVyYWxsIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuU01BTExdIC0gVGhlIGJsdXIga2VybmVsIHNpemUuIEhhcyBubyBlZmZlY3QgaWYgYmx1ciBpcyBkaXNhYmxlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ibHVyPXRydWVdIC0gV2hldGhlciB0aGUgZ29kIHJheXMgc2hvdWxkIGJlIGJsdXJyZWQgdG8gcmVkdWNlIGFydGlmYWN0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSwgbGlnaHRTb3VyY2UsIHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TQ1JFRU4sXG4gICAgc2FtcGxlcyA9IDYwLFxuICAgIGRlbnNpdHkgPSAwLjk2LFxuICAgIGRlY2F5ID0gMC45LFxuICAgIHdlaWdodCA9IDAuNCxcbiAgICBleHBvc3VyZSA9IDAuNixcbiAgICBjbGFtcE1heCA9IDEsXG4gICAgYmx1ciA9IHRydWUsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuU01BTEwsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdvZFJheXNFZmZlY3RcIiwgZ29kX3JheXNfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTIyKG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLl9saWdodFNvdXJjZSA9IGxpZ2h0U291cmNlO1xuICAgIHRoaXMubGlnaHRTb3VyY2UgPSBsaWdodFNvdXJjZTtcbiAgICB0aGlzLmxpZ2h0U2NlbmUgPSBuZXcgU2NlbmUyKCk7XG4gICAgdGhpcy5zY3JlZW5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IyMTIoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxMCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5uYW1lID0gXCJHb2RSYXlzLlRhcmdldC5BXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCID0gdGhpcy5yZW5kZXJUYXJnZXRBLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUubmFtZSA9IFwiR29kUmF5cy5UYXJnZXQuQlwiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMaWdodCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDEwKDEsIDEpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQudGV4dHVyZS5uYW1lID0gXCJHb2RSYXlzLkxpZ2h0XCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMaWdodC5kZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlMigpO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0ID0gbmV3IFJlbmRlclBhc3ModGhpcy5saWdodFNjZW5lLCBjYW1lcmEpO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0LmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3IzKDApO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyh0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjMoMCk7XG4gICAgdGhpcy5ibHVyUGFzcyA9IG5ldyBLYXdhc2VCbHVyUGFzcyh7IGtlcm5lbFNpemUgfSk7XG4gICAgdGhpcy5ibHVyUGFzcy5lbmFibGVkID0gYmx1cjtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgRGVwdGhNYXNrTWF0ZXJpYWwoKSk7XG4gICAgY29uc3QgZGVwdGhNYXNrTWF0ZXJpYWwgPSB0aGlzLmRlcHRoTWFza01hdGVyaWFsO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmRlcHRoQnVmZmVyMSA9IHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQuZGVwdGhUZXh0dXJlO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICAgIHRoaXMuZ29kUmF5c1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgR29kUmF5c01hdGVyaWFsKHRoaXMuc2NyZWVuUG9zaXRpb24pKTtcbiAgICBjb25zdCBnb2RSYXlzTWF0ZXJpYWwgPSB0aGlzLmdvZFJheXNNYXRlcmlhbDtcbiAgICBnb2RSYXlzTWF0ZXJpYWwuZGVuc2l0eSA9IGRlbnNpdHk7XG4gICAgZ29kUmF5c01hdGVyaWFsLmRlY2F5ID0gZGVjYXk7XG4gICAgZ29kUmF5c01hdGVyaWFsLndlaWdodCA9IHdlaWdodDtcbiAgICBnb2RSYXlzTWF0ZXJpYWwuZXhwb3N1cmUgPSBleHBvc3VyZTtcbiAgICBnb2RSYXlzTWF0ZXJpYWwubWF4SW50ZW5zaXR5ID0gY2xhbXBNYXg7XG4gICAgZ29kUmF5c01hdGVyaWFsLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLnJlbmRlclBhc3NMaWdodC5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aE1hc2tNYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEB0eXBlIHtNZXNofFBvaW50c31cbiAgICovXG4gIGdldCBsaWdodFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlnaHRTb3VyY2U7XG4gIH1cbiAgc2V0IGxpZ2h0U291cmNlKHZhbHVlKSB7XG4gICAgdGhpcy5fbGlnaHRTb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlLm1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICAgIHZhbHVlLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgcGFzcyB0aGF0IHJlZHVjZXMgYWxpYXNpbmcgYXJ0aWZhY3RzIGFuZCBtYWtlcyB0aGUgbGlnaHQgc29mdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIGludGVybWVkaWF0ZSByZXN1bHQgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnb2QgcmF5cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIG1hc2sgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aE1hc2tNYXRlcmlhbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBkZXB0aE1hc2tNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aE1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGludGVybmFsIGdvZCByYXlzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7R29kUmF5c01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGdvZFJheXNNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdvZCByYXlzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ29kUmF5c01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0dvZFJheXNNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0R29kUmF5c01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmdvZFJheXNNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7R29kUmF5c01hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ud2lkdGggaW5zdGVhZC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5oZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzTWF0ZXJpYWwuZGl0aGVyaW5nO1xuICB9XG4gIHNldCBkaXRoZXJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZ29kUmF5c01hdGVyaWFsO1xuICAgIG1hdGVyaWFsLmRpdGhlcmluZyA9IHZhbHVlO1xuICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdvZCByYXlzIHNob3VsZCBiZSBibHVycmVkIHRvIHJlZHVjZSBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3MuZW5hYmxlZDtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0tlcm5lbFNpemV9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyUGFzcy5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqL1xuICBnZXQga2VybmVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplO1xuICB9XG4gIHNldCBrZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdvZFJheXNNYXRlcmlhbC5zYW1wbGVzIGluc3RlYWQuXG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzTWF0ZXJpYWwuc2FtcGxlcztcbiAgfVxuICAvKipcbiAgICogQSBoaWdoZXIgc2FtcGxlIGNvdW50IGltcHJvdmVzIHF1YWxpdHkgYXQgdGhlIGNvc3Qgb2YgcGVyZm9ybWFuY2UuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBnb2RSYXlzTWF0ZXJpYWwuc2FtcGxlcyBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLmdvZFJheXNNYXRlcmlhbC5zYW1wbGVzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nNikge1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhCdWZmZXIwID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhQYWNraW5nMCA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgbGlnaHRTb3VyY2UgPSB0aGlzLmxpZ2h0U291cmNlO1xuICAgIGNvbnN0IHBhcmVudCA9IGxpZ2h0U291cmNlLnBhcmVudDtcbiAgICBjb25zdCBtYXRyaXhBdXRvVXBkYXRlID0gbGlnaHRTb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRBID0gdGhpcy5yZW5kZXJUYXJnZXRBO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldExpZ2h0ID0gdGhpcy5yZW5kZXJUYXJnZXRMaWdodDtcbiAgICBsaWdodFNvdXJjZS5tYXRlcmlhbC5kZXB0aFdyaXRlID0gdHJ1ZTtcbiAgICBsaWdodFNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgbGlnaHRTb3VyY2UudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICghbWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgICBtLmNvcHkobGlnaHRTb3VyY2UubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGxpZ2h0U291cmNlLm1hdHJpeC5jb3B5KGxpZ2h0U291cmNlLm1hdHJpeFdvcmxkKTtcbiAgICB9XG4gICAgdGhpcy5saWdodFNjZW5lLmFkZChsaWdodFNvdXJjZSk7XG4gICAgdGhpcy5yZW5kZXJQYXNzTGlnaHQucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRMaWdodCk7XG4gICAgdGhpcy5jbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRBKTtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRMaWdodCwgcmVuZGVyVGFyZ2V0QSk7XG4gICAgbGlnaHRTb3VyY2UubWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgIGxpZ2h0U291cmNlLm1hdHJpeEF1dG9VcGRhdGUgPSBtYXRyaXhBdXRvVXBkYXRlO1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICghbWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgICBsaWdodFNvdXJjZS5tYXRyaXguY29weShtKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5hZGQobGlnaHRTb3VyY2UpO1xuICAgIH1cbiAgICB2LnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodFNvdXJjZS5tYXRyaXhXb3JsZCkucHJvamVjdCh0aGlzLmNhbWVyYSk7XG4gICAgdGhpcy5zY3JlZW5Qb3NpdGlvbi5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCgodi54ICsgMSkgKiAwLjUsIC0xKSwgMiksXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCgodi55ICsgMSkgKiAwLjUsIC0xKSwgMilcbiAgICApO1xuICAgIGlmICh0aGlzLmJsdXJQYXNzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuYmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRBLCByZW5kZXJUYXJnZXRBKTtcbiAgICB9XG4gICAgdGhpcy5nb2RSYXlzUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldEEsIHRoaXMucmVuZGVyVGFyZ2V0Qik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldExpZ2h0LnNldFNpemUodywgaCk7XG4gICAgdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uLmNvcHkocmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5yZW5kZXJQYXNzTGlnaHQuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5kZXB0aE1hc2tQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuZ29kUmF5c1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlOCkge1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U4O1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U4O1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldExpZ2h0LnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlODtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0dyaWRFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTIzLCBWZWN0b3IyIGFzIFZlY3RvcjIxMyB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2dyaWQuZnJhZ1xudmFyIGdyaWRfZGVmYXVsdCA9IGB1bmlmb3JtIHZlYzIgc2NhbGU7dW5pZm9ybSBmbG9hdCBsaW5lV2lkdGg7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2Zsb2F0IGdyaWQ9MC41LW1heChhYnMobW9kKHV2Lngqc2NhbGUueCwxLjApLTAuNSksYWJzKG1vZCh1di55KnNjYWxlLnksMS4wKS0wLjUpKTtvdXRwdXRDb2xvcj12ZWM0KHZlYzMoc21vb3Roc3RlcCgwLjAsbGluZVdpZHRoLGdyaWQpKSxpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9HcmlkRWZmZWN0LmpzXG52YXIgR3JpZEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ3JpZCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uT1ZFUkxBWV0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZT0xLjBdIC0gVGhlIHNjYWxlIG9mIHRoZSBncmlkIHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW5lV2lkdGg9MC4wXSAtIFRoZSBsaW5lIHdpZHRoIG9mIHRoZSBncmlkIHBhdHRlcm4uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLk9WRVJMQVksIHNjYWxlID0gMSwgbGluZVdpZHRoID0gMCB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdyaWRFZmZlY3RcIiwgZ3JpZF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm0yMyhuZXcgVmVjdG9yMjEzKCkpXSxcbiAgICAgICAgW1wibGluZVdpZHRoXCIsIG5ldyBVbmlmb3JtMjMobGluZVdpZHRoKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIxMygpO1xuICAgIHRoaXMucyA9IDA7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMubCA9IDA7XG4gICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMucyA9IE1hdGgubWF4KHZhbHVlLCAxZS02KTtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBncmlkIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ3JpZCBzY2FsZS5cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBncmlkIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBncmlkIHNjYWxlLlxuICAgKi9cbiAgc2V0U2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsaW5lIHdpZHRoLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxpbmVXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5sO1xuICB9XG4gIHNldCBsaW5lV2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLmwgPSB2YWx1ZTtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBncmlkIGxpbmUgd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsaW5lV2lkdGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKi9cbiAgZ2V0TGluZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVXaWR0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbGluZVdpZHRoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKi9cbiAgc2V0TGluZVdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5saW5lV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZSAqIChoZWlnaHQgKiAwLjEyNSk7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZS5zZXQoYXNwZWN0ICogc2NhbGUsIHNjYWxlKTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImxpbmVXaWR0aFwiKS52YWx1ZSA9IHNjYWxlIC8gaGVpZ2h0ICsgdGhpcy5saW5lV2lkdGg7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0h1ZVNhdHVyYXRpb25FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTI0LCBWZWN0b3IzIGFzIFZlY3RvcjMyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvaHVlLXNhdHVyYXRpb24uZnJhZ1xudmFyIGh1ZV9zYXR1cmF0aW9uX2RlZmF1bHQgPSBgdW5pZm9ybSB2ZWMzIGh1ZTt1bmlmb3JtIGZsb2F0IHNhdHVyYXRpb247dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzMgY29sb3I9dmVjMyhkb3QoaW5wdXRDb2xvci5yZ2IsaHVlLnh5eiksZG90KGlucHV0Q29sb3IucmdiLGh1ZS56eHkpLGRvdChpbnB1dENvbG9yLnJnYixodWUueXp4KSk7ZmxvYXQgYXZlcmFnZT0oY29sb3Iucitjb2xvci5nK2NvbG9yLmIpLzMuMDt2ZWMzIGRpZmY9YXZlcmFnZS1jb2xvcjtpZihzYXR1cmF0aW9uPjAuMCl7Y29sb3IrPWRpZmYqKDEuMC0xLjAvKDEuMDAxLXNhdHVyYXRpb24pKTt9ZWxzZXtjb2xvcis9ZGlmZiotc2F0dXJhdGlvbjt9b3V0cHV0Q29sb3I9dmVjNChtaW4oY29sb3IsMS4wKSxpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9IdWVTYXR1cmF0aW9uRWZmZWN0LmpzXG52YXIgSHVlU2F0dXJhdGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgaHVlL3NhdHVyYXRpb24gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5odWU9MC4wXSAtIFRoZSBodWUgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhdHVyYXRpb249MC4wXSAtIFRoZSBzYXR1cmF0aW9uIGZhY3RvciwgcmFuZ2luZyBmcm9tIC0xIHRvIDEsIHdoZXJlIDAgbWVhbnMgbm8gY2hhbmdlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsIGh1ZSA9IDAsIHNhdHVyYXRpb24gPSAwIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiSHVlU2F0dXJhdGlvbkVmZmVjdFwiLCBodWVfc2F0dXJhdGlvbl9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiaHVlXCIsIG5ldyBVbmlmb3JtMjQobmV3IFZlY3RvcjMyKCkpXSxcbiAgICAgICAgW1wic2F0dXJhdGlvblwiLCBuZXcgVW5pZm9ybTI0KHNhdHVyYXRpb24pXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmh1ZSA9IGh1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNhdHVyYXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2F0dXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzYXR1cmF0aW9uXCIpLnZhbHVlO1xuICB9XG4gIHNldCBzYXR1cmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJzYXR1cmF0aW9uXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNhdHVyYXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzYXR1cmF0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNhdHVyYXRpb24uXG4gICAqL1xuICBnZXRTYXR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNhdHVyYXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNhdHVyYXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzYXR1cmF0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzYXR1cmF0aW9uLlxuICAgKi9cbiAgc2V0U2F0dXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuc2F0dXJhdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGh1ZSgpIHtcbiAgICBjb25zdCBodWUgPSB0aGlzLnVuaWZvcm1zLmdldChcImh1ZVwiKS52YWx1ZTtcbiAgICByZXR1cm4gTWF0aC5hY29zKChodWUueCAqIDMgLSAxKSAvIDIpO1xuICB9XG4gIHNldCBodWUodmFsdWUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5zaW4odmFsdWUpLCBjMiA9IE1hdGguY29zKHZhbHVlKTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImh1ZVwiKS52YWx1ZS5zZXQoXG4gICAgICAoMiAqIGMyICsgMSkgLyAzLFxuICAgICAgKC1NYXRoLnNxcnQoMykgKiBzIC0gYzIgKyAxKSAvIDMsXG4gICAgICAoTWF0aC5zcXJ0KDMpICogcyAtIGMyICsgMSkgLyAzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaHVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaHVlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGh1ZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgZ2V0SHVlKCkge1xuICAgIHJldHVybiB0aGlzLmh1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaHVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaHVlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBodWUgaW4gcmFkaWFucy5cbiAgICovXG4gIHNldEh1ZSh2YWx1ZSkge1xuICAgIHRoaXMuaHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0xlbnNEaXN0b3J0aW9uRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0yNSwgVmVjdG9yMiBhcyBWZWN0b3IyMTQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9sZW5zLWRpc3RvcnRpb24uZnJhZ1xudmFyIGxlbnNfZGlzdG9ydGlvbl9kZWZhdWx0ID0gYHVuaWZvcm0gdmVjMiBkaXN0b3J0aW9uO3VuaWZvcm0gdmVjMiBwcmluY2lwYWxQb2ludDt1bmlmb3JtIHZlYzIgZm9jYWxMZW5ndGg7dW5pZm9ybSBmbG9hdCBza2V3O2Zsb2F0IG1hc2soY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIGZsb2F0KHV2LnM+PTAuMCYmdXYuczw9MS4wJiZ1di50Pj0wLjAmJnV2LnQ8PTEuMCk7fXZvaWQgbWFpblV2KGlub3V0IHZlYzIgdXYpe3ZlYzIgeG49Mi4wKih1di5zdC0wLjUpO3ZlYzMgeERpc3RvcnRlZD12ZWMzKCgxLjArZGlzdG9ydGlvbipkb3QoeG4seG4pKSp4biwxLjApO21hdDMga2s9bWF0Myh2ZWMzKGZvY2FsTGVuZ3RoLngsMC4wLDAuMCksdmVjMyhza2V3KmZvY2FsTGVuZ3RoLngsZm9jYWxMZW5ndGgueSwwLjApLHZlYzMocHJpbmNpcGFsUG9pbnQueCxwcmluY2lwYWxQb2ludC55LDEuMCkpO3V2PShrayp4RGlzdG9ydGVkKS54eSowLjUrMC41O312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9bWFzayh1dikqaW5wdXRDb2xvcjt9YDtcblxuLy8gc3JjL2VmZmVjdHMvTGVuc0Rpc3RvcnRpb25FZmZlY3QuanNcbnZhciBMZW5zRGlzdG9ydGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbGVucyBkaXN0b3J0aW9uIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLmRpc3RvcnRpb25dIC0gVGhlIGRpc3RvcnRpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbnMucHJpbmNpcGFsUG9pbnRdIC0gVGhlIGNlbnRlciBwb2ludC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5mb2NhbExlbmd0aF0gLSBUaGUgZm9jYWwgbGVuZ3RoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2tldz0wXSAtIFRoZSBza2V3IHZhbHVlLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpc3RvcnRpb24gPSBuZXcgVmVjdG9yMjE0KDAsIDApLFxuICAgIHByaW5jaXBhbFBvaW50ID0gbmV3IFZlY3RvcjIxNCgwLCAwKSxcbiAgICBmb2NhbExlbmd0aCA9IG5ldyBWZWN0b3IyMTQoMSwgMSksXG4gICAgc2tldyA9IDBcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJMZW5zRGlzdG9ydGlvbkVmZmVjdFwiLCBsZW5zX2Rpc3RvcnRpb25fZGVmYXVsdCwge1xuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZGlzdG9ydGlvblwiLCBuZXcgVW5pZm9ybTI1KGRpc3RvcnRpb24pXSxcbiAgICAgICAgW1wicHJpbmNpcGFsUG9pbnRcIiwgbmV3IFVuaWZvcm0yNShwcmluY2lwYWxQb2ludCldLFxuICAgICAgICBbXCJmb2NhbExlbmd0aFwiLCBuZXcgVW5pZm9ybTI1KGZvY2FsTGVuZ3RoKV0sXG4gICAgICAgIFtcInNrZXdcIiwgbmV3IFVuaWZvcm0yNShza2V3KV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByYWRpYWwgZGlzdG9ydGlvbiBjb2VmZmljaWVudHMuIERlZmF1bHQgaXMgKDAsIDApLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCBkaXN0b3J0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImRpc3RvcnRpb25cIikudmFsdWU7XG4gIH1cbiAgc2V0IGRpc3RvcnRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImRpc3RvcnRpb25cIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByaW5jaXBhbCBwb2ludC4gRGVmYXVsdCBpcyAoMCwgMCkuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IHByaW5jaXBhbFBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInByaW5jaXBhbFBvaW50XCIpLnZhbHVlO1xuICB9XG4gIHNldCBwcmluY2lwYWxQb2ludCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwicHJpbmNpcGFsUG9pbnRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aC4gRGVmYXVsdCBpcyAoMSwgMSkuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IGZvY2FsTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImZvY2FsTGVuZ3RoXCIpLnZhbHVlO1xuICB9XG4gIHNldCBmb2NhbExlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZm9jYWxMZW5ndGhcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNrZXcgZmFjdG9yIGluIHJhZGlhbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2tldygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJza2V3XCIpLnZhbHVlO1xuICB9XG4gIHNldCBza2V3KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJza2V3XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0xVVDFERWZmZWN0LmpzXG5pbXBvcnQgeyBGbG9hdFR5cGUsIEhhbGZGbG9hdFR5cGUsIFVuaWZvcm0gYXMgVW5pZm9ybTI2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvbHV0LTFkLmZyYWdcbnZhciBsdXRfMWRfZGVmYXVsdCA9IGAjaWZkZWYgTFVUX1BSRUNJU0lPTl9ISUdIXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGx1dDtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGx1dDtcbiNlbmRpZlxuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbHV0O1xuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9dmVjNCh0ZXh0dXJlMkQobHV0LHZlYzIoaW5wdXRDb2xvci5yLDAuNSkpLnIsdGV4dHVyZTJEKGx1dCx2ZWMyKGlucHV0Q29sb3IuZywwLjUpKS5yLHRleHR1cmUyRChsdXQsdmVjMihpbnB1dENvbG9yLmIsMC41KSkucixpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9MVVQxREVmZmVjdC5qc1xudmFyIExVVDFERWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb2xvciBncmFkaW5nIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBsdXQgLSBUaGUgbG9va3VwIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGx1dCwgeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJMVVQxREVmZmVjdFwiLCBsdXRfMWRfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW1wibHV0XCIsIG5ldyBVbmlmb3JtMjYobnVsbCldXSlcbiAgICB9KTtcbiAgICB0aGlzLmx1dCA9IGx1dDtcbiAgfVxuICAvKipcbiAgICogVGhlIExVVC5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgbHV0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImx1dFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgbHV0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJsdXRcIikudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgKHZhbHVlLnR5cGUgPT09IEZsb2F0VHlwZSB8fCB2YWx1ZS50eXBlID09PSBIYWxmRmxvYXRUeXBlKSkge1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkxVVF9QUkVDSVNJT05fSElHSFwiLCBcIjFcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9MVVQzREVmZmVjdC5qc1xuaW1wb3J0IHtcbiAgRGF0YTNEVGV4dHVyZSBhcyBEYXRhM0RUZXh0dXJlMixcbiAgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTMsXG4gIEhhbGZGbG9hdFR5cGUgYXMgSGFsZkZsb2F0VHlwZTIsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXI0LFxuICBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXIyLFxuICBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTEwLFxuICBVbmlmb3JtIGFzIFVuaWZvcm0yNyxcbiAgVmVjdG9yMyBhcyBWZWN0b3IzNFxufSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3RleHR1cmVzL2x1dC9Mb29rdXBUZXh0dXJlLmpzXG5pbXBvcnQge1xuICBDb2xvciBhcyBDb2xvcjQsXG4gIENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIERhdGFUZXh0dXJlIGFzIERhdGFUZXh0dXJlMixcbiAgRGF0YTNEVGV4dHVyZSxcbiAgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTIsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXIzLFxuICBMaW5lYXJTUkdCQ29sb3JTcGFjZSBhcyBMaW5lYXJTUkdCQ29sb3JTcGFjZTMsXG4gIFJHQkFGb3JtYXQgYXMgUkdCQUZvcm1hdDMsXG4gIFNSR0JDb2xvclNwYWNlIGFzIFNSR0JDb2xvclNwYWNlOSxcbiAgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMTAsXG4gIFZlY3RvcjMgYXMgVmVjdG9yMzNcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lbnVtcy9MVVRPcGVyYXRpb24uanNcbnZhciBMVVRPcGVyYXRpb24gPSB7XG4gIFNDQUxFX1VQOiBcImx1dC5zY2FsZXVwXCJcbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9SYXdJbWFnZURhdGEuanNcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0LCBkYXRhKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGRhdGEsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGltYWdlRGF0YS5kYXRhLnNldChkYXRhKTtcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG52YXIgUmF3SW1hZ2VEYXRhID0gY2xhc3MgX1Jhd0ltYWdlRGF0YSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGltYWdlIGRhdGEgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIC0gVGhlIHdpZHRoIG9mIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gLSBUaGUgaGVpZ2h0IG9mIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtVaW50OENsYW1wZWRBcnJheTxBcnJheUJ1ZmZlcj59IFtkYXRhPW51bGxdIC0gVGhlIGltYWdlIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDAsIGRhdGEgPSBudWxsKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYW52YXMgZnJvbSB0aGlzIGltYWdlIGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm4ge0NhbnZhc30gVGhlIGNhbnZhcywgb3IgbnVsbCBpZiBpdCBjb3VsZG4ndCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdG9DYW52YXMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBjcmVhdGVDYW52YXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW1hZ2UgZGF0YSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7SW1hZ2VEYXRhfEltYWdlfSBpbWFnZSAtIEFuIGltYWdlIG9yIHBsYWluIGltYWdlIGRhdGEuXG4gICAqIEByZXR1cm4ge1Jhd0ltYWdlRGF0YX0gVGhlIGltYWdlIGRhdGEuXG4gICAqL1xuICBzdGF0aWMgZnJvbShpbWFnZSkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2U7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKGltYWdlIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0LCBpbWFnZSk7XG4gICAgICBpZiAoY2FudmFzICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGltYWdlLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1Jhd0ltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0LCBkYXRhKTtcbiAgfVxufTtcblxuLy8gdGVtcC9sdXQvd29ya2VyLnR4dFxudmFyIHdvcmtlcl9kZWZhdWx0ID0gJ1widXNlIHN0cmljdFwiOygoKT0+e3ZhciBPPXtTQ0FMRV9VUDpcImx1dC5zY2FsZXVwXCJ9O3ZhciBfPVtuZXcgRmxvYXQzMkFycmF5KDMpLG5ldyBGbG9hdDMyQXJyYXkoMyldLG49W25ldyBGbG9hdDMyQXJyYXkoMyksbmV3IEZsb2F0MzJBcnJheSgzKSxuZXcgRmxvYXQzMkFycmF5KDMpLG5ldyBGbG9hdDMyQXJyYXkoMyldLFo9W1tuZXcgRmxvYXQzMkFycmF5KFswLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pXSxbbmV3IEZsb2F0MzJBcnJheShbMCwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwxXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKV0sW25ldyBGbG9hdDMyQXJyYXkoWzAsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMCwwLDFdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMV0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSldLFtuZXcgRmxvYXQzMkFycmF5KFswLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pXSxbbmV3IEZsb2F0MzJBcnJheShbMCwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwxXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKV0sW25ldyBGbG9hdDMyQXJyYXkoWzAsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMCwwLDFdKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMV0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSldXTtmdW5jdGlvbiBkKGEsdCxyLG0pe2xldCBpPXJbMF0tdFswXSxlPXJbMV0tdFsxXSx5PXJbMl0tdFsyXSxoPWFbMF0tdFswXSxBPWFbMV0tdFsxXSx3PWFbMl0tdFsyXSxjPWUqdy15KkEsbD15KmgtaSp3LHg9aSpBLWUqaCx1PU1hdGguc3FydChjKmMrbCpsK3gqeCksYj11Ki41LHM9Yy91LEY9bC91LGY9eC91LHA9LShhWzBdKnMrYVsxXSpGK2FbMl0qZiksTT1tWzBdKnMrbVsxXSpGK21bMl0qZjtyZXR1cm4gTWF0aC5hYnMoTStwKSpiLzN9ZnVuY3Rpb24gVihhLHQscixtLGksZSl7bGV0IHk9KHIrbSp0K2kqdCp0KSo0O2VbMF09YVt5KzBdLGVbMV09YVt5KzFdLGVbMl09YVt5KzJdfWZ1bmN0aW9uIGsoYSx0LHIsbSxpLGUpe2xldCB5PXIqKHQtMSksaD1tKih0LTEpLEE9aSoodC0xKSx3PU1hdGguZmxvb3IoeSksYz1NYXRoLmZsb29yKGgpLGw9TWF0aC5mbG9vcihBKSx4PU1hdGguY2VpbCh5KSx1PU1hdGguY2VpbChoKSxiPU1hdGguY2VpbChBKSxzPXktdyxGPWgtYyxmPUEtbDtpZih3PT09eSYmYz09PWgmJmw9PT1BKVYoYSx0LHksaCxBLGUpO2Vsc2V7bGV0IHA7cz49RiYmRj49Zj9wPVpbMF06cz49ZiYmZj49Rj9wPVpbMV06Zj49cyYmcz49Rj9wPVpbMl06Rj49cyYmcz49Zj9wPVpbM106Rj49ZiYmZj49cz9wPVpbNF06Zj49RiYmRj49cyYmKHA9Wls1XSk7bGV0W00sZyxYLFldPXAsUD1fWzBdO1BbMF09cyxQWzFdPUYsUFsyXT1mO2xldCBvPV9bMV0sTD14LXcsUz11LWMsVT1iLWw7b1swXT1MKk1bMF0rdyxvWzFdPVMqTVsxXStjLG9bMl09VSpNWzJdK2wsVihhLHQsb1swXSxvWzFdLG9bMl0sblswXSksb1swXT1MKmdbMF0rdyxvWzFdPVMqZ1sxXStjLG9bMl09VSpnWzJdK2wsVihhLHQsb1swXSxvWzFdLG9bMl0sblsxXSksb1swXT1MKlhbMF0rdyxvWzFdPVMqWFsxXStjLG9bMl09VSpYWzJdK2wsVihhLHQsb1swXSxvWzFdLG9bMl0sblsyXSksb1swXT1MKllbMF0rdyxvWzFdPVMqWVsxXStjLG9bMl09VSpZWzJdK2wsVihhLHQsb1swXSxvWzFdLG9bMl0sblszXSk7bGV0IFQ9ZChnLFgsWSxQKSo2LHE9ZChNLFgsWSxQKSo2LEM9ZChNLGcsWSxQKSo2LEU9ZChNLGcsWCxQKSo2O25bMF1bMF0qPVQsblswXVsxXSo9VCxuWzBdWzJdKj1ULG5bMV1bMF0qPXEsblsxXVsxXSo9cSxuWzFdWzJdKj1xLG5bMl1bMF0qPUMsblsyXVsxXSo9QyxuWzJdWzJdKj1DLG5bM11bMF0qPUUsblszXVsxXSo9RSxuWzNdWzJdKj1FLGVbMF09blswXVswXStuWzFdWzBdK25bMl1bMF0rblszXVswXSxlWzFdPW5bMF1bMV0rblsxXVsxXStuWzJdWzFdK25bM11bMV0sZVsyXT1uWzBdWzJdK25bMV1bMl0rblsyXVsyXStuWzNdWzJdfX12YXIgdj1jbGFzc3tzdGF0aWMgZXhwYW5kKHQscil7bGV0IG09TWF0aC5jYnJ0KHQubGVuZ3RoLzQpLGk9bmV3IEZsb2F0MzJBcnJheSgzKSxlPW5ldyB0LmNvbnN0cnVjdG9yKHIqKjMqNCkseT10IGluc3RhbmNlb2YgVWludDhBcnJheT8yNTU6MSxoPXIqKjIsQT0xLyhyLTEpO2ZvcihsZXQgdz0wO3c8cjsrK3cpZm9yKGxldCBjPTA7YzxyOysrYylmb3IobGV0IGw9MDtsPHI7KytsKXtsZXQgeD1sKkEsdT1jKkEsYj13KkEscz1NYXRoLnJvdW5kKGwrYypyK3cqaCkqNDtrKHQsbSx4LHUsYixpKSxlW3MrMF09aVswXSxlW3MrMV09aVsxXSxlW3MrMl09aVsyXSxlW3MrM109eX1yZXR1cm4gZX19O3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixhPT57bGV0IHQ9YS5kYXRhLHI9dC5kYXRhO3N3aXRjaCh0Lm9wZXJhdGlvbil7Y2FzZSBPLlNDQUxFX1VQOnI9di5leHBhbmQocix0LnNpemUpO2JyZWFrfXBvc3RNZXNzYWdlKHIsW3IuYnVmZmVyXSksY2xvc2UoKX0pO30pKCk7XFxuJztcblxuLy8gc3JjL3RleHR1cmVzL2x1dC9Mb29rdXBUZXh0dXJlLmpzXG52YXIgYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQ29sb3I0KCk7XG52YXIgTG9va3VwVGV4dHVyZSA9IGNsYXNzIF9Mb29rdXBUZXh0dXJlIGV4dGVuZHMgRGF0YTNEVGV4dHVyZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgY3ViaWMgM0QgbG9va3VwIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VHlwZWRBcnJheX0gZGF0YSAtIFRoZSBwaXhlbCBkYXRhLiBUaGUgZGVmYXVsdCBmb3JtYXQgaXMgUkdCQS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgc2lkZWxlbmd0aC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIHNpemUpIHtcbiAgICBzdXBlcihkYXRhLCBzaXplLCBzaXplLCBzaXplKTtcbiAgICB0aGlzLnR5cGUgPSBGbG9hdFR5cGUyO1xuICAgIHRoaXMuZm9ybWF0ID0gUkdCQUZvcm1hdDM7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXIzO1xuICAgIHRoaXMubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyMztcbiAgICB0aGlzLndyYXBTID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0aGlzLndyYXBUID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0aGlzLndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5jb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2UzO1xuICAgIHRoaXMuZG9tYWluTWluID0gbmV3IFZlY3RvcjMzKDAsIDAsIDApO1xuICAgIHRoaXMuZG9tYWluTWF4ID0gbmV3IFZlY3RvcjMzKDEsIDEsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIExvb2t1cFRleHR1cmUzRC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgaXNMb29rdXBUZXh0dXJlM0QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNjYWxlcyB0aGlzIExVVCB1cCB0byBhIGdpdmVuIHRhcmdldCBzaXplIHVzaW5nIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gVGhlIHRhcmdldCBzaWRlbGVuZ3RoLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0cmFuc2ZlckRhdGE9dHJ1ZV0gLSBFeHRyYSBmYXN0IG1vZGUuIFNldCB0byBmYWxzZSB0byBrZWVwIHRoZSBvcmlnaW5hbCBkYXRhIGludGFjdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxMb29rdXBUZXh0dXJlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIG5ldyBMVVQgdXBvbiBjb21wbGV0aW9uLlxuICAgKi9cbiAgc2NhbGVVcChzaXplLCB0cmFuc2ZlckRhdGEgPSB0cnVlKSB7XG4gICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmIChzaXplIDw9IGltYWdlLndpZHRoKSB7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVGhlIHRhcmdldCBzaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBjdXJyZW50IHNpemVcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3b3JrZXJfZGVmYXVsdF0sIHtcbiAgICAgICAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVUkwpO1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldmVudCkgPT4gcmVqZWN0KGV2ZW50LmVycm9yKSk7XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBsdXQgPSBuZXcgX0xvb2t1cFRleHR1cmUoZXZlbnQuZGF0YSwgc2l6ZSk7XG4gICAgICAgICAgdGhpcy5jb2xvclNwYWNlID0gbHV0LmNvbG9yU3BhY2U7XG4gICAgICAgICAgbHV0LnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgICAgbHV0Lm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJVUkwpO1xuICAgICAgICAgIHJlc29sdmUobHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyTGlzdCA9IHRyYW5zZmVyRGF0YSA/IFtpbWFnZS5kYXRhLmJ1ZmZlcl0gOiBbXTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBvcGVyYXRpb246IExVVE9wZXJhdGlvbi5TQ0FMRV9VUCxcbiAgICAgICAgICBkYXRhOiBpbWFnZS5kYXRhLFxuICAgICAgICAgIHNpemVcbiAgICAgICAgfSwgdHJhbnNmZXJMaXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gTFVUIHRvIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge0xvb2t1cFRleHR1cmV9IGx1dCAtIEEgTFVULiBNdXN0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucywgdHlwZSBhbmQgZm9ybWF0IGFzIHRoaXMgTFVULlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGlzIHRleHR1cmUuXG4gICAqL1xuICBhcHBseUxVVChsdXQpIHtcbiAgICBjb25zdCBpbWcwID0gdGhpcy5pbWFnZTtcbiAgICBjb25zdCBpbWcxID0gbHV0LmltYWdlO1xuICAgIGNvbnN0IHNpemUwID0gTWF0aC5taW4oaW1nMC53aWR0aCwgaW1nMC5oZWlnaHQsIGltZzAuZGVwdGgpO1xuICAgIGNvbnN0IHNpemUxID0gTWF0aC5taW4oaW1nMS53aWR0aCwgaW1nMS5oZWlnaHQsIGltZzEuZGVwdGgpO1xuICAgIGlmIChzaXplMCAhPT0gc2l6ZTEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTaXplIG1pc21hdGNoXCIpO1xuICAgIH0gZWxzZSBpZiAobHV0LnR5cGUgIT09IEZsb2F0VHlwZTIgfHwgdGhpcy50eXBlICE9PSBGbG9hdFR5cGUyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQm90aCBMVVRzIG11c3QgYmUgRmxvYXRUeXBlIHRleHR1cmVzXCIpO1xuICAgIH0gZWxzZSBpZiAobHV0LmZvcm1hdCAhPT0gUkdCQUZvcm1hdDMgfHwgdGhpcy5mb3JtYXQgIT09IFJHQkFGb3JtYXQzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQm90aCBMVVRzIG11c3QgYmUgUkdCQSB0ZXh0dXJlc1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGF0YTAgPSBpbWcwLmRhdGE7XG4gICAgICBjb25zdCBkYXRhMSA9IGltZzEuZGF0YTtcbiAgICAgIGNvbnN0IHNpemUgPSBzaXplMDtcbiAgICAgIGNvbnN0IHNpemVTcSA9IHNpemUgKiogMjtcbiAgICAgIGNvbnN0IHMgPSBzaXplIC0gMTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc2l6ZSAqKiAzOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGk0ID0gaSAqIDQ7XG4gICAgICAgIGNvbnN0IHIgPSBkYXRhMFtpNCArIDBdICogcztcbiAgICAgICAgY29uc3QgZyA9IGRhdGEwW2k0ICsgMV0gKiBzO1xuICAgICAgICBjb25zdCBiID0gZGF0YTBbaTQgKyAyXSAqIHM7XG4gICAgICAgIGNvbnN0IGlSR0IgPSBNYXRoLnJvdW5kKHIgKyBnICogc2l6ZSArIGIgKiBzaXplU3EpICogNDtcbiAgICAgICAgZGF0YTBbaTQgKyAwXSA9IGRhdGExW2lSR0IgKyAwXTtcbiAgICAgICAgZGF0YTBbaTQgKyAxXSA9IGRhdGExW2lSR0IgKyAxXTtcbiAgICAgICAgZGF0YTBbaTQgKyAyXSA9IGRhdGExW2lSR0IgKyAyXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIExVVCBkYXRhIGludG8gdW5zaWduZWQgYnl0ZSBkYXRhLlxuICAgKlxuICAgKiBUaGlzIGlzIGEgbG9zc3kgb3BlcmF0aW9uIHdoaWNoIHNob3VsZCBvbmx5IGJlIHBlcmZvcm1lZCBhZnRlciBhbGwgb3RoZXIgdHJhbnNmb3JtYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGlzIHRleHR1cmUuXG4gICAqL1xuICBjb252ZXJ0VG9VaW50OCgpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSBGbG9hdFR5cGUyKSB7XG4gICAgICBjb25zdCBmbG9hdERhdGEgPSB0aGlzLmltYWdlLmRhdGE7XG4gICAgICBjb25zdCB1aW50OERhdGEgPSBuZXcgVWludDhBcnJheShmbG9hdERhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZmxvYXREYXRhLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICB1aW50OERhdGFbaV0gPSBmbG9hdERhdGFbaV0gKiAyNTUgKyAwLjU7XG4gICAgICB9XG4gICAgICB0aGlzLmltYWdlLmRhdGEgPSB1aW50OERhdGE7XG4gICAgICB0aGlzLnR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlMTA7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBMVVQgZGF0YSBpbnRvIGZsb2F0IGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGNvbnZlcnRUb0Zsb2F0KCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUxMCkge1xuICAgICAgY29uc3QgdWludDhEYXRhID0gdGhpcy5pbWFnZS5kYXRhO1xuICAgICAgY29uc3QgZmxvYXREYXRhID0gbmV3IEZsb2F0MzJBcnJheSh1aW50OERhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdWludDhEYXRhLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBmbG9hdERhdGFbaV0gPSB1aW50OERhdGFbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICB0aGlzLmltYWdlLmRhdGEgPSBmbG9hdERhdGE7XG4gICAgICB0aGlzLnR5cGUgPSBGbG9hdFR5cGUyO1xuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExVVCBpbnRvIFJHQkEgZGF0YS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgTFVUcyBhcmUgUkdCQSBieSBkZWZhdWx0IHNpbmNlIHRocmVlIHIxMzcuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGNvbnZlcnRUb1JHQkEoKSB7XG4gICAgY29uc29sZS53YXJuKFwiTG9va3VwVGV4dHVyZVwiLCBcImNvbnZlcnRUb1JHQkEoKSBpcyBkZXByZWNhdGVkLCBMVVRzIGFyZSBub3cgUkdCQSBieSBkZWZhdWx0XCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgb3V0cHV0IG9mIHRoaXMgTFVUIGludG8gc1JHQiBjb2xvciBzcGFjZS5cbiAgICpcbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhpcyB0ZXh0dXJlLlxuICAgKi9cbiAgY29udmVydExpbmVhclRvU1JHQigpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5pbWFnZS5kYXRhO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IEZsb2F0VHlwZTIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgYy5mcm9tQXJyYXkoZGF0YSwgaSkuY29udmVydExpbmVhclRvU1JHQigpLnRvQXJyYXkoZGF0YSwgaSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTk7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNvbG9yIHNwYWNlIGNvbnZlcnNpb24gcmVxdWlyZXMgRmxvYXRUeXBlIGRhdGFcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgb3V0cHV0IG9mIHRoaXMgTFVUIGludG8gbGluZWFyIGNvbG9yIHNwYWNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGlzIHRleHR1cmUuXG4gICAqL1xuICBjb252ZXJ0U1JHQlRvTGluZWFyKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmltYWdlLmRhdGE7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gRmxvYXRUeXBlMikge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICBjLmZyb21BcnJheShkYXRhLCBpKS5jb252ZXJ0U1JHQlRvTGluZWFyKCkudG9BcnJheShkYXRhLCBpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlMztcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ29sb3Igc3BhY2UgY29udmVyc2lvbiByZXF1aXJlcyBGbG9hdFR5cGUgZGF0YVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTFVUIGludG8gYSAyRCBkYXRhIHRleHR1cmUuXG4gICAqXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgY3VzdG9tIGlucHV0IGRvbWFpbnMgYXJlIG5vdCBjYXJyaWVkIG92ZXIgdG8gMkQgdGV4dHVyZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0RhdGFUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIHRvRGF0YVRleHR1cmUoKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmltYWdlLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaW1hZ2UuaGVpZ2h0ICogdGhpcy5pbWFnZS5kZXB0aDtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlMih0aGlzLmltYWdlLmRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRleHR1cmUubmFtZSA9IHRoaXMubmFtZTtcbiAgICB0ZXh0dXJlLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdGV4dHVyZS5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjM7XG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXIzO1xuICAgIHRleHR1cmUud3JhcFMgPSB0aGlzLndyYXBTO1xuICAgIHRleHR1cmUud3JhcFQgPSB0aGlzLndyYXBUO1xuICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5jb2xvclNwYWNlID0gdGV4dHVyZS5jb2xvclNwYWNlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IDNEIExVVCBieSBjb3B5aW5nIGEgZ2l2ZW4gTFVULlxuICAgKlxuICAgKiBDb21tb24gaW1hZ2UtYmFzZWQgdGV4dHVyZXMgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byAzRCBkYXRhIHRleHR1cmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgTFVULiBBc3N1bWVkIHRvIGJlIGN1YmljLlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBBIG5ldyAzRCBMVVQuXG4gICAqL1xuICBzdGF0aWMgZnJvbSh0ZXh0dXJlKSB7XG4gICAgY29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2U7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgIGxldCBkYXRhO1xuICAgIGlmIChpbWFnZSBpbnN0YW5jZW9mIEltYWdlKSB7XG4gICAgICBjb25zdCByYXdJbWFnZURhdGEgPSBSYXdJbWFnZURhdGEuZnJvbShpbWFnZSk7XG4gICAgICBjb25zdCBzcmMgPSByYXdJbWFnZURhdGEuZGF0YTtcbiAgICAgIGlmICh3aWR0aCA+IGhlaWdodCkge1xuICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHogPSAwOyB6IDwgc2l6ZTsgKyt6KSB7XG4gICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplOyArK3kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZTsgKyt4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGk0ID0gKHggKyB6ICogc2l6ZSArIHkgKiBzaXplICogc2l6ZSkgKiA0O1xuICAgICAgICAgICAgICBjb25zdCBqNCA9ICh4ICsgeSAqIHNpemUgKyB6ICogc2l6ZSAqIHNpemUpICogNDtcbiAgICAgICAgICAgICAgZGF0YVtqNCArIDBdID0gc3JjW2k0ICsgMF07XG4gICAgICAgICAgICAgIGRhdGFbajQgKyAxXSA9IHNyY1tpNCArIDFdO1xuICAgICAgICAgICAgICBkYXRhW2o0ICsgMl0gPSBzcmNbaTQgKyAyXTtcbiAgICAgICAgICAgICAgZGF0YVtqNCArIDNdID0gc3JjW2k0ICsgM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBpbWFnZS5kYXRhLnNsaWNlKCk7XG4gICAgfVxuICAgIGNvbnN0IGx1dCA9IG5ldyBfTG9va3VwVGV4dHVyZShkYXRhLCBzaXplKTtcbiAgICBsdXQudHlwZSA9IHRleHR1cmUudHlwZTtcbiAgICBsdXQubmFtZSA9IHRleHR1cmUubmFtZTtcbiAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBsdXQuY29sb3JTcGFjZTtcbiAgICByZXR1cm4gbHV0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV1dHJhbCAzRCBMVVQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gVGhlIHNpZGVsZW5ndGguXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IEEgbmV1dHJhbCAzRCBMVVQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTmV1dHJhbChzaXplKSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqKiAzICogNCk7XG4gICAgY29uc3Qgc2l6ZVNxID0gc2l6ZSAqKiAyO1xuICAgIGNvbnN0IHMgPSAxIC8gKHNpemUgLSAxKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHNpemU7ICsrcikge1xuICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBzaXplOyArK2cpIHtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBzaXplOyArK2IpIHtcbiAgICAgICAgICBjb25zdCBpNCA9IChyICsgZyAqIHNpemUgKyBiICogc2l6ZVNxKSAqIDQ7XG4gICAgICAgICAgZGF0YVtpNCArIDBdID0gciAqIHM7XG4gICAgICAgICAgZGF0YVtpNCArIDFdID0gZyAqIHM7XG4gICAgICAgICAgZGF0YVtpNCArIDJdID0gYiAqIHM7XG4gICAgICAgICAgZGF0YVtpNCArIDNdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsdXQgPSBuZXcgX0xvb2t1cFRleHR1cmUoZGF0YSwgc2l6ZSk7XG4gICAgbHV0Lm5hbWUgPSBcIm5ldXRyYWxcIjtcbiAgICByZXR1cm4gbHV0O1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2x1dC0zZC5mcmFnXG52YXIgbHV0XzNkX2RlZmF1bHQgPSBgdW5pZm9ybSB2ZWMzIHNjYWxlO3VuaWZvcm0gdmVjMyBvZmZzZXQ7XG4jaWZkZWYgQ1VTVE9NX0lOUFVUX0RPTUFJTlxudW5pZm9ybSB2ZWMzIGRvbWFpbk1pbjt1bmlmb3JtIHZlYzMgZG9tYWluTWF4O1xuI2VuZGlmXG4jaWZkZWYgTFVUXzNEXG4jaWZkZWYgTFVUX1BSRUNJU0lPTl9ISUdIXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjNEIGx1dDtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjNEIGx1dDtcbiNlbmRpZlxuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyM0QgbHV0O1xuI2VuZGlmXG52ZWM0IGFwcGx5TFVUKGNvbnN0IGluIHZlYzMgcmdiKXtcbiNpZmRlZiBURVRSQUhFRFJBTF9JTlRFUlBPTEFUSU9OXG52ZWMzIHA9Zmxvb3IocmdiKTt2ZWMzIGY9cmdiLXA7dmVjMyB2MT0ocCswLjUpKkxVVF9URVhFTF9XSURUSDt2ZWMzIHY0PShwKzEuNSkqTFVUX1RFWEVMX1dJRFRIO3ZlYzMgdjIsdjM7dmVjMyBmcmFjO2lmKGYucj49Zi5nKXtpZihmLmc+Zi5iKXtmcmFjPWYucmdiO3YyPXZlYzModjQueCx2MS55LHYxLnopO3YzPXZlYzModjQueCx2NC55LHYxLnopO31lbHNlIGlmKGYucj49Zi5iKXtmcmFjPWYucmJnO3YyPXZlYzModjQueCx2MS55LHYxLnopO3YzPXZlYzModjQueCx2MS55LHY0LnopO31lbHNle2ZyYWM9Zi5icmc7djI9dmVjMyh2MS54LHYxLnksdjQueik7djM9dmVjMyh2NC54LHYxLnksdjQueik7fX1lbHNle2lmKGYuYj5mLmcpe2ZyYWM9Zi5iZ3I7djI9dmVjMyh2MS54LHYxLnksdjQueik7djM9dmVjMyh2MS54LHY0LnksdjQueik7fWVsc2UgaWYoZi5yPj1mLmIpe2ZyYWM9Zi5ncmI7djI9dmVjMyh2MS54LHY0LnksdjEueik7djM9dmVjMyh2NC54LHY0LnksdjEueik7fWVsc2V7ZnJhYz1mLmdicjt2Mj12ZWMzKHYxLngsdjQueSx2MS56KTt2Mz12ZWMzKHYxLngsdjQueSx2NC56KTt9fXZlYzQgbjE9dGV4dHVyZShsdXQsdjEpO3ZlYzQgbjI9dGV4dHVyZShsdXQsdjIpO3ZlYzQgbjM9dGV4dHVyZShsdXQsdjMpO3ZlYzQgbjQ9dGV4dHVyZShsdXQsdjQpO3ZlYzQgd2VpZ2h0cz12ZWM0KDEuMC1mcmFjLngsZnJhYy54LWZyYWMueSxmcmFjLnktZnJhYy56LGZyYWMueik7dmVjNCByZXN1bHQ9d2VpZ2h0cyptYXQ0KHZlYzQobjEucixuMi5yLG4zLnIsbjQuciksdmVjNChuMS5nLG4yLmcsbjMuZyxuNC5nKSx2ZWM0KG4xLmIsbjIuYixuMy5iLG40LmIpLHZlYzQoMS4wKSk7cmV0dXJuIHZlYzQocmVzdWx0LnJnYiwxLjApO1xuI2Vsc2VcbnJldHVybiB0ZXh0dXJlKGx1dCxyZ2IpO1xuI2VuZGlmXG59XG4jZWxzZVxuI2lmZGVmIExVVF9QUkVDSVNJT05fSElHSFxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBsdXQ7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBsdXQ7XG4jZW5kaWZcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGx1dDtcbiNlbmRpZlxudmVjNCBhcHBseUxVVChjb25zdCBpbiB2ZWMzIHJnYil7ZmxvYXQgc2xpY2U9cmdiLmIqTFVUX1NJWkU7ZmxvYXQgc2xpY2UwPWZsb29yKHNsaWNlKTtmbG9hdCBpbnRlcnA9c2xpY2Utc2xpY2UwO2Zsb2F0IGNlbnRlcmVkSW50ZXJwPWludGVycC0wLjU7ZmxvYXQgc2xpY2UxPXNsaWNlMCtzaWduKGNlbnRlcmVkSW50ZXJwKTtcbiNpZmRlZiBMVVRfU1RSSVBfSE9SSVpPTlRBTFxuZmxvYXQgeE9mZnNldD1jbGFtcChyZ2IucipMVVRfVEVYRUxfSEVJR0hULExVVF9URVhFTF9XSURUSCowLjUsTFVUX1RFWEVMX0hFSUdIVC1MVVRfVEVYRUxfV0lEVEgqMC41KTt2ZWMyIHV2MD12ZWMyKHNsaWNlMCpMVVRfVEVYRUxfSEVJR0hUK3hPZmZzZXQscmdiLmcpO3ZlYzIgdXYxPXZlYzIoc2xpY2UxKkxVVF9URVhFTF9IRUlHSFQreE9mZnNldCxyZ2IuZyk7XG4jZWxzZVxuZmxvYXQgeU9mZnNldD1jbGFtcChyZ2IuZypMVVRfVEVYRUxfV0lEVEgsTFVUX1RFWEVMX0hFSUdIVCowLjUsTFVUX1RFWEVMX1dJRFRILUxVVF9URVhFTF9IRUlHSFQqMC41KTt2ZWMyIHV2MD12ZWMyKHJnYi5yLHNsaWNlMCpMVVRfVEVYRUxfV0lEVEgreU9mZnNldCk7dmVjMiB1djE9dmVjMihyZ2IucixzbGljZTEqTFVUX1RFWEVMX1dJRFRIK3lPZmZzZXQpO1xuI2VuZGlmXG52ZWM0IHNhbXBsZTA9dGV4dHVyZTJEKGx1dCx1djApO3ZlYzQgc2FtcGxlMT10ZXh0dXJlMkQobHV0LHV2MSk7cmV0dXJuIG1peChzYW1wbGUwLHNhbXBsZTEsYWJzKGNlbnRlcmVkSW50ZXJwKSk7fVxuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBjPWlucHV0Q29sb3IucmdiO1xuI2lmZGVmIENVU1RPTV9JTlBVVF9ET01BSU5cbmlmKGMucj49ZG9tYWluTWluLnImJmMuZz49ZG9tYWluTWluLmcmJmMuYj49ZG9tYWluTWluLmImJmMucjw9ZG9tYWluTWF4LnImJmMuZzw9ZG9tYWluTWF4LmcmJmMuYjw9ZG9tYWluTWF4LmIpe2M9YXBwbHlMVVQoc2NhbGUqYytvZmZzZXQpLnJnYjt9ZWxzZXtjPWlucHV0Q29sb3IucmdiO31cbiNlbHNlXG4jaWYgIWRlZmluZWQoTFVUXzNEKSB8fCBkZWZpbmVkKFRFVFJBSEVEUkFMX0lOVEVSUE9MQVRJT04pXG5jPWNsYW1wKGMsMC4wLDEuMCk7XG4jZW5kaWZcbmM9YXBwbHlMVVQoc2NhbGUqYytvZmZzZXQpLnJnYjtcbiNlbmRpZlxub3V0cHV0Q29sb3I9dmVjNChjLGlucHV0Q29sb3IuYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0xVVDNERWZmZWN0LmpzXG52YXIgTFVUM0RFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbG9yIGdyYWRpbmcgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGx1dCAtIFRoZSBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbj1mYWxzZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24uXG4gICAqIEBwYXJhbSB7Q29sb3JTcGFjZX0gW29wdGlvbnMuaW5wdXRDb2xvclNwYWNlPVNSR0JDb2xvclNwYWNlXSAtIFRoZSBpbnB1dCBjb2xvciBzcGFjZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGx1dCwge1xuICAgIGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQyxcbiAgICB0ZXRyYWhlZHJhbEludGVycG9sYXRpb24gPSBmYWxzZSxcbiAgICBpbnB1dENvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTEwXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiTFVUM0RFZmZlY3RcIiwgbHV0XzNkX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJsdXRcIiwgbmV3IFVuaWZvcm0yNyhudWxsKV0sXG4gICAgICAgIFtcInNjYWxlXCIsIG5ldyBVbmlmb3JtMjcobmV3IFZlY3RvcjM0KCkpXSxcbiAgICAgICAgW1wib2Zmc2V0XCIsIG5ldyBVbmlmb3JtMjcobmV3IFZlY3RvcjM0KCkpXSxcbiAgICAgICAgW1wiZG9tYWluTWluXCIsIG5ldyBVbmlmb3JtMjcobnVsbCldLFxuICAgICAgICBbXCJkb21haW5NYXhcIiwgbmV3IFVuaWZvcm0yNyhudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb24gPSB0ZXRyYWhlZHJhbEludGVycG9sYXRpb247XG4gICAgdGhpcy5pbnB1dENvbG9yU3BhY2UgPSBpbnB1dENvbG9yU3BhY2U7XG4gICAgdGhpcy5sdXQgPSBsdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBMVVQuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGx1dCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJsdXRcIikudmFsdWU7XG4gIH1cbiAgc2V0IGx1dCh2YWx1ZSkge1xuICAgIGNvbnN0IGRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGlmICh0aGlzLmx1dCAhPT0gdmFsdWUpIHtcbiAgICAgIHVuaWZvcm1zLmdldChcImx1dFwiKS52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gdmFsdWUuaW1hZ2U7XG4gICAgICAgIGNvbnN0IHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiA9IHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uO1xuICAgICAgICBkZWZpbmVzLmNsZWFyKCk7XG4gICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1NJWkVcIiwgTWF0aC5taW4oaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCkudG9GaXhlZCgxNikpO1xuICAgICAgICBkZWZpbmVzLnNldChcIkxVVF9URVhFTF9XSURUSFwiLCAoMSAvIGltYWdlLndpZHRoKS50b0ZpeGVkKDE2KSk7XG4gICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1RFWEVMX0hFSUdIVFwiLCAoMSAvIGltYWdlLmhlaWdodCkudG9GaXhlZCgxNikpO1xuICAgICAgICB1bmlmb3Jtcy5nZXQoXCJkb21haW5NaW5cIikudmFsdWUgPSBudWxsO1xuICAgICAgICB1bmlmb3Jtcy5nZXQoXCJkb21haW5NYXhcIikudmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gRmxvYXRUeXBlMyB8fCB2YWx1ZS50eXBlID09PSBIYWxmRmxvYXRUeXBlMikge1xuICAgICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1BSRUNJU0lPTl9ISUdIXCIsIFwiMVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2Uud2lkdGggPiBpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICBkZWZpbmVzLnNldChcIkxVVF9TVFJJUF9IT1JJWk9OVEFMXCIsIFwiMVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGEzRFRleHR1cmUyKSB7XG4gICAgICAgICAgZGVmaW5lcy5zZXQoXCJMVVRfM0RcIiwgXCIxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvb2t1cFRleHR1cmUpIHtcbiAgICAgICAgICBjb25zdCBtaW4gPSB2YWx1ZS5kb21haW5NaW47XG4gICAgICAgICAgY29uc3QgbWF4ID0gdmFsdWUuZG9tYWluTWF4O1xuICAgICAgICAgIGlmIChtaW4ueCAhPT0gMCB8fCBtaW4ueSAhPT0gMCB8fCBtaW4ueiAhPT0gMCB8fCBtYXgueCAhPT0gMSB8fCBtYXgueSAhPT0gMSB8fCBtYXgueiAhPT0gMSkge1xuICAgICAgICAgICAgZGVmaW5lcy5zZXQoXCJDVVNUT01fSU5QVVRfRE9NQUlOXCIsIFwiMVwiKTtcbiAgICAgICAgICAgIHVuaWZvcm1zLmdldChcImRvbWFpbk1pblwiKS52YWx1ZSA9IG1pbi5jbG9uZSgpO1xuICAgICAgICAgICAgdW5pZm9ybXMuZ2V0KFwiZG9tYWluTWF4XCIpLnZhbHVlID0gbWF4LmNsb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uID0gdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBMVVQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIExVVC5cbiAgICovXG4gIGdldExVVCgpIHtcbiAgICByZXR1cm4gdGhpcy5sdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIExVVC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1dCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIExVVC5cbiAgICovXG4gIHNldExVVCh2YWx1ZSkge1xuICAgIHRoaXMubHV0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNjYWxlIGFuZCBvZmZzZXQgZm9yIHRoZSBMVVQgc2FtcGxpbmcgY29vcmRpbmF0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVTY2FsZU9mZnNldCgpIHtcbiAgICBjb25zdCBsdXQgPSB0aGlzLmx1dDtcbiAgICBpZiAobHV0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzaXplID0gTWF0aC5taW4obHV0LmltYWdlLndpZHRoLCBsdXQuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMudW5pZm9ybXMuZ2V0KFwib2Zmc2V0XCIpLnZhbHVlO1xuICAgICAgaWYgKHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uICYmIGx1dCBpbnN0YW5jZW9mIERhdGEzRFRleHR1cmUyKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmluZXMuaGFzKFwiQ1VTVE9NX0lOUFVUX0RPTUFJTlwiKSkge1xuICAgICAgICAgIGNvbnN0IGRvbWFpblNjYWxlID0gbHV0LmRvbWFpbk1heC5jbG9uZSgpLnN1YihsdXQuZG9tYWluTWluKTtcbiAgICAgICAgICBzY2FsZS5zZXRTY2FsYXIoc2l6ZSAtIDEpLmRpdmlkZShkb21haW5TY2FsZSk7XG4gICAgICAgICAgb2Zmc2V0LmNvcHkobHV0LmRvbWFpbk1pbikubmVnYXRlKCkubXVsdGlwbHkoc2NhbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlLnNldFNjYWxhcihzaXplIC0gMSk7XG4gICAgICAgICAgb2Zmc2V0LnNldFNjYWxhcigwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmaW5lcy5oYXMoXCJDVVNUT01fSU5QVVRfRE9NQUlOXCIpKSB7XG4gICAgICAgICAgY29uc3QgZG9tYWluU2NhbGUgPSBsdXQuZG9tYWluTWF4LmNsb25lKCkuc3ViKGx1dC5kb21haW5NaW4pLm11bHRpcGx5U2NhbGFyKHNpemUpO1xuICAgICAgICAgIHNjYWxlLnNldFNjYWxhcihzaXplIC0gMSkuZGl2aWRlKGRvbWFpblNjYWxlKTtcbiAgICAgICAgICBvZmZzZXQuY29weShsdXQuZG9tYWluTWluKS5uZWdhdGUoKS5tdWx0aXBseShzY2FsZSkuYWRkU2NhbGFyKDEgLyAoMiAqIHNpemUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2FsZS5zZXRTY2FsYXIoKHNpemUgLSAxKSAvIHNpemUpO1xuICAgICAgICAgIG9mZnNldC5zZXRTY2FsYXIoMSAvICgyICogc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHBhcmFtZXRlcnMgZm9yIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25maWd1cmVUZXRyYWhlZHJhbEludGVycG9sYXRpb24oKSB7XG4gICAgY29uc3QgbHV0ID0gdGhpcy5sdXQ7XG4gICAgaWYgKGx1dCAhPT0gbnVsbCkge1xuICAgICAgbHV0Lm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjQ7XG4gICAgICBsdXQubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyNDtcbiAgICAgIGlmICh0aGlzLnRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbikge1xuICAgICAgICBpZiAobHV0IGluc3RhbmNlb2YgRGF0YTNEVGV4dHVyZTIpIHtcbiAgICAgICAgICBsdXQubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjI7XG4gICAgICAgICAgbHV0Lm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRldHJhaGVkcmFsIGludGVycG9sYXRpb24gcmVxdWlyZXMgYSAzRCB0ZXh0dXJlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsdXQubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbiBpcyBlbmFibGVkLiBSZXF1aXJlcyBhIDNEIExVVCwgZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogVGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbiBwcm9kdWNlcyBoaWdobHkgYWNjdXJhdGUgcmVzdWx0cyBidXQgaXMgc2xvd2VyIHRoYW4gaGFyZHdhcmUgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiVEVUUkFIRURSQUxfSU5URVJQT0xBVElPTlwiKTtcbiAgfVxuICBzZXQgdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiVEVUUkFIRURSQUxfSU5URVJQT0xBVElPTlwiLCBcIjFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJURVRSQUhFRFJBTF9JTlRFUlBPTEFUSU9OXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZ3VyZVRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbigpO1xuICAgIHRoaXMudXBkYXRlU2NhbGVPZmZzZXQoKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0ZXRyYWhlZHJhbCBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24gc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRUZXRyYWhlZHJhbEludGVycG9sYXRpb25FbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb24gPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VudW1zL0RlcHRoQ29weU1vZGUuanNcbnZhciBEZXB0aENvcHlNb2RlID0ge1xuICBGVUxMOiAwLFxuICBTSU5HTEU6IDFcbn07XG5cbi8vIHNyYy9lbnVtcy9FZGdlRGV0ZWN0aW9uTW9kZS5qc1xudmFyIEVkZ2VEZXRlY3Rpb25Nb2RlID0ge1xuICBERVBUSDogMCxcbiAgTFVNQTogMSxcbiAgQ09MT1I6IDJcbn07XG5cbi8vIHNyYy9lbnVtcy9QcmVkaWNhdGlvbk1vZGUuanNcbnZhciBQcmVkaWNhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEVEOiAwLFxuICBERVBUSDogMSxcbiAgQ1VTVE9NOiAyXG59O1xuXG4vLyBzcmMvZW51bXMvU01BQVByZXNldC5qc1xudmFyIFNNQUFQcmVzZXQgPSB7XG4gIExPVzogMCxcbiAgTUVESVVNOiAxLFxuICBISUdIOiAyLFxuICBVTFRSQTogM1xufTtcblxuLy8gc3JjL2VudW1zL1RvbmVNYXBwaW5nTW9kZS5qc1xudmFyIFRvbmVNYXBwaW5nTW9kZSA9IHtcbiAgTElORUFSOiAwLFxuICBSRUlOSEFSRDogMSxcbiAgUkVJTkhBUkQyOiAyLFxuICBSRUlOSEFSRDJfQURBUFRJVkU6IDMsXG4gIFVOQ0hBUlRFRDI6IDQsXG4gIE9QVElNSVpFRF9DSU5FT046IDUsXG4gIENJTkVPTjogNSxcbiAgQUNFU19GSUxNSUM6IDYsXG4gIEFHWDogNyxcbiAgTkVVVFJBTDogOFxufTtcblxuLy8gc3JjL2VudW1zL1ZpZ25ldHRlVGVjaG5pcXVlLmpzXG52YXIgVmlnbmV0dGVUZWNobmlxdWUgPSB7XG4gIERFRkFVTFQ6IDAsXG4gIEVTS0lMOiAxXG59O1xuXG4vLyBzcmMvZW51bXMvV2ViR0xFeHRlbnNpb24uanNcbnZhciBXZWJHTEV4dGVuc2lvbiA9IHtcbiAgREVSSVZBVElWRVM6IFwiZGVyaXZhdGl2ZXNcIixcbiAgRlJBR19ERVBUSDogXCJmcmFnRGVwdGhcIixcbiAgRFJBV19CVUZGRVJTOiBcImRyYXdCdWZmZXJzXCIsXG4gIFNIQURFUl9URVhUVVJFX0xPRDogXCJzaGFkZXJUZXh0dXJlTE9EXCJcbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvbm9pc2UuZnJhZ1xudmFyIG5vaXNlX2RlZmF1bHQgPSBgdm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzMgbm9pc2U9dmVjMyhyYW5kKHV2KigxLjArdGltZSkpKTtcbiNpZmRlZiBQUkVNVUxUSVBMWVxub3V0cHV0Q29sb3I9dmVjNChtaW4oaW5wdXRDb2xvci5yZ2Iqbm9pc2UsdmVjMygxLjApKSxpbnB1dENvbG9yLmEpO1xuI2Vsc2Vcbm91dHB1dENvbG9yPXZlYzQobm9pc2UsaW5wdXRDb2xvci5hKTtcbiNlbmRpZlxufWA7XG5cbi8vIHNyYy9lZmZlY3RzL05vaXNlRWZmZWN0LmpzXG52YXIgTm9pc2VFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vaXNlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TQ1JFRU5dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnByZW11bHRpcGx5PWZhbHNlXSAtIFdoZXRoZXIgdGhlIG5vaXNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIHdpdGggdGhlIGlucHV0IGNvbG9ycyBwcmlvciB0byBibGVuZGluZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU0NSRUVOLCBwcmVtdWx0aXBseSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiTm9pc2VFZmZlY3RcIiwgbm9pc2VfZGVmYXVsdCwgeyBibGVuZEZ1bmN0aW9uIH0pO1xuICAgIHRoaXMucHJlbXVsdGlwbHkgPSBwcmVtdWx0aXBseTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgbm9pc2Ugd2lsbCBiZSBtdWx0aXBsaWVkIHdpdGggdGhlIGlucHV0IGNvbG9ycyBwcmlvciB0byBibGVuZGluZy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgcHJlbXVsdGlwbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJQUkVNVUxUSVBMWVwiKTtcbiAgfVxuICBzZXQgcHJlbXVsdGlwbHkodmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcmVtdWx0aXBseSAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiUFJFTVVMVElQTFlcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlBSRU1VTFRJUExZXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBub2lzZSB3aWxsIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQgY29sb3JzIHByaW9yIHRvIGJsZW5kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlbXVsdGlwbHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBub2lzZSBpcyBwcmVtdWx0aXBsaWVkLlxuICAgKi9cbiAgaXNQcmVtdWx0aXBsaWVkKCkge1xuICAgIHJldHVybiB0aGlzLnByZW11bHRpcGx5O1xuICB9XG4gIC8qKlxuICAgKiBDb250cm9scyB3aGV0aGVyIG5vaXNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIHdpdGggdGhlIGlucHV0IGNvbG9ycyBwcmlvciB0byBibGVuZGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZW11bHRpcGx5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIG5vaXNlIHNob3VsZCBiZSBwcmVtdWx0aXBsaWVkLlxuICAgKi9cbiAgc2V0UHJlbXVsdGlwbGllZCh2YWx1ZSkge1xuICAgIHRoaXMucHJlbXVsdGlwbHkgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvT3V0bGluZUVmZmVjdC5qc1xuaW1wb3J0IHsgQ29sb3IgYXMgQ29sb3I2LCBSZXBlYXRXcmFwcGluZyBhcyBSZXBlYXRXcmFwcGluZzMsIFVuaWZvcm0gYXMgVW5pZm9ybTMwLCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxMSwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxMiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0RlcHRoQ29tcGFyaXNvbk1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxMSwgUGVyc3BlY3RpdmVDYW1lcmEgYXMgUGVyc3BlY3RpdmVDYW1lcmEzLCBSR0JBRGVwdGhQYWNraW5nLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDEyLCBVbmlmb3JtIGFzIFVuaWZvcm0yOCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZGVwdGgtY29tcGFyaXNvbi5mcmFnXG52YXIgZGVwdGhfY29tcGFyaXNvbl9kZWZhdWx0ID0gYCNpbmNsdWRlIDxwYWNraW5nPlxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2VuZGlmXG51bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7Y2VudHJvaWQgdmFyeWluZyBmbG9hdCB2Vmlld1o7Y2VudHJvaWQgdmFyeWluZyB2ZWM0IHZQcm9qVGV4Q29vcmQ7dm9pZCBtYWluKCl7XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxudmVjMiBwcm9qVGV4Q29vcmQ9KHZQcm9qVGV4Q29vcmQueHkvdlByb2pUZXhDb29yZC53KSowLjUrMC41O3Byb2pUZXhDb29yZD1jbGFtcChwcm9qVGV4Q29vcmQsMC4wMDIsMC45OTgpO1xuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxuZmxvYXQgZnJhZ0Nvb3JkWj11bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIscHJvalRleENvb3JkKSk7XG4jZWxzZVxuZmxvYXQgZnJhZ0Nvb3JkWj10ZXh0dXJlMkQoZGVwdGhCdWZmZXIscHJvalRleENvb3JkKS5yO1xuI2VuZGlmXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5mbG9hdCB2aWV3Wj1wZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihmcmFnQ29vcmRaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcbiNlbHNlXG5mbG9hdCB2aWV3Wj1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZnJhZ0Nvb3JkWixjYW1lcmFOZWFyLGNhbWVyYUZhcik7XG4jZW5kaWZcbmZsb2F0IGRlcHRoVGVzdD0oLXZWaWV3Wj4tdmlld1opPzEuMDowLjA7Z2xfRnJhZ0NvbG9yLnJnPXZlYzIoMC4wLGRlcHRoVGVzdCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1jb21wYXJpc29uLnZlcnRcbnZhciBkZXB0aF9jb21wYXJpc29uX2RlZmF1bHQyID0gYCNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxudmFyeWluZyBmbG9hdCB2Vmlld1o7dmFyeWluZyB2ZWM0IHZQcm9qVGV4Q29vcmQ7dm9pZCBtYWluKCl7XG4jaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxuI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cbiNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XG4jaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxuI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxudlZpZXdaPW12UG9zaXRpb24uejt2UHJvalRleENvb3JkPWdsX1Bvc2l0aW9uO1xuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9EZXB0aENvbXBhcmlzb25NYXRlcmlhbC5qc1xudmFyIERlcHRoQ29tcGFyaXNvbk1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDEyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggY29tcGFyaXNvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbZGVwdGhUZXh0dXJlPW51bGxdIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge1BlcnNwZWN0aXZlQ2FtZXJhfSBbY2FtZXJhXSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVwdGhUZXh0dXJlID0gbnVsbCwgY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJEZXB0aENvbXBhcmlzb25NYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTI4KG51bGwpLFxuICAgICAgICBjYW1lcmFOZWFyOiBuZXcgVW5pZm9ybTI4KDAuMyksXG4gICAgICAgIGNhbWVyYUZhcjogbmV3IFVuaWZvcm0yOCgxZTMpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxMSxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoX2NvbXBhcmlzb25fZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogZGVwdGhfY29tcGFyaXNvbl9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nO1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9XG4gICAqL1xuICBzZXQgZGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlciBhbmQgZGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gYnVmZmVyIC0gVGhlIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1SR0JBRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIoYnVmZmVyLCBkZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nKSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoZSBzZXR0aW5ncyBvZiB0aGUgZ2l2ZW4gY2FtZXJhLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29weUNhbWVyYVNldHRpbmdzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGFkb3B0Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKSB7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoZSBzZXR0aW5ncyBvZiB0aGUgZ2l2ZW4gY2FtZXJhLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBjb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKSB7XG4gICAgaWYgKGNhbWVyYSkge1xuICAgICAgdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XG4gICAgICBpZiAoY2FtZXJhIGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEzKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkEgPSBcIjFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL091dGxpbmVNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTIsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTMsIFVuaWZvcm0gYXMgVW5pZm9ybTI5LCBWZWN0b3IyIGFzIFZlY3RvcjIxNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvb3V0bGluZS5mcmFnXG52YXIgb3V0bGluZV9kZWZhdWx0ID0gYHVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dm9pZCBtYWluKCl7dmVjMiBjMD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MCkucmc7dmVjMiBjMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MSkucmc7dmVjMiBjMj10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2Mikucmc7dmVjMiBjMz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2Mykucmc7ZmxvYXQgZDA9KGMwLngtYzEueCkqMC41O2Zsb2F0IGQxPShjMi54LWMzLngpKjAuNTtmbG9hdCBkPWxlbmd0aCh2ZWMyKGQwLGQxKSk7ZmxvYXQgYTA9bWluKGMwLnksYzEueSk7ZmxvYXQgYTE9bWluKGMyLnksYzMueSk7ZmxvYXQgdmlzaWJpbGl0eUZhY3Rvcj1taW4oYTAsYTEpO2dsX0ZyYWdDb2xvci5yZz0oMS4wLXZpc2liaWxpdHlGYWN0b3I+MC4wMDEpP3ZlYzIoZCwwLjApOnZlYzIoMC4wLGQpO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvb3V0bGluZS52ZXJ0XG52YXIgb3V0bGluZV9kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZvaWQgbWFpbigpe3ZlYzIgdXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYwPXZlYzIodXYueCt0ZXhlbFNpemUueCx1di55KTt2VXYxPXZlYzIodXYueC10ZXhlbFNpemUueCx1di55KTt2VXYyPXZlYzIodXYueCx1di55K3RleGVsU2l6ZS55KTt2VXYzPXZlYzIodXYueCx1di55LXRleGVsU2l6ZS55KTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL091dGxpbmVNYXRlcmlhbC5qc1xudmFyIE91dGxpbmVNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxMyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG91dGxpbmUgbWF0ZXJpYWwuXG4gICAqXG4gICAqIFRPRE8gUmVtb3ZlIHRleGVsU2l6ZSBwYXJhbS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbdGV4ZWxTaXplXSAtIFRoZSBzY3JlZW4gdGV4ZWwgc2l6ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyMTUoKSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiT3V0bGluZU1hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0yOShudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTI5KG5ldyBWZWN0b3IyMTUoKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzEyLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogb3V0bGluZV9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBvdXRsaW5lX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KHRleGVsU2l6ZS54LCB0ZXhlbFNpemUueSk7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrVGV4dHVyZSA9IHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXhlbCBzaXplLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2l6ZSgpIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIHRleGVsIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB0ZXhlbCBoZWlnaHQuXG4gICAqL1xuICBzZXRUZXhlbFNpemUoeCwgeSkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCh4LCB5KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0RlcHRoUGFzcy5qc1xuaW1wb3J0IHsgQ29sb3IgYXMgQ29sb3I1LCBNZXNoRGVwdGhNYXRlcmlhbCwgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyMywgUkdCQURlcHRoUGFja2luZyBhcyBSR0JBRGVwdGhQYWNraW5nMiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxMSB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIERlcHRoUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIHNjZW5lIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBjYW1lcmEgdG8gdXNlIHRvIHJlbmRlciB0aGUgc2NlbmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW29wdGlvbnMucmVuZGVyVGFyZ2V0XSAtIEEgY3VzdG9tIHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MS4wXSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY2VuZSwgY2FtZXJhLCB7XG4gICAgcmVuZGVyVGFyZ2V0LFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRGVwdGhQYXNzXCIpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSwgbmV3IE1lc2hEZXB0aE1hdGVyaWFsKHtcbiAgICAgIGRlcHRoUGFja2luZzogUkdCQURlcHRoUGFja2luZzJcbiAgICB9KSk7XG4gICAgY29uc3QgcmVuZGVyUGFzcyA9IHRoaXMucmVuZGVyUGFzcztcbiAgICByZW5kZXJQYXNzLnNraXBTaGFkb3dNYXBVcGRhdGUgPSB0cnVlO1xuICAgIHJlbmRlclBhc3MuaWdub3JlQmFja2dyb3VuZCA9IHRydWU7XG4gICAgY29uc3QgY2xlYXJQYXNzID0gcmVuZGVyUGFzcy5jbGVhclBhc3M7XG4gICAgY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjUoMTY3NzcyMTUpO1xuICAgIGNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQWxwaGEgPSAxO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgIGlmICh0aGlzLnJlbmRlclRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDExKDEsIDEsIHtcbiAgICAgICAgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyMyxcbiAgICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyM1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkRlcHRoUGFzcy5UYXJnZXRcIjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gIH1cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICAgIHRoaXMucmVuZGVyUGFzcy5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMucmVuZGVyUGFzcy5tYWluQ2FtZXJhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIG5ldyByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvblNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnNjYWxlID0gc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNjZW5lIGRlcHRoLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIHRoaXMucmVuZGVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL291dGxpbmUuZnJhZ1xudmFyIG91dGxpbmVfZGVmYXVsdDMgPSBgdW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBlZGdlVGV4dHVyZTt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG1hc2tUZXh0dXJlO3VuaWZvcm0gdmVjMyB2aXNpYmxlRWRnZUNvbG9yO3VuaWZvcm0gdmVjMyBoaWRkZW5FZGdlQ29sb3I7dW5pZm9ybSBmbG9hdCBwdWxzZTt1bmlmb3JtIGZsb2F0IGVkZ2VTdHJlbmd0aDtcbiNpZmRlZiBVU0VfUEFUVEVSTlxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBwYXR0ZXJuVGV4dHVyZTt2YXJ5aW5nIHZlYzIgdlV2UGF0dGVybjtcbiNlbmRpZlxudm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzIgZWRnZT10ZXh0dXJlMkQoZWRnZVRleHR1cmUsdXYpLnJnO3ZlYzIgbWFzaz10ZXh0dXJlMkQobWFza1RleHR1cmUsdXYpLnJnO1xuI2lmbmRlZiBYX1JBWVxuZWRnZS55PTAuMDtcbiNlbmRpZlxuZWRnZSo9KGVkZ2VTdHJlbmd0aCptYXNrLngqcHVsc2UpO3ZlYzMgY29sb3I9ZWRnZS54KnZpc2libGVFZGdlQ29sb3IrZWRnZS55KmhpZGRlbkVkZ2VDb2xvcjtmbG9hdCB2aXNpYmlsaXR5RmFjdG9yPTAuMDtcbiNpZmRlZiBVU0VfUEFUVEVSTlxudmVjNCBwYXR0ZXJuQ29sb3I9dGV4dHVyZTJEKHBhdHRlcm5UZXh0dXJlLHZVdlBhdHRlcm4pO1xuI2lmZGVmIFhfUkFZXG5mbG9hdCBoaWRkZW5GYWN0b3I9MC41O1xuI2Vsc2VcbmZsb2F0IGhpZGRlbkZhY3Rvcj0wLjA7XG4jZW5kaWZcbnZpc2liaWxpdHlGYWN0b3I9KDEuMC1tYXNrLnk+MC4wKT8xLjA6aGlkZGVuRmFjdG9yO3Zpc2liaWxpdHlGYWN0b3IqPSgxLjAtbWFzay54KSpwYXR0ZXJuQ29sb3IuYTtjb2xvcis9dmlzaWJpbGl0eUZhY3RvcipwYXR0ZXJuQ29sb3IucmdiO1xuI2VuZGlmXG5mbG9hdCBhbHBoYT1tYXgobWF4KGVkZ2UueCxlZGdlLnkpLHZpc2liaWxpdHlGYWN0b3IpO1xuI2lmZGVmIEFMUEhBXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGFscGhhKTtcbiNlbHNlXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yLG1heChhbHBoYSxpbnB1dENvbG9yLmEpKTtcbiNlbmRpZlxufWA7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvb3V0bGluZS52ZXJ0XG52YXIgb3V0bGluZV9kZWZhdWx0NCA9IGB1bmlmb3JtIGZsb2F0IHBhdHRlcm5TY2FsZTt2YXJ5aW5nIHZlYzIgdlV2UGF0dGVybjt2b2lkIG1haW5TdXBwb3J0KGNvbnN0IGluIHZlYzIgdXYpe3ZVdlBhdHRlcm49dXYqdmVjMihhc3BlY3QsMS4wKSpwYXR0ZXJuU2NhbGU7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL091dGxpbmVFZmZlY3QuanNcbnZhciBPdXRsaW5lRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBvdXRsaW5lIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgbWFpbiBzY2VuZS5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TQ1JFRU5dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uLiBVc2UgYEJsZW5kRnVuY3Rpb24uQUxQSEFgIGZvciBkYXJrIG91dGxpbmVzLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtvcHRpb25zLnBhdHRlcm5UZXh0dXJlPW51bGxdIC0gQSBwYXR0ZXJuIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXR0ZXJuU2NhbGU9MS4wXSAtIFRoZSBwYXR0ZXJuIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWRnZVN0cmVuZ3RoPTEuMF0gLSBUaGUgZWRnZSBzdHJlbmd0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnB1bHNlU3BlZWQ9MC4wXSAtIFRoZSBwdWxzZSBzcGVlZC4gQSB2YWx1ZSBvZiB6ZXJvIGRpc2FibGVzIHRoZSBwdWxzZSBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aXNpYmxlRWRnZUNvbG9yPTB4ZmZmZmZmXSAtIFRoZSBjb2xvciBvZiB2aXNpYmxlIGVkZ2VzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGlkZGVuRWRnZUNvbG9yPTB4MjIwOTBhXSAtIFRoZSBjb2xvciBvZiBoaWRkZW4gZWRnZXMuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLlZFUllfU01BTExdIC0gVGhlIGJsdXIga2VybmVsIHNpemUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmx1cj1mYWxzZV0gLSBXaGV0aGVyIHRoZSBvdXRsaW5lIHNob3VsZCBiZSBibHVycmVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnhSYXk9dHJ1ZV0gLSBXaGV0aGVyIG9jY2x1ZGVkIHBhcnRzIG9mIHNlbGVjdGVkIG9iamVjdHMgc2hvdWxkIGJlIHZpc2libGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXNhbXBsaW5nPTBdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIHVzZWQgZm9yIG11bHRpc2FtcGxlIGFudGlhbGlhc2luZy4gUmVxdWlyZXMgV2ViR0wgMi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TQ1JFRU4sXG4gICAgcGF0dGVyblRleHR1cmUgPSBudWxsLFxuICAgIHBhdHRlcm5TY2FsZSA9IDEsXG4gICAgZWRnZVN0cmVuZ3RoID0gMSxcbiAgICBwdWxzZVNwZWVkID0gMCxcbiAgICB2aXNpYmxlRWRnZUNvbG9yID0gMTY3NzcyMTUsXG4gICAgaGlkZGVuRWRnZUNvbG9yID0gMjIzMDUzOCxcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5WRVJZX1NNQUxMLFxuICAgIGJsdXIgPSBmYWxzZSxcbiAgICB4UmF5ID0gdHJ1ZSxcbiAgICBtdWx0aXNhbXBsaW5nID0gMCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiT3V0bGluZUVmZmVjdFwiLCBvdXRsaW5lX2RlZmF1bHQzLCB7XG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJtYXNrVGV4dHVyZVwiLCBuZXcgVW5pZm9ybTMwKG51bGwpXSxcbiAgICAgICAgW1wiZWRnZVRleHR1cmVcIiwgbmV3IFVuaWZvcm0zMChudWxsKV0sXG4gICAgICAgIFtcImVkZ2VTdHJlbmd0aFwiLCBuZXcgVW5pZm9ybTMwKGVkZ2VTdHJlbmd0aCldLFxuICAgICAgICBbXCJ2aXNpYmxlRWRnZUNvbG9yXCIsIG5ldyBVbmlmb3JtMzAobmV3IENvbG9yNih2aXNpYmxlRWRnZUNvbG9yKSldLFxuICAgICAgICBbXCJoaWRkZW5FZGdlQ29sb3JcIiwgbmV3IFVuaWZvcm0zMChuZXcgQ29sb3I2KGhpZGRlbkVkZ2VDb2xvcikpXSxcbiAgICAgICAgW1wicHVsc2VcIiwgbmV3IFVuaWZvcm0zMCgxKV0sXG4gICAgICAgIFtcInBhdHRlcm5TY2FsZVwiLCBuZXcgVW5pZm9ybTMwKHBhdHRlcm5TY2FsZSldLFxuICAgICAgICBbXCJwYXR0ZXJuVGV4dHVyZVwiLCBuZXcgVW5pZm9ybTMwKG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmJsZW5kTW9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYmxlbmRNb2RlLmJsZW5kRnVuY3Rpb24gPT09IEJsZW5kRnVuY3Rpb24uQUxQSEEpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkFMUEhBXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJBTFBIQVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH0pO1xuICAgIHRoaXMuYmxlbmRNb2RlLmJsZW5kRnVuY3Rpb24gPSBibGVuZEZ1bmN0aW9uO1xuICAgIHRoaXMucGF0dGVyblRleHR1cmUgPSBwYXR0ZXJuVGV4dHVyZTtcbiAgICB0aGlzLnhSYXkgPSB4UmF5O1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2sgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxMigxLCAxKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2suc2FtcGxlcyA9IG11bHRpc2FtcGxpbmc7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrLnRleHR1cmUubmFtZSA9IFwiT3V0bGluZS5NYXNrXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXNrVGV4dHVyZVwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0TWFzay50ZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDEyKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZS50ZXh0dXJlLm5hbWUgPSBcIk91dGxpbmUuRWRnZXNcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImVkZ2VUZXh0dXJlXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lLnRleHR1cmU7XG4gICAgdGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKCk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yNigwKTtcbiAgICB0aGlzLmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQWxwaGEgPSAxO1xuICAgIHRoaXMuZGVwdGhQYXNzID0gbmV3IERlcHRoUGFzcyhzY2VuZSwgY2FtZXJhKTtcbiAgICB0aGlzLm1hc2tQYXNzID0gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSwgbmV3IERlcHRoQ29tcGFyaXNvbk1hdGVyaWFsKHRoaXMuZGVwdGhQYXNzLnRleHR1cmUsIGNhbWVyYSkpO1xuICAgIGNvbnN0IGNsZWFyUGFzcyA9IHRoaXMubWFza1Bhc3MuY2xlYXJQYXNzO1xuICAgIGNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3I2KDE2Nzc3MjE1KTtcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckFscGhhID0gMTtcbiAgICB0aGlzLmJsdXJQYXNzID0gbmV3IEthd2FzZUJsdXJQYXNzKHsgcmVzb2x1dGlvblNjYWxlLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIGtlcm5lbFNpemUgfSk7XG4gICAgdGhpcy5ibHVyUGFzcy5lbmFibGVkID0gYmx1cjtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLm91dGxpbmVQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IE91dGxpbmVNYXRlcmlhbCgpKTtcbiAgICBjb25zdCBvdXRsaW5lTWF0ZXJpYWwgPSB0aGlzLm91dGxpbmVQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICBvdXRsaW5lTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldE1hc2sudGV4dHVyZTtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbigpO1xuICAgIHRoaXMucHVsc2VTcGVlZCA9IHB1bHNlU3BlZWQ7XG4gIH1cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICAgIHRoaXMuc2NlbmUgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoUGFzcy5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLm1haW5TY2VuZSA9IHZhbHVlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoUGFzcy5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5tYXNrUGFzcy5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5tYXNrUGFzcy5vdmVycmlkZU1hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7UmVzb2x1dGlvbn1cbiAgICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1Jlc2l6ZXJ9IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5nZXRSZXNvbHV0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgTVNBQSBzYW1wbGVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyBXZWJHTCAyLiBTZXQgdG8gemVybyB0byBkaXNhYmxlIG11bHRpc2FtcGxpbmcuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWwgUmVxdWlyZXMgdGhyZWUgPj0gcjEzOC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtdWx0aXNhbXBsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldE1hc2suc2FtcGxlcztcbiAgfVxuICBzZXQgbXVsdGlzYW1wbGluZyh2YWx1ZSkge1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFzay5zYW1wbGVzID0gdmFsdWU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrLmRpc3Bvc2UoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBhdHRlcm4gc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcGF0dGVyblNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInBhdHRlcm5TY2FsZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgcGF0dGVyblNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJwYXR0ZXJuU2NhbGVcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2Ugc3RyZW5ndGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZWRnZVN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImVkZ2VTdHJlbmd0aFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgZWRnZVN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJlZGdlU3RyZW5ndGhcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHZpc2libGUgZWRnZSBjb2xvci5cbiAgICpcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKi9cbiAgZ2V0IHZpc2libGVFZGdlQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwidmlzaWJsZUVkZ2VDb2xvclwiKS52YWx1ZTtcbiAgfVxuICBzZXQgdmlzaWJsZUVkZ2VDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwidmlzaWJsZUVkZ2VDb2xvclwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGlkZGVuIGVkZ2UgY29sb3IuXG4gICAqXG4gICAqIEB0eXBlIHtDb2xvcn1cbiAgICovXG4gIGdldCBoaWRkZW5FZGdlQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiaGlkZGVuRWRnZUNvbG9yXCIpLnZhbHVlO1xuICB9XG4gIHNldCBoaWRkZW5FZGdlQ29sb3IodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImhpZGRlbkVkZ2VDb2xvclwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyUGFzcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtLYXdhc2VCbHVyUGFzc30gVGhlIGJsdXIgcGFzcy5cbiAgICovXG4gIGdldEJsdXJQYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGUgc2VsZWN0aW9uLlxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHVsc2Ugc3BlZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwdWxzZVNwZWVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNwZWVkLlxuICAgKi9cbiAgZ2V0UHVsc2VTcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWxzZVNwZWVkO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwdWxzZSBzcGVlZC4gU2V0IHRvIHplcm8gdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHB1bHNlU3BlZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNwZWVkLlxuICAgKi9cbiAgc2V0UHVsc2VTcGVlZCh2YWx1ZSkge1xuICAgIHRoaXMucHVsc2VTcGVlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLndpZHRoIGluc3RlYWQuXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24uaGVpZ2h0IGluc3RlYWQuXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzZWxlY3Rpb24gbGF5ZXIuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24ubGF5ZXIgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzZWxlY3Rpb25MYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24ubGF5ZXI7XG4gIH1cbiAgc2V0IHNlbGVjdGlvbkxheWVyKHZhbHVlKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24ubGF5ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5kaXRoZXJpbmc7XG4gIH1cbiAgc2V0IGRpdGhlcmluZyh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZGl0aGVyaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7S2VybmVsU2l6ZX1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJQYXNzLmtlcm5lbFNpemUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG91dGxpbmVzIHNob3VsZCBiZSBibHVycmVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJQYXNzLmVuYWJsZWQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBibHVyKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmVuYWJsZWQ7XG4gIH1cbiAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmVuYWJsZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgWC1yYXkgbW9kZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB4UmF5KCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiWF9SQVlcIik7XG4gIH1cbiAgc2V0IHhSYXkodmFsdWUpIHtcbiAgICBpZiAodGhpcy54UmF5ICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJYX1JBWVwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiWF9SQVlcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIFgtcmF5IG1vZGUgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHhSYXkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBYLXJheSBtb2RlIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc1hSYXlFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnhSYXk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgWC1yYXkgb3V0bGluZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB4UmF5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIFgtcmF5IHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0WFJheUVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLnhSYXkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBhdHRlcm4gdGV4dHVyZS4gU2V0IHRvIGBudWxsYCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBwYXR0ZXJuVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJwYXR0ZXJuVGV4dHVyZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgcGF0dGVyblRleHR1cmUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlLndyYXBTID0gdmFsdWUud3JhcFQgPSBSZXBlYXRXcmFwcGluZzM7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiVVNFX1BBVFRFUk5cIiwgXCIxXCIpO1xuICAgICAgdGhpcy5zZXRWZXJ0ZXhTaGFkZXIob3V0bGluZV9kZWZhdWx0NCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJVU0VfUEFUVEVSTlwiKTtcbiAgICAgIHRoaXMuc2V0VmVydGV4U2hhZGVyKG51bGwpO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInBhdHRlcm5UZXh0dXJlXCIpLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhdHRlcm4gdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBhdHRlcm5UZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgbmV3IHRleHR1cmUuXG4gICAqL1xuICBzZXRQYXR0ZXJuVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMucGF0dGVyblRleHR1cmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvblNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBuZXcgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIHNldFJlc29sdXRpb25TY2FsZShzY2FsZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zY2FsZSA9IHNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCBzZWxlY3RzIGEgbGlzdCBvZiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDNEW119IG9iamVjdHMgLSBUaGUgb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBvdXRsaW5lZC4gVGhpcyBhcnJheSB3aWxsIGJlIGNvcGllZC5cbiAgICogQHJldHVybiB7T3V0bGluZVBhc3N9IFRoaXMgcGFzcy5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNlbGVjdGlvbi5zZXQoKSBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uKG9iamVjdHMpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5zZXQob2JqZWN0cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgbGlzdCBvZiBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPdXRsaW5lUGFzc30gVGhpcyBwYXNzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uLmNsZWFyKCkgaW5zdGVhZC5cbiAgICovXG4gIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdHMgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIG91dGxpbmVkLlxuICAgKiBAcmV0dXJuIHtPdXRsaW5lUGFzc30gVGhpcyBwYXNzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uLmFkZCgpIGluc3RlYWQuXG4gICAqL1xuICBzZWxlY3RPYmplY3Qob2JqZWN0KSB7XG4gICAgdGhpcy5zZWxlY3Rpb24uYWRkKG9iamVjdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERlc2VsZWN0cyBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgbm8gbG9uZ2VyIGJlIG91dGxpbmVkLlxuICAgKiBAcmV0dXJuIHtPdXRsaW5lUGFzc30gVGhpcyBwYXNzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uLmRlbGV0ZSgpIGluc3RlYWQuXG4gICAqL1xuICBkZXNlbGVjdE9iamVjdChvYmplY3QpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5kZWxldGUob2JqZWN0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcbiAgICBjb25zdCBwdWxzZSA9IHVuaWZvcm1zLmdldChcInB1bHNlXCIpO1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuICAgIGNvbnN0IG1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2s7XG4gICAgaWYgKHRoaXMuZm9yY2VVcGRhdGUgfHwgc2VsZWN0aW9uLnNpemUgPiAwKSB7XG4gICAgICBzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgIHB1bHNlLnZhbHVlID0gMTtcbiAgICAgIGlmICh0aGlzLnB1bHNlU3BlZWQgPiAwKSB7XG4gICAgICAgIHB1bHNlLnZhbHVlID0gTWF0aC5jb3ModGhpcy50aW1lICogdGhpcy5wdWxzZVNwZWVkICogMTApICogMC4zNzUgKyAwLjYyNTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZSArPSBkZWx0YVRpbWU7XG4gICAgICBzZWxlY3Rpb24uc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICB0aGlzLmRlcHRoUGFzcy5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgc2VsZWN0aW9uLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICBjYW1lcmEubGF5ZXJzLnNldChzZWxlY3Rpb24ubGF5ZXIpO1xuICAgICAgdGhpcy5tYXNrUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0TWFzayk7XG4gICAgICBjYW1lcmEubGF5ZXJzLm1hc2sgPSBtYXNrO1xuICAgICAgc2NlbmUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgICB0aGlzLm91dGxpbmVQYXNzLnJlbmRlcihyZW5kZXJlciwgbnVsbCwgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lKTtcbiAgICAgIGlmICh0aGlzLmJsdXJQYXNzLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZSwgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSA9IHNlbGVjdGlvbi5zaXplID4gMDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuYmx1clBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2suc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLmRlcHRoUGFzcy5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZS5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMub3V0bGluZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUodywgaCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIFVuc2lnbmVkQnl0ZVR5cGUxMSk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmRlcHRoUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICAgIHRoaXMubWFza1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgICB0aGlzLm91dGxpbmVQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvUGl4ZWxhdGlvbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMzEsIFZlY3RvcjIgYXMgVmVjdG9yMjE2LCBWZWN0b3I0IGFzIFZlY3RvcjQzIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvcGl4ZWxhdGlvbi5mcmFnXG52YXIgcGl4ZWxhdGlvbl9kZWZhdWx0ID0gYHVuaWZvcm0gYm9vbCBhY3RpdmU7dW5pZm9ybSB2ZWM0IGQ7dm9pZCBtYWluVXYoaW5vdXQgdmVjMiB1dil7aWYoYWN0aXZlKXt1dj1kLnh5KihmbG9vcih1dipkLnp3KSswLjUpO319YDtcblxuLy8gc3JjL2VmZmVjdHMvUGl4ZWxhdGlvbkVmZmVjdC5qc1xudmFyIFBpeGVsYXRpb25FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHBpeGVsYXRpb24gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2dyYW51bGFyaXR5PTMwLjBdIC0gVGhlIHBpeGVsIGdyYW51bGFyaXR5LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ3JhbnVsYXJpdHkgPSAzMCkge1xuICAgIHN1cGVyKFwiUGl4ZWxhdGlvbkVmZmVjdFwiLCBwaXhlbGF0aW9uX2RlZmF1bHQsIHtcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImFjdGl2ZVwiLCBuZXcgVW5pZm9ybTMxKGZhbHNlKV0sXG4gICAgICAgIFtcImRcIiwgbmV3IFVuaWZvcm0zMShuZXcgVmVjdG9yNDMoKSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyMTYoKTtcbiAgICB0aGlzLl9ncmFudWxhcml0eSA9IDA7XG4gICAgdGhpcy5ncmFudWxhcml0eSA9IGdyYW51bGFyaXR5O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcGl4ZWwgZ3JhbnVsYXJpdHkuXG4gICAqXG4gICAqIEEgaGlnaGVyIHZhbHVlIHlpZWxkcyBjb2Fyc2VyIHZpc3VhbHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZ3JhbnVsYXJpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYW51bGFyaXR5O1xuICB9XG4gIHNldCBncmFudWxhcml0eSh2YWx1ZSkge1xuICAgIGxldCBkID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgaWYgKGQgJSAyID4gMCkge1xuICAgICAgZCArPSAxO1xuICAgIH1cbiAgICB0aGlzLl9ncmFudWxhcml0eSA9IGQ7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJhY3RpdmVcIikudmFsdWUgPSBkID4gMDtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGl4ZWwgZ3JhbnVsYXJpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBncmFudWxhcml0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBncmFudWxhcml0eS5cbiAgICovXG4gIGdldEdyYW51bGFyaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmdyYW51bGFyaXR5O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwaXhlbCBncmFudWxhcml0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdyYW51bGFyaXR5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgZ3JhbnVsYXJpdHkuXG4gICAqL1xuICBzZXRHcmFudWxhcml0eSh2YWx1ZSkge1xuICAgIHRoaXMuZ3JhbnVsYXJpdHkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZ3JhbnVsYXJpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGQgPSB0aGlzLmdyYW51bGFyaXR5O1xuICAgIGNvbnN0IHggPSBkIC8gcmVzb2x1dGlvbi54O1xuICAgIGNvbnN0IHkgPSBkIC8gcmVzb2x1dGlvbi55O1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZFwiKS52YWx1ZS5zZXQoeCwgeSwgMSAvIHgsIDEgLyB5KTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvUmVhbGlzdGljQm9rZWhFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTMyLCBWZWN0b3I0IGFzIFZlY3RvcjQ0IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvcmVhbGlzdGljLWJva2VoLmZyYWdcbnZhciByZWFsaXN0aWNfYm9rZWhfZGVmYXVsdCA9IGB1bmlmb3JtIGZsb2F0IGZvY3VzO3VuaWZvcm0gZmxvYXQgZm9jYWxMZW5ndGg7dW5pZm9ybSBmbG9hdCBmU3RvcDt1bmlmb3JtIGZsb2F0IG1heEJsdXI7dW5pZm9ybSBmbG9hdCBsdW1pbmFuY2VUaHJlc2hvbGQ7dW5pZm9ybSBmbG9hdCBsdW1pbmFuY2VHYWluO3VuaWZvcm0gZmxvYXQgYmlhczt1bmlmb3JtIGZsb2F0IGZyaW5nZTtcbiNpZmRlZiBNQU5VQUxfRE9GXG51bmlmb3JtIHZlYzQgZG9mO1xuI2VuZGlmXG4jaWZkZWYgUEVOVEFHT05cbmZsb2F0IHBlbnRhZ29uKGNvbnN0IGluIHZlYzIgY29vcmRzKXtjb25zdCB2ZWM0IEhTMD12ZWM0KDEuMCwwLjAsMC4wLDEuMCk7Y29uc3QgdmVjNCBIUzE9dmVjNCgwLjMwOTAxNjk5NCwwLjk1MTA1NjUxNiwwLjAsMS4wKTtjb25zdCB2ZWM0IEhTMj12ZWM0KC0wLjgwOTAxNjk5NCwwLjU4Nzc4NTI1MiwwLjAsMS4wKTtjb25zdCB2ZWM0IEhTMz12ZWM0KC0wLjgwOTAxNjk5NCwtMC41ODc3ODUyNTIsMC4wLDEuMCk7Y29uc3QgdmVjNCBIUzQ9dmVjNCgwLjMwOTAxNjk5NCwtMC45NTEwNTY1MTYsMC4wLDEuMCk7Y29uc3QgdmVjNCBIUzU9dmVjNCgwLjAsMC4wLDEuMCwxLjApO2NvbnN0IHZlYzQgT05FPXZlYzQoMS4wKTtjb25zdCBmbG9hdCBQX0ZFQVRIRVI9MC40O2NvbnN0IGZsb2F0IE5fRkVBVEhFUj0tUF9GRUFUSEVSO2Zsb2F0IGluT3JPdXQ9LTQuMDt2ZWM0IFA9dmVjNChjb29yZHMsdmVjMihSSU5HU19GTE9BVC0xLjMpKTt2ZWM0IGRpc3Q9dmVjNChkb3QoUCxIUzApLGRvdChQLEhTMSksZG90KFAsSFMyKSxkb3QoUCxIUzMpKTtkaXN0PXNtb290aHN0ZXAoTl9GRUFUSEVSLFBfRkVBVEhFUixkaXN0KTtpbk9yT3V0Kz1kb3QoZGlzdCxPTkUpO2Rpc3QueD1kb3QoUCxIUzQpO2Rpc3QueT1IUzUudy1hYnMoUC56KTtkaXN0PXNtb290aHN0ZXAoTl9GRUFUSEVSLFBfRkVBVEhFUixkaXN0KTtpbk9yT3V0Kz1kaXN0Lng7cmV0dXJuIGNsYW1wKGluT3JPdXQsMC4wLDEuMCk7fVxuI2VuZGlmXG52ZWMzIHByb2Nlc3NUZXhlbChjb25zdCBpbiB2ZWMyIGNvb3Jkcyxjb25zdCBpbiBmbG9hdCBibHVyKXt2ZWMyIHNjYWxlPXRleGVsU2l6ZSpmcmluZ2UqYmx1cjt2ZWMzIGM9dmVjMyh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzK3ZlYzIoMC4wLDEuMCkqc2NhbGUpLnIsdGV4dHVyZTJEKGlucHV0QnVmZmVyLGNvb3Jkcyt2ZWMyKC0wLjg2NiwtMC41KSpzY2FsZSkuZyx0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzK3ZlYzIoMC44NjYsLTAuNSkqc2NhbGUpLmIpO2Zsb2F0IGx1bWluYW5jZT1saW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKGMpO2Zsb2F0IHRocmVzaG9sZD1tYXgoKGx1bWluYW5jZS1sdW1pbmFuY2VUaHJlc2hvbGQpKmx1bWluYW5jZUdhaW4sMC4wKTtyZXR1cm4gYyttaXgodmVjMygwLjApLGMsdGhyZXNob2xkKmJsdXIpO31mbG9hdCBnYXRoZXIoY29uc3QgaW4gZmxvYXQgaSxjb25zdCBpbiBmbG9hdCBqLGNvbnN0IGluIGZsb2F0IHJpbmdTYW1wbGVzLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gdmVjMiBibHVyRmFjdG9yLGNvbnN0IGluIGZsb2F0IGJsdXIsaW5vdXQgdmVjMyBjb2xvcil7ZmxvYXQgc3RlcD1QSTIvcmluZ1NhbXBsZXM7dmVjMiB3aD12ZWMyKGNvcyhqKnN0ZXApKmksc2luKGoqc3RlcCkqaSk7XG4jaWZkZWYgUEVOVEFHT05cbmZsb2F0IHA9cGVudGFnb24od2gpO1xuI2Vsc2VcbmZsb2F0IHA9MS4wO1xuI2VuZGlmXG5jb2xvcis9cHJvY2Vzc1RleGVsKHdoKmJsdXJGYWN0b3IrdXYsYmx1cikqbWl4KDEuMCxpL1JJTkdTX0ZMT0FULGJpYXMpKnA7cmV0dXJuIG1peCgxLjAsaS9SSU5HU19GTE9BVCxiaWFzKSpwO312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixjb25zdCBpbiBmbG9hdCBkZXB0aCxvdXQgdmVjNCBvdXRwdXRDb2xvcil7XG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5mbG9hdCB2aWV3Wj1wZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyLGNhbWVyYUZhcik7ZmxvYXQgbGluZWFyRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcbiNlbHNlXG5mbG9hdCBsaW5lYXJEZXB0aD1kZXB0aDtcbiNlbmRpZlxuI2lmZGVmIE1BTlVBTF9ET0ZcbmZsb2F0IGZvY2FsUGxhbmU9bGluZWFyRGVwdGgtZm9jdXM7ZmxvYXQgZmFyRG9GPShmb2NhbFBsYW5lLWRvZi56KS9kb2YudztmbG9hdCBuZWFyRG9GPSgtZm9jYWxQbGFuZS1kb2YueCkvZG9mLnk7ZmxvYXQgYmx1cj0oZm9jYWxQbGFuZT4wLjApP2ZhckRvRjpuZWFyRG9GO1xuI2Vsc2VcbmNvbnN0IGZsb2F0IENJUkNMRV9PRl9DT05GVVNJT049MC4wMztmbG9hdCBmb2NhbFBsYW5lTU09Zm9jdXMqMTAwMC4wO2Zsb2F0IGRlcHRoTU09bGluZWFyRGVwdGgqMTAwMC4wO2Zsb2F0IGZvY2FsUGxhbmU9KGRlcHRoTU0qZm9jYWxMZW5ndGgpLyhkZXB0aE1NLWZvY2FsTGVuZ3RoKTtmbG9hdCBmYXJEb0Y9KGZvY2FsUGxhbmVNTSpmb2NhbExlbmd0aCkvKGZvY2FsUGxhbmVNTS1mb2NhbExlbmd0aCk7ZmxvYXQgbmVhckRvRj0oZm9jYWxQbGFuZU1NLWZvY2FsTGVuZ3RoKS8oZm9jYWxQbGFuZU1NKmZTdG9wKkNJUkNMRV9PRl9DT05GVVNJT04pO2Zsb2F0IGJsdXI9YWJzKGZvY2FsUGxhbmUtZmFyRG9GKSpuZWFyRG9GO1xuI2VuZGlmXG5jb25zdCBpbnQgTUFYX1JJTkdfU0FNUExFUz1SSU5HU19JTlQqU0FNUExFU19JTlQ7Ymx1cj1jbGFtcChibHVyLDAuMCwxLjApO3ZlYzMgY29sb3I9aW5wdXRDb2xvci5yZ2I7aWYoYmx1cj49MC4wNSl7dmVjMiBibHVyRmFjdG9yPWJsdXIqbWF4Qmx1cip0ZXhlbFNpemU7ZmxvYXQgcz0xLjA7aW50IHJpbmdTYW1wbGVzO2ZvcihpbnQgaT0xO2k8PVJJTkdTX0lOVDtpKyspe3JpbmdTYW1wbGVzPWkqU0FNUExFU19JTlQ7Zm9yKGludCBqPTA7ajxNQVhfUklOR19TQU1QTEVTO2orKyl7aWYoaj49cmluZ1NhbXBsZXMpe2JyZWFrO31zKz1nYXRoZXIoZmxvYXQoaSksZmxvYXQoaiksZmxvYXQocmluZ1NhbXBsZXMpLHV2LGJsdXJGYWN0b3IsYmx1cixjb2xvcik7fX1jb2xvci89czt9XG4jaWZkZWYgU0hPV19GT0NVU1xuZmxvYXQgZWRnZT0wLjAwMipsaW5lYXJEZXB0aDtmbG9hdCBtPWNsYW1wKHNtb290aHN0ZXAoMC4wLGVkZ2UsYmx1ciksMC4wLDEuMCk7ZmxvYXQgZT1jbGFtcChzbW9vdGhzdGVwKDEuMC1lZGdlLDEuMCxibHVyKSwwLjAsMS4wKTtjb2xvcj1taXgoY29sb3IsdmVjMygxLjAsMC41LDAuMCksKDEuMC1tKSowLjYpO2NvbG9yPW1peChjb2xvcix2ZWMzKDAuMCwwLjUsMS4wKSwoKDEuMC1lKS0oMS4wLW0pKSowLjIpO1xuI2VuZGlmXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGlucHV0Q29sb3IuYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL1JlYWxpc3RpY0Jva2VoRWZmZWN0LmpzXG52YXIgUmVhbGlzdGljQm9rZWhFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXM9MS4wXSAtIFRoZSBmb2N1cyBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY2FsTGVuZ3RoPTI0LjBdIC0gVGhlIGZvY2FsIGxlbmd0aCBvZiB0aGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mU3RvcD0wLjldIC0gVGhlIHJhdGlvIG9mIHRoZSBsZW5zIGZvY2FsIGxlbmd0aCB0byB0aGUgZGlhbWV0ZXIgb2YgdGhlIGVudHJhbmNlIHB1cGlsIChhcGVydHVyZSkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sdW1pbmFuY2VUaHJlc2hvbGQ9MC41XSAtIEEgbHVtaW5hbmNlIHRocmVzaG9sZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmx1bWluYW5jZUdhaW49Mi4wXSAtIEEgbHVtaW5hbmNlIGdhaW4gZmFjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmlhcz0wLjVdIC0gQSBibHVyIGJpYXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mcmluZ2U9MC43XSAtIEEgYmx1ciBvZmZzZXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhCbHVyPTEuMF0gLSBUaGUgbWF4aW11bSBibHVyIHN0cmVuZ3RoLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJpbmdzPTNdIC0gVGhlIG51bWJlciBvZiBibHVyIGl0ZXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2FtcGxlcz0yXSAtIFRoZSBhbW91bnQgb2Ygc2FtcGxlcyB0YWtlbiBwZXIgcmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaG93Rm9jdXM9ZmFsc2VdIC0gV2hldGhlciB0aGUgZm9jYWwgcG9pbnQgc2hvdWxkIGJlIGhpZ2hsaWdodGVkLiBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYW51YWxEb0Y9ZmFsc2VdIC0gRW5hYmxlcyBtYW51YWwgY29udHJvbCBvdmVyIHRoZSBkZXB0aCBvZiBmaWVsZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wZW50YWdvbj1mYWxzZV0gLSBFbmFibGVzIHBlbnRhZ29uYWwgYmx1ciBzaGFwZXMuIFJlcXVpcmVzIGEgaGlnaCBudW1iZXIgb2YgcmluZ3MgYW5kIHNhbXBsZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbixcbiAgICBmb2N1cyA9IDEsXG4gICAgZm9jYWxMZW5ndGggPSAyNCxcbiAgICBmU3RvcCA9IDAuOSxcbiAgICBsdW1pbmFuY2VUaHJlc2hvbGQgPSAwLjUsXG4gICAgbHVtaW5hbmNlR2FpbiA9IDIsXG4gICAgYmlhcyA9IDAuNSxcbiAgICBmcmluZ2UgPSAwLjcsXG4gICAgbWF4Qmx1ciA9IDEsXG4gICAgcmluZ3MgPSAzLFxuICAgIHNhbXBsZXMgPSAyLFxuICAgIHNob3dGb2N1cyA9IGZhbHNlLFxuICAgIG1hbnVhbERvRiA9IGZhbHNlLFxuICAgIHBlbnRhZ29uID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJSZWFsaXN0aWNCb2tlaEVmZmVjdFwiLCByZWFsaXN0aWNfYm9rZWhfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5DT05WT0xVVElPTiB8IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImZvY3VzXCIsIG5ldyBVbmlmb3JtMzIoZm9jdXMpXSxcbiAgICAgICAgW1wiZm9jYWxMZW5ndGhcIiwgbmV3IFVuaWZvcm0zMihmb2NhbExlbmd0aCldLFxuICAgICAgICBbXCJmU3RvcFwiLCBuZXcgVW5pZm9ybTMyKGZTdG9wKV0sXG4gICAgICAgIFtcImx1bWluYW5jZVRocmVzaG9sZFwiLCBuZXcgVW5pZm9ybTMyKGx1bWluYW5jZVRocmVzaG9sZCldLFxuICAgICAgICBbXCJsdW1pbmFuY2VHYWluXCIsIG5ldyBVbmlmb3JtMzIobHVtaW5hbmNlR2FpbildLFxuICAgICAgICBbXCJiaWFzXCIsIG5ldyBVbmlmb3JtMzIoYmlhcyldLFxuICAgICAgICBbXCJmcmluZ2VcIiwgbmV3IFVuaWZvcm0zMihmcmluZ2UpXSxcbiAgICAgICAgW1wibWF4Qmx1clwiLCBuZXcgVW5pZm9ybTMyKG1heEJsdXIpXSxcbiAgICAgICAgW1wiZG9mXCIsIG5ldyBVbmlmb3JtMzIobnVsbCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmluZ3MgPSByaW5ncztcbiAgICB0aGlzLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIHRoaXMuc2hvd0ZvY3VzID0gc2hvd0ZvY3VzO1xuICAgIHRoaXMubWFudWFsRG9GID0gbWFudWFsRG9GO1xuICAgIHRoaXMucGVudGFnb24gPSBwZW50YWdvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBibHVyIGl0ZXJhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmluZ3MoKSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0aGlzLmRlZmluZXMuZ2V0KFwiUklOR1NfSU5UXCIpKTtcbiAgfVxuICBzZXQgcmluZ3ModmFsdWUpIHtcbiAgICBjb25zdCByID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlJJTkdTX0lOVFwiLCByLnRvRml4ZWQoMCkpO1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJSSU5HU19GTE9BVFwiLCByLnRvRml4ZWQoMSkpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIGJsdXIgc2FtcGxlcyBwZXIgcmluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzYW1wbGVzKCkge1xuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGhpcy5kZWZpbmVzLmdldChcIlNBTVBMRVNfSU5UXCIpKTtcbiAgfVxuICBzZXQgc2FtcGxlcyh2YWx1ZSkge1xuICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiU0FNUExFU19JTlRcIiwgcy50b0ZpeGVkKDApKTtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiU0FNUExFU19GTE9BVFwiLCBzLnRvRml4ZWQoMSkpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZm9jYWwgcG9pbnQgd2lsbCBiZSBoaWdobGlnaHRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgc2hvd0ZvY3VzKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiU0hPV19GT0NVU1wiKTtcbiAgfVxuICBzZXQgc2hvd0ZvY3VzKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2hvd0ZvY3VzICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTSE9XX0ZPQ1VTXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJTSE9XX0ZPQ1VTXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgRGVwdGggb2YgRmllbGQgc2hvdWxkIGJlIGNhbGN1bGF0ZWQgbWFudWFsbHkuXG4gICAqXG4gICAqIElmIGVuYWJsZWQsIHRoZSBEZXB0aCBvZiBGaWVsZCBjYW4gYmUgYWRqdXN0ZWQgdmlhIHRoZSBgZG9mYCB1bmlmb3JtLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBtYW51YWxEb0YoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJNQU5VQUxfRE9GXCIpO1xuICB9XG4gIHNldCBtYW51YWxEb0YodmFsdWUpIHtcbiAgICBpZiAodGhpcy5tYW51YWxEb0YgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIk1BTlVBTF9ET0ZcIiwgXCIxXCIpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmdldChcImRvZlwiKS52YWx1ZSA9IG5ldyBWZWN0b3I0NCgwLjIsIDEsIDAuMiwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiTUFOVUFMX0RPRlwiKTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJkb2ZcIikudmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYmx1ciBzaGFwZSBzaG91bGQgYmUgcGVudGFnb25hbC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgcGVudGFnb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJQRU5UQUdPTlwiKTtcbiAgfVxuICBzZXQgcGVudGFnb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5wZW50YWdvbiAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiUEVOVEFHT05cIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlBFTlRBR09OXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9TY2FubGluZUVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMzMsIFZlY3RvcjIgYXMgVmVjdG9yMjE3IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvc2NhbmxpbmVzLmZyYWdcbnZhciBzY2FubGluZXNfZGVmYXVsdCA9IGB1bmlmb3JtIGZsb2F0IGNvdW50O1xuI2lmZGVmIFNDUk9MTFxudW5pZm9ybSBmbG9hdCBzY3JvbGxTcGVlZDtcbiNlbmRpZlxudm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2Zsb2F0IHk9dXYueTtcbiNpZmRlZiBTQ1JPTExcbnkrPXRpbWUqc2Nyb2xsU3BlZWQ7XG4jZW5kaWZcbnZlYzIgc2w9dmVjMihzaW4oeSpjb3VudCksY29zKHkqY291bnQpKTtvdXRwdXRDb2xvcj12ZWM0KHNsLnh5eCxpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9TY2FubGluZUVmZmVjdC5qc1xudmFyIFNjYW5saW5lRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzY2FubGluZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uT1ZFUkxBWV0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZW5zaXR5PTEuMjVdIC0gVGhlIHNjYW5saW5lIGRlbnNpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY3JvbGxTcGVlZD0wLjBdIC0gVGhlIHNjYW5saW5lIHNjcm9sbCBzcGVlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uT1ZFUkxBWSwgZGVuc2l0eSA9IDEuMjUsIHNjcm9sbFNwZWVkID0gMCB9ID0ge30pIHtcbiAgICBzdXBlcihcIlNjYW5saW5lRWZmZWN0XCIsIHNjYW5saW5lc19kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiY291bnRcIiwgbmV3IFVuaWZvcm0zMygwKV0sXG4gICAgICAgIFtcInNjcm9sbFNwZWVkXCIsIG5ldyBVbmlmb3JtMzMoMCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyMTcoKTtcbiAgICB0aGlzLmQgPSBkZW5zaXR5O1xuICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSBzY3JvbGxTcGVlZDtcbiAgfVxuICAvKipcbiAgICogVGhlIHNjYW5saW5lIGRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5kO1xuICB9XG4gIHNldCBkZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5kID0gdmFsdWU7XG4gICAgdGhpcy5zZXRTaXplKHRoaXMucmVzb2x1dGlvbi53aWR0aCwgdGhpcy5yZXNvbHV0aW9uLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICovXG4gIGdldERlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVuc2l0eTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBzY2FubGluZSBkZW5zaXR5LlxuICAgKi9cbiAgc2V0RGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMuZGVuc2l0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NhbmxpbmUgc2Nyb2xsIHNwZWVkLiBEZWZhdWx0IGlzIDAgKGRpc2FibGVkKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY3JvbGxTcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzY3JvbGxTcGVlZFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgc2Nyb2xsU3BlZWQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInNjcm9sbFNwZWVkXCIpLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5kZWZpbmVzLmRlbGV0ZShcIlNDUk9MTFwiKSkge1xuICAgICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmRlZmluZXMuaGFzKFwiU0NST0xMXCIpKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiU0NST0xMXCIsIFwiMVwiKTtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiY291bnRcIikudmFsdWUgPSBNYXRoLnJvdW5kKGhlaWdodCAqIHRoaXMuZGVuc2l0eSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1Nob2NrV2F2ZUVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMzQsIFZlY3RvcjIgYXMgVmVjdG9yMjE4LCBWZWN0b3IzIGFzIFZlY3RvcjM1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvc2hvY2std2F2ZS5mcmFnXG52YXIgc2hvY2tfd2F2ZV9kZWZhdWx0ID0gYHVuaWZvcm0gYm9vbCBhY3RpdmU7dW5pZm9ybSB2ZWMyIGNlbnRlcjt1bmlmb3JtIGZsb2F0IHdhdmVTaXplO3VuaWZvcm0gZmxvYXQgcmFkaXVzO3VuaWZvcm0gZmxvYXQgbWF4UmFkaXVzO3VuaWZvcm0gZmxvYXQgYW1wbGl0dWRlO3ZhcnlpbmcgZmxvYXQgdlNpemU7dm9pZCBtYWluVXYoaW5vdXQgdmVjMiB1dil7aWYoYWN0aXZlKXt2ZWMyIGFzcGVjdENvcnJlY3Rpb249dmVjMihhc3BlY3QsMS4wKTt2ZWMyIGRpZmZlcmVuY2U9dXYqYXNwZWN0Q29ycmVjdGlvbi1jZW50ZXIqYXNwZWN0Q29ycmVjdGlvbjtmbG9hdCBkaXN0YW5jZT1zcXJ0KGRvdChkaWZmZXJlbmNlLGRpZmZlcmVuY2UpKSp2U2l6ZTtpZihkaXN0YW5jZT5yYWRpdXMpe2lmKGRpc3RhbmNlPHJhZGl1cyt3YXZlU2l6ZSl7ZmxvYXQgYW5nbGU9KGRpc3RhbmNlLXJhZGl1cykqUEkyL3dhdmVTaXplO2Zsb2F0IGNvc1Npbj0oMS4wLWNvcyhhbmdsZSkpKjAuNTtmbG9hdCBleHRlbnQ9bWF4UmFkaXVzK3dhdmVTaXplO2Zsb2F0IGRlY2F5PW1heChleHRlbnQtZGlzdGFuY2UqZGlzdGFuY2UsMC4wKS9leHRlbnQ7dXYtPSgoY29zU2luKmFtcGxpdHVkZSpkaWZmZXJlbmNlKS9kaXN0YW5jZSkqZGVjYXk7fX19fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvc2hvY2std2F2ZS52ZXJ0XG52YXIgc2hvY2tfd2F2ZV9kZWZhdWx0MiA9IGB1bmlmb3JtIGZsb2F0IHNpemU7dW5pZm9ybSBmbG9hdCBjYW1lcmFEaXN0YW5jZTt2YXJ5aW5nIGZsb2F0IHZTaXplO3ZvaWQgbWFpblN1cHBvcnQoKXt2U2l6ZT0oMC4xKmNhbWVyYURpc3RhbmNlKS9zaXplO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9TaG9ja1dhdmVFZmZlY3QuanNcbnZhciBIQUxGX1BJID0gTWF0aC5QSSAqIDAuNTtcbnZhciB2MiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMzUoKTtcbnZhciBhYiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMzUoKTtcbnZhciBTaG9ja1dhdmVFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNob2NrIHdhdmUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IFtwb3NpdGlvbl0gLSBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHNob2NrIHdhdmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNwZWVkPTIuMF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmFkaXVzPTEuMF0gLSBUaGUgZXh0ZW50IG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2F2ZVNpemU9MC4yXSAtIFRoZSB3YXZlIHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbXBsaXR1ZGU9MC4wNV0gLSBUaGUgZGlzdG9ydGlvbiBhbXBsaXR1ZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIHBvc2l0aW9uID0gbmV3IFZlY3RvcjM1KCksIHtcbiAgICBzcGVlZCA9IDIsXG4gICAgbWF4UmFkaXVzID0gMSxcbiAgICB3YXZlU2l6ZSA9IDAuMixcbiAgICBhbXBsaXR1ZGUgPSAwLjA1XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU2hvY2tXYXZlRWZmZWN0XCIsIHNob2NrX3dhdmVfZGVmYXVsdCwge1xuICAgICAgdmVydGV4U2hhZGVyOiBzaG9ja193YXZlX2RlZmF1bHQyLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYWN0aXZlXCIsIG5ldyBVbmlmb3JtMzQoZmFsc2UpXSxcbiAgICAgICAgW1wiY2VudGVyXCIsIG5ldyBVbmlmb3JtMzQobmV3IFZlY3RvcjIxOCgwLjUsIDAuNSkpXSxcbiAgICAgICAgW1wiY2FtZXJhRGlzdGFuY2VcIiwgbmV3IFVuaWZvcm0zNCgxKV0sXG4gICAgICAgIFtcInNpemVcIiwgbmV3IFVuaWZvcm0zNCgxKV0sXG4gICAgICAgIFtcInJhZGl1c1wiLCBuZXcgVW5pZm9ybTM0KC13YXZlU2l6ZSldLFxuICAgICAgICBbXCJtYXhSYWRpdXNcIiwgbmV3IFVuaWZvcm0zNChtYXhSYWRpdXMpXSxcbiAgICAgICAgW1wid2F2ZVNpemVcIiwgbmV3IFVuaWZvcm0zNCh3YXZlU2l6ZSldLFxuICAgICAgICBbXCJhbXBsaXR1ZGVcIiwgbmV3IFVuaWZvcm0zNChhbXBsaXR1ZGUpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuc2NyZWVuUG9zaXRpb24gPSB0aGlzLnVuaWZvcm1zLmdldChcImNlbnRlclwiKS52YWx1ZTtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1wbGl0dWRlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGFtcGxpdHVkZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJhbXBsaXR1ZGVcIikudmFsdWU7XG4gIH1cbiAgc2V0IGFtcGxpdHVkZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYW1wbGl0dWRlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3YXZlIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd2F2ZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwid2F2ZVNpemVcIikudmFsdWU7XG4gIH1cbiAgc2V0IHdhdmVTaXplKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJ3YXZlU2l6ZVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSByYWRpdXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4UmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm1heFJhZGl1c1wiKS52YWx1ZTtcbiAgfVxuICBzZXQgbWF4UmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXhSYWRpdXNcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yM31cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBvc2l0aW9uIGluc3RlYWQuXG4gICAqL1xuICBnZXQgZXBpY2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICB9XG4gIHNldCBlcGljZW50ZXIodmFsdWUpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yM30gVGhlIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2YWx1ZSAtIFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIHNldFBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzcGVlZCBvZiB0aGUgc2hvY2sgd2F2ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNwZWVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNwZWVkLlxuICAgKi9cbiAgZ2V0U3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNwZWVkIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3BlZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNwZWVkLlxuICAgKi9cbiAgc2V0U3BlZWQodmFsdWUpIHtcbiAgICB0aGlzLnNwZWVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBzaG9jayB3YXZlLlxuICAgKi9cbiAgZXhwbG9kZSgpIHtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImFjdGl2ZVwiKS52YWx1ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGEpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IHVBY3RpdmUgPSB1bmlmb3Jtcy5nZXQoXCJhY3RpdmVcIik7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICBjb25zdCB3YXZlU2l6ZSA9IHVuaWZvcm1zLmdldChcIndhdmVTaXplXCIpLnZhbHVlO1xuICAgICAgY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKHYyKTtcbiAgICAgIGFiLmNvcHkoY2FtZXJhLnBvc2l0aW9uKS5zdWIocG9zaXRpb24pO1xuICAgICAgdUFjdGl2ZS52YWx1ZSA9IHYyLmFuZ2xlVG8oYWIpID4gSEFMRl9QSTtcbiAgICAgIGlmICh1QWN0aXZlLnZhbHVlKSB7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImNhbWVyYURpc3RhbmNlXCIpLnZhbHVlID0gY2FtZXJhLnBvc2l0aW9uLmRpc3RhbmNlVG8ocG9zaXRpb24pO1xuICAgICAgICB2Mi5jb3B5KHBvc2l0aW9uKS5wcm9qZWN0KGNhbWVyYSk7XG4gICAgICAgIHRoaXMuc2NyZWVuUG9zaXRpb24uc2V0KCh2Mi54ICsgMSkgKiAwLjUsICh2Mi55ICsgMSkgKiAwLjUpO1xuICAgICAgfVxuICAgICAgdGhpcy50aW1lICs9IGRlbHRhICogdGhpcy5zcGVlZDtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMudGltZSAtIHdhdmVTaXplO1xuICAgICAgdW5pZm9ybXMuZ2V0KFwicmFkaXVzXCIpLnZhbHVlID0gcmFkaXVzO1xuICAgICAgaWYgKHJhZGl1cyA+PSAodW5pZm9ybXMuZ2V0KFwibWF4UmFkaXVzXCIpLnZhbHVlICsgd2F2ZVNpemUpICogMikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB1QWN0aXZlLnZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9TZWxlY3RpdmVCbG9vbUVmZmVjdC5qc1xuaW1wb3J0IHtcbiAgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmc3LFxuICBDb2xvciBhcyBDb2xvcjcsXG4gIE5vdEVxdWFsRGVwdGggYXMgTm90RXF1YWxEZXB0aDIsXG4gIEVxdWFsRGVwdGggYXMgRXF1YWxEZXB0aDIsXG4gIFJHQkFEZXB0aFBhY2tpbmcgYXMgUkdCQURlcHRoUGFja2luZzMsXG4gIFNSR0JDb2xvclNwYWNlIGFzIFNSR0JDb2xvclNwYWNlMTEsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTNcbn0gZnJvbSBcInRocmVlXCI7XG52YXIgU2VsZWN0aXZlQmxvb21FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEJsb29tRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgc2VsZWN0aXZlIGJsb29tIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgbWFpbiBzY2VuZS5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLiBTZWUge0BsaW5rIEJsb29tRWZmZWN0fSBmb3IgZGV0YWlscy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZXModGhpcy5nZXRBdHRyaWJ1dGVzKCkgfCBFZmZlY3RBdHRyaWJ1dGUuREVQVEgpO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuZGVwdGhQYXNzID0gbmV3IERlcHRoUGFzcyhzY2VuZSwgY2FtZXJhKTtcbiAgICB0aGlzLmNsZWFyUGFzcyA9IG5ldyBDbGVhclBhc3ModHJ1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3I3KDApO1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBEZXB0aE1hc2tNYXRlcmlhbCgpKTtcbiAgICBjb25zdCBkZXB0aE1hc2tNYXRlcmlhbCA9IHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWw7XG4gICAgZGVwdGhNYXNrTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gICAgZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhCdWZmZXIxID0gdGhpcy5kZXB0aFBhc3MudGV4dHVyZTtcbiAgICBkZXB0aE1hc2tNYXRlcmlhbC5kZXB0aFBhY2tpbmcxID0gUkdCQURlcHRoUGFja2luZzM7XG4gICAgZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhNb2RlID0gRXF1YWxEZXB0aDI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxMygxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZC50ZXh0dXJlLm5hbWUgPSBcIkJsb29tLk1hc2tlZFwiO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbigpO1xuICAgIHRoaXMuX2ludmVydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faWdub3JlQmFja2dyb3VuZCA9IGZhbHNlO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLmRlcHRoUGFzcy5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMuY2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aFBhc3MubWFpbkNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIGdldFNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBtYXNrIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhNYXNrTWF0ZXJpYWx9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZGVwdGhNYXNrTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnZlcnRlZDtcbiAgfVxuICBzZXQgaW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLl9pbnZlcnRlZCA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhNb2RlID0gdmFsdWUgPyBOb3RFcXVhbERlcHRoMiA6IEVxdWFsRGVwdGgyO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWFzayBpcyBpbnZlcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIG1hc2sgaXMgaW52ZXJ0ZWQuXG4gICAqL1xuICBpc0ludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmludmVydGVkO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGUgbWFzayBpbnZlcnNpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgbWFzayBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqL1xuICBzZXRJbnZlcnRlZCh2YWx1ZSkge1xuICAgIHRoaXMuaW52ZXJ0ZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJhY2tncm91bmQgY29sb3JzIHdpbGwgYmUgaWdub3JlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaWdub3JlQmFja2dyb3VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWdub3JlQmFja2dyb3VuZDtcbiAgfVxuICBzZXQgaWdub3JlQmFja2dyb3VuZCh2YWx1ZSkge1xuICAgIHRoaXMuX2lnbm9yZUJhY2tncm91bmQgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoTWFza01hdGVyaWFsLm1heERlcHRoU3RyYXRlZ3kgPSB2YWx1ZSA/IERlcHRoVGVzdFN0cmF0ZWd5LkRJU0NBUkRfTUFYX0RFUFRIIDogRGVwdGhUZXN0U3RyYXRlZ3kuS0VFUF9NQVhfREVQVEg7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaWdub3JlQmFja2dyb3VuZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgaXNCYWNrZ3JvdW5kRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWdub3JlQmFja2dyb3VuZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYmFja2dyb3VuZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlnbm9yZUJhY2tncm91bmQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIGJhY2tncm91bmQgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0QmFja2dyb3VuZERpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pZ25vcmVCYWNrZ3JvdW5kID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzcpIHtcbiAgICB0aGlzLmRlcHRoTWFza01hdGVyaWFsLmRlcHRoQnVmZmVyMCA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmRlcHRoTWFza01hdGVyaWFsLmRlcHRoUGFja2luZzAgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIGNvbnN0IGludmVydGVkID0gdGhpcy5pbnZlcnRlZDtcbiAgICBsZXQgcmVuZGVyVGFyZ2V0ID0gaW5wdXRCdWZmZXI7XG4gICAgaWYgKHRoaXMuaWdub3JlQmFja2dyb3VuZCB8fCAhaW52ZXJ0ZWQgfHwgc2VsZWN0aW9uLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBtYXNrID0gY2FtZXJhLmxheWVycy5tYXNrO1xuICAgICAgY2FtZXJhLmxheWVycy5zZXQoc2VsZWN0aW9uLmxheWVyKTtcbiAgICAgIHRoaXMuZGVwdGhQYXNzLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICBjYW1lcmEubGF5ZXJzLm1hc2sgPSBtYXNrO1xuICAgICAgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQ7XG4gICAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCk7XG4gICAgICB0aGlzLmRlcHRoTWFza1Bhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgcmVuZGVyVGFyZ2V0KTtcbiAgICB9XG4gICAgc3VwZXIudXBkYXRlKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQsIGRlbHRhVGltZSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBzdXBlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kZXB0aFBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBzdXBlci5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmNsZWFyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmRlcHRoUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLmNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSB7XG4gICAgICB0aGlzLmRlcHRoTWFza1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuTE9HX0RFUFRIID0gXCIxXCI7XG4gICAgfVxuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlMTEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UxMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1NlcGlhRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0zNSwgVmVjdG9yMyBhcyBWZWN0b3IzNiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3NlcGlhLmZyYWdcbnZhciBzZXBpYV9kZWZhdWx0ID0gYHVuaWZvcm0gdmVjMyB3ZWlnaHRzUjt1bmlmb3JtIHZlYzMgd2VpZ2h0c0c7dW5pZm9ybSB2ZWMzIHdlaWdodHNCO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMzIGNvbG9yPXZlYzMoZG90KGlucHV0Q29sb3IucmdiLHdlaWdodHNSKSxkb3QoaW5wdXRDb2xvci5yZ2Isd2VpZ2h0c0cpLGRvdChpbnB1dENvbG9yLnJnYix3ZWlnaHRzQikpO291dHB1dENvbG9yPXZlYzQoY29sb3IsaW5wdXRDb2xvci5hKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvU2VwaWFFZmZlY3QuanNcbnZhciBTZXBpYUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgc2VwaWEgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbnRlbnNpdHk9MS4wXSAtIFRoZSBpbnRlbnNpdHkgb2YgdGhlIGVmZmVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiwgaW50ZW5zaXR5ID0gMSB9ID0ge30pIHtcbiAgICBzdXBlcihcIlNlcGlhRWZmZWN0XCIsIHNlcGlhX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJ3ZWlnaHRzUlwiLCBuZXcgVW5pZm9ybTM1KG5ldyBWZWN0b3IzNigwLjM5MywgMC43NjksIDAuMTg5KSldLFxuICAgICAgICBbXCJ3ZWlnaHRzR1wiLCBuZXcgVW5pZm9ybTM1KG5ldyBWZWN0b3IzNigwLjM0OSwgMC42ODYsIDAuMTY4KSldLFxuICAgICAgICBbXCJ3ZWlnaHRzQlwiLCBuZXcgVW5pZm9ybTM1KG5ldyBWZWN0b3IzNigwLjI3MiwgMC41MzQsIDAuMTMxKSldXG4gICAgICBdKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmxlbmRNb2RlLm9wYWNpdHkgaW5zdGVhZC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBpbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxlbmRNb2RlLm9wYWNpdHkudmFsdWU7XG4gIH1cbiAgc2V0IGludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMuYmxlbmRNb2RlLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzZXBpYSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibGVuZE1vZGUub3BhY2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBnZXRJbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZW5zaXR5O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZXBpYSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibGVuZE1vZGUub3BhY2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgaW50ZW5zaXR5LlxuICAgKi9cbiAgc2V0SW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5pbnRlbnNpdHkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdlaWdodHMgZm9yIHRoZSByZWQgY2hhbm5lbC4gRGVmYXVsdCBpcyBgKDAuMzkzLCAwLjc2OSwgMC4xODkpYC5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjN9XG4gICAqL1xuICBnZXQgd2VpZ2h0c1IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwid2VpZ2h0c1JcIikudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3ZWlnaHRzIGZvciB0aGUgZ3JlZW4gY2hhbm5lbC4gRGVmYXVsdCBpcyBgKDAuMzQ5LCAwLjY4NiwgMC4xNjgpYC5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjN9XG4gICAqL1xuICBnZXQgd2VpZ2h0c0coKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwid2VpZ2h0c0dcIikudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3ZWlnaHRzIGZvciB0aGUgYmx1ZSBjaGFubmVsLiBEZWZhdWx0IGlzIGAoMC4yNzIsIDAuNTM0LCAwLjEzMSlgLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yM31cbiAgICovXG4gIGdldCB3ZWlnaHRzQigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ3ZWlnaHRzQlwiKS52YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvU01BQUVmZmVjdC5qc1xuaW1wb3J0IHtcbiAgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmc5LFxuICBDb2xvciBhcyBDb2xvcjgsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXI1LFxuICBMb2FkaW5nTWFuYWdlcixcbiAgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyNCxcbiAgVGV4dHVyZSBhcyBUZXh0dXJlMyxcbiAgVW5pZm9ybSBhcyBVbmlmb3JtMzgsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTRcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRWRnZURldGVjdGlvbk1hdGVyaWFsLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzgsIE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzEzLCBSRVZJU0lPTiBhcyBSRVZJU0lPTjIsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTQsIFVuaWZvcm0gYXMgVW5pZm9ybTM2LCBWZWN0b3IyIGFzIFZlY3RvcjIxOSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZWRnZS1kZXRlY3Rpb24uZnJhZ1xudmFyIGVkZ2VfZGV0ZWN0aW9uX2RlZmF1bHQgPSBgdmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTtcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFICE9IDBcbnZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZhcnlpbmcgdmVjMiB2VXY0O3ZhcnlpbmcgdmVjMiB2VXY1O1xuI2VuZGlmXG4jaWYgRURHRV9ERVRFQ1RJT05fTU9ERSA9PSAxXG4jaW5jbHVkZSA8Y29tbW9uPlxuI2VuZGlmXG4jaWYgRURHRV9ERVRFQ1RJT05fTU9ERSA9PSAwIHx8IFBSRURJQ0FUSU9OX01PREUgPT0gMVxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2VuZGlmXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XG4jZWxzZVxucmV0dXJuIHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikucjtcbiNlbmRpZlxufXZlYzMgZ2F0aGVyTmVpZ2hib3JzKCl7ZmxvYXQgcD1yZWFkRGVwdGgodlV2KTtmbG9hdCBwTGVmdD1yZWFkRGVwdGgodlV2MCk7ZmxvYXQgcFRvcD1yZWFkRGVwdGgodlV2MSk7cmV0dXJuIHZlYzMocCxwTGVmdCxwVG9wKTt9XG4jZWxpZiBQUkVESUNBVElPTl9NT0RFID09IDJcbnVuaWZvcm0gc2FtcGxlcjJEIHByZWRpY2F0aW9uQnVmZmVyO3ZlYzMgZ2F0aGVyTmVpZ2hib3JzKCl7ZmxvYXQgcD10ZXh0dXJlMkQocHJlZGljYXRpb25CdWZmZXIsdlV2KS5yO2Zsb2F0IHBMZWZ0PXRleHR1cmUyRChwcmVkaWNhdGlvbkJ1ZmZlcix2VXYwKS5yO2Zsb2F0IHBUb3A9dGV4dHVyZTJEKHByZWRpY2F0aW9uQnVmZmVyLHZVdjEpLnI7cmV0dXJuIHZlYzMocCxwTGVmdCxwVG9wKTt9XG4jZW5kaWZcbiNpZiBQUkVESUNBVElPTl9NT0RFICE9IDBcbnZlYzIgY2FsY3VsYXRlUHJlZGljYXRlZFRocmVzaG9sZCgpe3ZlYzMgbmVpZ2hib3Vycz1nYXRoZXJOZWlnaGJvcnMoKTt2ZWMyIGRlbHRhPWFicyhuZWlnaGJvdXJzLnh4LW5laWdoYm91cnMueXopO3ZlYzIgZWRnZXM9c3RlcChQUkVESUNBVElPTl9USFJFU0hPTEQsZGVsdGEpO3JldHVybiBQUkVESUNBVElPTl9TQ0FMRSpFREdFX1RIUkVTSE9MRCooMS4wLVBSRURJQ0FUSU9OX1NUUkVOR1RIKmVkZ2VzKTt9XG4jZW5kaWZcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFICE9IDBcbnVuaWZvcm0gc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG52b2lkIG1haW4oKXtcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFID09IDBcbmNvbnN0IHZlYzIgdGhyZXNob2xkPXZlYzIoREVQVEhfVEhSRVNIT0xEKTtcbiNlbGlmIFBSRURJQ0FUSU9OX01PREUgIT0gMFxudmVjMiB0aHJlc2hvbGQ9Y2FsY3VsYXRlUHJlZGljYXRlZFRocmVzaG9sZCgpO1xuI2Vsc2VcbmNvbnN0IHZlYzIgdGhyZXNob2xkPXZlYzIoRURHRV9USFJFU0hPTEQpO1xuI2VuZGlmXG4jaWYgRURHRV9ERVRFQ1RJT05fTU9ERSA9PSAwXG52ZWMzIG5laWdoYm9ycz1nYXRoZXJOZWlnaGJvcnMoKTt2ZWMyIGRlbHRhPWFicyhuZWlnaGJvcnMueHgtdmVjMihuZWlnaGJvcnMueSxuZWlnaGJvcnMueikpO3ZlYzIgZWRnZXM9c3RlcCh0aHJlc2hvbGQsZGVsdGEpO2lmKGRvdChlZGdlcyx2ZWMyKDEuMCkpPT0wLjApe2Rpc2NhcmQ7fWdsX0ZyYWdDb2xvcj12ZWM0KGVkZ2VzLDAuMCwxLjApO1xuI2VsaWYgRURHRV9ERVRFQ1RJT05fTU9ERSA9PSAxXG5mbG9hdCBsPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KS5yZ2IpO2Zsb2F0IGxMZWZ0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MCkucmdiKTtmbG9hdCBsVG9wPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MSkucmdiKTt2ZWM0IGRlbHRhO2RlbHRhLnh5PWFicyhsLXZlYzIobExlZnQsbFRvcCkpO3ZlYzIgZWRnZXM9c3RlcCh0aHJlc2hvbGQsZGVsdGEueHkpO2lmKGRvdChlZGdlcyx2ZWMyKDEuMCkpPT0wLjApe2Rpc2NhcmQ7fWZsb2F0IGxSaWdodD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjIpLnJnYik7ZmxvYXQgbEJvdHRvbT1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjMpLnJnYik7ZGVsdGEuenc9YWJzKGwtdmVjMihsUmlnaHQsbEJvdHRvbSkpO3ZlYzIgbWF4RGVsdGE9bWF4KGRlbHRhLnh5LGRlbHRhLnp3KTtmbG9hdCBsTGVmdExlZnQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY0KS5yZ2IpO2Zsb2F0IGxUb3BUb3A9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY1KS5yZ2IpO2RlbHRhLnp3PWFicyh2ZWMyKGxMZWZ0LGxUb3ApLXZlYzIobExlZnRMZWZ0LGxUb3BUb3ApKTttYXhEZWx0YT1tYXgobWF4RGVsdGEueHksZGVsdGEuencpO2Zsb2F0IGZpbmFsRGVsdGE9bWF4KG1heERlbHRhLngsbWF4RGVsdGEueSk7ZWRnZXMueHkqPXN0ZXAoZmluYWxEZWx0YSxMT0NBTF9DT05UUkFTVF9BREFQVEFUSU9OX0ZBQ1RPUipkZWx0YS54eSk7Z2xfRnJhZ0NvbG9yPXZlYzQoZWRnZXMsMC4wLDEuMCk7XG4jZWxpZiBFREdFX0RFVEVDVElPTl9NT0RFID09IDJcbnZlYzQgZGVsdGE7dmVjMyBjPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpLnJnYjt2ZWMzIGNMZWZ0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKS5yZ2I7dmVjMyB0PWFicyhjLWNMZWZ0KTtkZWx0YS54PW1heChtYXgodC5yLHQuZyksdC5iKTt2ZWMzIGNUb3A9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpLnJnYjt0PWFicyhjLWNUb3ApO2RlbHRhLnk9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzIgZWRnZXM9c3RlcCh0aHJlc2hvbGQsZGVsdGEueHkpO2lmKGRvdChlZGdlcyx2ZWMyKDEuMCkpPT0wLjApe2Rpc2NhcmQ7fXZlYzMgY1JpZ2h0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKS5yZ2I7dD1hYnMoYy1jUmlnaHQpO2RlbHRhLno9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzMgY0JvdHRvbT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MykucmdiO3Q9YWJzKGMtY0JvdHRvbSk7ZGVsdGEudz1tYXgobWF4KHQucix0LmcpLHQuYik7dmVjMiBtYXhEZWx0YT1tYXgoZGVsdGEueHksZGVsdGEuencpO3ZlYzMgY0xlZnRMZWZ0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY0KS5yZ2I7dD1hYnMoYy1jTGVmdExlZnQpO2RlbHRhLno9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzMgY1RvcFRvcD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NSkucmdiO3Q9YWJzKGMtY1RvcFRvcCk7ZGVsdGEudz1tYXgobWF4KHQucix0LmcpLHQuYik7bWF4RGVsdGE9bWF4KG1heERlbHRhLnh5LGRlbHRhLnp3KTtmbG9hdCBmaW5hbERlbHRhPW1heChtYXhEZWx0YS54LG1heERlbHRhLnkpO2VkZ2VzKj1zdGVwKGZpbmFsRGVsdGEsTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IqZGVsdGEueHkpO2dsX0ZyYWdDb2xvcj12ZWM0KGVkZ2VzLDAuMCwxLjApO1xuI2VuZGlmXG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2VkZ2UtZGV0ZWN0aW9uLnZlcnRcbnZhciBlZGdlX2RldGVjdGlvbl9kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7XG4jaWYgRURHRV9ERVRFQ1RJT05fTU9ERSAhPSAwXG52YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2YXJ5aW5nIHZlYzIgdlV2NDt2YXJ5aW5nIHZlYzIgdlV2NTtcbiNlbmRpZlxudm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dlV2MD12VXYrdGV4ZWxTaXplKnZlYzIoLTEuMCwwLjApO3ZVdjE9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwtMS4wKTtcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFICE9IDBcbnZVdjI9dlV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwwLjApO3ZVdjM9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwxLjApO3ZVdjQ9dlV2K3RleGVsU2l6ZSp2ZWMyKC0yLjAsMC4wKTt2VXY1PXZVdit0ZXhlbFNpemUqdmVjMigwLjAsLTIuMCk7XG4jZW5kaWZcbmdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRWRnZURldGVjdGlvbk1hdGVyaWFsLmpzXG52YXIgRWRnZURldGVjdGlvbk1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDE0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZWRnZSBkZXRlY3Rpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIFRPRE8gUmVtb3ZlIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW3RleGVsU2l6ZV0gLSBUaGUgc2NyZWVuIHRleGVsIHNpemUuXG4gICAqIEBwYXJhbSB7RWRnZURldGVjdGlvbk1vZGV9IFttb2RlPUVkZ2VEZXRlY3Rpb25Nb2RlLkNPTE9SXSAtIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjIxOSgpLCBtb2RlID0gRWRnZURldGVjdGlvbk1vZGUuQ09MT1IpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkVkZ2VEZXRlY3Rpb25NYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBUSFJFRV9SRVZJU0lPTjogUkVWSVNJT04yLnJlcGxhY2UoL1xcRCsvZywgXCJcIiksXG4gICAgICAgIExPQ0FMX0NPTlRSQVNUX0FEQVBUQVRJT05fRkFDVE9SOiBcIjIuMFwiLFxuICAgICAgICBFREdFX1RIUkVTSE9MRDogXCIwLjFcIixcbiAgICAgICAgREVQVEhfVEhSRVNIT0xEOiBcIjAuMDFcIixcbiAgICAgICAgUFJFRElDQVRJT05fTU9ERTogXCIwXCIsXG4gICAgICAgIFBSRURJQ0FUSU9OX1RIUkVTSE9MRDogXCIwLjAxXCIsXG4gICAgICAgIFBSRURJQ0FUSU9OX1NDQUxFOiBcIjIuMFwiLFxuICAgICAgICBQUkVESUNBVElPTl9TVFJFTkdUSDogXCIxLjBcIixcbiAgICAgICAgREVQVEhfUEFDS0lORzogXCIwXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0zNihudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMzYobnVsbCksXG4gICAgICAgIHByZWRpY2F0aW9uQnVmZmVyOiBuZXcgVW5pZm9ybTM2KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMzYodGV4ZWxTaXplKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTMsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBlZGdlX2RldGVjdGlvbl9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBlZGdlX2RldGVjdGlvbl9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1vZGUgPSBtb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nOCkge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAdHlwZSB7RWRnZURldGVjdGlvbk1vZGV9XG4gICAqL1xuICBnZXQgZWRnZURldGVjdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuRURHRV9ERVRFQ1RJT05fTU9ERSk7XG4gIH1cbiAgc2V0IGVkZ2VEZXRlY3Rpb25Nb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkVER0VfREVURUNUSU9OX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvbk1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RWRnZURldGVjdGlvbk1vZGV9IFRoZSBtb2RlLlxuICAgKi9cbiAgZ2V0RWRnZURldGVjdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvbk1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVkZ2UgZGV0ZWN0aW9uIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0VkZ2VEZXRlY3Rpb25Nb2RlfSB2YWx1ZSAtIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKi9cbiAgc2V0RWRnZURldGVjdGlvbk1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25Nb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgZWRnZSBkZXRlY3Rpb24gbW9kZSBpcyBzZXQgdG8gREVQVEguIERlZmF1bHQgaXMgMi4wLlxuICAgKlxuICAgKiBJZiBhIG5laWdoYm9yIGVkZ2UgaGFzIF9mYWN0b3JfIHRpbWVzIGJpZ2dlciBjb250cmFzdCB0aGFuIHRoZSBjdXJyZW50IGVkZ2UsIHRoZSBlZGdlIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyB0byBlbGltaW5hdGUgc3B1cmlvdXMgY3Jvc3NpbmcgZWRnZXMgYW5kIGlzIGJhc2VkIG9uIHRoZSBmYWN0IHRoYXQgaWYgdGhlcmUgaXMgdG9vIG11Y2ggY29udHJhc3QgaW4gYVxuICAgKiBkaXJlY3Rpb24sIHRoZSBwZXJjZXB0dWFsIGNvbnRyYXN0IGluIHRoZSBvdGhlciBuZWlnaGJvcnMgd2lsbCBiZSBoaWRkZW4uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IpO1xuICB9XG4gIHNldCBsb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3Rvcih2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5MT0NBTF9DT05UUkFTVF9BREFQVEFUSU9OX0ZBQ1RPUiA9IHZhbHVlLnRvRml4ZWQoXCI2XCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGZhY3Rvci5cbiAgICovXG4gIGdldExvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgZWRnZSBkZXRlY3Rpb24gbW9kZSBpcyBzZXQgdG8gREVQVEguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3RvciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbG9jYWwgY29udHJhc3QgYWRhcHRhdGlvbiBmYWN0b3IuIERlZmF1bHQgaXMgMi4wLlxuICAgKi9cbiAgc2V0TG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLmxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiB0aHJlc2hvbGQuIFJhbmdlOiBbMC4wLCAwLjVdLlxuICAgKlxuICAgKiBBIGxvd2VyIHZhbHVlIHJlc3VsdHMgaW4gbW9yZSBlZGdlcyBiZWluZyBkZXRlY3RlZCBhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZS5cbiAgICpcbiAgICogRm9yIGx1bWEtIGFuZCBjaHJvbWEtYmFzZWQgZWRnZSBkZXRlY3Rpb24sIDAuMSBpcyBhIHJlYXNvbmFibGUgdmFsdWUgYW5kIGFsbG93cyB0byBjYXRjaCBtb3N0IHZpc2libGUgZWRnZXMuIDAuMDVcbiAgICogaXMgYSByYXRoZXIgb3ZlcmtpbGwgdmFsdWUgdGhhdCBhbGxvd3MgdG8gY2F0Y2ggJ2VtIGFsbC4gRGFya2VyIHNjZW5lcyBtYXkgcmVxdWlyZSBhbiBldmVuIGxvd2VyIHRocmVzaG9sZC5cbiAgICpcbiAgICogSWYgZGVwdGgtYmFzZWQgZWRnZSBkZXRlY3Rpb24gaXMgdXNlZCwgdGhlIHRocmVzaG9sZCB3aWxsIGRlcGVuZCBvbiB0aGUgc2NlbmUgZGVwdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZWRnZURldGVjdGlvblRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5FREdFX1RIUkVTSE9MRCk7XG4gIH1cbiAgc2V0IGVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuRURHRV9USFJFU0hPTEQgPSB2YWx1ZS50b0ZpeGVkKFwiNlwiKTtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfVEhSRVNIT0xEID0gKHZhbHVlICogMC4xKS50b0ZpeGVkKFwiNlwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvblRocmVzaG9sZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB0aHJlc2hvbGQuXG4gICAqL1xuICBnZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC4gUmFuZ2U6IFswLjAsIDAuNV0uXG4gICAqL1xuICBzZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBtb2RlLlxuICAgKlxuICAgKiBQcmVkaWNhdGVkIHRocmVzaG9sZGluZyBhbGxvd3MgdG8gYmV0dGVyIHByZXNlcnZlIHRleHR1cmUgZGV0YWlscyBhbmQgdG8gaW1wcm92ZSBlZGdlIGRldGVjdGlvbiB1c2luZyBhbiBhZGRpdGlvbmFsXG4gICAqIGJ1ZmZlciBzdWNoIGFzIGEgbGlnaHQgYWNjdW11bGF0aW9uIG9yIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1ByZWRpY2F0aW9uTW9kZX1cbiAgICovXG4gIGdldCBwcmVkaWNhdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fTU9ERSk7XG4gIH1cbiAgc2V0IHByZWRpY2F0aW9uTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9NT0RFID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtQcmVkaWNhdGlvbk1vZGV9IFRoZSBtb2RlLlxuICAgKi9cbiAgZ2V0UHJlZGljYXRpb25Nb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uTW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ByZWRpY2F0aW9uTW9kZX0gdmFsdWUgLSBUaGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICovXG4gIHNldFByZWRpY2F0aW9uTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMucHJlZGljYXRpb25Nb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IHByZWRpY2F0aW9uQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5wcmVkaWNhdGlvbkJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgY3VzdG9tIHByZWRpY2F0aW9uIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uQnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgcHJlZGljYXRpb24gYnVmZmVyLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25CdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnByZWRpY2F0aW9uQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJlZGljYXRpb25UaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fVEhSRVNIT0xEKTtcbiAgfVxuICBzZXQgcHJlZGljYXRpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fVEhSRVNIT0xEID0gdmFsdWUudG9GaXhlZChcIjZcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWRpY2F0aW9uIHRocmVzaG9sZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uVGhyZXNob2xkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIGdldFByZWRpY2F0aW9uVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uVGhyZXNob2xkO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVkaWNhdGlvbiB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVkaWNhdGlvblRocmVzaG9sZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgdGhyZXNob2xkLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLnByZWRpY2F0aW9uVGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBzY2FsZS4gUmFuZ2U6IFsxLjAsIDUuMF0uXG4gICAqXG4gICAqIERldGVybWluZXMgaG93IG11Y2ggdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZCBzaG91bGQgYmUgc2NhbGVkIHdoZW4gdXNpbmcgcHJlZGljYXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufFRleHR1cmV8TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByZWRpY2F0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fU0NBTEUpO1xuICB9XG4gIHNldCBwcmVkaWNhdGlvblNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLlBSRURJQ0FUSU9OX1NDQUxFID0gdmFsdWUudG9GaXhlZChcIjZcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWRpY2F0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25TY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZS5cbiAgICovXG4gIGdldFByZWRpY2F0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZGljYXRpb25TY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZGljYXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVkaWNhdGlvblNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS4gUmFuZ2U6IFsxLjAsIDUuMF0uXG4gICAqL1xuICBzZXRQcmVkaWNhdGlvblNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGlvblNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBzdHJlbmd0aC4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIERldGVybWluZXMgaG93IG11Y2ggdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZCBzaG91bGQgYmUgZGVjcmVhc2VkIGxvY2FsbHkgd2hlbiB1c2luZyBwcmVkaWNhdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwcmVkaWNhdGlvblN0cmVuZ3RoKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLlBSRURJQ0FUSU9OX1NUUkVOR1RIKTtcbiAgfVxuICBzZXQgcHJlZGljYXRpb25TdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9TVFJFTkdUSCA9IHZhbHVlLnRvRml4ZWQoXCI2XCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmVkaWNhdGlvbiBzdHJlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uU3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBnZXRQcmVkaWNhdGlvblN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uU3RyZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByZWRpY2F0aW9uIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25TdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3RyZW5ndGguIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25TdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZGljYXRpb25TdHJlbmd0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvU01BQVdlaWdodHNNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTQsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTUsIFVuaWZvcm0gYXMgVW5pZm9ybTM3LCBWZWN0b3IyIGFzIFZlY3RvcjIyMCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvc21hYS13ZWlnaHRzLmZyYWdcbnZhciBzbWFhX3dlaWdodHNfZGVmYXVsdCA9IGAjZGVmaW5lIHNhbXBsZUxldmVsWmVyb09mZnNldCh0LCBjb29yZCwgb2Zmc2V0KSB0ZXh0dXJlMkQodCwgY29vcmQgKyBvZmZzZXQgKiB0ZXhlbFNpemUpXG4jaWYgX19WRVJTSU9OX18gPCAzMDBcbiNkZWZpbmUgcm91bmQodikgZmxvb3IodiArIDAuNSlcbiNlbmRpZlxuI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgYXJlYVRleHR1cmU7dW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBzZWFyY2hUZXh0dXJlO3VuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSB2ZWMyIHJlc29sdXRpb247dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzQgdk9mZnNldFszXTt2YXJ5aW5nIHZlYzIgdlBpeENvb3JkO3ZvaWQgbW92ZWMoY29uc3QgaW4gYnZlYzIgYyxpbm91dCB2ZWMyIHZhcmlhYmxlLGNvbnN0IGluIHZlYzIgdmFsdWUpe2lmKGMueCl7dmFyaWFibGUueD12YWx1ZS54O31pZihjLnkpe3ZhcmlhYmxlLnk9dmFsdWUueTt9fXZvaWQgbW92ZWMoY29uc3QgaW4gYnZlYzQgYyxpbm91dCB2ZWM0IHZhcmlhYmxlLGNvbnN0IGluIHZlYzQgdmFsdWUpe21vdmVjKGMueHksdmFyaWFibGUueHksdmFsdWUueHkpO21vdmVjKGMuencsdmFyaWFibGUuencsdmFsdWUuencpO312ZWMyIGRlY29kZURpYWdCaWxpbmVhckFjY2VzcyhpbiB2ZWMyIGUpe2Uucj1lLnIqYWJzKDUuMCplLnItNS4wKjAuNzUpO3JldHVybiByb3VuZChlKTt9dmVjNCBkZWNvZGVEaWFnQmlsaW5lYXJBY2Nlc3MoaW4gdmVjNCBlKXtlLnJiPWUucmIqYWJzKDUuMCplLnJiLTUuMCowLjc1KTtyZXR1cm4gcm91bmQoZSk7fXZlYzIgc2VhcmNoRGlhZzEoY29uc3QgaW4gdmVjMiB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGRpcixvdXQgdmVjMiBlKXt2ZWM0IGNvb3JkPXZlYzQodGV4Q29vcmQsLTEuMCwxLjApO3ZlYzMgdD12ZWMzKHRleGVsU2l6ZSwxLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKGNvb3JkLno8ZmxvYXQoTUFYX1NFQVJDSF9TVEVQU19ESUFHX0lOVC0xKSYmY29vcmQudz4wLjkpKXticmVhazt9Y29vcmQueHl6PXQqdmVjMyhkaXIsMS4wKStjb29yZC54eXo7ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmQueHkpLnJnO2Nvb3JkLnc9ZG90KGUsdmVjMigwLjUpKTt9cmV0dXJuIGNvb3JkLnp3O312ZWMyIHNlYXJjaERpYWcyKGNvbnN0IGluIHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gdmVjMiBkaXIsb3V0IHZlYzIgZSl7dmVjNCBjb29yZD12ZWM0KHRleENvb3JkLC0xLjAsMS4wKTtjb29yZC54Kz0wLjI1KnRleGVsU2l6ZS54O3ZlYzMgdD12ZWMzKHRleGVsU2l6ZSwxLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKGNvb3JkLno8ZmxvYXQoTUFYX1NFQVJDSF9TVEVQU19ESUFHX0lOVC0xKSYmY29vcmQudz4wLjkpKXticmVhazt9Y29vcmQueHl6PXQqdmVjMyhkaXIsMS4wKStjb29yZC54eXo7ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmQueHkpLnJnO2U9ZGVjb2RlRGlhZ0JpbGluZWFyQWNjZXNzKGUpO2Nvb3JkLnc9ZG90KGUsdmVjMigwLjUpKTt9cmV0dXJuIGNvb3JkLnp3O312ZWMyIGFyZWFEaWFnKGNvbnN0IGluIHZlYzIgZGlzdCxjb25zdCBpbiB2ZWMyIGUsY29uc3QgaW4gZmxvYXQgb2Zmc2V0KXt2ZWMyIHRleENvb3JkPXZlYzIoQVJFQVRFWF9NQVhfRElTVEFOQ0VfRElBRyxBUkVBVEVYX01BWF9ESVNUQU5DRV9ESUFHKSplK2Rpc3Q7dGV4Q29vcmQ9QVJFQVRFWF9QSVhFTF9TSVpFKnRleENvb3JkKzAuNSpBUkVBVEVYX1BJWEVMX1NJWkU7dGV4Q29vcmQueCs9MC41O3RleENvb3JkLnkrPUFSRUFURVhfU1VCVEVYX1NJWkUqb2Zmc2V0O3JldHVybiB0ZXh0dXJlMkQoYXJlYVRleHR1cmUsdGV4Q29vcmQpLnJnO312ZWMyIGNhbGN1bGF0ZURpYWdXZWlnaHRzKGNvbnN0IGluIHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gdmVjMiBlLGNvbnN0IGluIHZlYzQgc3Vic2FtcGxlSW5kaWNlcyl7dmVjMiB3ZWlnaHRzPXZlYzIoMC4wKTt2ZWM0IGQ7dmVjMiBlbmQ7aWYoZS5yPjAuMCl7ZC54ej1zZWFyY2hEaWFnMSh0ZXhDb29yZCx2ZWMyKC0xLjAsMS4wKSxlbmQpO2QueCs9ZmxvYXQoZW5kLnk+MC45KTt9ZWxzZXtkLnh6PXZlYzIoMC4wKTt9ZC55dz1zZWFyY2hEaWFnMSh0ZXhDb29yZCx2ZWMyKDEuMCwtMS4wKSxlbmQpO2lmKGQueCtkLnk+Mi4wKXt2ZWM0IGNvb3Jkcz12ZWM0KC1kLngrMC4yNSxkLngsZC55LC1kLnktMC4yNSkqdGV4ZWxTaXplLnh5eHkrdGV4Q29vcmQueHl4eTt2ZWM0IGM7Yy54eT1zYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsY29vcmRzLnh5LHZlYzIoLTEsMCkpLnJnO2Muenc9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy56dyx2ZWMyKDEsMCkpLnJnO2MueXh3ej1kZWNvZGVEaWFnQmlsaW5lYXJBY2Nlc3MoYy54eXp3KTt2ZWMyIGNjPXZlYzIoMi4wKSpjLnh6K2MueXc7bW92ZWMoYnZlYzIoc3RlcCgwLjksZC56dykpLGNjLHZlYzIoMC4wKSk7d2VpZ2h0cys9YXJlYURpYWcoZC54eSxjYyxzdWJzYW1wbGVJbmRpY2VzLnopO31kLnh6PXNlYXJjaERpYWcyKHRleENvb3JkLHZlYzIoLTEuMCwtMS4wKSxlbmQpO2lmKHNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZCx2ZWMyKDEsMCkpLnI+MC4wKXtkLnl3PXNlYXJjaERpYWcyKHRleENvb3JkLHZlYzIoMS4wKSxlbmQpO2QueSs9ZmxvYXQoZW5kLnk+MC45KTt9ZWxzZXtkLnl3PXZlYzIoMC4wKTt9aWYoZC54K2QueT4yLjApe3ZlYzQgY29vcmRzPXZlYzQoLWQueCwtZC54LGQueSxkLnkpKnRleGVsU2l6ZS54eXh5K3RleENvb3JkLnh5eHk7dmVjNCBjO2MueD1zYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsY29vcmRzLnh5LHZlYzIoLTEsMCkpLmc7Yy55PXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMueHksdmVjMigwLC0xKSkucjtjLnp3PXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMuencsdmVjMigxLDApKS5ncjt2ZWMyIGNjPXZlYzIoMi4wKSpjLnh6K2MueXc7bW92ZWMoYnZlYzIoc3RlcCgwLjksZC56dykpLGNjLHZlYzIoMC4wKSk7d2VpZ2h0cys9YXJlYURpYWcoZC54eSxjYyxzdWJzYW1wbGVJbmRpY2VzLncpLmdyO31yZXR1cm4gd2VpZ2h0czt9ZmxvYXQgc2VhcmNoTGVuZ3RoKGNvbnN0IGluIHZlYzIgZSxjb25zdCBpbiBmbG9hdCBvZmZzZXQpe3ZlYzIgc2NhbGU9U0VBUkNIVEVYX1NJWkUqdmVjMigwLjUsLTEuMCk7dmVjMiBiaWFzPVNFQVJDSFRFWF9TSVpFKnZlYzIob2Zmc2V0LDEuMCk7c2NhbGUrPXZlYzIoLTEuMCwxLjApO2JpYXMrPXZlYzIoMC41LC0wLjUpO3NjYWxlKj0xLjAvU0VBUkNIVEVYX1BBQ0tFRF9TSVpFO2JpYXMqPTEuMC9TRUFSQ0hURVhfUEFDS0VEX1NJWkU7cmV0dXJuIHRleHR1cmUyRChzZWFyY2hUZXh0dXJlLHNjYWxlKmUrYmlhcykucjt9ZmxvYXQgc2VhcmNoWExlZnQoaW4gdmVjMiB0ZXhDb29yZCxjb25zdCBpbiBmbG9hdCBlbmQpe3ZlYzIgZT12ZWMyKDAuMCwxLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKHRleENvb3JkLng+ZW5kJiZlLmc+MC44MjgxJiZlLnI9PTAuMCkpe2JyZWFrO31lPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix0ZXhDb29yZCkucmc7dGV4Q29vcmQ9dmVjMigtMi4wLDAuMCkqdGV4ZWxTaXplK3RleENvb3JkO31mbG9hdCBvZmZzZXQ9LSgyNTUuMC8xMjcuMCkqc2VhcmNoTGVuZ3RoKGUsMC4wKSszLjI1O3JldHVybiB0ZXhlbFNpemUueCpvZmZzZXQrdGV4Q29vcmQueDt9ZmxvYXQgc2VhcmNoWFJpZ2h0KHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gZmxvYXQgZW5kKXt2ZWMyIGU9dmVjMigwLjAsMS4wKTtmb3IoaW50IGk9MDtpPE1BWF9TRUFSQ0hfU1RFUFNfSU5UOysraSl7aWYoISh0ZXhDb29yZC54PGVuZCYmZS5nPjAuODI4MSYmZS5yPT0wLjApKXticmVhazt9ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdGV4Q29vcmQpLnJnO3RleENvb3JkPXZlYzIoMi4wLDAuMCkqdGV4ZWxTaXplLnh5K3RleENvb3JkO31mbG9hdCBvZmZzZXQ9LSgyNTUuMC8xMjcuMCkqc2VhcmNoTGVuZ3RoKGUsMC41KSszLjI1O3JldHVybi10ZXhlbFNpemUueCpvZmZzZXQrdGV4Q29vcmQueDt9ZmxvYXQgc2VhcmNoWVVwKHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gZmxvYXQgZW5kKXt2ZWMyIGU9dmVjMigxLjAsMC4wKTtmb3IoaW50IGk9MDtpPE1BWF9TRUFSQ0hfU1RFUFNfSU5UOysraSl7aWYoISh0ZXhDb29yZC55PmVuZCYmZS5yPjAuODI4MSYmZS5nPT0wLjApKXticmVhazt9ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdGV4Q29vcmQpLnJnO3RleENvb3JkPS12ZWMyKDAuMCwyLjApKnRleGVsU2l6ZS54eSt0ZXhDb29yZDt9ZmxvYXQgb2Zmc2V0PS0oMjU1LjAvMTI3LjApKnNlYXJjaExlbmd0aChlLmdyLDAuMCkrMy4yNTtyZXR1cm4gdGV4ZWxTaXplLnkqb2Zmc2V0K3RleENvb3JkLnk7fWZsb2F0IHNlYXJjaFlEb3duKHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gZmxvYXQgZW5kKXt2ZWMyIGU9dmVjMigxLjAsMC4wKTtmb3IoaW50IGk9MDtpPE1BWF9TRUFSQ0hfU1RFUFNfSU5UO2krKyl7aWYoISh0ZXhDb29yZC55PGVuZCYmZS5yPjAuODI4MSYmZS5nPT0wLjApKXticmVhazt9ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdGV4Q29vcmQpLnJnO3RleENvb3JkPXZlYzIoMC4wLDIuMCkqdGV4ZWxTaXplLnh5K3RleENvb3JkO31mbG9hdCBvZmZzZXQ9LSgyNTUuMC8xMjcuMCkqc2VhcmNoTGVuZ3RoKGUuZ3IsMC41KSszLjI1O3JldHVybi10ZXhlbFNpemUueSpvZmZzZXQrdGV4Q29vcmQueTt9dmVjMiBhcmVhKGNvbnN0IGluIHZlYzIgZGlzdCxjb25zdCBpbiBmbG9hdCBlMSxjb25zdCBpbiBmbG9hdCBlMixjb25zdCBpbiBmbG9hdCBvZmZzZXQpe3ZlYzIgdGV4Q29vcmQ9dmVjMihBUkVBVEVYX01BWF9ESVNUQU5DRSkqcm91bmQoNC4wKnZlYzIoZTEsZTIpKStkaXN0O3RleENvb3JkPUFSRUFURVhfUElYRUxfU0laRSp0ZXhDb29yZCswLjUqQVJFQVRFWF9QSVhFTF9TSVpFO3RleENvb3JkLnk9QVJFQVRFWF9TVUJURVhfU0laRSpvZmZzZXQrdGV4Q29vcmQueTtyZXR1cm4gdGV4dHVyZTJEKGFyZWFUZXh0dXJlLHRleENvb3JkKS5yZzt9dm9pZCBkZXRlY3RIb3Jpem9udGFsQ29ybmVyUGF0dGVybihpbm91dCB2ZWMyIHdlaWdodHMsY29uc3QgaW4gdmVjNCB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGQpe1xuI2lmICFkZWZpbmVkKERJU0FCTEVfQ09STkVSX0RFVEVDVElPTilcbnZlYzIgbGVmdFJpZ2h0PXN0ZXAoZC54eSxkLnl4KTt2ZWMyIHJvdW5kaW5nPSgxLjAtQ09STkVSX1JPVU5ESU5HX05PUk0pKmxlZnRSaWdodDtyb3VuZGluZy89bGVmdFJpZ2h0LngrbGVmdFJpZ2h0Lnk7dmVjMiBmYWN0b3I9dmVjMigxLjApO2ZhY3Rvci54LT1yb3VuZGluZy54KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC54eSx2ZWMyKDAsMSkpLnI7ZmFjdG9yLngtPXJvdW5kaW5nLnkqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnp3LHZlYzIoMSwxKSkucjtmYWN0b3IueS09cm91bmRpbmcueCpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQueHksdmVjMigwLC0yKSkucjtmYWN0b3IueS09cm91bmRpbmcueSpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQuencsdmVjMigxLC0yKSkucjt3ZWlnaHRzKj1jbGFtcChmYWN0b3IsMC4wLDEuMCk7XG4jZW5kaWZcbn12b2lkIGRldGVjdFZlcnRpY2FsQ29ybmVyUGF0dGVybihpbm91dCB2ZWMyIHdlaWdodHMsY29uc3QgaW4gdmVjNCB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGQpe1xuI2lmICFkZWZpbmVkKERJU0FCTEVfQ09STkVSX0RFVEVDVElPTilcbnZlYzIgbGVmdFJpZ2h0PXN0ZXAoZC54eSxkLnl4KTt2ZWMyIHJvdW5kaW5nPSgxLjAtQ09STkVSX1JPVU5ESU5HX05PUk0pKmxlZnRSaWdodDtyb3VuZGluZy89bGVmdFJpZ2h0LngrbGVmdFJpZ2h0Lnk7dmVjMiBmYWN0b3I9dmVjMigxLjApO2ZhY3Rvci54LT1yb3VuZGluZy54KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC54eSx2ZWMyKDEsMCkpLmc7ZmFjdG9yLngtPXJvdW5kaW5nLnkqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnp3LHZlYzIoMSwxKSkuZztmYWN0b3IueS09cm91bmRpbmcueCpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQueHksdmVjMigtMiwwKSkuZztmYWN0b3IueS09cm91bmRpbmcueSpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQuencsdmVjMigtMiwxKSkuZzt3ZWlnaHRzKj1jbGFtcChmYWN0b3IsMC4wLDEuMCk7XG4jZW5kaWZcbn12b2lkIG1haW4oKXt2ZWM0IHdlaWdodHM9dmVjNCgwLjApO3ZlYzQgc3Vic2FtcGxlSW5kaWNlcz12ZWM0KDAuMCk7dmVjMiBlPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpLnJnO2lmKGUuZz4wLjApe1xuI2lmICFkZWZpbmVkKERJU0FCTEVfRElBR19ERVRFQ1RJT04pXG53ZWlnaHRzLnJnPWNhbGN1bGF0ZURpYWdXZWlnaHRzKHZVdixlLHN1YnNhbXBsZUluZGljZXMpO2lmKHdlaWdodHMucj09LXdlaWdodHMuZyl7XG4jZW5kaWZcbnZlYzIgZDt2ZWMzIGNvb3Jkcztjb29yZHMueD1zZWFyY2hYTGVmdCh2T2Zmc2V0WzBdLnh5LHZPZmZzZXRbMl0ueCk7Y29vcmRzLnk9dk9mZnNldFsxXS55O2QueD1jb29yZHMueDtmbG9hdCBlMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzLnh5KS5yO2Nvb3Jkcy56PXNlYXJjaFhSaWdodCh2T2Zmc2V0WzBdLnp3LHZPZmZzZXRbMl0ueSk7ZC55PWNvb3Jkcy56O2Q9cm91bmQocmVzb2x1dGlvbi54eCpkKy12UGl4Q29vcmQueHgpO3ZlYzIgc3FydEQ9c3FydChhYnMoZCkpO2Zsb2F0IGUyPXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMuenksdmVjMigxLDApKS5yO3dlaWdodHMucmc9YXJlYShzcXJ0RCxlMSxlMixzdWJzYW1wbGVJbmRpY2VzLnkpO2Nvb3Jkcy55PXZVdi55O2RldGVjdEhvcml6b250YWxDb3JuZXJQYXR0ZXJuKHdlaWdodHMucmcsY29vcmRzLnh5enksZCk7XG4jaWYgIWRlZmluZWQoRElTQUJMRV9ESUFHX0RFVEVDVElPTilcbn1lbHNle2Uucj0wLjA7fVxuI2VuZGlmXG59aWYoZS5yPjAuMCl7dmVjMiBkO3ZlYzMgY29vcmRzO2Nvb3Jkcy55PXNlYXJjaFlVcCh2T2Zmc2V0WzFdLnh5LHZPZmZzZXRbMl0ueik7Y29vcmRzLng9dk9mZnNldFswXS54O2QueD1jb29yZHMueTtmbG9hdCBlMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzLnh5KS5nO2Nvb3Jkcy56PXNlYXJjaFlEb3duKHZPZmZzZXRbMV0uencsdk9mZnNldFsyXS53KTtkLnk9Y29vcmRzLno7ZD1yb3VuZChyZXNvbHV0aW9uLnl5KmQtdlBpeENvb3JkLnl5KTt2ZWMyIHNxcnREPXNxcnQoYWJzKGQpKTtmbG9hdCBlMj1zYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsY29vcmRzLnh6LHZlYzIoMCwxKSkuZzt3ZWlnaHRzLmJhPWFyZWEoc3FydEQsZTEsZTIsc3Vic2FtcGxlSW5kaWNlcy54KTtjb29yZHMueD12VXYueDtkZXRlY3RWZXJ0aWNhbENvcm5lclBhdHRlcm4od2VpZ2h0cy5iYSxjb29yZHMueHl4eixkKTt9Z2xfRnJhZ0NvbG9yPXdlaWdodHM7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9zbWFhLXdlaWdodHMudmVydFxudmFyIHNtYWFfd2VpZ2h0c19kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gdmVjMiByZXNvbHV0aW9uO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWM0IHZPZmZzZXRbM107dmFyeWluZyB2ZWMyIHZQaXhDb29yZDt2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTt2UGl4Q29vcmQ9dlV2KnJlc29sdXRpb247dk9mZnNldFswXT12VXYueHl4eSt0ZXhlbFNpemUueHl4eSp2ZWM0KC0wLjI1LC0wLjEyNSwxLjI1LC0wLjEyNSk7dk9mZnNldFsxXT12VXYueHl4eSt0ZXhlbFNpemUueHl4eSp2ZWM0KC0wLjEyNSwtMC4yNSwtMC4xMjUsMS4yNSk7dk9mZnNldFsyXT12ZWM0KHZPZmZzZXRbMF0ueHosdk9mZnNldFsxXS55dykrdmVjNCgtMi4wLDIuMCwtMi4wLDIuMCkqdGV4ZWxTaXplLnh4eXkqTUFYX1NFQVJDSF9TVEVQU19GTE9BVDtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1NNQUFXZWlnaHRzTWF0ZXJpYWwuanNcbnZhciBTTUFBV2VpZ2h0c01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDE1IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgU01BQSB3ZWlnaHRzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt0ZXhlbFNpemVdIC0gVGhlIGFic29sdXRlIHNjcmVlbiB0ZXhlbCBzaXplLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtyZXNvbHV0aW9uXSAtIFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjIyMCgpLCByZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIyMCgpKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJTTUFBV2VpZ2h0c01hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIC8vIENvbmZpZ3VyYWJsZSBzZXR0aW5nczpcbiAgICAgICAgTUFYX1NFQVJDSF9TVEVQU19JTlQ6IFwiMTZcIixcbiAgICAgICAgTUFYX1NFQVJDSF9TVEVQU19GTE9BVDogXCIxNi4wXCIsXG4gICAgICAgIE1BWF9TRUFSQ0hfU1RFUFNfRElBR19JTlQ6IFwiOFwiLFxuICAgICAgICBNQVhfU0VBUkNIX1NURVBTX0RJQUdfRkxPQVQ6IFwiOC4wXCIsXG4gICAgICAgIENPUk5FUl9ST1VORElORzogXCIyNVwiLFxuICAgICAgICBDT1JORVJfUk9VTkRJTkdfTk9STTogXCIwLjI1XCIsXG4gICAgICAgIC8vIE5vbi1jb25maWd1cmFibGUgc2V0dGluZ3M6XG4gICAgICAgIEFSRUFURVhfTUFYX0RJU1RBTkNFOiBcIjE2LjBcIixcbiAgICAgICAgQVJFQVRFWF9NQVhfRElTVEFOQ0VfRElBRzogXCIyMC4wXCIsXG4gICAgICAgIEFSRUFURVhfUElYRUxfU0laRTogXCIoMS4wIC8gdmVjMigxNjAuMCwgNTYwLjApKVwiLFxuICAgICAgICBBUkVBVEVYX1NVQlRFWF9TSVpFOiBcIigxLjAgLyA3LjApXCIsXG4gICAgICAgIFNFQVJDSFRFWF9TSVpFOiBcInZlYzIoNjYuMCwgMzMuMClcIixcbiAgICAgICAgU0VBUkNIVEVYX1BBQ0tFRF9TSVpFOiBcInZlYzIoNjQuMCwgMTYuMClcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTM3KG51bGwpLFxuICAgICAgICBzZWFyY2hUZXh0dXJlOiBuZXcgVW5pZm9ybTM3KG51bGwpLFxuICAgICAgICBhcmVhVGV4dHVyZTogbmV3IFVuaWZvcm0zNyhudWxsKSxcbiAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVuaWZvcm0zNyhyZXNvbHV0aW9uKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTM3KHRleGVsU2l6ZSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE0LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogc21hYV93ZWlnaHRzX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHNtYWFfd2VpZ2h0c19kZWZhdWx0MlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlYXJjaCBsb29rdXAgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgc2VhcmNoVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zZWFyY2hUZXh0dXJlLnZhbHVlO1xuICB9XG4gIHNldCBzZWFyY2hUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zZWFyY2hUZXh0dXJlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhcmVhIGxvb2t1cCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBhcmVhVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5hcmVhVGV4dHVyZS52YWx1ZTtcbiAgfVxuICBzZXQgYXJlYVRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmFyZWFUZXh0dXJlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlYXJjaCBhbmQgYXJlYSBsb29rdXAgdGV4dHVyZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWFyY2hUZXh0dXJlIGFuZCBhcmVhVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHNlYXJjaCAtIFRoZSBzZWFyY2ggbG9va3VwIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gYXJlYSAtIFRoZSBhcmVhIGxvb2t1cCB0ZXh0dXJlLlxuICAgKi9cbiAgc2V0TG9va3VwVGV4dHVyZXMoc2VhcmNoLCBhcmVhMikge1xuICAgIHRoaXMuc2VhcmNoVGV4dHVyZSA9IHNlYXJjaDtcbiAgICB0aGlzLmFyZWFUZXh0dXJlID0gYXJlYTI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBzdGVwcyBwZXJmb3JtZWQgaW4gdGhlIGhvcml6b250YWwvdmVydGljYWwgcGF0dGVybiBzZWFyY2hlcywgYXQgZWFjaCBzaWRlIG9mIHRoZSBwaXhlbC5cbiAgICogUmFuZ2U6IFswLCAxMTJdLlxuICAgKlxuICAgKiBJbiBudW1iZXIgb2YgcGl4ZWxzLCBpdCdzIGFjdHVhbGx5IHRoZSBkb3VibGUuIFNvIHRoZSBtYXhpbXVtIGxpbmUgbGVuZ3RoIHBlcmZlY3RseSBoYW5kbGVkIGJ5LCBmb3IgZXhhbXBsZSAxNiwgaXNcbiAgICogNjQgKHBlcmZlY3RseSBtZWFucyB0aGF0IGxvbmdlciBsaW5lcyB3b24ndCBsb29rIGFzIGdvb2QsIGJ1dCBhcmUgc3RpbGwgYW50aWFsaWFzZWQpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9ydGhvZ29uYWxTZWFyY2hTdGVwcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5NQVhfU0VBUkNIX1NURVBTX0lOVCk7XG4gIH1cbiAgc2V0IG9ydGhvZ29uYWxTZWFyY2hTdGVwcyh2YWx1ZSkge1xuICAgIGNvbnN0IHMgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDExMik7XG4gICAgdGhpcy5kZWZpbmVzLk1BWF9TRUFSQ0hfU1RFUFNfSU5UID0gcy50b0ZpeGVkKFwiMFwiKTtcbiAgICB0aGlzLmRlZmluZXMuTUFYX1NFQVJDSF9TVEVQU19GTE9BVCA9IHMudG9GaXhlZChcIjFcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gYW1vdW50IG9mIHN0ZXBzIHBlcmZvcm1lZCBpbiB0aGUgaG9yaXpvbnRhbC92ZXJ0aWNhbCBwYXR0ZXJuIHNlYXJjaGVzLCBhdCBlYWNoIHNpZGUgb2YgdGhlIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3J0aG9nb25hbFNlYXJjaFN0ZXBzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzZWFyY2ggc3RlcHMuIFJhbmdlOiBbMCwgMTEyXS5cbiAgICovXG4gIHNldE9ydGhvZ29uYWxTZWFyY2hTdGVwcyh2YWx1ZSkge1xuICAgIHRoaXMub3J0aG9nb25hbFNlYXJjaFN0ZXBzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHN0ZXBzIHBlcmZvcm1lZCBpbiB0aGUgZGlhZ29uYWwgcGF0dGVybiBzZWFyY2hlcywgYXQgZWFjaCBzaWRlIG9mIHRoZSBwaXhlbC4gVGhpcyBzZWFyY2hcbiAgICoganVtcHMgb25lIHBpeGVsIGF0IGEgdGltZS4gUmFuZ2U6IFswLCAyMF0uXG4gICAqXG4gICAqIE9uIGhpZ2gtZW5kIG1hY2hpbmVzIHRoaXMgc2VhcmNoIGlzIGNoZWFwIChiZXR3ZWVuIDAuOHggYW5kIDAuOXggc2xvd2VyIGZvciAxNiBzdGVwcyksIGJ1dCBpdCBjYW4gaGF2ZSBhXG4gICAqIHNpZ25pZmljYW50IGltcGFjdCBvbiBvbGRlciBtYWNoaW5lcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkaWFnb25hbFNlYXJjaFN0ZXBzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLk1BWF9TRUFSQ0hfU1RFUFNfRElBR19JTlQpO1xuICB9XG4gIHNldCBkaWFnb25hbFNlYXJjaFN0ZXBzKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMjApO1xuICAgIHRoaXMuZGVmaW5lcy5NQVhfU0VBUkNIX1NURVBTX0RJQUdfSU5UID0gcy50b0ZpeGVkKFwiMFwiKTtcbiAgICB0aGlzLmRlZmluZXMuTUFYX1NFQVJDSF9TVEVQU19ESUFHX0ZMT0FUID0gcy50b0ZpeGVkKFwiMVwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBtYXhpbXVtIHN0ZXBzIHBlcmZvcm1lZCBpbiB0aGUgZGlhZ29uYWwgcGF0dGVybiBzZWFyY2hlcywgYXQgZWFjaCBzaWRlIG9mIHRoZSBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRpYWdvbmFsU2VhcmNoU3RlcHMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNlYXJjaCBzdGVwcy4gUmFuZ2U6IFswLCAyMF0uXG4gICAqL1xuICBzZXREaWFnb25hbFNlYXJjaFN0ZXBzKHZhbHVlKSB7XG4gICAgdGhpcy5kaWFnb25hbFNlYXJjaFN0ZXBzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRpYWdvbmFsIHBhdHRlcm4gZGV0ZWN0aW9uIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGRpYWdvbmFsRGV0ZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuRElTQUJMRV9ESUFHX0RFVEVDVElPTiA9PT0gdm9pZCAwO1xuICB9XG4gIHNldCBkaWFnb25hbERldGVjdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5ESVNBQkxFX0RJQUdfREVURUNUSU9OO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZmluZXMuRElTQUJMRV9ESUFHX0RFVEVDVElPTiA9IFwiMVwiO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlhZ29uYWwgcGF0dGVybiBkZXRlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRpYWdvbmFsRGV0ZWN0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgZGlhZ29uYWwgcGF0dGVybiBkZXRlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzRGlhZ29uYWxEZXRlY3Rpb25FbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRpYWdvbmFsRGV0ZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGRpYWdvbmFsIHBhdHRlcm4gZGV0ZWN0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGlhZ29uYWxEZXRlY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgZGlhZ29uYWwgcGF0dGVybiBkZXRlY3Rpb24gc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXREaWFnb25hbERldGVjdGlvbkVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmRpYWdvbmFsRGV0ZWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBob3cgbXVjaCBzaGFycCBjb3JuZXJzIHdpbGwgYmUgcm91bmRlZC4gUmFuZ2U6IFswLCAxMDBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvcm5lclJvdW5kaW5nKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkNPUk5FUl9ST1VORElORyk7XG4gIH1cbiAgc2V0IGNvcm5lclJvdW5kaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgciA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMTAwKTtcbiAgICB0aGlzLmRlZmluZXMuQ09STkVSX1JPVU5ESU5HID0gci50b0ZpeGVkKFwiNFwiKTtcbiAgICB0aGlzLmRlZmluZXMuQ09STkVSX1JPVU5ESU5HX05PUk0gPSAociAvIDEwMCkudG9GaXhlZChcIjRcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBob3cgbXVjaCBzaGFycCBjb3JuZXJzIHdpbGwgYmUgcm91bmRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcm5lclJvdW5kaW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBjb3JuZXIgcm91bmRpbmcgYW1vdW50LiBSYW5nZTogWzAsIDEwMF0uXG4gICAqL1xuICBzZXRDb3JuZXJSb3VuZGluZyh2YWx1ZSkge1xuICAgIHRoaXMuY29ybmVyUm91bmRpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgY29ybmVyIGRldGVjdGlvbiBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvcm5lckRldGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLkRJU0FCTEVfQ09STkVSX0RFVEVDVElPTiA9PT0gdm9pZCAwO1xuICB9XG4gIHNldCBjb3JuZXJEZXRlY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuRElTQUJMRV9DT1JORVJfREVURUNUSU9OO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZmluZXMuRElTQUJMRV9DT1JORVJfREVURUNUSU9OID0gXCIxXCI7XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBjb3JuZXIgcm91bmRpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcm5lckRldGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGNvcm5lciByb3VuZGluZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgaXNDb3JuZXJSb3VuZGluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ybmVyRGV0ZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGNvcm5lciByb3VuZGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcm5lckRldGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBjb3JuZXIgcm91bmRpbmcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRDb3JuZXJSb3VuZGluZ0VuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmNvcm5lckRldGVjdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIHVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgICB1bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvc2VhcmNoSW1hZ2VEYXRhVVJMLmpzXG52YXIgc2VhcmNoSW1hZ2VEYXRhVVJMX2RlZmF1bHQgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRUFBQUFBUUNBWUFBQUNtNTNrcEFBQUFlRWxFUVZSWVIrMlhTd3FBTUF4RUoxNjhlUEVxd1JTS2hJSWl1SGpKcWlVMGdXRSsxQ1FkQXBjVkFNVUF1QVJhTUdDWDFNSUwvT3cxMysrOWxXMnMzbVc5TVd2c25XYy8yZnZHeWd3UEFONEU4UXpBQTRDWEFCNkFIakc0SlRIWUkxZXkzcGN4NkZIbkVmaExET0lCS0FtVUJLNi9BTlVEVGxST1hBSGQ5RUMxQUFBQUFFbEZUa1N1UW1DQ1wiO1xuXG4vLyBzcmMvdGV4dHVyZXMvc21hYS9hcmVhSW1hZ2VEYXRhVVJMLmpzXG52YXIgYXJlYUltYWdlRGF0YVVSTF9kZWZhdWx0ID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUtBQUFBSXdDQVlBQUFBQk5tQkhBQUFnQUVsRVFWUjRYdXk5Q2JobFYxa3RPdmJwcTA5RGtpSWtVQkk2a3hBU0lIMERsQVFpSUsxd1JmU0pUeCtpNEpYN3ZLSWlnczhIWHBYdnFWY3ZyY0M5YWdRN0lEVFNTV2dxQ1FRbGlEUkJKS2traERTa3FWUE5xVk9uUCs4Yi8vckgzUCtlWisxOTl0bHpuVlRsdlZyZnQ3KzFUN09hdWVaWTQyL20zN1FBTEtOazJ3SGcxcElUbEIxN21DK1BwMTFXM1gvTEh5VDMydmhnNDgvNVNPditQbndwc0hBNzBKb0dsdWVCMWlLQXBlcXp2T3puNDRHYXRUQjc2WHpoZDdzdUJSNytXV0FEZ0RFQXd3Q0cvTDU0Yi9wb0RMckh1dnZtNzBaMkF2aHNjK1BWY3hzY0JVOEY4QzhBRGc1K2lwSWpEL1BsR3dmZ2p1OEI5MjRFNXNlQVJVZkxzaU5tcVFXMElqTDgrN0wyTllELzdDT0J6ZmNDbSthQjhTVmdkQWtZSVJDWEt5RGF4NEVkQWFuTDVQdU5QbGxOdlhEbEFId0ZnUDhBY0MyQWhSSW9EWGJzWWI0OGRsNVdrVkZURTNMR0RjQzltNENaQ1dCdUZGZ2VBWmFHQVlKUVFDUnFESFQrTWNKclZiOHp3QVRVWEgwMk1IWWZNSEVJR0ZzQXhnakFwUXFBQ1lRT1JqdGQvQjdBeHQvejc5c0MwK2NNUGdqamx3UHdWd0hjQStEZkFIelR4Y1ZnV0Jyb3FNTjgrY1lCZU03MXdIMFR3S0V4WUhZVVdDSUFIWVJMVGxrQ1lnY0lCY0FnVS9uM3F5OEdSdTRIUmduQU9XQmtFUmhkZFBBSmhHSkRCeGt2dzdjcWltcit6Rk0vWkxuWkY2NGNnTDhCWUQrQVd3Qjh4L2RsV3VXYWdIaVlMOTg0QUovMFJXQnkxQUU0QWl6eU0xeXhZQWNUaWdXNTV4TWJBa3hFaXdFZGtKL1pDUXhQQWlPSGdCRUNjS0VDNFRCWmNLa1N2K21UaWVOY05QTkMyNm1MTnNqNDVRRDhMUURUQU80R2NKdC83aXcyYmZvRzRXRyt2QUd3bTlFeGlFZzY5enBnL3dnd1BRTE1qZ0FMem40RTRhSXpvSmpROWc0MDI0dXlna2orcHl1QW9YMFZBSWZuZ09INU5nQ0hNaEFtOFN2MnkzWERaZUJoTklwOE96SkU4T3NCekFLWUJIQVhnRHQ4LzRPK01WVDBqNGY1OG8wRDhQeHJnZjNEd013SU1FUFFFWVJrTndmZ3N1dURaTHNraXAwTm8wZ1dNRC85SEdEb0FEQWtBQzRBdy93c0FnWkFnczJaMEFCSTBHVTZJVm1LditmMjhLRG5IeGtBL0cwQTh5Nkc3M045a09DalhuaC9FYmI2T3Znd1g3NXhBRjV3TFRBMVZJSFBBRGdNTERqNHlJQTVBQW02YUNVbnY0b3o0NmVlRHd4TkFVTXp3SkF6NEJBQlNOREZUd1NmZzdEREtIRTIzTUc1UHFJWThBMXUvZElOczlkQmR5OEFnbkdQTTJOZlVCcnNudzd6NVJzSDRJWFhBQWNKdmlGZ2x1QWJ5Z0JJTm5TTFdPQWpHeEo0cGdPS0RWMHYvT1NMS3A4aUdYQm92aExCQk9DUU0yQUNvVE9obllyQWRJdFliQ2lqNUpGelJ5SUFxUmNjQW5EQVFVamc2VU5RN2hzTVhQMGNSUUFleHNzM0RzQ0xDRUNDTHdDUXpNY1B3VWkyTXdBU2NBS2JmblkvWVJMRlE4REhYK0lBSkFNU2ZEa0FGMTNrTHZsZUlqaGpRUUh4VVZTM2pqZ0dwS2VlTnpZVlFFamdVUzhrK1BnaE9OZGhJd0FQNCtYWEJZQ0hLSUpid0p5RFRnYUlBZENCSngzUTJNOHRZQUhQOW00ZGYveWxRT3NRMEpxdFJMQ3gzMEsxd3RMQmdnU2NRT2dzS0JHY1dIQUplT3dSQzBCU00xbVFJS1JiaGgrQmo5OEpRUDZ0NFUwQVBFeVhYeGNBRW54a1FBRndvVlV4SUQ5a3ZRZytjMUM3dmlkUmJJRGtjMjRCLy9oVFFHdW1EY0NXQTVEZ014QVNkTklGQlVJNXBDTUw4djhBUEk1emZFUXg0QnVkZ3FpY3p2aVNuSmhRd0NQNEJNQ0dsK3dPOCtVN0FKaS9XNE80WVM2K3BtSy8yY2lBRHNBT0JoVElJaUFKblBCN0F2TmpQKzBBbkFOYVlrQUhYMkpCQWMrdFlhSlhPcUJadjI0VmMzODZYVzVkdGtIR1crNEhGQUpvbnBPZStZWVFaQVNoZ0tqdjNQTnZQUWF4Vm9JOHpKZGZGd0FTZlB6TVV3UzNLdDF2MFVGSWxvczZvREZkQUdGY2xpTUFQL3J5QUVBR053UVJuRE9nTGJkbElFd3JJczZBWi9RZ2tNTUhRRjZaQUtRY0pBc1NZUHdJZUFJazl3SmdvUEsxZ2k3K1B3RjRHQy9mT0FBdklRUFNzMFVSVFBCSi9QcDNHU0VHUkhmQkNJUTB4b3dCdFViY0FqN3lzNVg0SmZ1MUhJQUdRcklnUVJYRXNBRlFJT1JERmhpRFkvck1IbXJVNFFVZ1IwOEFrZ1VqQ0FXNkNENkNrd0JzQUlRQzRHRzZmUE1BM09YaU56Q2cySTlnTkNNa3NtQUFvZW1Eem9pbUZ3TDQ4TTg1QUtraXVRVk1BQXA4Q1lSUkRBdDhHUWlKNjdONkdKT0RBWEFIbHNHZ3VzY0EyQUpnMUlQR1lteE9wQnhGV2tSTjlMc0FUZ0l3WG5Ocy92LzV6LzlYQ2Y4Qk8zWUF0eGJjLzQ2L0tEdCs1K2VhMVlrdTJWVXhIei96MHYyNEZ3TUdLMWdXc0syT1VVeEhIZENCZVJVQjZPeEhBQnI0WklDSUJkMFFXU0YrWFJkTVRBamdDZFRyRzljQk53RTRGOENwRGtJQ3lZTEdzdWhGdDZ6cytnSVN3VWVuOHpFQWpnTXc0Y2Z4Mkg2Ty85MHlBRm84NENiZzRJRDMvOVRmTFR0KzUrZWJuUkFCa09EangwU3dQaTVlYy9GcllwbXFTQXhNOERuNjBDc3FBRkk2R2ZocUFNaURFL2dva212RXIwQzRQZ0RrQlFtNDB3RTh6TUZFVURLRVZveElNTGwvS1M3M21FN0g5ZCt2Y0tIUVFjandXMFl1OW5QOG04c0FtT0lCdVdZNndQMi80czBlempqZzhUdXZhUjZBQko3MHZ4VUFwR3JtN0ViR0UraTQ3MkJBQitXSGZxSFMvZW9BYUV3WTJFOSt3TFNYVHFoSTdDWGduQjZMQ29PSjRCaVNUK2hUbkcwSGNDd0FnbEN4M0FSb1pFVkZYbkJQcC9PL0EvaFhBQ2M3Q1BzOS9pMWxBT3lJQitSRFgrUDkvK3BiUWpqakFNZnYvUEw2QUZEczF3RkFncy85ZmdLZmdkRS9aRXB1aVFsYndBZGU2UUFNQmdpUm1zU3dBOUJZMEpmam92R1JEQk1INFRsY1hHaGNCT2M2SGtGMGdqUGhaZ2NoeFRMWk1BY2kvMDRXL0I2QWIzdDA5RVBYY1B5ZmxnRndSVHdnSjJNTjkvOGJmNXFGTTY3eCtCL2FXNFhRejQyRmVMMFlyUnlpa3p0VUZ3MDcwNG1mOWtYZ3hoT0FxYzNBQXNQeVJ4eFFDcy9QZFhPRlkwVzFLSHkzUUlVR3R4KzZ2ZG54MXZzQitkc1RuY20yQW9nZ2xGZ1ZFQWxVV3JPTUIyUnlFbU1DR1EvWTcvSHZLbnM2dGZHQW5KUStyLzliNzZvSloxekQ4V2R5UWpZQmg4YUJoVkVIakVMb3VROHVrUTdWUlNDSkFBTHdrcitzQUxobkd6REQzSkFKWUpIZzl1aG9pNGJ4OHl0a1dVdHZIVC83K1pjNGR3MXVaMzYxMmZIMmRrUWY3eXhJRUVvY2t3a0pRbjRJUW9xOHVuaEFobVBSS0tGeDB1djRLOHVlVHM5NHdEN3UvL1ZYOWdobjdPUDRjKzRHN2g4SHBzZUIrZEYyQUtsRkx3dUFJWjhqRDZOUHJPaEFmZm1mQTkvWkJ1elpDa3lSV1NlcUJDV3lvWUdRNXlRckJwRGJ1bS9NRTFIb1BvMFhFa1NEMnpsZmJuYThxNitFVUpjVEN4S0V0SEw1RVFqUDZCRVB5SWdZQVpCdll0M3hIeXg3T3F2R0E2NXkvNy85d1ZYQ0dWYzUvc2w3cXhENjZkRXFpWWdSekFxaE4xQTRDQk5BQWxEeUFGSStpWjkvTjNETEp1QytqY0RVQm1DV3lVbk9ybVRZQ01JT2tOY2xMZzBCOC9Sc05MZzkrVXZOam5kMUFQTG1tUXBGSHlFQlJPdVdBQ1FUOG5OK0gvR0F2WTcvVk5uVDZTc2VzTWYxMy9DcGFoR25aemhqaitQUG13WDJNWWRESWZRZXhXeUJBd0VVT1FEclJETi85OHAzQTdkdkFPNmZBQTVzcUhKREJFQXlvVVZHa3dFZDZIUjEyWFU0a3d6Zmw2ZkNYVFp6ank1N3Z2blI1MTNYN0hqN0F5RHZnZ0FVaTlFeUZnaVpxTnhQUUY2MzQ1bk9XYkQxSFEvWTVmcHZ1TGEvMis4Mi92TkhnQVBERlFEbmhvRjVqMkMycUJXQ0k4YncxZVJ3NUNMNWw5NEwzREVPVEk0REI4WTlPV21zRXUvekJKM3Jnc2F5YnFCb2IvN0E0QzdqdFdjb29ScmN6cit1MmZIMkQwQU9RZ0FVQ3hLRVA3YUdnTHk2NCttNktkaldGQTlZYy8wMy9Pc2E0Z2xyanIrQXVwcUh6MXNFczBjeEcwQkM5SEllUExvaXQ5ZU5rVmY5TCtEdVVXQnlESmdhcTR5YkdZTFBBV2dpWG1MZWRVRTdkd0M3c2FMN0NxZlBLWGk0TllkYXlrQ0Q0MTBiQUhsREVzTml3Wjl3QVBZYmtKY2Z6NlQyZ20zTjhZRFo5ZC93SHhVQSs3MzlmUHdYUHJTS1lHYitCdVAzakFGREVsRkg5SElXd2J6Q0lHa0JyL29yNEo0UllPOG9NT1c2WlZjQXV2aTFDZ29oYTA0QkN3VDVnZk1LSG03Tm9SZGUyK3g0MXc1QTNoUVprQURrNStjR2lBZU14MysvN0FFTkZBOFlydi9HNzFjQVhGTTRZemorb3RPQWFRTFFBMGdaeGFJSVp0TURGVGlnS0pWOEg5SXE2YVo1OVpYQXZTUEF2cEVLZ0JUdEJPRGNTQ1dDWmVSWXRwenJtTHllR05DQXlGbDF2K0hlaThxZWIzNzBSZGMyTzk3QkFNaTdFZ0IvMlFHNDFuaEFIVTlMdVdBYk9CN1FyLy9HUFJVQTEzcjdHdjlGWndJTW9WY0Vzd0V3ZkRvaW1FUDBzaEtLdElwaGFaUUFYdjErWU0rd0EzREVkY3ZSS2tHSkFEUVFFc1F1aGkxVGp0OTV2QnNoNW54MklPNTlTc0hEclRtVU9TdE5qbmR3QUFxRXJ5MEl5Q01JQ2tPeWl1SUJOd0J2UEZRUVQ3Z0J1UGpjOW9SWUFJSHlPRUw0dklGRVlWTmFPb3U1dkNHRS90Vi9BMHdPVmNucHpJNDdOT3JpM1FGSUJwU2VhU0RVZFlMT1NXdllJbVNHZ2Z0cEpEYTRNV0piQUd4aXZHVUE1TUFPYzBCZTZlVkxqNy80TWsraHpDT1lQWXBaREJpTmtMaCtHL00zeUZ5di9sdGdMM1czWVFmZ2NGVWhnUlkyUHdZK1o3L0VoQVIxU0Z5WENPYjU3cjI4UWZRQnNKUUJNbjVENHkwSFlMUGplOUNkN1JJQzBQTTNFaU1vZkY0Z1ZDQnAxUDg0MGl4L2d5ejU2cit2QU1qazlHbDM3NWlCNCtDenZldVpkTGtrRVBKOFpFZlgvNlI3M3ZPanpUNVNpOWh1Y0x4SEFWZzRQd0pnUndoOUNLT1hLOFlBNFpFcUtaWFNRV2g1UCs1QWZ0WGZBL3VHS3ZZakNLbjcyY2N0YkZyWk5FQ2thNUw1Q1B3SVB0TUgzVFZ6MTdNTEI1Z2RMZ0EyTmQ2akFDeWNId0xReEZFVVNSNUFTdkFSREIwaDlBUWI5YlhJZ0NHazZsVWZBUFlUZ0VQQUlUS2dnMUJPYms1OHNyVEpnRzU4V01rV01hQWJRUVQxbmM4ckhHQU5BSnNjNzFFQUZzNFBBYWdRZXN0Z0MxbHNCSjRCTUNTT0s2ZERVY3dxcWFGaVFyLzBRZUFBQWRqeStqQmlRUWVlTVNCWlQzbkNQVURJYTl6Ky9NSUIxZ0N3eWZFZUJXRGgvQkNBZVFTemdrakZmR0xCQkQ1bnhRNER4TjB3djNoVnhYNVRCR0R3TDVvYnh2VkE1WXFZTDVCZU1MZDY2WVl4SnBSQjBnSys5NkxDQWRZQXNNbnhIZ1ZnNGZ3SWdNcmhVUEtRMkMrQnowUG1CVHFCTVFlaEFiRGxJamo0RjgwS0pndVNWWjBGdVhwam9DT2dYYXdMakFMaGJUOWVPTUF1QUd4cXZFY0JXRGcvbDFJRTA1RWQweWdabnlIZHowVndDcUVQSWZOeXgwUVF2dkxERlFDcCs4bmZaazV1bmQ4dFh3SWdXY0hTTlgwTjJDSm1uQWwzdjZSd2dObmhsMTdUN0hpUEFyQndmZ2hBUzdtVi9oZXkySlM5RnZNM0JMcFVVaTFZd0RSTVh2a1JZSm9BbEFoMmwwZGNaMDRzNkpVVERJanlCY3JsNHlEYy9kTENBZFlBc01ueEhnVmc0Znh3S1Z3SmdHRUpObVd0eHBRTXBYOW9uMmVSaFZBK081NkFqTWZuUCtlM1h2ZjNOd0c0eElQVGxlaVk1NWJwR2g2VWJhZk5VMGwwejBwKzVKaDVIcVlKNmI1MW5QNlhQOGN4MTJYTkhRVmdJUUIvYkZQVmcyT0M3UStXZ1ZGV25nL0Z2dFdMSTA2dVdoNW9ndUtFY1hWUy85c0VBRi8vVkdEN3Q0RVREZ0piRjRDTmk4Q0daV0JzMmZQTC9INlZ3cDJLRXRWazRmSit2L0VJWVBOOXdLYTVxdStJbmNmUHdYSFZaZS9hT0wzRWJ3Uzd4djhBMXJRdm5PMGo4UEFyVGdUR1o0QnhGdjltSXhoT0NHc3YrME9QWURSZ2hjTGZrV2tFdXEwK0cwMHg0T3RmREd6K2QyRGJIbURMakw4c2k4QVlQLzdDR0lBaUVFTVRHOTJ6WHFTYkgrZDlSMmFBMFhudk8rSmp0aGlJck9WREhIUE9rQnJ6VVFBV0FQc1pwM29QRHBhL1hhZzZFVmtMQksrNXJBbkpDMy9uWWsvQVBENzA0V2lFQVY4T1RId1gyTFFIMkRnRmJKZ0ZOckJoamQ4cjc5ZGVHb0V3c2xsZ05CT3p5OENkandlRzl3QmowOEFJQWNpMkQ2SGFmbXlBazQvWjdTSjcyaEdZUndGWUFNRExUd09HcDRGUkZnRDNIaHpxUkdRaXlldXJxT2RHNnIwUm04SUVaanpSbGtpcUNXb0VnSzhBeG00Qkp1NEhKaHlBYkZoRHhtYkRHblpPNGowU2dMR0RrcGliZ0VxNjZUSncvMW5BMEY1Z2RMcHErekRxRmZkNUxNZVdxdTVITlNUMHVKT0lsbGcrcWdNV2dJK0hQdjB4d0xBM2dXSHBXMnNDNDQxZ0NFQ2JtS3ppYUdyblVkTU80YUhlaDZNeEFQNFNNSEk3TUw0SEdEOEFqSHZISkdOQWdwRGdZL2NrM3N0aXBSZW12VmhjK3VBU01QVUVZR2gvOWRJUmdHeDhZK01OYlIvMDB1VnRIMHdFeDk0ai92MG9BeGFBOEVkK0dCaWVBWVpaZzVrQURDMFFXR09GekdKbGNHUHpsMUJ4TkxYRDhzazR4ZnR3TkFiQS93d00zd0dNVW14T09RQm5IWHpldElZdmlib25tU2l1WVROanJpVmc3Z2xBaXdCazBmTlpINitQbVg5UDZrZk5tQ1hHcGZ0SjdUZ0t3QklBbmxuMTRCQUFZeE1ZbTVDNlJqQ3lDb095cjBxa0QvYytISTBCOERYQThOM0F5Q1F3ZXNEMVZRS0g3RWNBU20xUSt5NENrTjlwVUtpVkY1bkx2eStmQmJUVWQ4UUJhSDFIdk5CUk9pWnZmc05uckY0a2N2UHdwZHNCTEJlVTE4TmY3QUIyM0RwNGVjSEM4b0JnVWxKSmVjTFMrNytXT3BFM2diRStIS3creW9ldkNZa01HS3FQSnJkRUtBUnV0YUZZUnMxZmlFWjB3UDhDRE44TERPOEZScVlxM1cxMHBnS2dmWUxhWUN6b290Z0E2S1hhVEE5MHkzNzRUS0Ixc0Jvenk3N3hIRlo1MzZ1dFJnQW1FYXc2ZzVrVVNGWndTWG5BMzMwcXNPbGZnSE1QRGxaZXNMQThJT2pvTHlwUFdIai8xMUVuQ2lWd2t6N2tBRXh0c0dyYVlVV2RTRFg1VG1zYWdMOEtEQkdBN0JkMzBKc1cwb1dpdm5FT1FOUDd5R1RTQlIxMDFBbFpTVXRHeWZnWkRrQ1dZMUhuSmRjQlZlNjMyNWhUdmVsZzJDUWpaTkR5Z0cvMkFuMGoxd0tuTDZ5OXZHQmhlVUM4cHJROFllSDlYMzlPVlFTYzdNYzZmQ2FLdkFlSGRDSVZmNHlNWUN5blRwWCtuYjk3TkptbFNRYjhyOERRSG05WU9GVVpUS096b1hHaHM2QXhGMEhJZXhjTEJ2V0J1aUhOOHMybmU5OFIzcWM2TDRWeWIyb0JWamZtOU1JRkhiakRDaDZrUE9CYlFvRytvVzhDTzViV1ZsNndzRHdnZnIyMFBHSGgvWC8xaWFFSXVEY0NUSVcvMVE0ckZ2OE9uWWlXM2MrVzJpS3dVaktieWpRTndMMXV1UjZzQUVnRGdxMWJyWE9tVjgxUHhoTkI2RFVEQlNZelFKd0Z0ejYyM1hja3RYMVExVldLYVRGL3paaFZhekJWWUExdFg1TWF6c0d2b2J3ZS9qUXIwTmU2QlRoNXVmL3lnb1hsQWZHNjB2S0VoZmYvclNlMWk0RG5UV0RVQUNZMWd1RlREcUxZZENCdmY2REpZU01ZQVRCZk94MWtMZmoxdjFheEgxMG5RM1NkMEdVa0JuVGZwZW10Qkpnc2VJS1FBSExRY1Z4YTJUbnVNVzBBcXVpNWVzOHhCSWVnVmRWVkU4Vmh6SG5MaDY1V01COUFuK1gxOEs2YUFuMnRPNEVUbDZ2cWJLdVZGeXdzRHdoZXZxZzhZZUg5My9SazcwSkU5MG5vd3haYklKanZTM1dZTlNHVXdHSEpUcFB4d3djYkJ1QnJnUllCZUtBQ243VnRwZFV1L2MwTkp4TzlCSXhjS3U0VFRPRHpia29uUExvYUwwdnlVUVJiMnk4SHNMMWNrZld6TWV1Rmk0MFFlenFpK3lpUGh5dDdGT2pyNi9nQ0Z3Z1A3WGI1dnNzVEZ0Ny9uUVJnNk1HUldtRFJvZXlUbHBndzY4R1JUd2daZ28xZ0dtWEFYNi84ZHRheWxTS1kva295SUQ5Qmh6TUwzcTFnQW9zMkFjT3JaWVNvcS9wSnAxVnRPRFJtOVozTFMvN1dqVmt2WE96RXRPcEt5R3JsQVQrNFNvRytWWTh2QkdDdnkvZFZuckR3L3ZlZTY1TkJKaUFqQklWY0FKUWpPbStEa0NaRWVpR0FNdzZzQXdEWnNKckFkaEZNOXJQR2hkNDkwNENvNW9WdUNaUFY2a0Q0MEVjNis5VzhkQlRCc2ZkYzNua3B2bkI4MmZwMlJQY3M3OWRIZ2I1MUxBOW9mc0RWNnZ1dDUvM1BueGNBbUxWQmlEcWdldkRhSkxrWXJwdVF4emNOd044QVdnSWdSYkI4bG9FQnpYRHdsNGNHaURHZnQ1OFNDT1dHZWRnanZPSitiUHZnUmtpdUErWmp6aG5RUU9pRk5WYmxvYTdsL2ZvczBMZE81UUVOZ0VYbENmczhRYmY3SHlNQTNRVmpZaWhZaExFTmdqWDl5L3F3eFFtUlUvYXNmZDBaY0xVMkNIVkd5dXNKUUxLZlZpOThDUzEyVDVmN2lFQ2tIcHNNa0FoQ0Y4K25zaFdIMkkvalhzT1lPMTQ0R1YvOUFwQUlyUzN2dDRZQ2ZldFFIdEFBMkcrLzRQVzQvMlBQYnpNZ21VTWkyTm9lU0NSeEl0Mi9GdnV4V1VSSVdDWGczNTdnZlRqRUROSUhuVFJYUkNwSDV1Z0t3R2wzSHBNQlhRYzB2NldMWVZtLzVsaW1qMDRyRzc2MksydVlZOWpCa3I5K3JJMDNOTDVaYmN6Uy9kSitMUXlvZ2E0bzc3ZkdBbjBObHdkTUFPeTN2bC9UOTM4S0FjajEyMXo4Qm4rWTllV1FKUno4WTZrTmFnRGgyZXk1RXZ4anhRRDhUV2RBdW5lQ0NPNEFuMXZ3NXZkelFNbWRrdHdxN3BMWlFSK2RNMzQrWnVtQXh2WTFZMDR1cU9BSjZGc0V4emV0bzd6ZkFBWDZHaXdQYUxXUjFscmZyOG43Zi9SbDNRR3ptc2lzKy91TzcxVjlPRmdQMmdwUGhncjdUR1JxUlVUNmR5dnI0YUlzL3BtLzJ6VlVOYkJTdjZHOGU1cEV2MEN2ZWM3UG83K2JUdGpsQlJsa3ZBTUJrRGVReXZzTldLQ3ZvZktBQ1lCcnJlL1gxUDAvb1dFQW5uRkQxWWRqaHRYeFI3M21YMTBGZkNISEU5cFZXY0dBSS9TMGdLc2ZBMnkrdHdyRlp3Nkh4Zi9GMFBrOFJpL2twR1NuTXVEeDVUMGlBQ2dRSGlvbzBOZEFlY0JVSFc2UWRzVjIvY0w3di9DeXFyNWduYzQyQ0NPY2ZYMVZJWi9WOFdlOUlEbVR6Vlh3UERKaVh1S1hQeHREQm1hOCtselA0V0FnS2tQeENVQVBFNHY1R3pFdU1YMFBZSlBMaEI2RkpzYzdNQU1ta1Z4YVlDL0s5Z0crRjErKzhBUTdHd2Jnazc4STdHRnBYZ0l3RmlSWE93YUpaUFViaVIweUNVRFJrK2NIZitZcHdNajlIZ2ZJOENsR1B5dnNTaUgwV1NLUnVZbGl0TGIvekhNL0pPU3M1Qy9ZSUM5Y01RRFpyL2R3eGdPVzlndEdZVUJpMHdBOGwzMDR2RFF2QWNoaWxGYnBJQlFoWjdFanE2WlEwL1loaWw4eTRqODlBeGllOURBc0Q2Rlg5SE9LM1F0Uk9URmt2aU44M2tHNGZlbElZOERDZUxyU2VNRFNmc0VvdkFFQ1VGc1RqSEQrdGNCK3RrRmdjWEt2QlJpcjdxdEZsOW93bU80WHkvMUczYkFGZlByWkhvckZOV0JGd0hqUUFGY3RJZ2hqMmtCYXJ3MDZJZi8rTU05WnFUTjZEZ3NEb2pDZXJqUWVzTFJmTUFwdm9Ha0FXaDhPYi90Z0FQU0tXQ3A4bmdOUXRhZGptVGRsdHZOdm4zcGVGWWhnUVFnaCtpVW1FYVVBVW9YTTF5UkxtV3VGTGFFOVorWElBV0JoUEYxcFBHQnB2MkFVM2tEVEFMendtcW82cXRWaDlrSkVyQXVkQUJpYTM4VEM1d0pnUzJ4SWhBd0JuM3loQnlMNEVoelhmUlh4WXNEVEo0SXZyTk4ySkZNeFpjQnpWbzRjQUJiRzA1WEdBNWIyQzBiaERUUU5RTFpCWUgxQVZzUVNBQVUraW1JMW9iSHlibG5qRy9rSmszVThCSHo4eFZVUUFoblFJbDVDeU5nS0FHcDVMS1NTQ29BeVNoNUpqNzl2VGFnY3hVYUlCZVJOZTc5ZzlncStEWGlnNHdHenkrUE9OZlQ3UldGQTRub0FrR1haVkFoY0Jja0pRZ05nckxpYU5iM3BhSURvMXZISFgrb0E5TFFCaTREeEpjT1VQSlVuVGdVMk5KVXlST3M4aXJHQVJ4UUFDK1BwQ3RzRmQ0MEgvQUVmMGdNUWtMZ2VBQ1Q0MVBpR29MT0txeXJKcTNLL1lhOW1OeXI1RnVzTi91UExQSWVEYThCYyt3M3J0eWw0VkZIYU1aYzNpOVJXQk05amp6Z0FGc2JURmJZTFJtbS9ZQlRlUU5NQXRENGNCS0RYQlRRR2RBQjJNR0JvOFNDTG1FdVMxQUZWQUozQS9OaFB0MFBvQ2NBOGJTREc3NlhJN2F5U2c2Sll1R2ZLd0pIRmdIMEU1QjN1ZU1DZS9ZNEwreFZIQU9aKzlFSGNFZ1Fnd2JlaUVZeDZqd1RkejRxZnU3RWhFSnF4R3FydWYvUm5ISUFFbnhnd0JNMGFDOGFVQVlXTkJSQ21vSWxsNEhUcU8xMjJRY1picmdNV3h0TVZ0Z3Z1T3g2d2E3L2p3aHRvR29EV2g0TUJKMTZXTjRsZnI4QXFJMFRWVjFPMWZhOUJiUXpvdmtBeTRFZCtOZ0NRVVN4WkNGV3ZDT2FPRlJFWHlVd1pPUElBMkdkQTN1R09CNndQYU96K1FQdjVTK01BM09YaU45YWNsZ2hXK2QzSWd1cEJGMnBQcXhjeEdlbkRQeGZTUmgyQVNpS0tpVlAyUGFaU2N2QUtvQTBWRGM2Y09sSUIyR2RBM3VHT0IxelI3N2l3WC9GNkFGQjlPTlNPUVcwZnJBNTBzSUxWY2NrV0p5SURTZ3dQQVZjSmdGYll1WjNGSnZBbEVIYkozSXNnSkxHZWRlQklBK0FBQVhtSE94NndvOTl4WWIvaTlRS2cyaUFJZkRKRUpIcWo0U0V4YkV0eTBna2RoQi82UDlvWmJCWklHaUtZVmI5R0thTjUwbFJIQkxPdmhEeGgvNUVLd0RVRzVCM3VlTUIyUUdNL2dyYjcvNndIQVBOR01BWStHU0dVakM1MlZYMmYyQ0Q0K0hPMGdxa1pmZWdYS2dCYUhrY1d0UzBBV2lpOXhHMUltckxsTjVYUjhMOGZtUUQwNUJWcm1FRU5tcFlTUDlRWCtLSGlxajIvODIrSHFxRFd3bmJCUmZHQVRkekFlZ0d3cnUyRHBScTdNenEyZnBBZjBOcTBSbDJ3Qlh6Z2xaNHlVQVBBbURTVldEQlBIUWpMY2dUcU9aNnpVdmRLSGg0cnVEQ2Vyb3gvRG51N1lxd1hBQzFOSS9RY0VRdUs2V0sva2RnQ1RHQzBQWUFQL0tJRE1CZ2dscStoSWtyT2ZzYUN2aUxTb2ZjSmdKNUFkTTdra1NhQ2ovSHFRS1ZJR3ZENHN3RjhiY0JqbXpqc2FRMkg1RC82YWNCZDl3QUxCNERGV1dCNUFWaGVyTXA0R0tJWUVPcDcrMjZVRjBhU2ZUL3hZdURHN3dEanJJcEFFUnl0WGYydmFqajd1ZXJ5UVhTRmwxMEsvT04zZ0lXRHdDTHZqZkdCOFo1NE8rRWU0dmU2NTEzdUIyUjF5enNxQyt0d2JDOEhjTlZoZkFlYUJ1RFAvVHZ3dFMzQS9lUEFJZllGVmxQcTJISFR1eXVsWkNUbGhiamhFVEY1eXhUUUdnUEdob0hoSVdDNFZTWEdEM24wdExrTUhYSHh1K1l5QitNbFB3RHVaczVLNkZsc2JDemRWTzlEdUtma0hNOEFFa1A3QjhmT2t3RGNEK0I3bnA0MitKa0dPdktkQUw0RTRLOFAwenZRZEVUMGIxNEQzRGdCM0QwQjdCOEhaa2E5V3pyRDg4TjZzRm0rWWNVanJuN0UxWkR2TXRGOURCZ2VBWWFIZ1NHQjBQTkhDRDRCTHdMUnNCeUF5WC9pajAvZERVeHVxbElHNWhpeDdlRmh2TGNPVlVBdHlQU3lkQUZtT1FOZTZFWUdWLzlaRVNpS2dJRWd0YmFEL2dIQUxRQzRvdlk1cjVLd3RqT1UvWGZUQUh6ekx1Q21JZUR1TVdEdktIQndwTW9OMFdRek50QWFZU3MwSzRabE9TQWpHRzlrUGpDQlJ3WjBBQktFQkpleFlBWkVBVTNBN09pMUJlRHltNEVEbmpRMVR3Q0dXTVc4TVhjS2tzMFlPeVpObFFPUWpjZ1lJVUhsbEV6WVEwa3RtK3I2b3o4RzRGNEFYd1h3UmQ4L2tPOUEwd0I4eTY1S21QeGdHSmdjcVlKVEtZcFR2MkNDenlkZFFKUkRPaktpdm4rRGVoOEJGOEJud0J0YUNVQStZWUV5QVU4aCtjNkF6OWdOSEhSbXJnT2dtREEzakhRK2lXdXBDZVVBdk5TckE5SE53cXgrbXVrOW5KVk5nL0NUZnJtYkFQd2JnSzhEK1BjSGtJaWJqb2I1bzEzQTNYeXBXc0FrRzFjUEE5UERGUURaTTFpZDBpMUt4c1dmT3JLbkFGWGxpZkNGRk1NUmNBU2lnT2NzMk1HQUlmRTlpV1hwbFM2T243VWJtUGFVVVRYUXJnc1ZNemNSajVGb2xnMlY1YXlVQTVCV1lLd094S1VhZm5vc1dqY0p3ays3VzVGMkVLdmxFM3hjWGFOWWZpQ1lzR2tBL3NtdXF1ZzZoY2xlQW5BSW1QYk82WXdScE1nakNBVkFtL3lRbUtUdjVoTnNBZi9pN1N5TkJTbDJhOFF2LzQvTTF5RitCWlNZbE5RQ25uVnJwYkMrbVRvQUFDQUFTVVJCVkpjYUk3c09TRVkyTnBhRFhMcXBSK3ZFL09Wa3NEZ0ltZ0dnZ2hIb1lKYlRXYzdvSnRGV2M2NS9jZzJBWXZoMkFMc0IzQXpnVnY5NW5TL2Y0UWRzSWtUOVQzY0JyR3RJVFdaZkM1aHF0UUhJbnNFR1FuM1VERHZFREVZL0lDZjdTeE1PckFnOFQrYzAwSkdrdkhHZDJEQUJVWVpJQU9OekNVRHBwQ0ZoU3VrQ0JzTFFyRnRaZS9JaXhZUXBTeUVvSm9xbnVQV3JWUkF1YlFoODNITmxaQjIzejdqMXl3bWo2Q0lJcVVQeHcyWGV1OWJ4Mmp4MTB3ejRaN3NxVFlaYUREOEVJRHVvRTNoTVZFcGhXZzY2SklwOTBrMHNCeEJjeStpUElJYVQxUnRFc0hTL3lJQXF3K1ZTTlBXUWZlNXRsVkVrOGF1WGdWYTVCVXNFSnVUNXVvbGlBYkU1QUdvdG1JQWpDUG5SOXhERzNUUWVybllBVXVwVGRCR0VGTWY4M09rQXBIRytYbHZUQVB3ZnV5cmdTWk9oYXMzdTZjd1RzVUJWbjJnVHd5Rk1pOHdqSFpBQTFNOWZZR0hEVUxKRDFtOENwYThmUnhEYWQrbCtZa2YvM1hOdmQxMVUrcWlMMzlTeFhldlNzc2hkREZ2Z2JJMU8yQXdBdFJaTVp6VEJSdURGanhlMVhnOFFFSUI4eXlqNXlZSVV4ZlFJa2ZrSVJubUhDTTcxMkpvRzRGc2RnSEhwM0FDb01IMkc2ak00bFd6b1FhclN2d1E2TVNCL3Zwb3JWYUZraCttQ0xscFZSOForZHFEWkxvRE9wSFNpUWVBRkRrQmpQcmxnQ0hnQ1VhRmlmZzY3SC85dVlqbjRBaTF2cFRFUlRBQVNCYW9RSkJBS2VOcUhsTDZtd1BEWllBT1JPYWcvRVlSa1BYMzRNd0hJdnpXOXJRY0ErVExwSTIyRzdFY1FLbEpHc1lJSmhDNkNsVU1pWGZCVGJGVVFBZWo2blBTL091QWw5cE9PcUljMkJMemcrKzNWbVdnSUVVejgyY1J1Q0F0TElIUVFtMGdPNTJ1T0FiMjJzQzNKRVdnUmZQcFpmMnNRQlFJZ0x5ZFBFSUZHd1BFajhNbEYyYlNic3VsZ2hMZnRxc0NYcTlIR2dIeXN6bnJHZ2k1cXpUVVRGSDhGTGhBVW4zaElKd0NOMEhMbmN3MzdxYUYyem9ZdnVLTml2bVFJdVVOYzdHdld0NnNITnMyNnR3QTZ2aHlxOE5FTUFIbHludEZyRENjUWVoeWFQVGwrRndBYlhEY21BS01SVGhha0VrOFE4a1BnOFNQTDBxekxCbCtBOVFDZ1I2dVpHczN2Zkh6OFR0Qlp2a2dHUXJFUEJWQVVnMlNpajUwUUFPamlWS0kzc2FBREpSbTdkU0xZV2ZTRkRrQ2VtL2RoWmVNeTlwUFk1UXZTRFlReVVKb0RJSzhxTWV6aDN3WTZmU0w0OVBjR2dDQUE4cFNjSkxJZ0FVWVFFbXo4UlBBMTdTdHZHb0J2MzlXMjRlUkVpQm9OUVNnV05JMUhCa2RneEpTdzFBSStkRkliZ09ZbWtqaW1RMXI2WFhDM3JBYkNIeWNBZ3l0b2hmOHZzQi9yMktSYVJxN3pwWitEMzdITVgwczNERGNDVUdMWWF3NTNNSjRZVU9EenVzcWxHQ1FBT1FDZWp1eEE4VVVMVWt4SXdBbU1BcDhXYTNxa04vUjlXK3NCd09oSUVQams1U0xyOEhlS0ZiVFFmYjc3Y3NQSU1IR2wvNE1QYlJlc2xQaE5lNCtNaVRwaTlBRkdWNG5JN01mdmFnTlFMaC9wZnJZbkRBUzhhSlE0MkEydzRlbTJjQXlXUVV1SlZRVEdXTHMxdUw3REc5SjFSamhBK2p2WWs0dDNLWGVNcWlqcHpydWQ0QXQ5ejNYdFAxNnlHZmpLWm1DR29vWWgxdFp6dnY4eFhQRmw0UG9KWUM5N2s5Rmx3WldEK0F6aS9kZU1aV2VQMTNlUUNHRXlvRVJ1ZENoSWpiYjNtSll3SDdWMFFJS3VDd2ovZ2ZNajBhc24ySTBGWFJTSFhmTC9pUmtOZ0x5ZVZqOGNjTVkvL0oxZnl4elRBWFQyK3hvUVZpS1lELzFoRHFMeFBpWXhUZ1N2UXJwaHBoRzk3dHo0U2xxYWZuajd1azFrSVFEWnJ2V1R3OEIzandFVytSTHhQZ1NpQ0VSZFB3UFI3K3dDUGcvZ3VsRmdmcnVEa09NUWtGYzV4ODRlNzA4SkFNbUN1Uk5CWGk0VElnNUNHUnpHaUJHRS9ENEUvQzJyMnZjQVlKb2lmeTYyaTBhSlNNaEIrMklIb053dTBma2NqUTg1cHUzYWNrNW5JQlJFcW5lWUZ5V0xrQVhJSkhFU2UwMEN5eDVReWVMNkYvdHlFY0Rjck9XMm43Zlg4ZGYwbU1FKy92US9QUWpob3kzZ3pvM0FJU1lmODBNUWFReDFwZUg5d2I3djJtcnRtQ0JrSU1NZWpwM2pJSkQxTXNheGFNWjh2NU4vNjdJTkFzQjNCQVlVNEpMNERTbzFKMTVBRlBBRXd1UUhaSnprS2ZVQXRPSExKU09RUlduZEJZUXZDUUEwMWNmbk5vcGZzYUNKYUQyYmFCbjc5UWpTVGlPRVAxRWNhd0lwa3Eya2VnQlROZ0hXRXBPS0Y4VXdxMk5SRlBNNEFxQ2Y0Ni9yQTJVOS91VkR2dXJCMDF6dkFKcGlpd09sM2ZFZWNpQ0dGK0lqMTFmK1FrYlNmTVBmSXpxdzU3bUVGWjlEbDNQczVIWFdBWUJ5SEpBSktWN04rczBjQ1FRaHdTbGZtNGxHWjBLQjhDL3JBQmdaVVM2WkhJVEJTRWhDb3dVWUFBa3NGN2NTdFdSRXl4Und0dVBwT2xndys1czlzcTZPYUlKSUlsVWdFaEExZWRvVGdIeGE5SFZ3NWppYlpORitqLzl5R1FBLzdwYnVqWjRid3YyK2NXQjZ0Rm8wTnpZbmt4RkErY3ZFQW80M1ZCb0VvMmUrNDhFTVhFT21EOUY2eGhDRThSd1pFSjgwVmJsS3ZEbG16d2ljZnF5OTMvbys4SzhUd0IyalZTZ1cxMzhGckpRVFhCTmxuSmdtcmpad2Fub3c5Q0JQL3JMOXdGMGp3QUdXRHRGeW9OOVBIdXRuSUhUMDVtUFh6OTNkTUdRQVBuaUpzamlCWGlUYnhEWkZNRjlOTFVQUXhLUjVxZXp6MVk2L1laREgwRDZHa2RBa1lKSXZSYWxBZEhBTW1QWm9ZaGI2TmhEV3ZFeWYvbWE3MzdDWE43UjFaQzdoVWJQZ2NGZ3F0L1paakFEbk0xeHFFVmhZQnBiNENVazVVc0w3alF2ai8vLzVidURyTGVDT0VlRCtZUWNoWXdHOVZJZnlnMU5hWnN6RmlDSDZEa1JHTHplNS9kZ2s4SU1XY01DamRDaUN6UjhvZDFCOE9Ud3ZKTThKRVNoRnV0MWZ6TWhpK2VSSnI2TEk3aFlQMk0veFZMd0tOb1pqVVR3Uk1BUVFtWXloV0dReHNTQURPZmxaNGt1a2o3UGhaNzViRVRqQnBrQUdhaE1rY3JHZ3doc1hlQ3lCSEJqMXdtT0JRd3ZBd3FLem9GZVJWOFphZXJqS1lBdWlybVBZL285WDdxNUN5cjdmQXZZTUFmdENQR0FFb1lsQmlWdEZ3TGp0cDJVNGlyajd5T0FOYmkrY3JIeXJmQ2JUcXVKVjQ0TzBGMUZyd1FHSU1aRnFkUUR5UC9nR1NaOFRDMFpSUnNPbFZ6emdhc2QvdSt6cE1CeUxlaEFmQ2dNUUNEeUdaSkhGQ0NnTFoyZjhtZ0k1cWF1RWNWeDllNXZBQ1RnQ1R3RU1XcjVUZElwV0tKYjVNdnJub29jRHN3dkFQQUc0VkxHZzZVS2VxbWk0aXVEejRlcjMwb1gwRlA3dTVtb012SWY3VzhCK2p3bFVOQXpGbmxaQ0lodkdGUkNlV3pyZ1hTU0lCcmVYVEZaU2dWTEhBcDRVSE9GdW9jaUVFc24yUEp3bC9YRWswZHpmU29qZWVyRmcxSU9vNUJLQXZlSUJleDFQNjdsZ1V6Z1dRYUp3TEFLUkgwNGkxNEl0Z0RLRXRHc1JuV3g0OWIyVmtrOXdVZWZUR3JLQ0Y3UjBKeFpNcXhOOGNtUEF4V2NBY3hHQUJLRUFLUEE1dTlsRWFBYkNtS01JK3NETjFYM3orcm8yNHdFWkZjMFZFRTY0QUJnVDE4MFBGOVpkQmNEYjZKcHFjUHRQaysxQUNibUtqSm5sbHd5dUlMdW5FQVdqWkhrQnNyc1JVbmZEMHFFaUM1SUpmeWlzZ01oeldoY1AyTzE0Um80V2JBU2dBTVFKNDhTSndjaG1CQ0RGYThxcHlCYlNQN092VTRQUTBwMlc3K0xTblNKVUZPckk0Vjd3NUlvQlRRUVRmSjZvVFNZazJtUWNwR1J5SDJzeUdqSUY2RU0zVi9mTSsrQzFDZndVRXhoQ3NtekNhUVQ0M2xaQzNlMWhCcEVIaDM2WEVxckI3U2NtcTVkVjBYWnhtVjhXdURGekFGOWl3aG93OXNlQUdvQmNHdEtqcUFjKzFsOXJMYi8xaWdlc081NXlzbUNyQzhlaTZJeFJNQUtUV05CaTZYdzk4eE5URlVpMGpFY21wWWdSQVBoZGRwVmk5T0lFUFA1Y1lENENjTGtDb29IUHdhVzlrVitpd1dyUUhUOHVBMWZkM0Y3REZ2Z1VIVVAyazhqVGlvZ0FxTG94RnBEZ2JNajlqWFN1TjdpOWRMSWRheHpCcDVYVkJNSU1nRkVuRkFQS1Q5cVBkNkE5QklHSTdNZlBtZjRVKzQwSHpJOG5XZ3EyUEJ4TDRGRWtqS0ppeEdSUkZ5UVFQenpkMWlBVXpDQVFhczFZT21BRW9GandrZWNEQy9QQXdoS3c2Q3hJa0NYd09kVkpMeFRvYk1qQmR5SWdmdmltTnZOSjdFdmY0ald0ZG5SWUQxWU5HVnVHOTNWV3VXczRKZittbFpDQ1p4d1AvY25KNm1YVktrMit0SzhsUVFWSFJUR2M2NFNEQVpCM0V5M0pjeHlBQ2tUb0p4NHdIbCtZd3Fsb0dESUNtWW1URmdNUUZCRVQ4eXlZenlBRy9BZldYOG1DR1FnMEJUUm9Id3Q5S1ZhUEUvSFE4OTBBSWZnV0srQ1JBYU1SWW5WZHhIYmhkWThXc2x3MVY5M1VEc21QSWo5R3hnaUFpb1JSTUlKTnZvdGkrU1cvSWtkMGd3QVU4K1h4SmNiR0lUSlBEdkk2WGRDRlJFRlNrblRCODN4a2E0MEgxUEdGOWRueWNDeEZ3eWdrSzBiQVNKUVNWQWJBWWVEOTh4VUFlNVUzaktJd0Jvc1NnTnN1QUJZb2dsMy9Jd2dGUHJPSWcxWGM0WnJwQXNTcnZydXlrbDJ1Y3lrYXBrTU1oNENFeEQ1RHdKZldBWUF4d2s0TUtQQUpnT0lqR1NFR3d1Q2FrUmhlbXc2WXYwVVV3UmY3TDAwTDlwbnNOeDZReDRmZVk0TzhwREVjaXhPanNvVEtLcE1ZalNGWVlqT0M4RXEzV25ucjBZWVMrMFRtaTJIeXNyUEdMcXdBU05ZekJuVDJNejJRRDkxbGF4TEIwZ3MxMkdBaDgxY2Yvby9PY0h5SitxajBTL3p4bmhVWmJTeVlXYUw4K1JxMlMyOXdvd2lXa0pQYW40TXZnckRER0FsUmU3S0l5d0RJZ1IzbWVFRFdnOUhiSmdBcE5Ua1hvOG8waTdvVmd4bkVnRnI4RjdqRWRuVTVHdnFmSlFLUUt5RU9QbHNOSVF2eXZ1cEFHSFMvT2t2NHF2OW9oK1BIeE1MazhnZ0JDUnh2QW1FTitBaUV6ejJpUWZRQmVObWtoNEs1MmhKQktPYU5lL0ZTTG9iTFJYQ3o0M3JRbnUyeWk5b01TTUR4czJqbzgzMDNFUnoxd3NDR1pFQ0Y0a2QzRHdFWVl3Smpob05sUXJnSWpsWW9kYkJQcndNQVpmRW15emNJdjI3Z3M2WER6Qy9JUjFET2dBOWE2RFJ6NHdaQXNaK0xZWHZRWXNIb0Q0emlPRmtsbmE2WUQzK25uVTZkWjdiR0RBY0JVSW1JQW1FVXcvemJKMWkvc2NHTkRKaUxYbWxlM1JoUStsL2FxNTdnVVFDV3p3d0JLUGVMc1ovTEZyR2cvU2hSWEFlNjRBamt2MzBrQUxBakY4UjExRHkzSzdLUndKY3NVVGFxV1NjQVJvdTN3L0lOVm5DSCtBMzZuOFJ2TTNuQjVYUDRvRDZEQVRCWXdHYjVhamxPTE9oNlg4SmFCS1JHNzcrN3lnR1lwMWJuK1YyNS8wMUF6Qm53UTF5cGFuRDdLV2ZBMVFEWUMzekpJajdLZ09VemM5bkZiZXRYL3IrTzViaXdOaHlYNXVTRURyNW8weHNKd0xwOC9tNEE3R2FKVXYvajMvNStIUUZZSjNvRlBQa2hvL2hOZXFCY01rY0IyQkFBNlhyeG1NQmtmRkFjaS9tMEpwd3pYdzBUWHZYdHpyeitQS2MvTWwvdWd6TTlNRHFDQWJ6L2tlVmpqR2NRQS9ZTHZqb2d1bzFtUnNsUkk2Undmc2lBNW5xaEw1RDZuc2NGOGdmVGRmeHBTKy9oTHp2V2Z6TVFDb0IxRnEvOGIzVldhUElEWnFzUlY2NERBTHNaSFZIczFnRXZzcUZBZUJTQXBRQzhwSEs5ME9xbDRVRUF5dkN3TmVHY0JYTkxPUE1MZnRnWnNJNzVvdVVyOW91c3AyVEV5SUovc1U0QXpDMWUrV0lGc2h5QUhQWlJFVndJdHJyRDN3R0FoaWJUWUJoeFZwZS94ZVB5ck5CdVdhb05wM0RnRndDODFPK1JBZXBLL2E1TGZlNTFqeHI3SndBODNuUFhZZ3ExYXNsMHlYNU40OCtmNFZFR0xBVGxLMXZBbzVZQjFnQlNSbXNNK05GRTU3bGNmUEQ1cFBGV0NKSW10eXZHZ0dmT0FhY0JZTzU5ekZnbGdIZ1BlZlpzWFY2L2dQWEJZZUMwUlZneUpOT0dZdUpqUGthOWVIV2dqTDliV3poV2swL24vd1BuK2s4YmdGTm1nWWNzVmZsWm5CUm1JU2h0Sk0vbTdKR2liR0JvT0lJZXo5d0tQUDRBY05weWxmYk5sR2ZkSSs5TmpCano4SlZ6cHBja1p1SitkQnc0YVE0NGRyazZqMUxJWTlKa1BEN1A0czJsd1ZFR0xId0pubmNzY05JaDROaDVZTXNTc0htNW5kT3UxQkdGVGhKOC9LNkpyWnRvc2xTVDIrWEhBNmZ0QjA1WkFFNWNyZ0F1cHM1VGZhTDZFRitVeUlpZjNnQWNPd3RzWGVwODJlSVlZOUprWHBNZ01wL0FlWlFCQzJiOE9kdUJZdzhDMithQUxRdkFSZ0p3R1poWTdzd0V6Yk5hODhJUnZBVk8xcWtGOTFKMzZETk9CRTdlRDJ5ZkI0NWZxcGhMbmV2emRHZUJLQmZMOFVYNS9DWmd5eXl3ZVJIWXNGd3hZSHpSTks2b2V0U0JNRExqVVFBV1RQcVBuZ3BzblFLMnpnS2JDTUFsWU1NU01FNEFMcmNuUjZKWVFJd3NvVW5qcERSc3RPTHk3Y0JKQjRDSFVHd3VBdHVXMm5VRFZIMUVGVWh5Y1N3V2pHRDY0bVpnMHh5d2NhRUNvSTB6NVAzWDVQNm5XbEhkZ0hnVWdBVUFmT1lPWU10QllOTXNzSEVlMkxnSVRCQ0FEa0l6U0paWHBDT25JZzI1dVByaGdudXBPL1R5aHdMSEh3U09td1cyTFZTaWsycENyRHNRc2t6TklCR0lwQmRHSStWZk5nTWI1b0VOQ3hYNHlQUmpQajR4YUowK1dHZUVIUlhCRFV6Mk14NEZiRG9JYkp5cEFEaXhVQUZ3ekFGSThLVUpDaE1WMlNVYUFHYzFjRS94RkplZjNGWVJ0aTY0bmtxV0RycXFFaGJyc201enZaQ2RQQ2Q4bkh6Sk9MWnVBQlJ6OWhUSFp3UEw3TG5Mbm9OTUlZMlZ5YUtjanRaTEhPQWJOZ05QbmdLZTRCYWNmR0YxcG55ZEQraHBoUS84WFY1VWlFdWVMR25ETjF0V1hqLzMvNGNUd0FVendHUGNSY0ZKaURwUHQzRkxtZjV2andFMkhBUTJ6UHJFekR2N09RZzVPU00rU2NZUXk1WGJvODQ2NXUvWmZMVEo3ZktIQWR1bUt4Vmg4d0t3ZWFsU0U2aW5Fb1N5Mk1XQ2RiVUhJZ2h2M0FxTXp3SGppOVZMWnVEekQ4Y1h4eFdaczVjN2FwbVcwZk1CbklIS241WDdkNkk1bnB2Uno5NE83TGdYdUdJUmVKU2IrWGwxdHpxZmx5YndSd3FmOWk5N0JRUldvbVdKUTdvWlZGdEpvcURYL2Ivb0dPRHN2Y0JUQVRCOWdzZkdxbXpkanRWeitHK1BBeWFtZ1ltWkNvRGpGRTJhbkNWZzFDZUp3T01uVFJCL0RtVUlOVmtrZ2lhM3kwOEJ0a3dEVytZcUFGSkZNRDFWQUF3NlhHNjFSMzFPOS9mZHJjRFlQRERtWTB6amMxVWppdkJ1QU14MVFkTUIrV0FZWFU4ZGhFVTE2ZE9Ta3BwYmNIRlNybmc4TUh3bnNHTVBjTjV5cFVSSHAyeE1JYTd6RHoyejhHbi9rVmUwWW9tTzB3RXdCWUt1akw3di96SEE2QzNBeGZPVmg1OGc1QXNaeHg0ZlpNN3NmM2g2QmNEeFdXZUdCWitjTUVGaXdHRUhIUm5EenVuN09OSHMvZGprUmdCdW5xbDBWRE9TSElEVTNjeFNENGFFYWpoRlhTNEg0UzFiZ1ZHTjBWOHdlN0UwRmg5alZERzZPYnIxTEpNUnduK2tPQ2FURVlUMGRzZnFaSFhsL3A3UHJMaTl3SVk3Z08wSDJ5QWdDQVdDV0Nvd0tyWUU4bk1Mbi9hN1BRbjlYN3pJSlBQa0NjSys3NTh5N3g3Z3VOc0I2bDk4Z1pqTExZZXQzQXk1bjBzdjRSK2ZDWXhQQTJNT3dMRUFRTElEUHlQOHVCZzJjUlltekZ3ZUFZaWxLa24rT0M4L0ZkaDBDTmhFQTRuR0E0MGtkNkZFUzEzV0xPOHYxcUhLQWZoOUIrRG9ZalUyQWsvanMvOE5BSXdnN09VYjdMQ0MrV0FmQjRDcEJKb0lpVFJOUm1TMWwxM2txV2gzQWR2MkE4Y2RxcXAxTUIrYUlPU3hXdjZwcTVEMmtrSUF2dDhyRjdCTEprc04vak1xZmE3dis3L0FrNEIzQTZjZXFwYXNLTXE1YWtBbWxMV1kzN3Q4Wlc5N1BEQjJxQUxnMkJ4Z0FGd0FORUdjbkk1SmNyRFpSUGxrYVhMNHUxS0pVQWZBamJUUTU5eDZkU3ZkTFBYQWdHWXNoWldSNkpJUmFYQi9Od0ZJOEMxV3dMTVh6TWVTd0xmY1h1S3JBMkcrd3JMQ0RjTi9JSWc0RVJSbjBxdnl5U0FRWDZtRzFYdUE0ZnVBYlRPVndrdFJScjJNTENvUXl2RVovVVkvV3dqQWozanRGSlprVTc5ZzFnaGtnRUJmOTgrMFVtYi8zQTJNM2xrQmwvZk9jZE1vazJFamtaeXY4NzczTEFmZ0hEREtqd053eEVVdzl5YWlscHdkeEJBRVloQmJBdUd6RzNhS2tRRUp3QWtDa09DamxiN1k2U1l5ZjJVd2xBUyt2S1luQVhqZk5tREVYN0RFZkE1Q2pVY3NuenZidTFuRHRVTW1DRGtSWkVFeUdkbEFrNkc2bFFUU2E2bTBNUDZIdVk3M0F4TlRsY0pMWjZXT0pZQzUvQ054THBITWdkS0lLTmw2OVF2dTYvNzVBakhPaVRVODdnS09PVmlKYjc0OEJLQ1dybksvbWFUQSs1OEFqTTBBbzdQQTZMeC94QkF1cG9ZREM5b2tCUkFtUGRCWjQ3bE5BL0Rod01Sc3hYN21QZ2wrU3JtSzVFYVJOUnNsWEZROUNLQjlEa0FEbjc5Y1p0a0hGa3lzSjEwM2VCYnFsaDk3RHBtVFFUWWdrOVZOeHUreFliWEtVM2xoRm9KUE9nZEZHWStsUGtnUXhva2tnRjlYZ2o0QXZmb0ZzODRlWDRLZTl4OWZJQyt0UmZEeHZ2bmlpZjM1OHNTaXIyTENqNXdOakJLQWM4Q0lpMkF4eExDeklBR1k5TDdBaEdJS2dwQVR3NGw4d1RvQjBKalByZlRrcCtTTFFiSHJPcW01ak55YWpTNlZDTUlwQXBEQVd3UTRMckdnWHF6SWZucTVjdjB2TjBaWEhUSW5NRTVHQk5MYjFER2RPWVFzSTdBZkdLRmpsZ3F2ZTh3SndHNFQrZnVGQUZ5dFh6Q0xiK1ZnV25IL2ZJR1lmYzQ2SHM3aUhDOFprUGNkWHg0VmZWWEp3OCtjQTR3SWdNNkFIU0xLV1pDVEVTZkxmZzdXc0l5UkYzY2tpUlErSEFDWGt3SHB0eVA0S0hycEp2S1ZHbk9oUkY5ZUJGOXdFMG1VRW9nejJ3QytXR0kvdlZ4aVFRSXhBczkrcm1IQTZFMVlGWUI4REp3UU1abDBPckxaKytpN3NmVDh6cm9ZSExTOWRmNFJBQ1dLeFNadkxYekcvZlFMWnFrMmdxbjIvdlVDVVE5VVphTTl3RGFQZVNQckM0QTVDMUtWK05JVEt3Q1MvU2lDUi9qUkJEbExtUDduSHluc3hubzFJUHdKU3lScGJpTUFEWHp1UERZZlpmQlRFb0FtY3VWUWRpYVcwendYd1FzQ1lEWW1NYURBMXdHOFRCU3Zhb1IwRzc3RWNHU0VUNmhqT3ZWQXBmUlBBVU4wempyNDVKelZjU3FpVHhEK1ZlR3pYa3UvNE5yN0p3REpPa3hGSXd0Nmo2K1JxVXJsa080Ylh6cDFnQ0FBdjA0QXpnTEREc0JoS3VnTEZVdlFVaFR3Q0VLYm5LQ3cxNEh3SjljRGdHUTlXZWdSZ0RJOFhFY1ZFRHZBbDdsVmxnbEFnaStJNENSK1pmMW1MR2dNbURGaEJHRmZEQ2ljUkpGRVJ2aVNBQmpMUzdGQzBNRktNVSswN3dPUEUwa0d2YW9RZ0d2dEY5ejEvaU9Ea3duM1ZXb0VYeHJlczVpYjl4eDF3WnVmQkF3TGdBUWV4YkFEMEppUXdKT3VKQkE2OC9IM1poazYrM0NpZnFxd1dOTUtOOHdqS2diazZnV0pnQytGTWFCYjV2SlZtc1ViVjJ2Q3FvM2NSV1pjQ0lBQ29heDUzK3Vsa3FOZDdpcU9jVTFXY0M5Y3hFbTVrUUJVZForc1RuU0wvakV0VFduZ2kyMWpoSk5KQml2WkJ1a1h2T0wreVlCa2NPcXhLako0QUdneHpNckJWd2RBTW1IclpPQVlGMmw2eS9td1Y2eEQxN3ptV282TWJSeWVXdE9Id3hKOTFJSWhyNnJxWlM3MERQUExYRFZVcmZCd3pIS3IxRVVwNi9oMFQvNkwvR2NDcXNsdDRJaG9UY3dkQXFEU3M3STYwV1FINlIzMjlwSHVGeXVYREptRWp1T1NiZEIrd1N2dVA1YkdVam1zQTVYb1V2Y3ZCWEtLQVFuQXBVZFh3YWgwYjhqWFIyWXpKVHNDMFpIQjMzRkwrMnlpWDNoLzFZZUQxZkZaR1Q4MWcvSDZ5cWtWYTlZRXBxTWhUQURsZThlckhBNnQ3TWg2ajRaQlhkQkdqRnlPNENTSW05d0dCaUJ2Z3F4d0lBSlFsWEl5RUpMeUkvaTBTa0FHL0ZiaGFFcjZCWGZjdis1ZExLaENnNHoxQzFIRUJKOCtCT0RRR1pYZmsvcXVBWkM2a2V0QVpFUUNUV0FVOFBJSnQwZmd3SHpadlZXTmFLcWk3SkxPbXREV0Z5NDJnMUZ4SC9YZnFHa0lJMEMrYTB0bkRrZnNHeFFqbjNWUHNrN3RYbXV5K1hwMEpodG9Kb3NBYUZjVUFKVVlLaVlKeGNxSHFLQUg5clBsRzJjTXJtQ1ViTVg5Z3VNTHBHVGNDTUtEbFpHaE1LOElQblBJbjFYNVBBMkF3ZWd3RUVZbURHQk1qT0k1d2hHUVAzTlBCVDdWSmxSTmFLdkY0dDJJV0hiREVydERsU2sxcDRsSjcvemQyNDZ0Z2xHWnJ5SWZyRmhRN3BVOFdDQVgwWkVORys1N1UxNFo0WXJDZUxyU3hYZGV2NlRmTHdyYnhUN3puTXJmS1FYZkhMUUNueXZtUkl2MFEzNDMwZXpNbUw5OFAzOTNHM3dxejZhbTFOWXp6b0duK3N2cVJtVEFVMmNpdGN0cUFYLzJFSThGOUFDRW1MSFhMWkdvRnh0U2wyeHlLMmJBWXdyajZYcjEyKzFub0wvalVUQ0Q5dnZGcm42dTB2MS9udkdrYW9WQkFRaTBldW1tTUF1WFFITVdKQUE3Z0NpeEc4VTBnRmZjWGRsQktrNFo2ekVMZ0FKZlpFS3J4cEMxeE9JbC8rU2s3amtjZFlsU2NvOTB5OStnSzZ2SnJSaUFERDBwaWFkN1J1Rm8zdWROQ2dmdDk0dkNkckdYbit0dWpnVjNRQWNITGNGbnJvZWxpdkhrY2hFTDh1ZTB1UTc0UzNldWJBSVRTM0lRaEtrTVJqQk1va2dXRzNMLy8yejNWU25QNFZEZ1FXeFVFRVV4QVpGSEwwZVIzSERmbTNJUmJESGtCZkYwenk0RUlLTmhTdnI5Z29HRUJkdlR6L01JWVFMUWRWc1R3UlRGRGo1alFtZEFyUkRZSlFORFNzOTYxUjN0UGh4NU5Yb1Znb3hsZUhuYXJqb2hnTGVjM0QySEk0OTJ5UU52SXd2cU85ZkptOXpLR2JBd251NkZoYVA1cEZ1TWcvYjd0VGJwQmR2VHo2OGN6L3pJOGF6Vmo4aUFIVHFnbUZIWERVQjg5UjJkdGFDN3RVR3c0a0RPZ0ZiMFIyd1lSREdaOGc5TzhhVTRYd1BPY3poaXdHbE1qcXFMV2lGWUd1NTcwd0FERnNiVHZheGc4bmtvdzdFOG5NL2F0Zkt6bG42LzFtUzRZSHY2QlE0K1owQmJxSGNkME53d1liVkQzKzF5V2hYSnhQQnJicThBcUUvWEFwU3FBeGlCVjJNWi81NERNT1p3S0UwMHJuRFVXY1I1S2lWL2JyanRTQU1BTEl5bisvbUN5ZWVoaklZcDZmZHJ2VkVMdGg4UkFDbHlIWHhtaFBpNnIxbThGTTB1Y2drOCt5NFJIQzFrQUsvNVhnVysyaFpZb2ZhZldjUHExQjVBcURxRVlzUTNuZXBSMmdxaFYyeWlvbDFDT2tEMEMrYU9hb0d4NGFMN0RRQ3dNSjd1VndvbW40Zm03VnJYMnUvWEFsRUx0aCs1c0hQdE4rbC9BcDZzWDJkQ3NaL3BoWmtJSmd2OWwrKzF3YmNxKzJXRnYyTlhJak5LQVB6dXc3TVVBVjhEVHV5bkZJRXNReTgzUmdUQWhpditOZ0JBQmFRT0dFLzNtd1dUTHdBcUhuYVFmcjlHbndVYkFSZ0ROQlVsa3B6UWJveVlDeVlEWWRJTGRmMGw0TmR1VzlrR29hNGdlTmRhekxFbEtvQTNQcng3RG9maUVUdEM2WHZFN2hHRXpKbHBjaXMzUWdyajZkNVVPSm9ZRGNNZ2xyWDIreTBOUHRsNVVaVWprZngvSHFiZWNvZTBPWnpkRjFnSFFybG45QmhlZTRzM2YzWnhtNE12QWs5VlNGZFVJdzBpK1EyUGFCdElTaUJTU0ZnQ1lNak1XMDBNUDdwd3Z2TERtd0ZnUVR6ZEh4Y09TR3ZCZy9iN1pSWkJ5V1lBbE9FUmx1S00zUmE5Q0tXYzBxNzNkVEJoTUZUNFp3SXc5bDVMcnBlcytIamVCaUdDVU9LWGV1QnZQY0tUaUVJT1IwZitSaERCTVlpMExoZWE0R1RhYTVOYk9RQVZEemhnUEIxTGE1UnNzVjNySVAxKzd5eTVPQUFEb0FjaEVIQmtGYktmR1JwaXdlQVB0TXM1SUZOb2t5T0drLzdyQVlDOU9oQkZ3TlhWWTFhdDV0ZnRDQkhhV1ZTMkFKZEVjRWluckROQytMdW1peWMxQjhBQjQrbXVMQVJBWFREQ1d2cjkzbFI0L1owWHQ2T0RGUWtqOFd0dW1Fd0hUS0RMUWVqQWZOM3Vkcy9kZmpvUWRhdEdMeGI4alFCQVl6Ni9ib3hpRmdBVnVkek5JYzIvczN4TGsxc3pBT1JvQjR5bisyRGhhQVRBR0pDdGJwa0NZcTkrdjRWK2FCZ0FRNGk2Nlh0YUM4NVlrRG9nL3pkWnZ6VWdmTjFON2E2MzNYcXY2ZmU5bXNESUhmTmFCNkF5MkpSRTFBSEFFRElmSTVuelpDTGVONE5ibTl5YUErQ0E4WFNzdWw2eXFWMHJKMldRZnIrc3BsQ3lDWUJSL0hKeUtYNHBoczBQS0JaMGxxT1lUcHZuaUFpVUFtQWQrSEtqbzFjdkRqSGdyKzN3UEpRc1ZDeW1VWnJQTXVSc1JCREc0QVFDc3VueUp0RkdId0FBSUFCSlJFRlVjYzBCVUpseFFvSDYycThTVDhjZ2dwS05BRlJHd0NEOWZrdXZid0FreUdnSkUzQytOejFQMXE5L1QzRjFFWkJ4dlpoNTBzNkFFWUM1eXlVSFh0NS9ROHpJNS9LckFtQUlra2lwa3lHUFl3WHoxYVJUOHY1Wk82akpyUnlBdktPdk5YbExhenNYczliby96dGMyOVBvaGdvdHA1SjQ5UmNqL3B6Zkl3R1MvLzNPTTRDTmQxZHBudFFwRlVtakVINExZSWdueW4vT0xqTDhGZURHaHdKYk5nRmpJOERJRURBOEJBeTFQRks3RlNLZjQzY05LcnZIeCs4Qy92bXh3TWdtWUhnRWFBMzVKMFN0cHZ2ekwvblA4UmJMQWZoeVQyMDdUQ2hnRFJpdS9aTDlEc2ZXTkFCdll6YmhDREJLb0JBay9wRW9iR1dUcXA4MTloelExLzBrMFBvYU1ERUpiSmp4VlpGZ0RhZDBTYVVPNUxrc1dWaitYU2NEbXc1VUVVREo2VTRkMG5WYkM5MVMzb3ZmVkhwNWFsNjRjZ0MrazdtWkFQNzY4S0NBMFdEM0EvaWVMejA5MENEY2VWbWxBdWhCbGpMZ3JmY0F3NlBBeURBd1BGd0JrQ0FiSXRNNGEvRmlOdEVSakJsNzZXOWZmRDJBYndKRGR3RmorNnN5SW1SWHJkNVkyRmpJWWNueldQTEVxbnNmQzB6c3I2cUJNUW1mSURSL3B5SjZ4TWhLeU1yU0RpS0QyeGphNlRBRFR0MC9BR0FzMUtjQVVDRnJPTEY2dGJ0aVJWRmF2VC93dU1DYTdNZlZUbEgwOThZQmVCY3dOQUlNRVlBVWxTNHVCVUxPbUszTENud09QQU5sRUlPU29GOStDNER2Vm9XWGh2ZFdaVk9ZcVdnaTN2T1hEVVFoZ2llQjBFRWxWaU1ZSjA4SHhxZXFuRzhENElJRGtBem81MURLUVFKdkJLVW1LQUN6Yk00KzVoVWl2d3JnaXdDNEx6dmptZ0NoNm5CY2dpTVRjdjlBYm8wRDhFNmc1ZUNqZnBVQTZBeG9RSXpnaThBTG1Xd0M0ei8vRHhjUFB3QmFrOERRRkRCOHlKUHBQWkhlR0N5QzBLTjVERkNCeWZoOS8rT0FzZWtLZ0V6Q1R3RDA0N1gwU0NQTTFJWVFqQ3YyRS9NSm9HVndVVVFvUGJvcTBNZHFrV1ZuN1J0RERNYWhCNGcrUDZxaFhGcGpWdGtEdFJHQTJuS2pvczdJeU95SEZVYklyWGUwRlhzVHV6SVlmTmI0TzJNM0FUR0lZUU9tUG42aEc2Z2kzZVVrUVFBZUFJWU9BVU96QUxNVmgycEFsRVNxR0ZCQVhBWU9NUVZqeGxsMDNpTy95WUtSQVQwRlFYa3daa2pwMXB6NTFMTzJYQVQzS3REM0FJQXdqNFdnMDVrZml1VUhZbHNYQUpMVm5QMElOTE0wT1lGeDc4QXpjUnlTZVRzdzJBSnVlSStEajJGbmU0RVdLejVNQTBNekRrQ0NrQUJ5VVdxc0p6YXJFYW56ajJ6WHdqRUdGSHVHWStwWXNNb2p6WkwxRzlFQmV4WG91MzM5SVJCckMzbEpHbU5EdVNIWCt3N1dDNENtNndXeG04RG5nTFRJbWdDOHBCY0dCdVRYZi8xZlhueVR1Z25Gd3hUUU9naTBDRUN5SUZsc3Z2SmZFbmgwbWhzWUkvczV1eEZZaTF4Wm9mN29PcVNBYXd3WWpSR0J6WUdYYnRXWGFDSXJsdkhVYWdYNlNQL3J1TVZZQ0ViRXFFQ1hBTWpmcmVlMkhnQTBFU3VyMS8wdnRuTndHU3NHMFJzWk1FMjAvKy9YV0g2TXVnay95bmdQQUd5NUdEWUFMamlJSElnUlVJcnNaak03QXgrQlN4MVM0cGZmZlFWSWVwOGRMN2RNRHNUR2pKQitDdlF4VEhtZHRydzRsMENvdkZydUMyTk9lOTc1ZWdEUXNDWFJLL2VLNjM0SmhCSzkwcTJDN0kxaStHdDBqeEY0MGsxY1BKQUI3VVAybTNNR0pBQUZRckdlaTlpVVRIOXlCVURUSGZVM0I1K0JPSUtRNDNCV3ROdFBjV0lPekVaRThGb0s5SzBEQ0dOeExpM0ZxYUtBOWdUZ2VvRndQUUFvSTBPdWxXVDExb0V3aUZ6N2N3YkVyek54V3RFWUJCK1ZZNzZWaDREV3JIOElPb0dRN09jZzFDcU1STFBsdG14dnMxL1NIYVA0ZGNBSmVQWXl5VUNSSXpyVEI4dEU4Rm9MOURVTXdsNjFrUVE4N1JteTJQUzJyZ0IwYTFjaTE4UnVkRUpINTdPc1kwMnkvKzgzL3NaZEJLcjRGWFFUQXBCdnByR2dRQ2c5VUVBTStoOUY2dWdKRGtDM2dKUEJFdlJHcllvWUNCWDlJeEVjUzVLNGk2Y1pBSEl3OG9YUTRtTEJiMzVZSDVkN09la2FkdFRWMVVaU2phRUlQSDRuUXpZTndnakFITndEdVdHWXBaYzdselBmWDFjUXVyNW9Cb3JmekRmK3ppMHlWVHVTa3V4QkkyUStQaFFESVVFbk1MbzFUQkNaTHVmR3cvaXhiUWEwS0I4Q1RPRGpQb2hkWTc4SVFtZkRqbVc3WW8vZG9BWDZHcUlpQXRESGFZc3dTbWVNdWJWODFrcDExTDZoeTJQZEFjZ2JsZnNsT0tDMUlpS1JteVJ4WmdWLzgrK0RTOEJGcnhYaTVIZC9VNk1lU0tkcUVzRUtocEJSc2dSTWJBdHVHNEtVLys5cnk1YnJ6UC9sUFZNdjFFUE9RZWdoYXJyVmNnWlVoVkhGeE5QY3A5VkZ0bE9Xa0w0MzdDMFdBQld5cEZSR3NWMHNiNUhuMnpZQnd2VUdvS2wxMHYxa25EZ28weTdYQThQZnYwVUFDbmphSzMzQ285Z0pRQU9lNjRGa052dFpBSFFkano5djJOejJHU2EzalllajJXM0tHdVo5aXhHZElWU29LVDEzQjJzNUFIa0doZVNUNnFuMGVySHY1QUlnQUFVK0xWZncvd3EzQ0VBVjdjbEJLRERHWkc5LzVvVlh4L295WUFSY3pjcUg1R3lIOGVGcGxUYXdGdkF0cnRYTEdwTnJRREdiZWp1cEIzb21sSUhRR2MvRXJ6T2NHU1JzOHpyaEFiYnVMMVRjby9KZmJMbE53SE9taTJrSWNzM293YmR3TnBZdHluRFFoc0ZjZ3Z1RzkvWWFwR0Z2WVgyMnpaY0FVMC9Hd0EyTEovNEFtR0Y5bXdFYkJ1OThZM2NNRit1QUdRQ2oySFZwM0JiUHVvM0lscXhBeTV3SEFxNE9mQVJtRUJYR2ZOSUJhMEJJc0cwZWN3QzY3bWVySGdScFpMd29jcldhb3Z1VHhldy9WMHR4SlEyRFdlYWUzV0FHYmRoYjJEQjQrd1J3N3c1ZzhRcHY4OGxpeUd0b1dIek1pNEM5ZkFFSGJCaThrd1VLdTJ4TkFkQnhhR0JMYkpkWnV4MUx3QUdFQ1lBRW02d3lmcGVsSnJFZ0ZuUkR4RVN3Z3lVeElVc1ZNd2pWeTVBWU8wYkc4OUF1dTEvNUJGMzhLcWpCSGxVQVlYc3RlTkNHd1RlV051d3RrNEpNa3JsekdOaXpBMWhtNjlnMU5peCt6RE9CVzBhQmVSWlpHcUJoOE00ZW1mV05BRERUK3pxTWpReUVTZFFGSGZEYlpFQ0NMUmdkSGVDVGU4Q0JhS0pZMXJEbkJSQ0lBdUdXNFRZQVplRkc4WnVNa0dpUTFJRXdHQ0p0SFpCbXkxb2JCc3ZWTW5ERDNqSUFlcnRpM0xFQk9NakdjT3BhM1dmRDRpYzl0Nm92ZUR0TGZ3N1FNSGpuSDZ3UEF5Ylc2eWFHNCs4RDRISVFmdnRESVZ0TGVqcEJGc1Z2VUk3TklCSHczRFVqUnpMM3JEVnRzWVBPa0FTY3VYM2NvTkR5blQyVllKQ2tuK1BqcXZVRDhoVmJTOE5nanBoR3hjQU5lOHNBR05vVlkvODI0QkNCdElhR3hSZThwTEtaZHBNa1R2WGlKMnRvR0h6U05IRFBTY0F5cTNlcjRxUHlHYU5jN0pDUlhXTFQyVGp3R21DT2VRYXNocTYrcVNwWm1wOHZvalFwaGVGNThuY2RaVmpMbmpXUEhyNFZXS1RLeHJIR1VxcTk3cVh1M2pwMHdQeStlRUMvRFlOWnNaQU82SUViOXBZOWxOQ3VHUGNOVjgzMFpta005ZG13K09LZmJkY1h2Sk1QZFkwTmcwLzdHbkRYS2NETWNjQlM3TXdkS3o4S0NBS1FJZ1kwTVdHQ3RyNFRPSEFhc013T2tUcWY2dW55dUx5a2ZkMjU0bmtiN3Fzdy9pVmc3amhnbVNYMzFWcGQ5eVJIZUx4K3pSaGpFR1JiQjZ3RFlUOE5keW15dWJ6RHpDQ0dmcE1KV2ZTUllmcjlIUC9hTWdCbTdZb3hOUUhNYlFIbStJRDZhRmg4eVM5M3RBdkdRYjdkYTJnWWZQb1hnYnRQQXFhUEErYTNBRXViZ0dVMVJNNkIwNjBmZ2tSb0N6aitUY0QrMDRDRkU0QmxkWmRSYzQvWXhseGdqSk1ld1Npd04xeldmc09uZ2RsanEzRW1ZMDh2bTVpLzdqNXlJTXFwdnVwS3lHb05nOWxuZ1lvc2w5d1kvMGRaZHJNellsOE5lOHNBV05PdTJNQTN6dy9GMkNvTml5OTlYYnZmdHJjTHJpejZQaHNHbjNVOWNNOXhNT0RPYlFZV0NNQU53UEo0OVVsaXVXNlNhcXFCbi9nR1lQOHB3UHlKd05JeHdESzc2YWhEZU42dVhZQ3VZeUFCa0V6YTRMYnBZNVdFV2RTTHhqRjI2L2RRQjBTSjZyNEJ5QU42TlF4bWtXY3FyblEwMHgxREVESkZqUjhDY05XR3ZXVlBwNlpkTVE2T1ZPQ2Izd0FzY1BKNk5DeSs3UGVya1A1UTN0QlkxUHJUOXRFdytKd2JnUHUyQWxOYmdWa0NjQ093dEFGWWNnQXVpd1dsTS9YcURqTUViUDl0NE1CMllPNTRZSkZNby81Z0hJY0FMVjFUUloxN0ZYT2hQdHZndHZrcWY5SDRrdkhEbHlLSzRsNlZ6dlZTQkYyMnV3ak9iN3BidytDZmN3QlNreWVGRUhBVXgveXc5SlR5RWJvMjdDMTdPbDNhRldOdUFsZ0luOVF4TzJ0WWZObGJLNk12YXhlTVJZcXV2TDlyVGNQZ0ozMFR1SDhMY0hBek1PdWdYM1FBTG8yMVdYQlpMRUh3UkYxT2dIUzJlT2diZ0lQSEE3UEhBZXpOdTdRRldGWjdKblhKNXJucXhIRXVsdmx6d3lWTk4zK3dlcm41WW92bDdTWExHd3ZuNHJpTFdPNGZnTVJKWGNQZC8rcG1PeW1FTEVoUnpCeEpBbzlnVkw0a3dWbmJzTGNjZ0hFcFdpM2Vwb2NDQU1lQlJVNWVUY1BpeS82cXRsMHdwdmhBKzJnWWZPN053T1FtNE9CR1lHYURzKzVFeFlER2dxUCtjY0FrSU5hVnBCOEdUdjRkNE9CeHdOdzJZR0ZyeFlDbVYwWXhMTlloZUNYYXU3RWhWM2dhM0xiOGc0K1I0NXVvR0xBRGdIV3Foc0JYQThLMUFaQUR5UnZ1dnRrQlNBcmgraTlEc1FoQ090ZjBVVWdXLzdhaVlXL1owK25Scmhpem94WHdGaHlBaTV5NHJHSHhVNjZxQUZoVDNyRFNJVmRwR0h6ZW5jRGVqY0RCRGNEc0JEQlAxdVgxQ01KUndGaVFJQnp4aWVMM0tJWTFZVzVNUE94TndMUmI4Z3MwYWdoQXNzMUdaMU8rU0ZIc2RSUHQwaS9QTEh1KytkRmIveDRtWGZoY2JXeGhmQ3RZTUZyL3VXdkt4ZkRhQWNnN2lwUEN2Rk9WcHVvM0hyQ2pZVy9aQStyUnJ0aTZUUzZNVlErTDROUEgybng2OThHblhGMEJzS2E4SWFiNGRGWnBHSHorSkxCdkFwaWVxQUE0SjhDUE9RdU9CQkFPVjBDVVliSXNrUmtBZWNydkFkTmJYYy9hREN4U3B5VDRDRUl5VGdSZ25laUxJcDNuUDZmcythNEE0TjhCOC80OENVQytaR0pBMjlmcHVMbXhKVys1aDVrTkZnMmppV0hTaTByMFV2NHBDb1pzeHc4RFVmbmhkNFZrMFhHZEd2YVdQYUJWMmhWamRqZ0EwQmxwa1EvSzlibW4vSE9WcXRDbHZLRUJxbGZENEF0bWdQM2pEc0J4QjZEQTd0ZGJjdll6SnZRSmtpaTJuNE5PZU1wYmdKa3RiWVBHQUNpRjN3Rm9FeDFaTU5lLzRqblBMWHUrS3dENHQvNVNPL2lNQmNYdWVzSHlseUFDTUJQRGd6R2c3b3BNOG1FSElHZHdyZkdBMXJDMzdBSDEwYTY0WXI0QVB2dk9TZHdFUE9WYkt4dStLMnBkS1JUbWRJM2Rxa1BQVmdiU1RCR0FZOEFzQVRqV25pQmR4MFF4SnlsT0ZDY3I2SEJpdzFQL0NEZ1UzRWdFSU1XNTJNOFlrTG9sUVJkZElOMUF5S1dpQnJldGY5TUpRTjZIc2FDUHhlNHJ2Z0RkSE9jT3hESUFjbURGRFh2TG5rNGY3WXF0NjNnRUlCL1lvais0cDl4YUFiQkhlVVBNOHFGMmFSaDg0UVF3TlFZY0dnZG14NEM1MFdxQ0ZuZ05zZ1N2UStEeHU0TXVpYXdod0lBWFZrMU8rZS9BN0NaZ1RoWTFkY25vMW5ITDJvREl5WlVMcEJzQUZUQlo5cGpUMFFRZ24yVjZ1ZlJpY1M4UVJnYnM1WllwRXNFTkRlakJmcG9McndBT2pnSXpaTUJSWjBBSG9VQytTT0E1NnhKd05sRXlURnc1RnhCUGVXdmx6cG5iQU5DZFExZVNHVFJ5Yk11eWRnTWdnVkJzS210WW9DNk10OHpuWnhzWk1MekF4b0FPdnNoK3lkRHF0WHg0RklEbDhML29tUTdBMFFxQTgyUy9FUmRUSTIybU5mYVR1QklJeFI0QmhLZSt5NjFwdW5RQytNeXRJL1p6L2M5RXV2eUJlZXRMQWZHWjVXT01aOWoyL2dxQUJCMWZNTHNIQVZCcWhmVGN5SDVkOU1CeUVkenMrQjUwWjd2b0daWCtOek5Tc2Q4Y3dVY0c1QVNSS1liZEhSTll3aGhESUhSZ0dtTzBnRlArSEpoMTVqT1hqbnlLYmxWVDVDYmZvcSt5Sk9zekY4UDgrVm5OUGxJQ2tNQXpkcy9ZTHhsWXpuckp3SXBPNmVnVFBNcUE1Wk5EQUI2aUNDWUF5WUJjQnFUUlEwZTQ2MzBTeFp5UUpRSXZNSjhtU2VMclllK3AvR3pHZm5UcEVJQnk2VVMvb3V0K0sxd2crYnJzODhySG1ET2dBVkNNbnJFZnh4TXRlMU10Nmo3dTl6ektnSVh6Y3pFQk9KSUIwQm5DSm9xZ0lmREVoTTU4U1d6SkVQR0plOWhmVkg0MnVuL01meGw5YmdTaUJ5U0lCV25BSkJER0VEQUI4UVdGQTh3TzMvYSt3SDQrcmc0UkxQWUx1bDh0Q0k4Q3NKbUpNUUFPdXdGQzlxTUk5ZzlaMEN4aFp6NjVLMHdmRkJQcXU3UEV5VmRXQU9USFZsVGNweGhYSFpMejF3MFpBNkVETGhrQ3NrUmYwc3c0ZFJZQzBQUS92VlNSQVlQbzdRQ2RqN0dxVk9TTWVCU0F6VXpNeFpjRE13TGdjS1gvemJ2NDVTUWxIWERJZ2FnSmMrYmpaQnFBV2hVb0gvWStCMkQwSjdyRmE2TFlEUm16b21zQWFPZUtxeEV2YldhY0hRQjA4SmtSSXRlU1hpU0JMWUpPTEIrWDR4cnpBelk3dmdmZDJTNFJBS2tERGdQek5FQUl4TUFTU1dGMzhXc2drdVhMeVhUUlNSQ2UvRGR1U1pNQk13ZTZPYlRkOEpCajI0QW90MDd1RE9iUFA5WHNJelVHRlBzNStKSi9NNm9UNGJ1eEh2OVg3QmVZOEtnT1dEZy9aNThHVEM5WHE1RnhUWE93OWMzQ202azVmUGNqZ2JIYmdBbHZWRzJ0SDFUM09hdm9xNkJsbmlaKzEybjV1LzJzRGJPdmFzcW9GZzh4MkxuYmNkMUdkaFNBaFhOKzdxTXJBQzRzQThzT1JKNnlId0QyOHorRnQ0ZmR2OFV5cVVEckRtQ0VCY3BaMzlrTFM2YXE5bDREMnJMYi9LWXNGVFBXZGZidmg4NnZRdTJzMUsvSyt6SWpUc1hJVlE5YTU5RWdzNFk2c1pmSUEvRWNTcC9qRVh2OEJXY0FoeGFBK1NWZ1NRQWtHQU1JQ2N3VmxOTGxxVGM5R2J2L0hBQTdNckw0K2YxVmxYd3JVcTdTdkNveUdjcnJXcEdodXVyMmZOR1l3TThZVDY3aFQzczFMYVp2cW41TUxNMGJ6bUhNbUlGU2dkRk5qL21JQmN0NjNOaEZad0V6RHNCRmdwRFBlYW5OZ0FUZkN0R3NYOVRJS3dOcmc5dHVWa2hsbmc3VEkvWUFyWDFWa1hLckVlMWwyU3luTjFSQ3NGSnNxblF2M1VJTXhod0lSalU1QUdOOVFVdGVWejNCVUF2YWh1TmdqQzNIeExBTkQ3bkJwL2NnT05YRjV3Q3o4eFVER2dDaktQYnZldmx6Y0tVSEgyYWc2Y25ZemVwWUJCOVppMkZ4REpkam9YSnYxV0RGaUxKNk1LcUtaVXpvUUZUZmoySG13VEtjVHBWV3ZjeEhLbTZrS2dvT1JBRXZWY2xQRDZOZHpMWHBNVDhJWU5QY0xWN3lKR0IyQVZoWXJBQzRTTkE1QXhLTTlyeURQRTVmczZlZVZLV0daMk0zUzNNUWZFeUpVS1Y4TDFacEpYcFZKOXBMaWxtbEF4V2tWSkhLd0loampEOVR0VlhWbTFIZE95L3BKaWFNRlJXTStibzByV2w0eU0xTjdvUGhUSmVjQzh3UmdBdHRCalFXZEJCR0VTd2dTaVYwUGI5RFJndTBUWTE5TitNMW1SS2g4bmlxRngzclJEc0xxamdsOXlhR1hUODB2Y0wxd25FMjUyUEFaQ3pBSFFDb2lxb1czeVlXRkl0NjY0ZlVwS2FSRXIxTlBha0g2WGt1T1ErWUR3eTRGTVN3Z1U4R1NSU3owVUp4M1Z4LzV2Rk5icnMvRWlMUlkrdjRBQ0lUd3c2aUpFb2RRS3dCSXlCUnY5dndoS3pVVzZ6NjZUVUdFd2hEUzNlenF1c0F5TnhuSm44eGExS1JQU0Z0czlZZkZCL1FEWmNBbTc4Q25EQlQ1VThyQ3FqZmMzeWg4R24vaEdkL01zS2YxK1F6WUo0ODkxSnllMTNpeTFjQUU5Y0RKKzZGcFlyRWtpZHhETjNPdFhSK0Z3QkdNZXpvTW14SkxPdW1BdUQ0SjRyeEpyZmRIL1hDb0xHRlZLaVVidytMQVBRcVdXYU1NTHJkNi8rSnljU0ltODV3OWxPcHQxajFNd0F3RlRpcUFXRVV4ZVlINUVObi9qSW5VVkhlTVhRL2YvalJlUHZDYTREaFR3TEhmQmM0ZnJHcXFhTkp6TFB3NmlaeFYrSFRwbEZHdlpyWFpUNDVOMzkrSFczVHVqbFp2OEQ2ZnA4SFJxOER0czlYSU9SNVl0YWtnQmdkcnJydDVRc3E4U3NkMEJoUTRITXdtVml0QVdIQVkvTGJMRFFOUURhVFZKOFE2VzRxVkI1MU9PcURaRFBWQjNUTE9CZXBXNWptcWFMYmVjM2pHZ0JHTVN4dnZlbURZa1E5R29LRjFTaFVDU0tDcUJlUXJ2bWZWWlBDMWtlQmpYY0NtdzkxMXRUSjhxNVhnT0xhUWdBK3gvT2RXQTJFR1o5OGdiamxlVEhkUUhRTisyaXdsczNuSzMvWmhqM1ZlUWhvdll6ZHhtQXJTd1FnRFJBM1FpU0NKVXJUbmpmbDRLb3pSQ1NDQ2VZbXQ5MEVvSkpiVkNrLzErRmlDd0ZaeExrNGRSZkxGaWE2eDhMYllrRDl2OWNYdExHNitPNEFZUVJmcmdQeWdWSWNxeWhUWGNXRk9KSDhmaDNyejdFS3duVUFycThtY0d3SzJNQ0MxaTdXWTdaZW5oNTZmZUhUL2pFM3lsaUU0VFpuY2Q2MzZnUEZDS1dhdkdoY1J4MkorY3ZzOU1sU3cwVHkzY0NtK2M3bjBHME1FeGRXNEJNSWJUWEU5VUN5bnZ5Q0NYK092bTRnYkJ5QS94aXNWZ0pQcFhyekxqNEVvUkpqSklacldIQXJTOWlwcksrS2NlZmdpeUIwWFZLR2pPbUNtVzl4aFJWTVVTeVJGbk5lRkdFZEkycSsvSEZYY2xrcDlXc0FiZ1RHOXdHajA4Q0k2NFd4UmsvT1REY1VBdkJIWFNMUXhjVkNETVFTV2J6disxZTdXVmJ6K2s1dzJ0SnRzYmNDWVY2V0pZN2htQXNEQTdyMVN6M09nT2dvTStLVE9KYmNqU0k1eUdJYU5FMXV1d2xBQVUvTUYrdEY1LzBzSWdoVkxkVmRNMlMwYlN6SHgyTWkrRlR4WGY4WDkyNU5DNEJ5Y0s4UXdmbWdWWDFMbGNGaXlrRU1jTDJCbmRKSjdhUWZpaktmeExHRHdBaEJ5TTdhQzVVNHF3UHpOd3VmTm5OdU9INFZaYUNQbFBvMkFhaHFGcW9QVkZjMTRnYTJtK1dFRUwwY0F6OWtkUHJPbU11OHIxby9yVHNYejdmOW9zd0ZzK2pPNkxBcWt2QzNHZ2c1Rmc2bXdXMDNDVUk2WDEyaDhseWZjejNRSHFyM0RJbDY0RGJxYVFLYzltSTg3UVhBQ0Q2dnBKcVkwRVZ4ejJDRXlDSTVlTVNHWDJlN1Z0STVKNHlUUnlaaHNjcnZ0MW5RdWl2T0FhTkxsWUVTd2N5U2dpVmJyMzdCZmQwL3UzMXlFZ2cyRlZhaVBDZVZPZ3VxQWZHb3YwaVIwUjlKQUJKMGJud2s5bk14dytmT2g1NUViZ1Joem96ckJVQTFwb2xOOUNMd29rNUhFRVVRQmpGTVFCN0QrajY1NlBXK0lySjhPL2JCQ280c0dGZEdlanFpeVlDeDNtS2U5L0p0VGlCdm1JNU9GaVRpc2c5THRKRkY3Z1pHRHJVYkhLczc5K2h5dTVoU2FVdmgxZm9GcjNyLzZ2WkpDaVhnQ0R3VlZGSjdNVm1STHNyR2x0dUZDYzY4eUZkQUNNREFmbHdSNFFNM0hQb0tnSUV4dDRnejQyU3VhUWI4aEJPRTJvWm1sdStLRmxLUjNRU3NzTUp4RFBXYmJqcGZMb0pyeEc4Q1lUOE1LR1pTVlRDeFlGVEliODRua0N4Q0lQTERpYnkzMGdYRmdoYUY0YzJSZVI0NjZVdTJmdm9GcjNyL2ZLQUVGeHZwcU1jZDl5b25Jcmt1SzVMTFY3TVZDTSsvdURKQ3lJQzJKOGEwejFpd3F5RVNnTWwxNVNhMzNRS2dtdFBFQm5wMTFtd3VYZ083MFVkNERIV3pmZ0RZQzN6QkVPazdIbEE2WEt5SFF6YjhIZ0dvQ1NRTHFzeG9ySXkxQnhpZTdXeDByRmFmK3dyOVh2MzJDKzU2LzdIYko1Vkh0UllUK0dKcnNlaEhjeWE1N1B5S0FRazYrdkJrQlpQcGpQRUV4bHdVNTlhd2czQzI0VzZLQnNDNnRxSFIrTWlkeVZHM2kzcmRBbkFzSDJUMDkzWFQrekxyMTk3TVRBODBoM1Nmc1pQMlVxcENyUFE0Nm9GMzE3VnJwZWlLWFRKOU1oTUxrZ0dkQ2FjS0cvbXVwVjl3MS92bnd5R2dDRENLV3pKZTNscXN5ekxXWldlNi9rYy9vS3pnS0g0akM3b29saGRDNGppdXpNMFdQbytjUFEyQXNYMW9iRkNUTzVKem41NjZQd2JSZWl3bmZUV2pJNEt2RG9oMWp1aCthVCtXS1NZRDNpOEFxbDJySmsrVnNWUWx5NWtrZGR2MkZ2SFQ2MWljcU83RnI3MS9Ja0xOWE9pMEZRalYwMDQ2b0J5NndaOTIyUTk1SUNxREVhTDRYV3czQ09jZjlNdzczREZCOUFxRTZ3WkFBUzhYdXpHUUlES2Yrb1ZrcXh0MDB0dEFjK1lUMFBKOXFSRlNCOHhveWU1WHUxWlZlQ1NnQ0xiWUxWTnN3b25jSHhvZUx3Q3pCR2pCTmtpLzRCWDN6OWxYZ1VDeUlJR21ob3ZhODNjUmdPNVRlOXlMZ1AzTWZtc0JTOHhzOC9VNjdlUFFPcXk5dW1CVXJ1RGNocW84c0hTZDNQTWZUNWlmbythY2s4ZUZISTZRRWNuVDVHdmRPblZkWG9mK3B0SitCVlBXY2VpYVJIQThVcy9ua0FDbzhtenFscW1XcmJGRHBwVDVBNVVJWm03Q1BBMlZnbTNRZnNFZDkwOWtLSXFCMXFKQUtDQkc4WnN0WnozeEhPQUFpd21wRElkbmcxbWFaUUFrWnpzSFo1MzdZZlFyd055eG9RK0hha3JuUzBoMW1VQTFDOTZUZEpUbU9SeWhDM29lcWR3Uk9pK0dEaGtGSTZiWU5yY05ERURlQWtYd1FpelBScG1uSXMzT2RxWlBTYVJGVWNiY2hIbGdpZTZhZ3Eya1g3RGQvK2Q4bFVKVlh1VXprOEVSbVMrMnZmZDR1dk4yVk9WNXJTd2IweTNKaGdJaDl3SmVOM1lNUUNJZ1I3OFErbkRFVllCWVpVclVwYlhGbk03Q09TZGY3TjRJUHZ0RG5UMkJZL2g4Q2hoMTBNWFFlWUdTKzdHR2phUWlBQnB1TklGaUVDbnpkV0pNSVVIY2F6THB0QzdZaXZzRjgvN0ZnTEZNcXBpUUw1VHVOYktmQS9EQzQ2cnFxQWJBd0lLV0srdGltUlVCRWlOR3NPUXN5UW0rR3BqZDRuMDQ2aGJUODRLUHVZak9tSEh5cDkyZ2NnRFMyT29JdVZJZWgveHlVa2FWd3lFV2RMcmV3SEUzdUJVRGNLSXducTQwSHBEWEwrbjNDemJhS2RndWVsNVZuRkpsMmF3YWdoTFFCVHp0ZVowY2pMcTJBMm4wTTZFUGgycEM1N1dnNDFwb0x6WnNBWk5zbzBIdzZlVlIvSjhiRjlZaldHbVZDcEdLd1FMQlJDY3JiaVN4TkxnVkF4Q0Y4WFNsOFlESEhGUFc3eGVGQlJ3di9yR3FPS1VCa09EenFnZFdQWUFNNTN2VEFTTVF1NEJ4OUorNjlPSElGK043MUYxTzFnVUIrQXNCZkZxS0MrNFdpNEJXWCtDWWdPVEFVMzZ3ZE1WTlZLa2EzTW9CV0JoUHh5aXVrbzN4a1NYOWZ2R01rcXNEbHp6SEMxTjZTUTREb0lOT2U3S2VsV1dUaGV6aU9iZUtDZEFSQXBEMUFkVm5SSDA0OGdLVUFtQUVZaTZPaDRESlY0Vm9HRFdxanE0WExiTzVvMWpCb2ltRVBoUEptd3U5RnZuVExnZGdZVHdkMnd5WGJNeVJLZW4zaTJlWFhCMjQ1RmxWWVVwVnhVcEdpTHRtR0JsclRFaFZVd1Y4ZEVrVktBcTNNSEoxdXpSYlJ4K09PZ0RXRlg2TXNYSlUvMzZsSm9Fb0EyQUt2dzgrdXdURURJQmJTdGRPczhkZERzRENlRG9tN1pkc3pCSXM2ZmNMOXJvcjJDNzVVUzlJeEpKc0VzSGRHRkJpbDR5WXVVd2tub2ZKZ0Y0WGNFVWZqcnorWDdmS280RUpKLy9Qa01PUk82RnJWalFNZUw1a0poWk1NWHpMd05aQ3QxbnpERmdZVDhjUXdwTHQ0aERPTjBpL1g3eXM1T3JBSlZlMFMvSVNnRlk3ajladm5RN0kzK2x5cXBZYUw5OENXcC9OK25Ea1pkaGk2Ylc4QW4xa1AzZlJUTEtWV2x3RjZSWkNIMkw0ekREUjBrMUlxZVROYjJPUVNZTmJPUU1XeHRNeGVxdGtZNkkrbnk5VkV6NmJ0ZmI3eGMrWFhCMjQ5QW9Ydjg1K3RJQlZnSko2bjRsZjZvVittZmpkREpOTUgwd0FWRlg5MEdNazFmNVR4bFMzRmdnaDkyRHlOMElPUnk1NjY1S0lmQ2t0c2wrSzNWc0d0cFZPV09NaXVEQ2VybFNualEyckIrbjNDK3BJQmR1bHo4d3FvbnJOUExLZ3dLYUM1QjNzNTNxaFhWcTZvRE5nNnNPaHF2cWhFcjNWMlZOTEJqbW5TU05kck9MSjF6a0F1NlZQUmpGY0Z6NGZYREo4aTQ1aEc5NEd0M0lHak9GWUE4VFRsUVovcUdIMW9QMSs4WnRsVDFNQXRISzhtUWcyNXpPWlVTQ0xJbGlXY2J3OHdmVzVMbjA0c3NxbkhYMDRldWlDazYvM2RlNjZNUHB1QVFWWkFFRmt3Mk1LRnc2YTF3RUw0K2xTQnZtQU9NaEQ4dmtPa0ZYNzdmZUxOdzE0WVQvc3NtYzRBNm9PZEhCRWt3WGxnakgyazROYWw2d0I0Zkl1WDlMelpqQW1vck5lSE1vNVRjME9ld0h3RFRVaDlIWHhmR0pzWWtBYkFBQWdBRWxFUVZTL3V2Q3BvQWNldzZ6QkJyZHlCbFF3d29EeGRMWldYTERGa0h5Rjh4R0UvZmI3eFI4WFhCeUFBVkMxb0IxOEhRWUlUKzh1R2ZQNzVTQ1VzMW82NGhlOHY0ajZjSVErSXFrUGh4ckJDSGpkakJINkFibFFrQWVZMW9uZHVrU2lFTG1zVVBwamJ5cDdYdXZEZ0FYeGROWlZ2V0NMSWZtS2c2QmJocmp1cDk4djNsVndjUUx3OGdxQTV2OXpDOWpFcnV0bHRnOGdNeERXV01CYU1Wa21BTldGeUVWNlIwdUgySTFJelc3eXBia1FPVFA1ZjJjaDlLc0Zrd3Awa1FsREFPbXh6SHBzY0d1R0FRdmk2VkQ0UmdtQWcvYjd4WlZsVDVNQVROWHdxUWM2S0d3ZjJVMnVHVjJ1emczRDR1YTdmRG5Qd1pjS2dJZHE5R2FJQlBaYjBZZEQ3aGd5SUZXTVhpSDBlUTV2WFM1SGNNa2MrKzlsejJ0OUdMQWduczdLeHhac0NrZ2R0Tjh2V0QrdllETUFVcGNqYTdsT1I5ZUxWY0lQNHRjdW9iLzNBT0hDZFcwMlZUWDYyQXBCNE12MXYyNGduUHk5SGlIMDNmSjM2NktZSFlUSHNnQkJnMXM1QXhiRzArSExaYU9wNjVpK2xuNi9ZTTVFd2RZQndHajFjbVVrRTcrOFRITE5kQUhod3JVT1h0Y3JPL3B3aEY0Y2N0Mm9ONjhCTURDZm1zSk0vbjZQRVBvWVBwOGJIM2tDa2J0amppMnRKSkE5NjJZQVdCQlBaMFdCQ3JiWXNGb09mOXBEQWlFTmsxNzlma3V2ZjluVFhld0tjQlNqc243bGRvbldiZ1FweCsyNm90YUxJd0FsZmkyUVFTSlkzWWp5NWk5ZG1zRk0vb0VETU0vWjdVZjBSaVlVQTdKK1RvTmJPUUMzZTBXQkJtOXFMYWQ2SElDRzFaSzFYQjVQb3hudU9PSWN4U1hlL09mOHhIVi9QK0Zwd040N2dLVXBZSG11U3ZlMHBLWmdDS1NxNXdxbmlXRTFXWnoveG91Qm03NEtUTXdCSTE3bFZCWHd0V1NzKzgvdkw0NUZmM3ZocGNBbnZ3b3M4ZDQ4RFpYM00yaHg5WElBbnUwSUlPMGNodTM1QU9nTEwweXVHL2pPbXdiZzAyOEcvbU56MVlXZEVUYm00STVCckZsb3YrRXREMndJbzdsK0F0ZzhEMnhZN2l3M1Y1ZGlFcU81NG1uajZYZE1BWWNVKzZnb243QTNOU08ycUZqbHlaWURrQVg2dUQ1SWFtNDRZYVVmVk5ETnhhSmNMSVBYY0dHcGZpNlBuWmRWRDF3UHNwUUJYL3dsNE9hTndONkpxZyt4d3J4c2xjVkZ1WUpibGVoa2NZWVpHUFMzTDIwQnh1ZUJjUzhud2c1SDVrWmt4NlRRU2JYRlpjQ1FLYWR4NUN6NW1QdXJBRnhyUmFhMTdwQVIyUEZDK0VsU0hLUS8wUWpRY2dDeUd5TTl2M1Nuc0RCUkpnTDZtc1dDZjZJZldlVUphYzhVRmxwWTg1MDBEY0NmdmdiNDNoaXdad3lZVmhkMkQvVlNyS0dBbUlEbkJraWFmRWNOOWNwckhnS016Z05qUzFWN3JSalJsY2V5cnFpZjZLQWtNZ1hJTSs2dEFuRGwrelNMMzZPOStVOHA5akdIUW8yODUvMlhBL0FuWGVObktBb3JEWEgvQUlMd2JTdkxFejZRbDIrY0FmLzNYY0NkdzhEa0tIQndwT3BGYkUyd2FkeklkeWgzampOUWlyWVdFd1lxKy96SndNaDhwZit4S05Td002RFpNbXpOUlJiTTJLKzJJaTZUbEZyQVdmZDVWM2kvRjdJZ1QyTEJGNUxiSWRrcXhMUFd2dHpsQUdRM1JwVTNZN0FpaXhNeExPVUIydDdwS1E4TTBxQ1RucDhIa29qSmdOcWFNRUplc1F2NEFSM0l3OERCNFFxQXMrNlNXUmlxZ0pnWTBIVkRBZEJBNEJhNHhON25kbFNGQUFqQVlYNElQTzVkQkRNQWRTMmkrSng3WFRmMWVFZFREZmdBUW5SMzRwL3dRa1Jtak5Bb0J5RFQvdWdGcGhYQW1qQUVuOHFhUFFBZ1pDczBsU2NrQ05tVmlnRWJGTXNQQkJFM0RjQlg3Z0x1YXdIN2hvQUQ3RU04RE13NDhBaEFUcmp0UXdpWG9xa1RFd1dkN0xPbmVYTkNiejZUaXEvVEluYjJNOFp6SUZyVFFiR2l5OTJvR3o3cFhsLzdqdmRBSm5iMjQ3MEliQjNUNzdTYWkraHlBUDV2b1RxVzZzS3dGQWMvVEFkYzUrM2R2Y3NUcnZQVllTSzRTUWI4eFYzKzZJYUFxU0hnMEZEVmgzaU9JRlRJRnh0aXQ5b3JMNVovTEQxUTRzK0I4T25IVnVYd2hoZGQ1RG9MR3NnQ0NKMDRxNjZYL0p1L3ZTYWVBeERQdmJkdG1kdEtEVjkwZ1ZFUElsL3h5U2t2aU9obUFFanJselNrd2o0MFNsUVpZWjM5SSs4SkJNeDhtWnJ5aE9zS3dxWUIrS3BkVlNERnZoWXdQVlI5QkQ3dXlYNFN3UlM1OW5OSStiUmNrL0R6SjA1djEyTTBuWThmQWs4aVdMNUJCNXFBU1BHUkNpOEVWanp2M21xcGtDOUFDcnJ3aEt1a0I2N0docHFSUm93UU1xQ2lZYmo4b09vSGVVV3BkWUlCQVVqOGM4V2pyanloTklKMXVuempEUGpxWGRVakpBQVA4VE1FekxZcTl1T0hJQ1FBTGUvRXdXZStRZ2RkQXFDenpEOCt2Z0lnZzBxcCs1bllqYUR6Q2dqbW5DWW9uZTBrbHFQNEpTZ3Z2Sys2TG9GUG9GTWxrUEdoKzByUFd0YTRSSFROSkpRejRNOEVBR29OVFBWVThvcFM2NENDOXpvQVdURkNoY3E3bENkY2g2czNMNEovMlFGSUVCS0ExUDltSElCbWhQaDNBaTM1NFJ5QUFtV3NSL1BSczZ2T1I4WjhGTVBTOTd5eHRJbFlnVkIvSTdqQzBySUtTZkxYRjFFRUIrQkZGalEzakNMQTQ5T1dzUlRURVB6dnpRRXdyeTdWclo1S3d6QVFBUHNzVDlqdzFkY0hnQ3JPUlFDUy9iZ24rMUhzQ1lRU3ZlYUhrenZHdjFzY2dVLzZSNTVZMVlJeGh2T20xRVpla1FXbDh3VkR4Smd3Yzg4UWlKYzZBS1gvbWVIRGF3WDl6MTZNL0VtN2JPOFEwOEdCUC9qRWtBRVZqTUJvQUZXWFVqUkEzS3ROd09CWFczRWtBWmhyQUxrdHBDNmxLdFRWNE9VN1JIQisza0hXZ3YvenJuWVpsMmtDa0Y0dUY4TUdRR2MrTXFFWVVDQTBuMXRrd3hidzRTY0hBSHI3MVE3VzQrK2M4Y3p3Y0JBbUhWQi9jN0JjZWs5YjNGdXdiZEQva2pHV2d6SmpRM3RoR21WQTNqaGZPeVUrUnhCNkZhbU9GcDhOcmhzVGdMeThDcHptNVFsVnB0QVUrNkNpTmdYQ2FJUTBCY0RZVjhiMFA0cGkzMHZmSXhENSt3NzJDOWFsaWVnVzhNSHpxcm1oL21ldUZoWWkwcEticzZEOWZzaC9uMVhGTXJZTWJQZ1VCeUNaejZKK3VFa25EQTlBb3JuV0ZSYjAxV1pFc0FDb0hoT3F5Qzd3ZGV0VDBRQUsyS3FPYjVNQ1V2UHloTEUwb1F4enFhWU5YTDV4QnZ5VlhlMTJ2QnlMQURqWEF2Z3hCdlNQR0ZHTUlqQ21KYkVXOEhmbnR4dFFteFQwY214cDlVUEFkS0FaMXVwQTZFQjdxZ0RvNm9DVXhYUnRQVlNwQXdKcG5VaHV4QXFXQ0NZSzFNQkV4WmxqWTVTOFNZcitweEFGQXVCYXloTkcyNmp3OHVzQ1FMWDBTQUFrd3djQUVuZ3lRaXphWG96aUlsaStPZTcvOWtKdk5rMUxtQk1lOUVDTzNYUkI3YVBlRjBFWUhOVlBkVDhnajAxNllCY1d0QmZCVllKdXo3bUY3VmdHWS9wTzhmNVdkUTEvN1U2N25JS05TN2owd0liRFBGWnN5TkhIWTdvZC94ZGxFSGo4Q2NDM1RnQ1dIZ0dBUFN4aVNkdDQzMTJ1LzhTUEFsOC9EbGg0cERlWlcyUEQ0SjFjOSt1eURhSURrZ0VKUUtuVGZHL044blVBbXU1SFVuTVc1QVJiUGZFdUlIeS9BQ2pSSzdGTDVwT1I0UmF4Z1RIb2ZLbDhyL1MxWldCbkFHREtlZmJuM0FGSVBSUFhCN3NGaVZRaW1LVmdHZGw1b29Od0xRMS8xVStEUUdTWFE5cjVFdnkxcTlyWmJQMWxHUURac1Bwekk4QVBIZ1hnb2Q3cVV4MTFZdEJiRnpDKy9DK0JMN1NBV3doZ2RvTGtPTlNMcXk1b0xvZ1lmdDNaSTFGN0VBQytwaHNBbmVrb2toUDRISXptbC9QdnRoUVdtUEI5TEo3anhrY1NyMTRqV2o0LzB3RmxnSkQ1ZW9EdzZmZTREekFZUEhva1doSEpaM1RGU2tuNGg3WU9TT0J3RXRpTVR2MWFZMHVrdEZZVG1JMi80M0VNUW1DdUFKbVVFMGdtVkQ4RUZkUHBkbnhoVmhxekRyOEY0Tk10WU05SmZnOThFVlRlTnU5UTJPRlpCWDd2cjl2dGdtL2xjZXpjelo2MVpOTjhEQ3ZpbFlDZFBYcU5EUXBBbGZHVEttME02QUEwUFRBeW9NU3g2NGNSZlBRSFhzbmlPVEkrZkVXREZHcCtRYjlCZXlTUkJWMmtwbDBReHhHQWxIRG1rSTU2WDZ6K0VQN1VEWVNkUmdoL0lvdXdJWjM2bEhhYkJFMEdKMHIxMFJnYi94QS90dC9qLzZhTUFmKzdSNEN4enVCWFdSR1VMd0JmSXJZNlVOZnB2TGFlN24wSStMTy9yZW9MTXFpVk1iVzM4b1Voa05rUUl6Wk83dEl3ZUdlUGNtV2xBRlRqQVlIUFZHd1h4V29MWWJsRURrTHVUVDhNRFBoWExKNGpBTHBhSkIrZ2dVNnhmZ0prblQ3SUtYSVFYaDRZMEZaQ29nK3d4aVVUd1NrWFViU01WMXJCL0EzMU9YV3VGcFBVZGEvbVJIS2kxZTZVK2hBN1pxN2wrQStVQWZEdEhnL0xycHRrUXBaNzI3Y1JXT0w5NTQyUGEzck92dU9xYWdVbHRndG1KTTA4ajQvUElMYklES3o2dzVQQUhzYnJhVG5NR2RaV0l3SXp4SWZlSzBybjU3OEozTEFWdUg4Q09EUmFoVi9GRlEvMUl1bUl2WFAxUXVkTmZ5TlQ4b1ZxY0h2aVBjQmQ0OEEwZzJSRHVvRHFIZGIyU2FsWkFkRzlkbmZEa0FFMGdYbkg1aWpXQ0RiS0NxNS9NUmlWMFFEOEhnSFE2M2pHMGhkc0xHeEEzeDlCdzFBc2xpN2hPM0J3QXBnbmcvR2p2cTAxSUhyWEo3cTNDejdFKytZemlGMnJzMVpMWis4SDlqSnNTb0VDV1hqNmlnbVI4N2FMZ2ZiR3E0R3ZiZ0x1Mmdqc0h3ZG1DRUlQU0kxaCtTa0NSanBmVUMzaU5XY3BvUnJjbnJZYnVHc1VPTUJvN1FCQ3hTVEcvaWd4VmNCSVZHUFdNMWgxSllRUG55S05FeEdaTURJSjliNjZlRUJHeFBEWTFZNW52K0dDamZHQXhEK0REcGlhd3BoQUJXWlBqd056TkxBRUlINFhDSDBNNy81YzkzYkJmSThZazJjZ1ZBZHZkVDEwaWZEa0JXQy9yOWxHSDUxTmhJc25zV0hPZlBtRVVLVDk0V2VBRzhlQU84YUFmV1BBd1ZFSElTTlFsS1FVZ2xKakpFeHFDK0g2TnE5M2tPcFVnOXN6YndMdUhhNjZRekZXa2FGaWVYeGk2aGdWSE9NQ1lHUnVKKzVWNGpZSklES0k5S2xzQXZGRHE4UURybmI4TldWUGg5RXdkRmtRNzlUbFNNSXNOME1pNXM5TW9PR25vNFU2ZjNZQXZlZkw3WTdydmRvRkx4T0FOU0E4Zjd4U2dXbWQwa0NRYm1aNm1UTEVuSjBVcVdMaFVreGxyQm42bjN3V3VHa1l1R3VrQ3N1ZkdxMmlvam5SRnBhZnNVN01EeEVySnVaaFlDc0pvc0h0V1RjQmUxb2VxK2h4aWdKZ1hCck1tVEJQbkpLTHJyK1ZFRDU0aWJIWXZab3M4c08rRE5jckhyRFg4WVZWeWdsQUt1ZDBMdE1qRlB0Tk16NlFMRFk3Vm9tTEpkNjcxQUVINFh1KzNnN25XcTI4SVN2WDU4L2hndU9CZzh2dEZRdlYvaEV6eGZxT2V2dVRmcGpyaTh2QVd6OEwzTllDZmpCYzZaWUhtQmNpdG5GZDA2cHh5YjhXNGdQbGdvbkJxZmZUdGRUZzlweWJxaVZOQnNzeVVzZFVEN2VHTzlhbW5mM3NYdHhRaXBsN1dnL3NENEE4QXdISXlaTVlreTUwVHAveGdOMk9MOHkwNTFxdzJoWHp3UkNFZFQybm1jazFSeEhHK3c1amVPOU5GUUJwUjZsZE1JTVhsRldnVm5kcUYyZFZGc0p6dU9nUndNRWxCNkRjSTZyem5lbUQwUm5id1FpU1JTM2c3Wit0VklsN1BDOWthaGlZWm02SWl6dUxpZ2xpVC9Wb1VvZytwOFA5bDN3SjdxR0VhbkI3N2szVmN6cm9VVG9XTENzQUJ1ZDR5cGFMQ1VveGY5aS85dzlBRGlJQ1VMclFSV3VJQjZ3N251WnJ3YVp3TEJHd0NsU3FTeXozQWhIYmFSR0VGR09tQzQ0RDcyVVZnalcyQzJaNGxJRjRBcmpvZE9EUWNxVUdxQXhmY3BHNG1KVnVWcWNMNXRiczJ6L3ZlVjB0WUsvbmhUQXFlc1lOSGRPNVBDSlpvcytXdXp4SEpJVml1WEZ5Snh1cE5MZzk3NlpLMmxpelVLb2RpbEdVZ3p5R2hva0Y4eXc1TWYrcVJramRqZnVEdHdra203RFRrTmFCYVEyb3gxcTNlTUQ4K0I2TzNINmVtOEt4MUNjeDlwdFdsOWlZSVVBQVdySTNJM25IZ1BkT3RzTzVlT3V4WFhCZGowVjF2T0wvc28zQ3hlZjYwdGxTcFl3dmVLZjBwQXU2b2hmZEo4azRDVXFndnI1alY2VkdUQktBTGVDQWgrVmJaTFRuaDVndTZENDRBNkg4Y1Zsa05LOTVPMVdrQnJmbjMxUjVIU3krSkN3UHBsQXhSZWdFLzJUK0Fsb0duY05tYlF5b2dVUXgvS3dCNGdIajhZV05Ud1JBT1cwRklJSW5kb3FOa1RBeHovYmQwOVhER0xCZE1NNi9wTEtpNXdoQVg2MGdDSzJ1anh6RUFxR0wycFExSmlzNUFKRUFGSHZUdWpZQUtqUmYrU0V1Z20xZDJDT1FMVS9EQXdRNDRjYUV3OEF0WnpTSVBnQXZ1S2tkcldNTTZNN3hDTUJvaUJuNFlwQ0UyTkNmeFdBQTVNRXV3dkNDRUlDd2xuaEFIVitZT1JmRHNXSkdnUHBNS3dnMWI5UXBGbnpIYkQyQksySkd1bDlzOEtrWVcxN3ZMQUxRUlRDQnB6WFpwUzRndENYWE1Ba2R1dUF5OEU3UGlqUFdwclhKNUNSMzh5Z3cxZkpEb2hoMkJsUkFncTJPZU43dVRXYzFEMEFGTnRtTDU0RVNCc0NhSmNMa0RhanhqNVpYUmlDSUdBMHdhRHdnank4c2s1K0hZK1g5cHBVYkpTQ3A2VG5GQ01Yd255MVdBRlE4clVBYzJ3VXJSTDZtWFRBZWZXbkZmbnozRnBiYWdRS0xBcUF6b1pqQUtra3BYa05PNUdDRXZPTUxGWE9ubkM0eElLT2puUUdOZFdTTStHcUhRR2Q3SlNzeFVmK0p6UUx3aFRkVjRqZTFuUXZyMU1rUEd0bGY5eVAyRHkrZ0FxWjZyUXl0ZnZkSFNEeGdMd0JGOEFtQVlqSFdsdUVEaUtHTWlxT1Z2dGVqWFRCT3VSU1lKd0RKQUFSZ1pBR1dMOU5rK0lNM1N6Z1R5ZEU0ZWVjMW5aSGJ0RGFOQWYxRHBkL1NNeDJFTkQ2a0Qwb1h0RmhCWG1jWStPWTZBRkNobktuemw3TmZkTVIzcUNBYWUyQitWVk1ZWEFTdkRzMy9YL3pISlpjQjg0dnVpcUFCRW8wUVBuaG53cVFMeVJVUm1aQlB5dG53SGRlME0xdk4ybFI2cGljb0tVTGF4SERJRWRIa1cyaVdnNC83YjV6YjdEU1FBVmQwL2dyaVYySllvamZwd1JHRVlzR0JyT0JteC9PZ1A1c0FLQU5rY2JGek5XVFJuWC9HU0dJbU1ZSC9MWWxrK2dHdmRUK2JXK1NXSCtJZzFHcUw1UWVUdFIyRVlqNUxWSGZqdy9aRHdMOHlKNlRCN1VVM1ZWb1RqVFl4WURLK0l2djdkek5BWkl4cFpTaVU4ampLZ0lXVGN5a1prQmF3REJCblFkTXI1UWVUS0k1aVdDQjA5QW1FYjcrdWNuT1EvYVRQV242d3V6eVM0dStSME9iNkNVR3FKcElEQTk3QWRxSU5iZ1JnQko2OUNHNEpwNnEvY2tqWHFCL1JLbGE0V3BrTzJPRGdIb3luaWdBMEppTHdhTmlFdDk1WVFLSjRGUkMrN2JyS3pSSDlqWmJONmlKWXVTSG05STVpT0FPaEhOSmZaa2grZ3hzQktQYkx1MytKZ2FXRGRvamhNTzVra0RXU2xOVGc0QjZNcHlJQWpmM0lnZ0pnTUQ0TUNBUmpGTVU5UUNnQXlraFNLblVDWUhCOUpCMHd5NWFUUlV4bXVwNGgrUTF1QW1EcytocFhnRkxuQjZVTE9OT241eEFDTkpxeGdoc2MzSVB4VkJHQWlRRzlhTGVpbFdVSlcxRnZWWEVOMFRLcDFDNkF0MTlUTVNDQnB6MWRIdFQvSkg3Tjl5YXhwNlFrRjczS0J4WUlyMTBuQU1wcm9CNDRxUUdUajZzalVydE9GUHRMZUZRSExFUzlBZERGcnExRTZNMTNNYXhWQ1ROQVhORlRoSXlsTGNvcjQwenh0Z0RBUEt1VndETXJPS3crU0JUYnRSMk1ORDdzWndDN1F2bTR3cUhhNFQvdUlyaGIrN24wRWdiUWRUaWpveWcrYWdXWFQ4bGxEc0FGV3IvQjhxUDFLN2JUMHB2dFZ3SGhXNit0MkMvbThzdnZabGF3aTJDS2UzN25oRnRhcGtEbklMUnFCUUErdjA0QWpNeW43OUVJa1hPL0RuenlDQndWd2VYNHd4czlCNHJSWmd5UFZGcXlrZ0RkKzVKU3BCVTVyMHZIeUh6K2pzYzN1YjBLQUJzWk1DeVFnZUV4S3lGUFZJejNsbWNNNk9mUEFHQ0FEWVBFNjdKZnM2aDdHMG8reHZpN295SzRjTFpmT2dwc1h3QzJMcTlNd3V1VkVSb25LbjRuU0pyY1huUUtjTTdkd01NWGdZY3NWeGtTZWJKZ3pPV1BxZEIxYWQyZjNncHNud0syTFhXZVI5bTNkYW5VSVYxbEJTQ1BBckJ3dHArN0RUaHVCdGk2VURXRG1XQS9EdlhrOExScHRmUHROVWxpaFlaVE9QQ2kwNEdIM3dGc253R09XNmlBczVuM0dlSkorS0xvRSs5VkRDbFE4UjZ2T1FIWWVnRFl3dVkzUzZIL2lKOGpiMTFjazBxOVFob2M5UU1XZ1BCWkp3RmJwb0ZOODhER1JXQmlxUUlnV3lKWTNsUG96YUdKMUtURVBoMzZ6cFRrSnJjWFBSRTQ0UzdnK0NuZzJEbGd5eUt3YWNsZkZvSXd2Q3d4OVpuM1ExRG1JUHgvMi9zU2FNdXVzc3p2amZYcTFaUlVFbEprS3NCRUdReVloSkNCU2tVcUFXMXRzQmRwdXhFVmFCem93WFpxZTFnOTBHMkxvdGpRZG1NaktxdEJ4UUVSZEFXVUFrVWxaTkJHa1FSTnlJQUVNQWt4cEZLcHFqZlVHM3Q5Ly9tL2MvKzczN25qUHE5dVZlcWN0ZTY2Yjdqbm5uMzIvczYvLy8zdi8vKytUejBkbUQwS3pDNERNNnZBRnBkLzBMM0doNnlURGdudkx3S3pBV0RHaUgvVGhjQzJPV0RyRXJCMXBSZ1Fpc0lRaEFhK0FFRCtIRUVZNnVOTHlyUm5aTFNsNnRTYnJnTE9lQlE0NHlpdzh6aXdmYVY0VUdiZGVnbUE1UU1UTEZscXNmbjdYZWNEVytlQW1lUEFsdFhpWG5rdVpTQmtSY200VUdYdFUydW8zeHNBWmd6Nnk1NEp6TXdEV3prZ0JPQXFNTVZCQ1NBVU9iaDhRdU4vQ2lUZ2NXQXV5V2hMMWFtdnZCYlkrVmd4Ylc0NzdwYWE3Z0lCcUNuVXJiVUJpUXVoQUtEVW90MTNJYkJsRHRpeUJFeXZ0TzVWRHh2dlZmeFcvSmtXTkZyQ2VLOE5BR3NZN0JzdktRQzRoUUNrSk5hS3kyTFJJc2c2U0ozSVFTZTFvbktLQzJDc09ZTWVOKzBEdGowT2JEc0diRnNFWm1XcDVTNzRnMklyMnVBMjJCU2NBSkdBK2RKRndQUThNTDBFVEFVQWtnRFRQcTl6ZEsvK3NNV3BQRjE5TnhZd0E0ZzNQdHNIeEFFNFNRQzZGZFNnbUdXUlJJSkxaSmxsOEVHS2pIaVgxandhTjEwSHpENEJiRDBHekM0V3JzS01XMnBOb2Jab0N1NkNMQ0RmQ1RxemdnNnNyK3dGcGhhQUtRZmdaSEt2cFJTWWc3SE41WENMMkFiQVp3UHJaR2FqNmlwcFhoZ24wa3FtVTF3b3huSGVkZzVBQVR1V0hpZzJGRTF1VlJ3b3hvWCtXY2JnODlTM0FxQ0tQT05jQ2k4b1B0VlArOSsrRzNqK29TSzJ4UkJGREVsVXhiVFMrM252YzRGcERzanhsbFhRb0pnOEZnZENRb0dKSlRUaWNMY1E2dlBMNndiZzljRE00Y0p2MjdvQXpGQTVreTkvVU9Tdm1nOG9QODZuMGRJQ0JuMjVKd2pBUldEU0FVZ0JITjZ2ZmRidjEwQWJBUmg4WDkxdkRNMnNzK052QUVDS1BWTENzSG95VWdScXJsYm5Sd0I5MzNPQmMrNERYcklDMElFbWlMbkU3NWRpOEhzeUFjanpXVVZHVWk2dUlDTXBWd3dKVk1YZGVPazNYQXhjK0huZyt2VjJlc0FZdytzV29QMzFyM2VMY0x3UUJlUVVyRUhoNEpvMmg0dkRtSlB1QXlNTEdBZUVuN3VxYmdCK0k3RGxTV0JHQ3dlMzFHYjlhTDIwa0dEYi9FR1J4WTZXVHo4ZjJ3dE04bDRwZ0wxU2dNOGVzSEN2c3V5bE1FNG5uOWNmUUx0bGRnNlRaMGtVS29yQWZpajIzdkFQQ21xcDNmY0NsNjBYRklOaWQxUGxacmY0MS9kbkFwQjZ3U1FqdXRVZklESlI4Q0dJUU93V0VIN0R5d3BLcldjOENGenFSTEhrVllyQjJqUzJGUUg1dmt1QnljWENBbElVVUFBa0NNMmlSQkE2K0FSQ2U3RGpZbVFkdUxZVGxlaVEvWFRUUzREcEkrNm5MaFpXMm56VkNFQmFNTGQrc29JR3FqRDFhbXBkdWdpWVdDcGVCS0E5YkJKQzlBY3RBazhMRVMyNlNxc2Z0SW5MWjQ0ZFFpZjRJZ2RoeW01V0xyUER5dVlILzdIVENOd0RuUGtvOExYckJjY2pRYWlvZTZCaUthZDMrUVkvTUdUSDZyUzNPQnZDblFEdUFJeXFoaURrUTlSWCsyOXlFM29uOEl3anhRUEk4emtUaUFwR1Uzb1ZrRC80ZkdEaWVBdUFkTXc1TUZRakVnZzFEWXNVa3UrYTN1STBUR0JmVjdQb3R3SHdhT0VtYkhFQVR2dURJdXRuaTZVQVFvRlJJRlJZaGZlL2RoRXc3dGJlOU9mMFNpMWc4SGtyd1JjZXZEYWp6MDdnSUo3bjA1cll5V0lwYjR5YS83dnY4UFJkRnBqL0xYRG1rUUxBbkE0akNDT2xUQlJOL3JGTUFKS2dra1ZIcEdVanlTU0JTRmVnNy9henFrOEVnYlNFcThVRFJBQ0xLRFhTeWFRN0JyLy9EY0E0TFNDdHduS2hURWtRY21BSVFodE0rVWFhamwwdVM5TmF0SVRYV3pwemZjZE5CNERwWSs2bkJnRGFDdGFuWUxONmZDajR1MWF5MFFJcXRNTC9FWUM2MXdTQTl0QUplUDZlV3NBb0R5c0ZwZzFlQjBISVFSQ0lJa1ZlQ3FRZi8wNVAzV0NCK1VQQStDUEF6dm1DYUZXREtFdVljbDF5TU4rWTJkY2txR1RlSFBFdnZXRFNOaE9BZmJlZlgwQTZyUzhDVXc4WDkwNjZiRklmZHFNSEpJRCsrREpnTEFDUXVteWMzZ3lBRVlSUktGQ0xEMWV1NU9ETEY2UXZYZWR4MHczQTFCd3d4ZEFKTFRYamQ4c2VRbkdyWjliUEZ4THlBN1dJS09ONjN0WXRDUUJOL3N2OVFQbTZCa0xwMHZsOXQvbTZpZXRSNmZieUJBNGduWHRPUndSUnBOblR0UHBXNmdXTEg4M2xLcWNPRlRFbkRpS3RvSHd5OFJORmhyZWZ5ZXp0Ym5yQmZiV2ZndHRzUCtrSXlPMzJFTEQxY0hIdklucmx2V3M2VHNuQjdxQVVsZy9zdUZ0QVdrRTU1ellRMFFwcWNBTG9OQ1hURXQ3QTNLb2FEd0dRZnFvQU9FVUJhN2ZVYktjdGx0d0NhalZieHZTaXl2b2FzTTBCYUJLd3dkS2I5Zk43TmZjcUJXR2lTV3lrV1hFUjB1bWVhY1VFb25RZ0NLUmZJZ0RGanlhNXlxOFdmc2ZzOGRZZ2l1TXhncEFnL3ZuTXp1Nm1GMHo2Wmo1QVBkdlBRZWMwVEVvc252UW9zR09oYUx1SVl2bndFWVNpdGhFNTJGMVhGQUEwcDV5aWdENG90Q3F5Z0ZLbnBIVXBMWVAwT2NLVVJZdjZNajRNTlI0MzNRaE0wZ0w2UW9uZ2F3T2crNnJsOUNzd0tvU2tFSXhQeVRzdUFQaWdDWUJtQVhWZlljVmYrbjBTUll3NmRQMVl3TmdIc2dTYWppSlA0MjlScnBXT002Y3hEaUpCNk5JTk00dzdMYlVHTVFVd0IvTTltWjNkU3krWVZHMEVvQmlEQlNUNWRkWitQa0NzQWlJbFFaRGEzTFZhdEowV1hHMlBiTDk4QUIrNG9tQjNvUC9IZ1RVaG1HZ0JmUnFXZjJUVHJVU2pFeERTUC9xV3pRRGdmQUZBV3l6Ujhya0Z0REFLWDc1am82blVndVp4WjhOQnlIYnZ2cUJRMzZUMXN3Y3NCYUJBR0dSZzQwSXIrcnQ5V1VEaFE1WkFVN0VzMmU5TEx6Z2xxSFJ4TmtiZXVXK29RUlJsczVqYU1qbkswYTllY05mMlI0TEF3TzgyOWtRQjNMVHRFWVFQVXd6UUFXZ1cwQUdvOEFRSDBsanAvVjE3cG0wS1JjRWlmR3VOT25vY08xckFDUWJLUFhoczhUdE53VnI1dWgrbjZaZjN3RGd1MjlnMkZkTXRPYzhCNlBkcEZqMDhaRnJwbHcrWkE1RlR2QVFRMC9CVDM2RlBEa1JxQlQ5SmFnN3hZbFFJdFkwZjg4ajc4c1p6Q2NLUFpsckFRZlNDSzl1dkI0aDU3N1NDb3RVaUVKOG9wcThJUUZsL1BVQlBFb0JMeGJSRTYyTFNxRzRkRkI4cjViSGNPdGlPUVNxVDVUN1JLellEZ0p4K0JVQ0NUeFpRQ3doYVFjOW9LY0VuRUJLa25qNUZzSjFMQVBvOXhvV1dQV0R5KzZJSW9xYmVhTzBWQSt6SEIwenhJUURLa24xR2d0WGlSeE1JQXgwVm4wRGIrbGt1RmpMUkN0NVdFd0Q3MVF2dTJINU9mZWtENUZhY2lRYXkvR0liRmdCWHJpd0F5R21KQURSMWNrM0R3VEUzVFE0QjBMZXR6QkpFclRZQXIyQkJTSTNIVFM4dExLQlpQby9mV1FEWnAxOTdaM3NjakdiNUJEcC9MMytuak13ZUI2QjgzR2o5d2ozYXRPc1BXaW45V2dYQ0ZsVk8vM2N0ZjRpRDhYa0JrSDVVU2xBWmxOUFpBUXFBUnI1dnh1MXlqbUgwZ2l2YlgwVVFLSTYzbzBXdW4veEh1UjhFNFZuUEs1SlFMZDRWTnR0VEJ2SzJ1b2lLT1VmL2YrR2p3TU5CaDBOTVY2SjBjME5wY1J2N21yWXYza2g4L3VIeFlwK2JWcHdMcDNSN3N0czJZem91U3EzS0dhK3E3K3g3Q280bmF6QWVyUktzVmxWMVFpdEY1OWR5eUZaYVlZMEhNdTltV0wzZ3R2WlhNYnltQklGTVoxb3YyaDBCK0xUTGlzeGdXK0VxNXVVOTJpWjcydWQ5dnZSKzRKRnA0TmprUmgyT05pME9CMS9VQkNrdkVZUmhmdU5zNE9taGhpUEtuRlFseDZhQWpNblNYSlVBQUNBQVNVUkJWUGptejF3NDFubndPNGNDSUJ2QndaZ1RBT1VIUnEzZ3lERXhENHpSR1ZZRW5wbTVMcW1RYzBNNWVzRnQ3YWNGbDBTbEhpQnh1VGtZeHhkYWloVUM0UVZYRnU1RkNVRDVRdEpsODVzakdBMHppUXhxZXUvZmVtK2h3MEYyZkxMUUd4RmxZTVJ2bzd2MVdtSVZ0cHQxREZrWHZPUjdMd0oySFNreW9abUV5cG9WVmU4cDdiNnFFTW5pZEdHL1ZsL0wyYVBPSXd1QTFwQUlRRTNEQW1GYTRqOWY3Q1BhRnBDSEt1anI1eHpaZXNHZEhxQXFLejVYK0ZMUkFsNThsZStqdWkra1RCQUxNY2daNzNDREJrcE4yLzcrYmZjV09od1V5Q0VBalFUY0FWaEtkamtQYzJSYWpld0t5dS9uMS8vcUpjQTJ1aEJNUkdYUU9jbjlVNkpJT2pYSFFxU1lPc1ZvUXAxSE5nQXZ6OHlueTgwSDVQVno5SDZScVZkODQ5V3RYUS96QTBPdzJheUdMSjQ3NEwwRzc5dnZidWx3a0ppOEJHQ2c0UzAxU0txb2ZvTnZTSUMrNXpraEZVdXBWOHJVVHBKTjA2S3BhQmtGUW01TTFIbGtBM0F5TTUvdTlabDM4enJrNmYwaVU2LzRobXNjZ0s1SVNVdENUb3d5RHFiN1V4d3NxRkpXM2ZvL3ZidUlCSkVaMVlSZ3lId1FLTmkwS0VsMU9LVENaSmR4dFBEbi8vdjhvb2FEYVZncUZ5aVREMklLZmNqWlM0Rm8rN2crSFhPUHY4NGpHNERJektmTHpRZjhLVmZJL0ZOS3JRNmg5NHRmeit2T0E5Y0dBQWJycHlsWTJTRGxWVFR0K3VDblYzL1YzYTdEUVFBeXNKQXdvYlpKZ1VYaTc4UWF5aGQ4MTJXZWlPQVp6RXlVaUFrSE1ldTVCRjVGd1pRQVdMUHdrbmtMUXk5Q3JQTXk4K2xJSFpGenZOM1QrWWJWKzhYN2M2NE9ISGl4NzRWNnpJeEIrUkowd1ErVVU5OTJ0WW9GeTNmY1hjVER4UWtvUHNDVWhGSWN6S1ZDZWdTZzVCOEEvUElMTjlad3hCU3h0aUtpVUFPaTdKVzBkTFR1c3RGOEFHYm0wLzFvM3Zqam5TR2RqK2xZbEd3ZFJPOFhOK2Mxd0FCSW9IazZrNjF5dVNDSklUcTNqRFk5VngwQnFLKyt1d0FmWDZKa0kvaE1FMFNDMUVHZ3VpUStpc3FjUVJMckY2LzBqTzJ3KzZGTW5aaHlaWXNRMVc1MHFPSGdQWDFOWG5kdE9Ec2ZnTXdIek1pbiswK1pOMFM5WU9sbE16V2ZMd0tRU1MzOTZQM2lZM2tOT0xEUE0xeTA2NUg0Z09XM3A0dVREa0I4eldkYjdGZ2JkRGhFZ0prQ1VEUnZvZ1RtZC92UHYzQlZBVUJ1dnlsTnpBQVlpNGhpc1ZRbkVIb0lxV2JscnhxbTRNeDh1amZsalQrWWpzV0JZZ0lPYzBvSlBzcTFzbENwSDcxZkt5YkpPRW9BdXVWVFJTQ25ZbG1VNlAvWjRpU0pFY2JMditZdTkvMUVBaDdKS0VYREt4cTRDaFVpS3ltUmJ3amdIZGNVV1RBUmdMWVhIU3IyTE9VK0JWN01Wd3p4d09ma09XeWJZQUdaRDVpUlQwZWRqcHhENlZoY09RNmo5NHRQNTF3ZE9IQmRNZVhhOU9xV1JjbVdYQTFYTFVJVUg2enlDd2xBczN6K1lCa2ZzMXUrVkllakpFRjNja3JqSTlUMHkvYU1BMisvdGdBZzA4VlVSS1Q4dmJLTVVnQU1JR3p6QWNPaTVIa25IUUF6OCtsK01XLzgyOUt4aHRIN3RUeitqSU1BSlBDWU1VTEFXZDZmdmkrRVk5b3VvWkJNL0t4LzRMVUJnRkxnTkM1bzE2RnJFOEpKVkpna2lGaGFRUUJ2MytkVmJNcldWc0M4VXhGUmtqamFWc1cyRHRSZE9KL3ZBeW9oVllLN0ErYlR2VGRqOEhscVRNY2FSdS9YeEhrempnTmtJT1d1RHI4am5ZWURLRHV0Z3BVaHJhMHVBbEF5Q0NVQUs4QlhjakJYZ0xDay9oMEQvaGNCeUR4RkFkQXpvRlVxVUJZUkpUVWNNV2RQUDdPTkw2aTViTFFlQUxKUlErYlQvVzdHNEF1QU9YcS9sc0dkY1JnQVkrZ2xMa1ljbEpWVHNhNnB0Q1gzdVFqQUtJTlFzdEZyQVpLSXdXeFFJaElKdW92Qi9OeCtyMkx6RkN3bGo4WTBldmwvTVlrMGtpZVZ0Y3Zyd0dVbkhRQ1ZqalZrUGwzbUl0UXNJUHVFbHg5Rzc5ZE96RGdNZ0drQVdsTnlCSm44eEtwckJSQyt6Z0VvNExXUmdjZFZjT0NqamxOdm14ODREcnpOQWFoYUZaV0x5Z0tXeFVOaWJJaFRjUEQ5Qk1MTGE2NWJ6cmVBTVNHVm9YdkovQ2doMVdVZk8rWFRaUzVDRFlEczlHSDFmbk9ySURjQWtBQlRURENDTFlLMEN3aS81ODZXY0tKVWlFcEM4Q0NCWURzaWlTcGxxVUlVbU9qZitvMnRJaUtWVUpiZ1U1dVNXbDREV3dYNCtQY1huclFBVEJOUys4eW55MXlFb3BkY2F5KzkzMHk1WWhnQWcrOW4yT29VZUk1VGRRZXIrMzJmZGhtR29PQlphbkJvK2cxeUVLVTRkWWdGU3ZxQi8vdlpCSUJ0OVJzaGtUYlc4WlpaMmhVZ3ZETDNpVTN1dXg0TFNCTTBaRDdkUFJuVEgwOFZBSWZWKzJYQU91Y1FBTXVWY0tmRlNELytJQUFCc0VvR3dZQW9IWklLRUVZeFJJSHdMUzhwVXVoakZWczYvWlpoSVZXeXhWS0JCSVJYbmJRQVRCTlMrOHluSTR0QnprRUFDditjaGxVVklLRS81Y1JHc1dtbEtmSXp1ZGMzQVBMUVNsZzNFMk9DeVZSYzFrcFUzRGdCbUtvUXNXdGxCY3N3alB1K25mVFl0QkwrR1FkZ09mMTZHQ1pXNnBYbEJDcVdTZ3FKeXBvT0FGZlhYRGlmYndGSkx2aTVIQWpsblVzaUllNkFqT3A0aVFOUUhSbFQyUGxnSkNVYmJjMnMrdi9oRndGYi9xN2dtNkhsWXBCYm1UVjJzc2NReXkvcUZCajJ2MC9jQWR6L0hHRDdOREExQVV5T09VKzFDd1dPZXdOaktqNi9PMDNGMS9XdXVnVzQvWEpnZkJvWW13REdkSDdJeEI1a0xQSUIrSThBZk53WmdnYTVjazJmSmJFbThWOXpOV1BmcmFzYmdNdVBBY3VzZUo4RXhzYjlGZEJoQSs3Z2FRTktCNlRmY2dDWXVnK1lKVCtnODlhb0JETW1JTVNjUDEydVRLajEzdUR2OHpzS2lnL3VKMXVRT3Nub2ptM3FCNVA1QUNSQkgzT2hQdXp6Uk45RFY4OEhxUUxFV1BKbnZUeTVubS90LzFzNEJjdVNwUlp0R0F1NGZpK3d0QlZZRXljY3JZd242aEY4L0ZrSnA5Ykt4QUtWRnNuL2Q4dXJnYkhQQTlOUE9FT1dsNCsyY2ZvRkhoZlZySlRaUEtIU2o1ZGFPdHVwNkp5Q3BQeDhySFdSVlE3V09scllDTXg4QUhJemx4a0FMUEQ5YzBWQit4L0EzRS8rRTJmVVlIWGRGN0tUR3dkdlRkMEFIUDlyNFBnV1lHMEtXQmRmc0Jkc01QZlByS0tzb0w5WEFWTEF2TzJmRnlsQ0U0Y0tsaXlyRFZaTmNHUzFDcUVZaFdGaUFaVitYbnRhVVJkVExtcENFYnBjaFRZTHFpNk5ya01Dekx6dDVYYzRId3lKbW1rSitaNzNqUU9oNE5XZURVWmlLMUswOGYwRVh0N0NNSFZhd0lrN2dhVnBZSlVBOUxJMUFvOGJ6S1gxY3l0b0Z0RmZwZENJV3o3cmd6SGd0aDh1MG9QR0R3RVRjOENFTXlTVXpGYWlrZ3RscFcxVGE4SnFOYmE3bFZsalNSZ1crUTZaUC81N1dRdmo2ZnlkQmpYZkFqS2JnRXZNTHdXQ3ZoTm9pcGdOcG5Rc2hsUzRJR0ZXeklrNnlsV3dBejkzRVRMeEdXQjVDbGlkTEFCb0lPUzdwbUdmRyszM1lBRzVtTkQwRzhGNDY3OHZraVBKY3pOT0FDNFV5UW0yTjh3OTRraXJGbGZJQWw3aTQwMmQ2ZGJQV1dBdHJzak9GaXVDdkFKWk9RRTBwSFRGc2NrSFlEZUN2aE5naXBRTnhvQXo4LzhJUHI1bmJ2SDJqZCs2QVRoSkFFNEFxd1RkWktFQkxEb0RnVTQrWVZrUEhJQm9Qd2FyZU90L0JrRGV4c01GQUZuYnpOSlltMElEblZ3YnQ0dXl1cjFrd0w3VHAraVpNLzA4V1Q5UmM3REhVbXVZVHIveCs2bzRvdnZ1OWZqQmJnUjlKeUErb213d3h2Wkk1VUxnNlpXN3k5RlBmOVFOd0ttL0NnQ2NLQUJvdmg4QnlWeS9VQ3RKcTJmK1gxeVlKUEdVMjdsSVpMYnVFV0RzV0JIZXNaZUR6NGlVUkxVV2ExVEU0N0xxSzEyZlptZDNPWGlkRmN0cW05MkthdFZzMWpBRXNOdjZzZHltYWEyZzgreFVMNEkrUG4yYmVDZ2JMR1dISS9oOEczb1RyNDVpSzg2UE9sYkJVOXlLSS9BY2ZMUitvdVF3SDlCZm1tYkxsVEhib09uWi9UOSs1dmFmOEZVYUFUaFhzRk9RNDVtVWNnWkNXVEF4ZTBVUSt1cllNTzEvMzdHdHhRbW9MQ0J0UlNwMzBMckRwMlNGZHpZTWdrL1IrVk53dndSOW13UURzYXNwR1NmSmdZRFlOVGJwOHBzQ1FGSnhFSUJrUWpEcnh0OGRYQ1VJWStDT0g1TVZGUGk4U09uMm4vUVlMWjlHcDBjeEFOSVA1SXZBa3pWenhpdlJ5ZG5LTnpCYThmZGRNODRiNkFGeUFyaU1GMnBhams5a1lJZW9DbFhtQTNBUWdyNU5RRUhNQnFNVkZNTmFJT2F5TlJML3ZobEgzUlp3bWhiUVFVY0Fhc3JWVkd6NEV0akN1LzNkZmIvSUQzUGJUN3VLQVovTWhjSUMwdnFSVG80VzBJQklFQW1FdEZ3Q1lxalcwM2JjbWR3Qlllb1dnZXRVYnJSOHNucmxvaVIyZHJwQUNmK3JENEQ5RXZUVmpJSnU3SEJWKzc4MVg3NTJDemo5bHdVWmtURWdjUG9OUHA1TnY0b0JSaENHNmRkKzFEa016MUpJaFIxQkFISjd6d3FPM2ZJUlJNNXRtREs1Q29RS3NTZ09lQllCS0ZaVUxUcWNCOXI2Tmk1S1ltZDNXS0RVQTBCbGhOTE04RWJUMVFCWEJVNzJhSTVaalVjVk94ejdXTGtROGQzN3ZzYXJ0L3VBNlJjUHN4TlNBdEFYSERZTkMxQUVwZjlzMDFrS3d1QndHVTdIZ1Z0LzFqdEQxZTYwZmdRaWdTZS9qNWJRcCtLWXBHQitINjJqVDdQOC9aeXBCSUM4RGhjeDhlWTl3RjAxNWFiaG1ub0F5SjVXU3JLZU5nS085U0h4blQvTFNhc0pCaW01bFJqV0JFSVZlUk9JbktMMXF1bnliUmF3TGdBU2RFeTc0cWphTk56SkNncUVFWXpCR3ZLMDI5N21BRlNIRUlCNmViS0RnYzhKMWtzbVY4dDI5ZjFlbjZMNXY2Y3hJSzVpSzZYbmUvNWpDVGlGY1RxVm4vci90V0RQV3dYbkVQVFZnSUtVSFU3bGpBU2F3S2VmSXdEcE1kUnhSQit3RmdEK1JSRURKQUJwd1N6ejJjMExmeGN6VmprVkt3YVlndEJCZXp1M1N2WDA4ZDM5UDV1TzNRS2FoWE1RY2lvdXJaUkFHS1pXYXIvWVoxeFhSUGU4d1FyMkFVSzdUdmJPVlRaQlh4NE1CRUNSbkNvblVCU0ZFWFQ2bWYvVEsrL3FtekFGLzBVQk9QcUJaWUY1MkhyVEZDdzJMSDVHOFVDekpFa281blpxbVJuUGgvdUNYbXBuVnBEVHNJUFB3S0FwT2FTQTJRTERMU0hmOTdpUHgwdHBJU0xmejdibDRpRmZzVXNuaitIWldFZU9ZRENEbkRtQ3Zaa0VnZWRjQ2p4R3NlSWhCWXQzdngwNDlId01MUmg4Z0E5Z2gyTW9IOUFCcUtKenhmME1jTzdYbFNBVTRIemhZWUZxKzVEN2h3QnUvOThPUUxsSUJDS25XMzlTbFhOWStucWVpcTJka1FnK2duR1BiOS9acFQwbHE2TVY1RDk2Z0xDd2dEbUN3YmRuQ3ZabUNnWS9keHk0N3h4ZzVTV3VVamlnWVBIRmJ3QStmeUd3ZnIyclhyTXZQQit2cDNMM0dIQ2dpOUpPSFFDa1JWUHBwZVVCaWdYTEZ5bXllallUQjRZc2dmQTIwb2ZSQWxZQjBGZkFsdlFxUDAvVHNYNVBMT0I1RE51NDcxY21Jd2lCYVJ3dy9GMDFKK216MnBxQ2h4VU1adnBKbG1CdjNpVG9jc1c0ZHpld2Zoa0dGaXgrMmZlYlhEQWVKTy9ZRUlMQkI3cFUxZzhMUUZvOThRQVNWR1lOUTZEWmZFRzNmbkVxcmdMaGJmL0hWMTVhbmJrRk5Ddm9oV1NsOVhQUTJYVE0vMnMzSTREd1BJWndCRURmZ2l0SDBFazZONngrdS9pRDdUNGcvWWRCQllQcFdIRWFIbHF3TncrQVFhNFlqNTRKckpPK2FRREI0cHQrb0NBeVl2T1BFSVFEQ2dZZmVGLzlVM0FiQU1YN0l0QWxWdEFzcEtaZHo1U09sdkEycHN0eGpFUzN3Sis5Mk5nQUdLMmd3aTc4UW9WZkVoQmVRQUNxTk5QMVJkb0ExOGtLZGdEaHhrVUkvektJWURDbnF5ekIzandBSm5MRk9FSVc3UUVFaTEvMVkyMXl3VmdsQ0FjUURENS9FZmo3TTRDVnJaNUFLbGtoeGVRVWF4Qkk0bnZGenhmOElmQ1ZDNEhWN2NDNlpFWDVuZW4zVlgxdkFHTFpxOHlzcnZIWStRQndiR2ZJMkU2SnBMdmRYK2tzdGhwVXZRcm1YL3NWREdaVlVKWmdiMTd2SkhMRmVHUWNtQ2RWYjUrQ3hkLzV4alo2UXp6TUxPUUJCSU9mVFYyUHM0SEZIUTdDTFFVUW1VclYwcmdLSk1zQ2pzeEdBcVRuL2h6dzBFWEE0dG5BeWc1Z2JUWUJvcktrVXlMbmtCOVlWaFR4dStrVDEzaWNjd3R3ZEJld1BBdXMrYjJhcjl4SkFhZnFmZ01RTzRkaCtKOStCSGU1Z3FaWlp6WW9rMUpKVWNwYVI2YnA5M1ArVy9ONnAwS3VHSWVtZ0VXS2dQUWhXUHhkUDdOQkxoaUhLWUhVcDJEd3BaOHJMT0Q4dG1KUVZwbE9MeEFxbWJSS0M2RURZQzcvQ2VDUlBjQ3gzY0RTcnNJU3JzMDRDUG05QXJaazU1VXZLQXNwWUxxUGFQZFI0L0gwZzhEUkhjRHlWci9YNlZhYkxIazJQaGpwUFZaWTdkNXh3RjZDd1M5eS80TGJiVnlRc0VLSXVmR2lLZTBwMkp2WE94M2tpbkYwR2poT1FZK29OUnRsamppOVRRUGYvZk9WOUlaWTRHcTREOEhneS80VytPbzJZRzViVVV5MDR2VWNMQ3FTSlZSV3N6SmJOZ3hTbU1hdStxL0FvMmNCUjg4RWp0T3FiZ05XV2FUa0lGejNZaVdyRjRuQWp0TjBuQlpySm5VKy84UEEzQ3h3Zk1ZQjZMVXJhM29nbEwwdHBzNndsVmhhNXJMaXFkOUFkRGZCNEplNlUwcy8wQlhURFloODBTcjJGT3pOQTJBWHVXSXN6QUJMMUphS1dxMVIrbndHZU0xN09zb0ZZNVhUVncvQjRDditEamcwQzh4dkxZcUpDRUN6Z3N4bVpscTlUOGUwWEdVeWFVaXphdlB0eG9Gci96dncyQm5BMFozQThlMkZWVjN4NmM0c3F3T2Jja2V5aGlYQW93VVNBRGhEMVhoY2VETXd4MzdsdlU0WHhWTjJuM3JKSW9jeWdrci9WYnM3ZmUrRWRCTGNmYVhYUTNJUFdJcnBCQjZYbG53cFI3NmpZRzllNy9TUUt6YXJ4TTdxSkZqOG1nOFVhck1WOUlaNGd2TkREOEhnS3g4SERzOEE4ek1GQUZuUFlRUERsMENvMmc0ZnBEWkxxS0N4VDAvN2ZoSjRmQ2R3YkZ2aFJpd1JnSnJ1Q093VWdDcGVDdlVqWm1FRnhoZms5Vzk2OWtXL0I4eHZLUXFuVmdnK0I2Q0IwTXNJN1A3MEFIZ21kMm4xTlEwcnY3RnZBTElsVllLNzNNblFDRExUaFNHWm9EcHVQN3VDZXVYNW44enJvQjV5eFRoR25RMENneUJNeFk2M0FxLzVhQkhHNkVCdmlEbE9MVjBFZzErMEFCeVpMZ2JsK0hSeG5aWEpvcXF0dEE0T0RvdmxKWlZ1U2pUUUZ0cStOd05QYkhNQXpyYW1kVnBWczZ3RW9QdGROZzM3d0pmdnNZaUpQOU5GcXZIWSs3dkF3alN3eEFlTnhWTzhUNmFOVlJSUmxUNmhIckowT3ZhdzBXREpDS25nN2c4NkFQdk5COXdnMkp2WE8zM0lGV09CZ244RUlmMm5STEQ0dGJlMStBVTd5QVdiWmVza0dId1ZkZDJtZ0FVQ2NOS25KZ0xRclovVjkvSm5uNUpVWW1uQUUzaENtdjMrdDhBV1FmU3p5UEsvUE9PZ0pnRGRzZ3FBNW5mSkF2TGRMVitiejBrSzRScVBaM3dRV0p4eUFQcURWaFpReVFyN2d5YVhJOWF4V0NGVkFHTHZSVWhWNDZQZ0xuVVdCczBIYkJQc3pldWRQdVdLc1RSWkFKRFRvOGw4dWkvNDJqdUw1dmVRQzdacHNFb3crT3JaUWxxVlZ1SDRGTEE4V1Z5REFPVEFtSFVRQ0FXUWtPbHNRQXdEdC85L0FFOFNnUFFwTmEwNytBaEFBNkhMWGJiNVhyNElhQU1mdi9lR3ZQNU56eVlBN1VHakJXVFdqaDQwdjlmU3lzY0hMdGF4aEpXeEZWc05OQVhIMWtodzk4MytEWVBtQTVhQ3ZYa2ROSUJjY2VtZmNlb29BZmhBQWNBKzZBMnhMdUFHdWN4cnpnS09NZXhEZlY5T3diUzJCQi9CRW9xTFNyQm9ZR2dKM0U4cUxjSUVzUC9uZ0NQdVV5N1MxM0wzd2I2UFU1Ni9tL1hqNFBzMFRLQ1hRQTZBWHVOZVpZM0hNejVRQU5BZU5EMWt3Y0tYbGo2d09aUStiN1IrUGkwUEQwRGVGQWZrNTkwQ0tnOHFuY2ZvRnpJUlZXVnFmRmZCaGduMjV2WE9BSExGV0NEYnZQc3RCc0paNExVUHQramRlc2dGZytxVnB0V3ExMWJnMmd0Z2Z1TGlSQUFnUWVnK29FbXNPdWpzWGI1U3NBb0NJTi8zdngwNE9sTk02WXYwdGR4MU1Ldks3L1RGalZtZUNENEhRUVFoZjE1OWVWNy9wbWMva3dDY0tBQm9lWXZSMG9lcHQ3U0VvWlEwVHIxbFB1UFFGbEF0TzBueUFjV2hwencvRlNqRnpHakx4K1JHdnh6b1NlQzFod3NBOWtsdmFGTjVGQXkrOW1KZ25oYVEwcXFhZ2dsQURvNGM5QWhDRHBKUGw1Wm9tbVE4NzM4SGNHdzZBSkJXMVZlY1p2MGNlUHdPWTAvd2wxbEFEL1dVQ3gwbU1sRExyOGJqbWIrRHdwM3g0bmtEWWJEMHRoSU81YU50Zm1EaS94R0VlUmF3eGhzN1ZiL3EyaHVBQlFKd0FsaHl5MmNDMHhvZ2dqQUFVQ1dXQWtrc09pSVk5NzhUbU9PcWVxcXdxQXgzV0doSEswNm43VER3T2NBVi9paXBQQUtqd2dyWm0ybzhua1VBMGdLbUFIVHJwK285TVRyRVl2cTQ0bzlwWklPdGdtdThtYWZDVjcyWUFLVC9Sd0F5NU9QT3VWbEFBazlPdWxlNnhRUlRXVUtsV3RrVS9JdkFIQUh0aTVvSXdESzg0MVpQRnRDbWRyMFU4UGFDOWhWdWx0ZDRDSUM4UDJadHQvbTUvcUMxMVRKWGxKREdHcGZHQW1ZT0RnRm9DeEFDa0xwdVdoM0tDZ3FFOGdOVlpLNEt0eGdqSkFCLzJYMUtyYW8xcmZON0NXWmYzTFNCVDR1QUVJeVdCVnBpcEw3R2d3QTBBVzI1R2JHRU5CVFJ4M3JtMU0ydzM5bW1yRlZ3alRkMUtuK1ZBWkFMRUU1THRJRHlNV1VCdmJMTkxHSGdkNUgvVjA3QkRwN3IzdVUrSmFkZ24zcHR4ZWtBNU1CcmkwL1dwNHd6QmpEYkNua01XTXFWcEU4R0p3TFFxdmZjMHBxYmtWajVhTms3Z2JDeGdKbm8zMGNBam50b3d0WE5hWjFzdXZTS05oc1lUY1ZLbXc5RjV4R0UrOTRkZkVvUCtKWWhELzhPQzhlSVBVc1VIb2tWVktCNzhYc3piekFGNFB2ZC8vUENLVkdJcE9Bcjc4bW40RFpPbThZQzFqY28rdzZFRlRERFBKcWVDRUJaQmE1R2ZmVmJobVE4RHRaVzVUWU92UGhYaXAwR1R1dTIybFRNTFN3K2FBVmw5UWhFV2p1ckkvYVFpTEprVE1Mc1g5UjNyL3ltWjczZnAxKzM3T1U5aHVuWFNrZGw3VDNRcmhLQ3RsQ001OWsyaTVDTU1TSUFHZHF4RUl3cm1wdHpUc0NFdXQ1eWlsS29KTEFjeENxM2ZlOHRMQ0RCRndPK3RLanl1eFNDTWRZRVhvZURySGNIdnUwdFR3THptd0hBNE4vR2g2ek5DcXFlT1N4QzJsYjh0UVNpTXdidXFYSXFBY2pGaDJKakJLR0p5U2hRRzZ5Z1ZiZkplZ1VMV0JZY01SM3J2YjZvQ1JhUXdGUGdsMU01clI3L0p0QlpPSVpXeC8wK3M0UWVZNXovMS9YMnRGbkF4UHBGRUxhVmtkTE44TVdHVnI0cENCc2ZNSE44Ym1US2ZDalowTmNwNDU2L3g1OHpMemZ3NlFmM0FCZDhwVWdFWW1xazViR3llazA2SVFsMWJrWFNjbmxOL3U4TDI0R2R4MXFWcTkxS1F2cnBnd2FBQXc5cCt3blhQdzFZanlXTUd0RG8yQVNPRkdNVTdTSUVVemRZRDM0dk1QbVh3TGJIZ2RrRllBdGxHaWltNkRweEp0dnE5THRsVnIvYVdLRUI4cFVYQU9PUEFGUHp3QlRaOXIwNHZkUTlUczRwQVozY2QreUh4Z2ZNQU9IK3ZjQTY5LzlVeGlqbXovQWVyWXBkYXIxbE5TTVl6Vit2V1kvMzRJOERZNThHcGg4QnBvOEEwNHZBRkVGSWtuSUhvaEdWUjYyUWhGUlNZalFFNnFGcmkyejNpYVBBaEhOTmx4S3dBckkwUTFJQXh3ZlJlYWNiQzVnQlBwNjYvNUlDZ0xLQ3RxbnNyS0tsckZaVUZQS09yN29zTVR0ZHN4enFRUlo5M1ExTVBBUk1QbGxvaFV4UnFrRUs2Z1NoT1AwUytkWTJobFJ2OTl5K292Umk3SWlUblR2THFtZzZ4RFBZcHFBVWdSZ3NvUjdNeGdKbWdIRC9jNEUxRlh1N0ZSUmJ2RWdkN2V2WFdsYlBwcDlFZ1VqaUpwd2U2endPTWx2cEFXQ01WdXNKWVBJWU1PbFNEWlJwb0dpTnhLemJkSVFsWE9OTVdKYkd0dzRzdmRnejNFbDQ3bnpUUnZQcnJLcHRBSlQ2WnJ6ZmludHZBSmd4NHZzdmRRdklYSzVWWUYzc1VaeG1KVXZnQTFGT3Z3RjhzcEt5QnRNMXk2RWVwSTRMcVZNZWRiRWFUcDBFSUtkUEtoNUZxWVlxU3hnbzJqZ0ZyMTNqNlhYSG5PaVNaT2VCVlN2eUM4cUMycjA1RlZ2Vnc5Y0FNQU9BMTc4QVdQTXAyTEphYWVraUNQWEV4d0h3NjYwbjFvQi9uaUdRYXp3T2trU2VwYkovNzJJMXg0Q0orY0o2bFlJMXJpY2NyVmljVXVWU21JVzgycGt3bkhIVk9LYkZzT296UUdrRmt3ZXduQkVTMzdBQllNYUFYMzlaQVVDQ2I4Mm5JbG8rNDBwMmdObnZzb0t1bnhIMXhHd0EvTE96ZFFPUUpQSXVIelYyR0JnN0NvdzdBSTBsMzNYZmpPc3Y2b1ZvZGVzNklTYkJzQVpNWCtrSnhVNTZLWTdwa21GVmhPY2l1dlR6U3QwNXYwK3J5dVQvOWdEclpOZTR3UE1zSTdWSlAzR2NQN2dVT09kdmdMMXJSWUowWkk1SVYzaFY0L3dyR1lQUFUzL0FpUmhZdXN5Mks3bVU5OTlQK3o5ME9iRDdMdUJaSzBYZGtlcTlOU1gyK280SEx3Zldsb3BGQ0MwZmdjaUJNdEFGQzhDR3JZWFZvVmpuVTJHN3JUWHJ6aDRrZlJ6TFkxa3lHd0JvZWlHY1BpWGI1ZUF6ZFhXbmF6UENTU2NiNGozeGZtYXY4Q3gycDUwbEFNVzBWWElOaXRDb2dsMnI5SDJkY2N0V3dReFFzbjZaVEJiTU50Y2dkS0liaVpqNTFWY0JrMzhDWFB4b1FjZkNVZzhwamNZZ1pTY3cvbW9tQUNuWHlyNGxlQmhzNVFhQlRIcGY3WDhkTVBZSllPOFhnQXY5ZThRSmxBWlpxOEQ0eFN1QU5ZS1BKUW4wQVIyQUhLeTFNQUNLZTluZkZJNklFcWR1RVdvSElKOXdsc1ZLTGVrb01DYTlFQWVnU1RZUWVNNFRYY28yU0VNa0FIRWJCWm9qNGJiWXRkeUNWckZxR1hnVFN4Z1hZVFplSExpOUFNakVRUkNWVVhQL240S1VhYVQ4dlZUaStSdGc3R1BBdVljQVdsTUNnVVZrUWZKMlExMnlCdlBYTXdISW1oRFd3ZjgxaW1zVGlMU0V2SFprcitqWS9wOUNRUkQ0cDhET0J3dGVJdGFpMDVxbjMxRkZkZkxsRnhZV2dDRFVJa1Jrai9UeGJDRWkvODlqZlBaM1gyVnFZU0pRYm1VTlFZM0hRVDdoYnYyc0xvZXJWd0tRSE5FRW9Dc204UjRNaFBSalhVR3pWRUlLSW9ZN3lhRVl1WTRkZ0diNVJYcnVvU2d0U0NMTGFya0lDUTlmNlFOeWtHakZkanNJQmFJNGtHbHQ4VytSZzVnMEhKOHFBcDQ3bmloQXpGcHVXdFBJTUJaSmxBU0lMdlI2ZlEwRENWYkpDa0pPSkNxbms0cEdwYjk5dFo4TW9weWlLRFg3V1dEaXdZS1hpRVFPZWhDcmdLaCtlSlErRVFIbzFMYnkvelJseWY4VEliZjlYUzVmdEliOEk5Mll1Z0g0YXkycEx1c29ybDdkQW9vbld0TXdRU1RkT0Z1UVNMVEdIeUlDOGt4U0lRdUE0aHdVMldVQW9PNC9nckJjRGJzZldFbFN6ZytKQ29ZRG9FR00xaXhTa0h6Z0Yvd0c3eThzSWEzSjdKUEFHV3VGSlNRSWFVMDFpSkhVaVlQNGUzM0JyUE9IbUcvSk1hT2ZUWlZZUmh3R2F2ODd2V0tQSjkvclNINElPR081c0lUcWcvZ2d4WHM0VE9hQkFFQ2Jlb09zZ2ZsK0RyUVNoRnFjRUloeXl0ME1iTXVzRWt4NzZpQVpYS004QnZYaVpBR2xGK0thSWJhYWRZcGVtNGFEZ3BKWlF6NllKQUJWNVZjSEFKWjB2NEZ4WDZLRzVVcFlzMEtucWpoUnVhZ0VWZ1BnbFlBbDljaUhmOG1kVXJKaDBReDl2a0RCekJ5d2Zia1lRSUd3YWhBL2tnbEFUc0hzRHpLQTBCQVRpUHlaNE5FRHdJZW9hL3VGWUtLWEwyZjI0blFvSWdkOVIzeVFDTVRGcXdJQWZkQldJNyt5QjVaTEVDWUxFVGQ4NVlKbCsyWUFVTm9zTEllbC94WWx1NEpzbDZiaE5oRDZpdDRXSkN2QTJaYzRHeG83M1JjZ0plT3FGbUdSNnJjQ2hMWUFDeUdvam1FWWRqNTlLblordElRUmhIOUl2V0EyaGlSRWpEZVJJOUNseTdmTUYzRXRXUkZhd2hRSWY1SUp3RTU2d2RUSVlkdDd0cDl5czFLOEpub0p2b2Q5V242ODJQTmtQNGhVeTFuZFdnc3RBdEJETUxZTjUvNlBBYzVER05vRjRTclpmTis0K0loVDhqcXdnMkNwOFRoSUo1dmZTV0JYQVZDcldOOVNNeERLK3NrYU92aG9BYzhtZTY1NHBtVUIzZjB3eXQrRThGeVJBR21QbE9Fb2lTRDJxZ3ZtQUtvT201MmZBdWlUREhTeUlSeHgrbEkwUXh4QUR1YmZGNXZmZk1tU2FqcldsUDdubVozZFN5KzRyL1p6QVVFSG5ROFI3MEhzWGxLK1BnSnNXNjhHNFhZR1pqMEVZMkVZQVRDQVQ2dEFobUUwRFhjQzRmYWFwY3dNZ0FJZkxiMGt1elQ5UW13NXV3QUFJQUJKUkVGVVNpK0VmZUFMa1NycEJvdmJyUURua204d0FvOC9FM2krQ0NzWjk4TkNwQXA4Y1Vla1p5QmF2STRFVC9UbmFBay9SUUN5QVh5NnVOU1BBMGkrd01lQjZlUEE1SEZnWnEyd3BOR0szRlVEQUhtdjNmU0NlN2FmWDhDQjRVTkVFT29sVmkvM29iYXN0TndKOWNPNUJPQktFUU1zQWNpZkhXelJBaWdXV0FsQ241SzJiUVlBT2UxS01qVElSMmtSVWhLVlM3SXJMaWEwdiszeHdITVpNQ2JZTlAwS2ZHNzl6QXFLNUR4T3Z5RXVXdTZWRDVLU0h5MllBRVFBZnBhUmRsNVVrdVVjdElwQm5DSUlsNHBzRDAzRnRJSVAxQURBbEJ1Sk00N0VxcVVYM0xYOWtTQlFjdXV5ZnRLNzh4VWtIeVErUkxxSFozRnYxS2NnTGo1a0FRMXMwUW82SUExbkhoTkxRekE4Wnh2Qlh1Tng4RGNTNVVZcE5ub1l4c0NuVUlxdlpvMEYzd1BUTWE3SHY1M0hPSlZiUy9sKzVidW1YN2QrNVdMRTQ0aHhJUkpCMk5NQ3FqOWl4d3VFOTBzdldDYUlBNmJBcDk1OUVLZVdDaEF5QTBQVE9WMnVuR01RdmVDTzdiZnFIYmNTNHJKUjdFd3FudzVBV2hMdUltZzJ1RlFBWEFWczhSR21udFc0K2cyaEIzUDc5TC9FSjl6R3ZxcnhPUGliaVZpaEFPZ3JXUU9mL0VCZkJjc1BOQkJxVzlIdjZ6ekdxRnptb1h6M0I5QWVQZ1hpcTZiZ2l2NFlPQjlRSFM4QWZwa0FGTU1qcldBY1FBMGlPOVhKaVF5QW5vczJ2VjdFU0hPT1FmV0NPN1pmN0Y0MG1aRlFTY1JLQVlCYVNVNnZBVmNUZ043eFhIaVVGcERUTUsyZEZoNTY5MTJCVGlEY3Zwa0FUSVh6Q0w0ZzNXWFRaNGpwR2Zqb0Yvb2loTCtmeCsweVdVQUJMd0l3dFlLS0lhYmdDekhRdmkyZ2dCS24wTWNFUURhS1Q1Y0drSU9vNlN1eVl6RWZqUUIwRU01blpnQVBveGU4b2Yzc2dTcUNRTTNqa2RGTHZwUnZSMTMrN1VWUnVoVUZTYXZOTzZvdHdwODhaWjMrdDRNNkhMdGNoNk9UOUFHL3E5Y210Zi8vZ1YxSkRZY25RMnpZNi9ZYWtmU3JVK1BnMU00NU5xUHQzSUV0b003V0ZIb2t5cldLa29vZ2xDTVdMWWppVVhNdEszZzhVemQxV0wzZ0RlM3ZSUkNvVUVZQ3dHdFlGeHhxZ0EyRS9qSTIwRjVoaG1Rb2Q5OEJITm5seE9UaWcxYUdpRGFuTzIxeVY0RHlnV3VCOFllQjZmbkM5V0V0aUtWVktlRTBaR2lYV2N6ZUpvV01JaWc1YTlWNURBMUFOb0tEZUR5bFo5TlNYeHlBc2lLYXdyUXFtQ3YySFZmNWU4YVJveGZjMW43eHMra2hJdEFVdm9qdnlXcnl4VmNXSlprc1ZTeVpvUVJBM2RjQW9IemF4NEdqMnd0dTZGVktNN2dNZ3RpMDJqYlY0NzZvVUpKczFqL0FiQTFtUTNQbThlVFJzb1pEdFIreFpLQ2lFS21NWFRJZVhIUEdkaFlBclg4RndHNERHTUVuQUhJSzR5dlQ1OG5XQzJiNzNjZXhhWmdXV2FFS2dVMWdqTmJQUDdQdk9ZR3NVU0JrdjNoQnRtUldOenhqVGs5UldrdHZ4cDZQT2owdkFSalk5c1drRmVsOFJXeGVnaklGNFJqd0FPblpXTVBCVEdqcXZIbXN6eEpPQlVEM3h5em5MMmJxUk92b1AzTjNxODRqRzRDN00vUHBjdk1CZWYwY3ZWOWs2aFh2KzJZbm81UWZHQXJSYmFDQzBtV3YyWXRGM2VjZXJORGhrTlpJSXNYUVJ2NWRsVHRHQURKU3oyZ0VFMUVKUU0vLzAyNkhkSUVaTEM4QjZBMHRrMGcxSmE4RHV6SmRwaFM4MlFCRVpqNWRiajdneFpONWVyL0laSSs2N3BzY2dFN1FhRE9VTXlDMFdiOCtnWGp1UjRGNUo2WXNhWG5GaEJvQUdFVnZVaGI2MGpJU2dDUW5vaC9PTEJndklyTDh2N0RkRmtFWU01ZHROZzk3dHZ6NXpKcXpkZklCbUpsUGw1c1ArREpQNXh0Vzd4ZmZuemVoN0grWiszK1Jwa3lXVDFZeHVVUkpZVnR4NlQwZkNUb2NvdVFWODVWa0hSSUdlZ0V1RXYvWUtwa0EvSmNlVm1MOGt2NnQ1LzlwdTYydGZpUFdjRlFWRWEwRFo5V2NMSkVQd014OHV2Zm5qVDlJZ1p5ajk0dC9sZGVBL1M5dE1hR2E5U05kbXNJeGJ2VnNjVkoxR1Njb010NFVQd2hBc21NWjBhWHpRQnN2ZEdSQmpRejBGVXBFSlJBSlFPcTRLQW5CZHorc2ZpUEozYk9Zbjhmc3lreVZXTWZpTjNCT3pja1MrUURNektlN09XLzg4YXFRenNmRTVrSDFmdkdqZVEwd0FEb2RtVkd3T2VpTXNVcUhyR09uUzRVRnk5UC93QUVvamtFbkkrSXFPSUpRTkxncENYaGNtTEF0RC9EK2tnUUUyMzVMOTN0aitZQnFnVFg5QmlDZVcvTmVkVDRBbVErWWtVLzNzYnp4QnltUXVaaG04ZzFUK1FiVit3V0ZkaktPL1RlMm1FRk5sQ2I2Z1BGNzA4VkoxVFhIZ0tkOTFHblpwRGZpMWsvZ00ydnFVM0RVbkN1Qm1OUWUzUDl2dzZwZTIyOUtPdkIwSzFrK1pTK3JucmZNMkFsQTNKTVp0YWgvRVpLWlQzZHJ4dUR6MU8veXhBd3U5SmdKeHIzbFFmUis4YWE4QnV5L3dkV1FaQVZsK1p6Q3JHM3E5Yy9ZcmttSHkzSVJZcnlBQXFBa0VCSWxvcEp4Tk5VYkVSK2ZBL0grLytBQWRQOVBtUzlkYXppY0p5Ym03bWxCOG5SMmRJMUh2Z1ZrT2xaR1B0Mm5NMjlHQ2FtY0daakF3bFErdnZyVis4WC96R3NBQVVpTFZQcC93ZCt6YVRNRld3Ky9rQUEwR1FRbnBDdzVtRHNBTUlyY1JCNW1DLytNQWZmVHdnZndLWTJLZm1DWjZaSWtVU2hyeFh4Qlg0eVlhVjhIem1jbjEzalVBOENNZkRxV1llUWNTa2hWT2w4VTZ1eEg3eGVrcnNnNDloOG9pQ0VOZ0M1VFVHNXZLeHhUOGYyYVJ0T3RjQUtRMXM4c29QdU9WVUl3cGNoTmxFRUlPeU5TSXJydnYzaHduY2tXSVpQWnNuYmNEeXpUcHZnM2xVOG1wWlFxb3p5Zks3NGFqM3dBS2gxTGdyc0Q1dE14aXovbmtHRDFzSHEvWU5GT3hrRUFjdVc3b3FtWGxpc3VRT1Q3VlYyandpL2tUZ2oxUmtvWmhCamU4WjgzU0NBRUVKWlcwQzNnZmY4dEFEQ3Q0VkFTYVdJQkswSEk5cThCRjV5VUFNeklwOHROeDVKZzliQjZ2L2pkRFBTUm5zMEJXSVplVWl0SW85SWhIbWhYVHZ6Q1BRZGRjY25aNzZVMVYvSXZDNFNCQ0Z5ZzI2REZOZzdjKytNaGhiNnFpQ2lrVDdXVlVtcjZsWW4yblJLeXJkWjUxR01CbFpJYzA3R1VCZE1qbnk2WENpVW1wQTZqOTR2TVpiZ0JNRm81NTJwdTI3UFhBcVhUeUFVUWNpdE9RakFtOXhYME45cEl3SVBtU0NtSDVRdVBxRVIwTDRrRFlncDl6T1VMNmZZeGtiWmNGY2V5QXJlQUYzR2xWK05SRHdBejh1a3NuVDNqaUlMVlNtcFdObGhNemUrazk0dk1aZmdHQVBKZUhEanBDcmdNMDFUZHJ5OU96dm1ZQXpBcUxWV0l3RVNod3piUnd3U0VuK01xUDZiUUs1dFpsV3loakNDQ3NDMTlYdjdnT25CUmJncDdjdS81QU95VmpxVk1tQTc1ZEpaOW5IRjB5b2hXTmxoTXhLblMrMFhtTXR3QW1GcTRpbW5ZYnJFcU5KUGMrOWtmZDYyUktoME9uOHFWOWhYWjlhc2tFUGdBZkk1Nnppb2NVZ1ZiekdUMjhsRXRSTW9LdGc3bEJIdHpuZlpOQStDUStYUVdNOGs0dWdsV0svTkxZS3pTKzhVOUdSZVhEMGcvVHl2aDROZTE3WWI0WmJyNmc2eTcvYU5XY29QcGpLUlRzSklhZ3M1SUp3a0VBdjZlbjA1UzZHVUJmUldzVUV4WnlWWlZRQ1F3cmdON1dmZGQ0MUdQQmN6SXA4T0RlWGZUU2JCYTZZWXhsWTgvcDNxL3VkYzNDK2pUYnR2cXQyb2FkbkIybTRvTmdNbjBXMHAraFlXSFdid2c5eVUvMEtiOUVJeSs1eTJoaUNpdDRVZ0t5VGVBa044VmFsazRMZS9sZGxPTlJ6NEFXV0JSTTZmZElQZkhzdHcvRytTRTVyTW5WUS9rQTVBa0xIUzBhazdWN3JlWGZoZ0FDYUJxRHREM2Uvbm1jNWs5a0EvQTgwSlJlcStVMzh6R1ZwM09iSm8vQnZBT0QzZHR3aVdhcjl6RUhzZ0hJR2xGdWJxU3g3K0pqYTM2YW5MTGNEdnZnd0ErTkRwRGZJTHYrcWx6dVh3QVh1U2pya0tlbWxPMmUzVTF1V1VZbkw4ZHdCLzVlMmFwY2E5TE52K3ZzUWZ5QVVoZVg0Vmd1QitteklzYUc5bnRxeGhGNFhiZTNRRCtuNy91SExBVzl3UTF0YmxNUlEvVUEwQ2FIQzdwbFhFaCtxNFQwT1djZmhsZVlUU0hCSzBFSC9taStmY1J1S1FuNEk2ZldwZW9CNEFldkN6M0hPT205eWIzRjVtQmxaQk5jbFlDajFhUmZ5ZnJiZ1BDVFI2QXpLK3ZENEN5Z2xYN2pwbU43SFk2NmQxRTBjdGRJckVFRTR3RUlNbGFtK1BrN1lGNkFNajdFd0FWYlU4MnZUZXJDd2hBWG9wSk45elZJK0FZck9lVUxMWmdFclkyeDhuWkEva0FKR1dyMG5hVVdkRnB5MmNUK29DV2pwZGpMRnhFNVV6WUlCQnBFVVg1bkxubHZBa3RiNzZTUFZBZkFPVUhwaUFNbTk2YnNWdENBTWFLQUxJQ015eERxNmNYZnljQStiL21PTGw2b0Y0QWlxQlJJRXpCcDcvWDJBZjArZmkxWElpb01JbEFJK0FJUElHUG1lUk9XVjNqMVp1dnl1MkIrZ0hvRmZaaURTMmxDMExpWTUyV1VBRGtRb1RUTUgxQkZTWVJkSG9SZktTdTV2OXFyaXpNSFlQVCt2eDZBUmhTdURjQXp6bURvNVpHSFQxUEFLWU13UXhNRTJqaVNvL2dFd0JycnErdTQxWk95KytvRDRCYUNjc1hUUGlTSTNleThzNEtHb0c4UXdDTUZNKzBnZ1FoTFIwQkYxOVNYdUQvYXlha3o3dVIwL1RzTWN4ZzNTamZxV05BMGhzcmdhL29qYXEvOFdQY0MrWUlrNEtlNENNU3VCMlhWaHQxT2o4eklmWGxVOEJ0VThEaG1ZUlhXZGZyZEYxZmdyMytTOEF0NDhDRDA0RFZqWFFTRE83MFBUVW5hSjV1T0N3c0lJRkhTU0Z5MXBLUFdDRHNaeENwdzhVVmdLU1B4TFhNOTM3T3p4eEFsanpjUEFiY3N3VTRRaDRWM1VOOG1Lb2VLbS9idTc4SWZLSlFhOFZENDhDeWxIUWlMM08zL3FnNVJmMzBCS0FDTXRKWGpYS1FjZkJTSzhEZnFjM0tWQ3d1TjJWRkdSbm0veUtadHE0UmU1aWZ5UVFnTTJBK0JlQjNHSGFaQm81TUFJdWUwbDdLdDNjQzR4aHcrNWVMN1R1Q2tKazFqQnR5ZXJiVWZZRzVFeGpaL3BxcnhFNWZBT3JPcTVTbW93VklyUnAxSXlUMlI2K2ZnMGJnVllHNENzeVplMlVzYWlPR0tYcjRTZnA5azhDeENZQUZTS3l2WGVZMW8xQnhRdXg5MXlNdGZzSFB1dGdubnlVdVV2aGMwWnNnVVhpYituVmtxNitaS2FBQklIc2dWWm51d0Q5c1ZvNjZyclI0SW1kaExHU1E4elBML0pnQlF4ZVUxb3VXa085UFRnRHpiZ21YeHJ6TWthdGwza2VpdmZHNXg0cjRJUmN6NUJma081dkVaMGtncElmQlo4eUtqbEwxN3N5eTB0TU5jT245ZGw0Rnk2ZExGYWJqMU1wdm93OUlmeStJNE5sbzlYdCtacVU5VmRKcHFaaDRRRER5eFV5WU9ZSndIRGcrRGhnSS9XVVZabDdhU0V0OTMrR085SWEyaXVaS09mQTdsaHA5SnB2QVZ5NjF3Mm1Pd081aG1DZ01IQzFIOU8yNGd1NlVEOWpQK1ptYnRMUmFTc2VpOVNMNFhEUGJBRWgva0dRL3BTVWNjMGxiQXBGV2I2N2xRVWhwVm5MQnNvS3FxWmNsRk1tVXRyeFBjd3hsM1g3dk9DQXRZTFNDY3VnRlFtcWhkc3NIN0hVK1J6bmppT2xZWEE4d3FrT2ZrSXRUQW9tK29LeWdjYTRFUzhqWStOM3o3ZlNHNGhmVXRwM2loVUhydVZTc0Z5MWlSdk5QKzFON0E1QmRKQUNtVnBBZ1pQaEdPeUNpZ0VqbFBMdWRuN2t2RnRPeHVCNGc2T2pEOFVXTFJrQ1pGUndyTENFWEpRUWhwMksrMzdsUWVCQ1JYMUE3S1BRdG8xcHJGRW1TWW4ybUI5RUFzTytrWWZrOEtRaFpGOHlqVno1Z3AvTXp0eU9VamlXOWJDVWhFQmhLUkNDZ1NpczQ1dVEvUGhYL3hmRldNZ09uV3UyZ3hCMFRGL28wa0VaL2tDRE0xVHMrM1JIWW53VlVMNlhoREZyQXN3ZklCNnc2UDFNclR1bFkwc3VtMVZJQ2dsS3dDRUFDcXZRRkNVSzNnSGNzRlFDTS9JTGF5cVAxazlKc2hWcXJuY01hbE9ZWXZnY0dBeUN2SXd1b2Q4WUJKUW1acG1HSmV5UndrR3c0bjhqSk9KUU53M2lkTEZoTVJOQjBTZ0FTVEp5S295LzRpZVhDZUZmSkJVZVYyU29BY2xGeVIwYmJtMU9IVFVpTjAvRFRBd0Q3elFlTTUyZHFqOFZzR0VrVkUyaktldEc3QUVoUTBmckpBdjZSQzB0ckMxc2tsK0lXbE5pbkdMYlNhWmc3TWMweGZBOE1iZ0YxTFFWMXowOEEyRzgrb003UFZGOU1zMkdVRTBnUXlwK0x3dTJ5YWdMZ1I5WmFZcGtTeXBRNmE2UTJEQ3F6cGt2aWV0WElGZG9aZnVpZUdtY09EMERlUDBIRWJCaE53WVBtQS9MOHpKUXNBVEFLbmd1RXFTK1hUcWtFNFlmV1d3Q1VGWlRrc1lBWXdaZklCZU45VHcwY2pPd3U4Z0RJWnFzb1NTdmhFZVFEaWlHWUZveVdpU0RSeXBXZ2k2OVVQNXNjNWZJY3F1U0NOZVhxZTJYOVpBSGZNN0toZTJwY09CK0FUNDErYU81aVJEM1FBSEJFSGQ5Y3R1aUJCb0FORWtiYUF3MEFSOXI5emNVYkFEWVlHR2tQTkFBY2FmYzNGMjhBMkdCZ3BEM1FBSENrM2Q5Y3ZBRmdnNEdSOWtBRHdKRjJmM1B4Qm9BTkJrYmFBdzBBUjlyOXpjVWJBRFlZR0drUE5BQWNhZmMzRjI4QTJHQmdwRDNRQUhDazNkOWNmT3hxWUoyYXU5UmRQdGRwL2tob0VPbGdsRFlUMzlWMVB6UUZYTHNNWEFsZ3Q5UEN4SktQYnVmeWY4L0tISVBmQlBBWkFCZjc5WGM1WFEwWlExUTczNjBOYnhvSHJsc0R2czVaUnNnbzB1bmUwNmJ5NlgxbVp2dFA5OVBOQXA0RjRMc0JYQTVnanc4RUdUZXFhR0Y0UWh6UUY4MENYN2NBdkdJZGVEWUFmaGRaMnNUS1VjVnJwRTduZDMxTjVnajhlMmRJbzJvc2s3TlpwTWRLMFoxOXR2K2JKNEY5SzhEMUFDajh5Zk5TaWtIZWcrNVo5NjltNTdZLzgvWlArZFBMS1poUC9yY0ErQVlBRjdnMW9SVWhFTVV6Rk10NmVTSmZYNzhiMkRrUGZNMGk4R0lBWCt1V2xBTXBwcmVVVUVybjhwMmd6VGwrMmZsZy9zRGJUa3ZJT2lrK0NQMjAvL216d0FYendEY0N1TlRQSmVGWHBFcE02UUVqSUhtL3pURjhEN1Q1Z0FUWU5RQ2U2OWFBbG9SVEd1bGZCRVNCU1lOeXhSNWcvQmh3N2hLd1p3bDR2azlMbk01Sm1zQnpVeURHQVgzQjhHMjNNei9nOUJ1VWEvMElpdXRmTWtqN3p3S21uZ0F1WFN2T3BVdkFXWUJ0RjRCVG5zcElqL084elBhZjdxZHZXSVR3NmVaQTBKTFFFaEtFR2d4WmhVai9kejNOelNLd2JSNDRleG5ZdlZLY3krbU01S20wSmh4SW5VdHJHa216Q1BpY2czVzVMTUdrUWlaWlRtOXhTOVozKzRtMm84QzVjNFgxNXBUS1cyTGIrZkN4N1dMdGpZeHpxaXFsMjlJY3cvZEE1U3FZZjZSVFRpbGcrbFlDSVhtSUNLUTRJSzl3eGZTSlk4QVpLOEN1RldEbmFuRXVhOVpUQU1zYUNvZzNEdDkyTy9Ndm5SR0J0R3drcUtSbU1Fa3FDYWErMmsrMExRRFRoNHJQODhVSGo3NGtGMVdhQVRvOVFIUTdtbVA0SHVnWWh0RUtqNFBCNlpRK0ZTMGhRYWhwbGRQeWExa1hUT3FOWThEc2NnRytIYXZBdHRVQ3ZCeEluaXRya2dMNGxjTzMzYzdzcEJkTTNrQXVTbnEybng5Z1FmQWg0SnlWd3ZyeHdlbDJ6M3A0YU1sekg2RE0yei9sVCs4YUIrUS9PVDRFRXFja1dRU0JrR0Q2RVFLUW5EQ0x3QlNuWWdjZjMyZlhpb0dVRmF3QzRlc3l1N0NYWG5EUDl0T0NzeUQ0S0xCMXJtZ3ZYN3pmYnUyV0cvSnRtZTAvM1Uvdkt4Qk5BTW9pMEtjamtBVENOM0hPRXIzVUFqRHJ3T1A3MXJYaXhZRWtlS01GbFNYOG9jd1I2S1VYVEo3QWFORTJ0RjhXZkE0WWU3S3cxbXd2WC95Wm4rZUtudmNyZnpDNklLL09iUC9wZm5wZkFHUW55U29JU0JxVVh5QUFTUzFBSzBKZmFnV1ljUkRPckFGNjZUeFpRVTdqQk9FYk0wZWdINzFnY2dYU0ZaQVY1NE5RdGo5WWNOSXBiT05DeWg4WWdpOENWb3NwQXBEdUI2M2c5MlcyLzNRL3ZXOEFzcU00Z0xJS0JCSUg4YmNKd01DTk1YNjhCVHFCYjhzNnNHV3RzSUE2andEazY2MlpJOUN2WGpBNUE2TlZhMnQvSUFpY25DL2FHVis4VDc0SVFQbS9BbUd1QmMrOC9WUCs5SUVBeUxzbEFLTVYvTGdBeUlVSW5mbmp3UFFxTU9PZ0kvRHN0UTVNcjdVQXFNRjhWMllYRHFvWFhObCtFUVE2Tjl2MjlhS2Rlc1VwV0paYkFQeVBtZTAvM1U4ZkdJRHNzRGlkL3BVQVNDdkNhWGdKbUZndUFFZmdFWFQyN2dEa3V3YVVnL25ibVNNd2pGN3dodmJMaFNETDVUd3d2ZFJxbzlvcUh6QUNrQ0I4VTJiN1QvZlRod0lnTzAxVDFJTUNvQVp4R1JoYktvQVhRVWNRVGprSSthNEI1ZTVGempHc1h2Q0c5Z2RxckxHRllycFZHL1V1SHpCT3cyL0xhWHh6Ymg0M0RLZW9Kd2xBSHFMbmRTczR1ZG9Db0lCSFFFNDVFUGszRHVpdG1ZT1FveGRjdHA4K3JGd0lXc0dGWWlGRm9MR05jaGNFUUM2ZStPSkM1SjJaN1QvZFR4L2FBcFlkSjM3QXlKSy9ESXd2RnhZdldyMEl3RW4vSDFPcGNvNXN2ZURVaFNBQUY0SEpwUUprV2l4cDZrMm40SVlmTUdmMGFtREhldjJJOCtsNC9VYnZOdzhFb3p3NzJ3SmVQT0o4dW5kN0VrS2o5enRLR0ExLzdXd0FUbzQ0bjQ1cFdJM2U3L0FBR1BXWjJRQmtZSENVK1hUTWZHR1FtWUl4amQ3dnFPRTArUFh6QVRqaWZEckt0VFo2djRNUC9NbHlSajRBUjV4UEYrVmFxWkxKRjFVektkUFY2UDJlTEREcjNJNThBSTQ0bjA3Wk1BUmJvL2Q3OGdNdWJXRStBRWVjVDhlOVlPbjJVaGV1MGZzOXRVQ1lEOEFSNTlNcEc2YlIrejIxZ0tmVzFnTkF6NGdlUlQ1ZFRFWm85SDVQUFJEbUF6Qm1STThCSnpxZkxpWWpTS0tyMGZzOWRZQllEd0JIbUU5WHRSZk1zSXowNGFRWjErajlucHlnckErQWtxczh3ZmwwQkNDVFdScTkzNU1UWUwxYVZROEFvMXpsQW5BaTgra0VRR1pUTlhxL3ZZYjc1UHQvZlFBY1VUNWRCR0NqOTN2eUFheFhpK29Eb0ZMeVQzQSszUmNhdmQ5ZVkzeFMvejhmZ0NRWC9MUFIzU096a29uNTVqZzFleUFmZ0Q4TTROY0FQRDZhRG1CdEIxZTROTUROY2VyMVFENEFid2J3eHdEZTRVdlJFOXdIWkcxZ05TWERMbHdMTmNlcDFRUDVBUHh6endqOUlJQVBuWGhUNU9SYzVFWUNBOUhOY1dyMVFENEFtUkg2RlFCTVRTWlpIOThabUQ1Qmg1ZzFGb3BpTm5zMXg2blRBL2tBdkFmQUV3RHVkbkkrRXZReFBma0V6WWZhQ1hSU0JsdVFNQjdZSEtkR0QrUURzQk5CSC85K0FrQW9icVRBREdLN0ludzF4OG5mQS9rQTdFWFF0OGtnckdBR01mQnhaNUN2NWppNWV5QWZnTDBJK3I2OHVSMFFtVUZvQlFVOHZmTnZ6WEh5OWtBOUFPUm9NdzdDZEdRQ2pvVVpEd0w0a3YvKzhPWjFnSmhCSWpHRGdNaDN2VGF2QmMwMzUvUkFQZ0Q3SmVnak9EZmhpTXdnb3FlSndOUFBUYUI2RXpxL2hxK3NCNEFjWGVYRVArWmhHVm85dlJpbUlRRDV2NW9QQVpDdXBnREk5d2c4L3F6LzFYejU1dXN5ZXlBZmdNTVE5R1UyT3A0ZUFjaHBPSUpRUUV6L1Z1UGxtNi9LN0lINkFNamdHemRsNlF0eVg1aldqcFFGZXZGM2xxM3hmNnlock9sSUFVZ1FDb2pSOGdtRStsOU5sMisrSnJNSDZnRWdSNVVBNUtZc2MrQVptQ2JRQ0RpK0l2Z0VRTW9iMVhCRUFISWFqZ0JNTFYrMGtDZHdzNmFHdTN6cWZrVjlBR1R3amZ0ZzNKUlZWUkF0SFFFWFgvd2JBY29YUDVkNUNJRDhHb0pLdnFEQWxvS09vSXoveTd4OGMzcG1ENHpoYXF3alJ6Q1l5UWc1Z3IyWmdzRlRMd2VXcjhYUWdzWGpid0xXcm5OdE1sS2dOb0xCbVpBYTdQVENBdVlJQmxNdmxXUXN3d3IyVWxVdzQ1amREU3g4SGJEK0N0ZCtIVkN3ZVBLYmdKVjlhQVNETThZZzU5VFdGRHlzWVBCdG1ZSzkxSWJOT0hhUEEvTTdnVVhLWEE0aFdEejc5Y0E4K1cwYXdlQ01VUmorMUhZZmNCakJZTzU0TU1ZM3RHRHY4STNubVdTSE96WU9MSjBMTFBHWEFRV0x6M29COE1RVXNFYTE2a1l3T0c4d2hqaDc0eUprVU1GZ2JzTmxDZllPMGVwd2lzc1ZZMzRic0h3MnNFSVJrQUVFaS9kY1UwU1A1cWhGMWdnRzV3M0dFR2RYcjRMNTEzNEZnNGtBanVEUWdyMUR0RHFjVW1aRVR3QXJad0FydTRCVnFzdjBLVmg4L28zRjR2MFFYWkJHTURodk1JWTR1M01ZaHY5NVpoK0N1MXhCY3h1T1UvSGZlRElxNWN2N0Z1d2RvdFhobENCWGpPWFpBbnlyTzRCVjZpbjBJVmg4d1N0THVXQ3NVQXl2RVF6T0c1QUJ6KzRlQitSL2V3bnUva09QLzNHL2w0a0pURVJsbGpRdElvdDJlNTMvSXdPMk9QbDRGTHRjbkNxQXA5Y2FoVDU2Q0JaZitMcFNMaGh6MU41cUJJUHpCbVRBcy9zTFJIY1RES2JpTkhkQkdHeW1PQy8zaGdsRXZnakFub0s5QTdZNCtYZ2lWNHpWV1lEQXMvZXR4YXViWVBGRlAxUWtMdENJUDhuZWFBU0Q4d1prd0xQN0F5Qy90Sk5nOEwveExOQnUrWUJkQlhzSGJIRUZBSU5jTVZhbWdkV1pBb1JyZlBkWG04S2l0TGRtZ1l2ZVdBcSsyeTdpTXFmdVJqQTRiMUFHT0x0L0FQSkxxd1NEMyt5NVQxeUkwQW9TYkF4TU16R1YxbzgvTXkycm8yRHZBSzJ0K0dnaVY0emo0KzNBSXdEWHR3QnJWSmV1RUN6ZSs5YVc0RHV0NFB4a0loWXNkZXRHTURodm9EcWNQUmdBK1NXcDRPNHZlUTVVdi9tQUd3Ujc4KzZyUXE0WXE5UEFPaTJmQTQvdkJrS3VkS1ZVN1Zadzc3dUt2V0Z1WmJ0Y01OYjV2MFl3T0c5ZytqeDdjQUR5aTZQZzdnY2NnSXhsY0E1VEtoYUQwMXlZS0JtVkZwQlpNZngvbTJCdm55M3Q4TEdxb3FUbGlaYlZJK2dNZ0h3bk1BbkNJRmk4OTdjTEFBWjZReXpGenpTQ3dYa0QxT1BzNFFESUw1WGdMbWs1SkhrL1NENWdLZGliZDM4VmNzVllHbXVCVGFBekVITEhneUNjYW9rQjcvMUlrVUVUNUlLeHdGNXBCSVB6QnFiUHM0Y0hJQy9BYWVxdlBMOXBtSHhBRSt6dHM2VmRMQ0QvbGNnVlkzVXlXRDBCajFad3FnQ2dnWEE3c1BmV0FvQUp2YUV0WkJyQjRMeXg2ZWZzUEFEeUN0bUN2ZjAwcy9Obk9zZ1ZZM204QlRSWlBadUdCVUFDZEFyWSs1bFdEcUdtWWJJckxIRXgwZ2dHNXcxT0gyZm5BN0NQaXpRZmFYcWdVdzgwQUd5d01kSWVhQUE0MHU1dkx0NEFzTUhBU0h1Z0FlQkl1Nys1ZUFQQUJnTWo3WUVHZ0NQdC91YmlEUUFiREl5MEJ4b0FqclQ3bTRzM0FHd3dNTkllYUFBNDB1NXZMdDRBc01IQVNIdWdBZUJJdTcrNWVBUEFCZ01qN1lFR2dDUHQvdWJpRFFBYkRJeTBCOFpZTk1ia1grWmVrcHVJaU9RclBhcit4czg4OUhKZzZqWmc1akF3dlZaOEIrbGw5UGxPNS9GYy9vK0VDam5IZmk4ellma3ZNNXVsbXA0cUpYVnF4NWRlRDR6ZkFrdy9DR3hkQVpnb0hmdWgxMzFRa2FJNWh1OEJzNERzOEIwQVdMbklSR0NCc0Zmbjg3SmZmRE13ZGpPdzVSNWc4Z2l3WmEzNGpuUVFVd0RvOTl3QmZKNFRNN0NPaU5kbGFqMnJBL2plVi92ZkRlQVRBUDRVR0g4STJMcmM2Z2MrU0hxWTRvTVo3NFZTS00weGZBK1VVekIvb0JVVUNLTWw2elNRL1BzWHFaRDVLUUMvQTB3L0RFd2NBY1lYZ1luVndwcHdBRHVCa2VmbkNpbTkwRm1CV1h3bks4N1VlbjUzQkk4c2J1d3FhejlwNVVnblFoQlMrWk4xekU4QWswdXR2aUN3cThESTgvbng1aGkrQnpiNGdKektaRTFTRUZaWmdTOS8ycFdSL2dUQUo0SEpROERFTVdCOEFSaGZCc2FXQ3dEcXV3UUt2dk5nSFh2T2NZVmJQRkpQa3crZER4Qy9XMVk0dFdEcHcvUmxnbzRsbzFUNC9LeFRpaEROcEp3ajMvVWlNTFhlbXByamZmQzdlV3B6RE44RGxZc1FEaUt0Vnh6RXFvSGt5WDlIUml6VytuSWdhUW52QWlhZUJDYm1DMHM0dGdTTXUyck1lUEFSOVgyNTJqWGtsYVRGVTEwOEswTUhhdi9udko2WnhWVms5T0k3R1IySVpvR1FOYy9IZ2JIZ0l3cUlMSVZ1anVGN29PTXFXRmF3Q29SeGtmRUlCNUNXZ2tSRUJDTmY5d01UYzhBNFFjaUJXeW9HejE2cndOZ2FNTDVlV0twY3RZWkwzTitUV0xYMGd2dHVQMEhIazJuMTZKRHl4WG1WaGZVMHF5d2JKYnI1R1N1WEt4QS9zVjVZOVVZV2Ruand5UzNxS0tnYXJXQTY5V2c2ZmpRT0lLMEhhZG5JalBWRkIrQWlNRTRBdWlVa0NGbkVTeUNTa21BdVU3Q2ptMTV3WCsyWDJpZkJSbjlBOG1LY1cyVUZqVUxWUWNnVkRsODB1NDBTWWg3NjNGZnZxdWhMQ3hpdG9CWVVzb0pmalhLdHRCeU1xOUNLY0huNHNQdUNiZ1hOSnd5V2tFQ2N6NVEzNzZVWDNMTm5jWnlRQUFBREVrbEVRVlQ5ZkZnSUpzNmxCQnd0bjNUdDZGcEl6NFJXbnVReFBoMlhJR3ptNEN3UTloV0lGZ0JUSzBnUUhpSUFKZGRLcTBFTFFoK0tMMXFVUjRNdlNFc29FTklLcmdBTEhOaU1veCs5NEs3dGw5cW5uTWlvOE1TZjZTTndHcFlWakNEay9KdTdpc3E0OTZmQ3FYMEJrRGVxbFd3S3dpYzFnQVFTcHpHUkVuRmdSRXowMWVBTEx2dnEyS2ZpNDVtNmNmM3FCWGRzZnhSYkpNaG84ZGltcU9oRUs4Y1hRUnI5UVZwdlBvRE5NWFFQOUEzQUNFTEZ4UGgrakFDa1AwZkxJS0ZDQ1JScUt1UFVkcWpsQzlvMDdKWndLVk5IZUJDOTREUWNaTzBYQUFrbWdvdEFrOVFZclI5Zi9CdkJ5WWZNU0FURFZNendUWE1NM1FNREFWQWdWSENaNy9NYVFLNFFaVUhpTkNiQlFscVV3NzRZQ2I3Z2NtWWtlbEM5WUZsd3ZWdjdSUkFvclR1QmtFQ1U5YXNDSUQ5L3g5QjkzNXpZenlLa3FwZmlOSHhjQTBnTFFndkJBYVBWa0NxbTNoMkF0QzVtL1J5RXF6dy80eGhHTDNoRCsrTW1zbGdxQ2JnVWZMS0FjUnJtVGxCekROMERBMXRBWFVsV2NEbTFJT0lJSkFqbFQvRmQwNWxiRlFGd2pkdGdHY2V3ZXNGdDdSYy9HeDhpV2pVQ2pHQ1QxWXZXVDFNd2dVcXJmM05HNDV0VGJjdTBheGltV3g5eEVOY0VRSEdiY1lBRXd0U1hTcVkwZ25DZGdldU1JMGN2dUd4L0ZVR2dGaHdFWXJSODBRY2tXTitYMGZqbTFEd0FXdjhSZ0pGaWxKWkJ6bnowcFFnK0FaQUFsVldoMUd2R2thMFh6QjBjQ1FpMzBhU0dWYTlBRjYyZkxPQjdNaHJmbkpvUHdQRVI1OVB4K28zZTc2bUw1S3dwMkc1N3hQbDBreGMzZXIrbkx2eUt0TG1oZlVDNzhSSG4wODFPTm5xL3B6Y0FSNXhQUjltUlJ1LzMxSVZndmdVY2NUNGROYW9idmQvVEdZQWp6cWVqdW1xajkzczZBM0RFK1hSVWcyVlNDamRhR3IzZlV3K0krVlB3aVBQcHFKak84SjFOdzQzZTd5bUh3SG9BS01GZDdRRXJBZUVFNU5OSk1iM1IrejNsc0djTnpnZmdpUFBwb21KNm8vZDc2b0d3UGdDT0tKOHVLcVkzZXIrbkt3QkhtRStub3FSRzcvZlVBMTk5VS9BSTgra0V3RWJ2OTNRSG9FaFpUbkErbllxU0dyM2ZCb0F0YWlxQlVJbWRtNWhQSndBMmVyK25Ld0JIbkUrWDFnVXpTYm5SK3oxMXdQai9BZUNwUEREM3Q3cnZBQUFBQUVsRlRrU3VRbUNDXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvc21hYS5mcmFnXG52YXIgc21hYV9kZWZhdWx0ID0gYHVuaWZvcm0gc2FtcGxlcjJEIHdlaWdodE1hcDt2YXJ5aW5nIHZlYzIgdk9mZnNldDA7dmFyeWluZyB2ZWMyIHZPZmZzZXQxO3ZvaWQgbW92ZWMoY29uc3QgaW4gYnZlYzIgYyxpbm91dCB2ZWMyIHZhcmlhYmxlLGNvbnN0IGluIHZlYzIgdmFsdWUpe2lmKGMueCl7dmFyaWFibGUueD12YWx1ZS54O31pZihjLnkpe3ZhcmlhYmxlLnk9dmFsdWUueTt9fXZvaWQgbW92ZWMoY29uc3QgaW4gYnZlYzQgYyxpbm91dCB2ZWM0IHZhcmlhYmxlLGNvbnN0IGluIHZlYzQgdmFsdWUpe21vdmVjKGMueHksdmFyaWFibGUueHksdmFsdWUueHkpO21vdmVjKGMuencsdmFyaWFibGUuencsdmFsdWUuencpO312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjNCBhO2EueD10ZXh0dXJlMkQod2VpZ2h0TWFwLHZPZmZzZXQwKS5hO2EueT10ZXh0dXJlMkQod2VpZ2h0TWFwLHZPZmZzZXQxKS5nO2Eud3o9dGV4dHVyZTJEKHdlaWdodE1hcCx1dikucmI7dmVjNCBjb2xvcj1pbnB1dENvbG9yO2lmKGRvdChhLHZlYzQoMS4wKSk+PTFlLTUpe2Jvb2wgaD1tYXgoYS54LGEueik+bWF4KGEueSxhLncpO3ZlYzQgYmxlbmRpbmdPZmZzZXQ9dmVjNCgwLjAsYS55LDAuMCxhLncpO3ZlYzIgYmxlbmRpbmdXZWlnaHQ9YS55dzttb3ZlYyhidmVjNChoKSxibGVuZGluZ09mZnNldCx2ZWM0KGEueCwwLjAsYS56LDAuMCkpO21vdmVjKGJ2ZWMyKGgpLGJsZW5kaW5nV2VpZ2h0LGEueHopO2JsZW5kaW5nV2VpZ2h0Lz1kb3QoYmxlbmRpbmdXZWlnaHQsdmVjMigxLjApKTt2ZWM0IGJsZW5kaW5nQ29vcmQ9YmxlbmRpbmdPZmZzZXQqdmVjNCh0ZXhlbFNpemUsLXRleGVsU2l6ZSkrdXYueHl4eTtjb2xvcj1ibGVuZGluZ1dlaWdodC54KnRleHR1cmUyRChpbnB1dEJ1ZmZlcixibGVuZGluZ0Nvb3JkLnh5KTtjb2xvcis9YmxlbmRpbmdXZWlnaHQueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsYmxlbmRpbmdDb29yZC56dyk7fW91dHB1dENvbG9yPWNvbG9yO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3NtYWEudmVydFxudmFyIHNtYWFfZGVmYXVsdDIgPSBgdmFyeWluZyB2ZWMyIHZPZmZzZXQwO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0MTt2b2lkIG1haW5TdXBwb3J0KGNvbnN0IGluIHZlYzIgdXYpe3ZPZmZzZXQwPXV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwwLjApO3ZPZmZzZXQxPXV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwxLjApO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9TTUFBRWZmZWN0LmpzXG52YXIgU01BQUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgU01BQSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtTTUFBUHJlc2V0fSBbb3B0aW9ucy5wcmVzZXQ9U01BQVByZXNldC5NRURJVU1dIC0gVGhlIHF1YWxpdHkgcHJlc2V0LlxuICAgKiBAcGFyYW0ge0VkZ2VEZXRlY3Rpb25Nb2RlfSBbb3B0aW9ucy5lZGdlRGV0ZWN0aW9uTW9kZT1FZGdlRGV0ZWN0aW9uTW9kZS5DT0xPUl0gLSBUaGUgZWRnZSBkZXRlY3Rpb24gbW9kZS5cbiAgICogQHBhcmFtIHtQcmVkaWNhdGlvbk1vZGV9IFtvcHRpb25zLnByZWRpY2F0aW9uTW9kZT1QcmVkaWNhdGlvbk1vZGUuRElTQUJMRURdIC0gVGhlIHByZWRpY2F0aW9uIG1vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDLFxuICAgIHByZXNldCA9IFNNQUFQcmVzZXQuTUVESVVNLFxuICAgIGVkZ2VEZXRlY3Rpb25Nb2RlID0gRWRnZURldGVjdGlvbk1vZGUuQ09MT1IsXG4gICAgcHJlZGljYXRpb25Nb2RlID0gUHJlZGljYXRpb25Nb2RlLkRJU0FCTEVEXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU01BQUVmZmVjdFwiLCBzbWFhX2RlZmF1bHQsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogc21hYV9kZWZhdWx0MixcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuQ09OVk9MVVRJT04gfCBFZmZlY3RBdHRyaWJ1dGUuREVQVEgsXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJ3ZWlnaHRNYXBcIiwgbmV3IFVuaWZvcm0zOChudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgbGV0IHNlYXJjaEltYWdlLCBhcmVhSW1hZ2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBzZWFyY2hJbWFnZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGFyZWFJbWFnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICBwcmVzZXQgPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgZWRnZURldGVjdGlvbk1vZGUgPSBhcmd1bWVudHNbM107XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxNCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEVkZ2VzLnRleHR1cmUubmFtZSA9IFwiU01BQS5FZGdlc1wiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cyA9IHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldFdlaWdodHMudGV4dHVyZS5uYW1lID0gXCJTTUFBLldlaWdodHNcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIndlaWdodE1hcFwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyh0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjgoMCk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckFscGhhID0gMTtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25QYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCgpKTtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uTW9kZSA9IGVkZ2VEZXRlY3Rpb25Nb2RlO1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLnByZWRpY2F0aW9uTW9kZSA9IHByZWRpY2F0aW9uTW9kZTtcbiAgICB0aGlzLndlaWdodHNQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IFNNQUFXZWlnaHRzTWF0ZXJpYWwoKSk7XG4gICAgY29uc3QgbG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcbiAgICBsb2FkaW5nTWFuYWdlci5vbkxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWFyY2hUZXh0dXJlID0gbmV3IFRleHR1cmUzKHNlYXJjaEltYWdlKTtcbiAgICAgIHNlYXJjaFRleHR1cmUubmFtZSA9IFwiU01BQS5TZWFyY2hcIjtcbiAgICAgIHNlYXJjaFRleHR1cmUubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjQ7XG4gICAgICBzZWFyY2hUZXh0dXJlLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI0O1xuICAgICAgc2VhcmNoVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgIHNlYXJjaFRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgc2VhcmNoVGV4dHVyZS5mbGlwWSA9IHRydWU7XG4gICAgICB0aGlzLndlaWdodHNNYXRlcmlhbC5zZWFyY2hUZXh0dXJlID0gc2VhcmNoVGV4dHVyZTtcbiAgICAgIGNvbnN0IGFyZWFUZXh0dXJlID0gbmV3IFRleHR1cmUzKGFyZWFJbWFnZSk7XG4gICAgICBhcmVhVGV4dHVyZS5uYW1lID0gXCJTTUFBLkFyZWFcIjtcbiAgICAgIGFyZWFUZXh0dXJlLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjU7XG4gICAgICBhcmVhVGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI1O1xuICAgICAgYXJlYVRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICBhcmVhVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBhcmVhVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGhpcy53ZWlnaHRzTWF0ZXJpYWwuYXJlYVRleHR1cmUgPSBhcmVhVGV4dHVyZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwibG9hZFwiIH0pO1xuICAgIH07XG4gICAgbG9hZGluZ01hbmFnZXIuaXRlbVN0YXJ0KFwic2VhcmNoXCIpO1xuICAgIGxvYWRpbmdNYW5hZ2VyLml0ZW1TdGFydChcImFyZWFcIik7XG4gICAgaWYgKHNlYXJjaEltYWdlICE9PSB2b2lkIDAgJiYgYXJlYUltYWdlICE9PSB2b2lkIDApIHtcbiAgICAgIGxvYWRpbmdNYW5hZ2VyLml0ZW1FbmQoXCJzZWFyY2hcIik7XG4gICAgICBsb2FkaW5nTWFuYWdlci5pdGVtRW5kKFwiYXJlYVwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBJbWFnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgc2VhcmNoSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGFyZWFJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgc2VhcmNoSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gbG9hZGluZ01hbmFnZXIuaXRlbUVuZChcInNlYXJjaFwiKSk7XG4gICAgICBhcmVhSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gbG9hZGluZ01hbmFnZXIuaXRlbUVuZChcImFyZWFcIikpO1xuICAgICAgc2VhcmNoSW1hZ2Uuc3JjID0gc2VhcmNoSW1hZ2VEYXRhVVJMX2RlZmF1bHQ7XG4gICAgICBhcmVhSW1hZ2Uuc3JjID0gYXJlYUltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICAgIH1cbiAgICB0aGlzLmFwcGx5UHJlc2V0KHByZXNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlcyB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBlZGdlc1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRnZXMgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VzVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldEVkZ2VzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlc1RleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIHdlaWdodHMgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgd2VpZ2h0c1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIHdlaWdodHMgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodHNUZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0V2VpZ2h0c1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMud2VpZ2h0c1RleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0VkZ2VEZXRlY3Rpb25NYXRlcmlhbH1cbiAgICovXG4gIGdldCBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvblBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWRnZSBkZXRlY3Rpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtFZGdlRGV0ZWN0aW9uTWF0ZXJpYWx9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICovXG4gIGdldCBjb2xvckVkZ2VzTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIGRldGVjdGlvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtFZGdlRGV0ZWN0aW9uTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIHdlaWdodHMgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtTTUFBV2VpZ2h0c01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IHdlaWdodHNNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWlnaHRzUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkZ2Ugd2VpZ2h0cyBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodHNNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTTUFBV2VpZ2h0c01hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRXZWlnaHRzTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMud2VpZ2h0c01hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBlZGdlIGRldGVjdGlvbiBzZW5zaXRpdml0eS5cbiAgICpcbiAgICogU2VlIHtAbGluayBFZGdlRGV0ZWN0aW9uTWF0ZXJpYWwjc2V0RWRnZURldGVjdGlvblRocmVzaG9sZH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIGVkZ2UgZGV0ZWN0aW9uIHNlbnNpdGl2aXR5LiBSYW5nZTogWzAuMDUsIDAuNV0uXG4gICAqL1xuICBzZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkKHRocmVzaG9sZCkge1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gYW1vdW50IG9mIGhvcml6b250YWwvdmVydGljYWwgc2VhcmNoIHN0ZXBzLlxuICAgKlxuICAgKiBTZWUge0BsaW5rIFNNQUFXZWlnaHRzTWF0ZXJpYWwjc2V0T3J0aG9nb25hbFNlYXJjaFN0ZXBzfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugd2VpZ2h0c01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwcyAtIFRoZSBzZWFyY2ggc3RlcHMuIFJhbmdlOiBbMCwgMTEyXS5cbiAgICovXG4gIHNldE9ydGhvZ29uYWxTZWFyY2hTdGVwcyhzdGVwcykge1xuICAgIHRoaXMud2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IHN0ZXBzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBxdWFsaXR5IHByZXNldC5cbiAgICpcbiAgICogQHBhcmFtIHtTTUFBUHJlc2V0fSBwcmVzZXQgLSBUaGUgcHJlc2V0LlxuICAgKi9cbiAgYXBwbHlQcmVzZXQocHJlc2V0KSB7XG4gICAgY29uc3QgZWRnZURldGVjdGlvbk1hdGVyaWFsID0gdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWw7XG4gICAgY29uc3Qgd2VpZ2h0c01hdGVyaWFsID0gdGhpcy53ZWlnaHRzTWF0ZXJpYWw7XG4gICAgc3dpdGNoIChwcmVzZXQpIHtcbiAgICAgIGNhc2UgU01BQVByZXNldC5MT1c6XG4gICAgICAgIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gMC4xNTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IDQ7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5kaWFnb25hbERldGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyRGV0ZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTTUFBUHJlc2V0Lk1FRElVTTpcbiAgICAgICAgZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgPSAwLjE7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5vcnRob2dvbmFsU2VhcmNoU3RlcHMgPSA4O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxEZXRlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmNvcm5lckRldGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU01BQVByZXNldC5ISUdIOlxuICAgICAgICBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZWRnZURldGVjdGlvblRocmVzaG9sZCA9IDAuMTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IDE2O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxTZWFyY2hTdGVwcyA9IDg7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5jb3JuZXJSb3VuZGluZyA9IDI1O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxEZXRlY3Rpb24gPSB0cnVlO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyRGV0ZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNNQUFQcmVzZXQuVUxUUkE6XG4gICAgICAgIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gMC4wNTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IDMyO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxTZWFyY2hTdGVwcyA9IDE2O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyUm91bmRpbmcgPSAyNTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmRpYWdvbmFsRGV0ZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmNvcm5lckRldGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nOSkge1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgdGhpcy5jbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCB0aGlzLnJlbmRlclRhcmdldEVkZ2VzKTtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25QYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMpO1xuICAgIHRoaXMud2VpZ2h0c1Bhc3MucmVuZGVyKHJlbmRlcmVyLCB0aGlzLnJlbmRlclRhcmdldEVkZ2VzLCB0aGlzLnJlbmRlclRhcmdldFdlaWdodHMpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLndlaWdodHNNYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldFdlaWdodHMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cyBhbmQgdGV4dHVyZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHsgc2VhcmNoVGV4dHVyZSwgYXJlYVRleHR1cmUgfSA9IHRoaXMud2VpZ2h0c01hdGVyaWFsO1xuICAgIGlmIChzZWFyY2hUZXh0dXJlICE9PSBudWxsICYmIGFyZWFUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICBzZWFyY2hUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgIGFyZWFUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgU01BQSBzZWFyY2ggaW1hZ2UsIGVuY29kZWQgYXMgYSBiYXNlNjQgZGF0YSBVUkwuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNlYXJjaEltYWdlRGF0YVVSTCgpIHtcbiAgICByZXR1cm4gc2VhcmNoSW1hZ2VEYXRhVVJMX2RlZmF1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBTTUFBIGFyZWEgaW1hZ2UsIGVuY29kZWQgYXMgYSBiYXNlNjQgZGF0YSBVUkwuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgZ2V0IGFyZWFJbWFnZURhdGFVUkwoKSB7XG4gICAgcmV0dXJuIGFyZWFJbWFnZURhdGFVUkxfZGVmYXVsdDtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvU1NBT0VmZmVjdC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxMywgQ29sb3IgYXMgQ29sb3I5LCBSZXBlYXRXcmFwcGluZyBhcyBSZXBlYXRXcmFwcGluZzQsIFJHQkFGb3JtYXQgYXMgUkdCQUZvcm1hdDQsIFVuaWZvcm0gYXMgVW5pZm9ybTQxLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDE2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvU1NBT01hdGVyaWFsLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzEwLCBNYXRyaXg0IGFzIE1hdHJpeDQyLCBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxNSwgUGVyc3BlY3RpdmVDYW1lcmEgYXMgUGVyc3BlY3RpdmVDYW1lcmE0LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE2LCBVbmlmb3JtIGFzIFVuaWZvcm0zOSwgVmVjdG9yMiBhcyBWZWN0b3IyMjEgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL3NzYW8uZnJhZ1xudmFyIHNzYW9fZGVmYXVsdCA9IGAjaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPHBhY2tpbmc+XG4jaWZkZWYgTk9STUFMX0RFUFRIXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbm9ybWFsRGVwdGhCdWZmZXI7XG4jZW5kaWZcbmZsb2F0IHJlYWREZXB0aChjb25zdCBpbiB2ZWMyIHV2KXtyZXR1cm4gdGV4dHVyZTJEKG5vcm1hbERlcHRoQnVmZmVyLHV2KS5hO31cbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG5vcm1hbEJ1ZmZlcjtcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxpZiBkZWZpbmVkKEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIKVxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbmRpZlxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxucmV0dXJuIHVucGFja1JHQkFUb0RlcHRoKHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikpO1xuI2Vsc2VcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XG4jZW5kaWZcbn1cbiNlbmRpZlxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBub2lzZVRleHR1cmU7dW5pZm9ybSBtYXQ0IGludmVyc2VQcm9qZWN0aW9uTWF0cml4O3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O3VuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSB2ZWMyIGNhbWVyYU5lYXJGYXI7dW5pZm9ybSBmbG9hdCBpbnRlbnNpdHk7dW5pZm9ybSBmbG9hdCBtaW5SYWRpdXNTY2FsZTt1bmlmb3JtIGZsb2F0IGZhZGU7dW5pZm9ybSBmbG9hdCBiaWFzO3VuaWZvcm0gdmVjMiBkaXN0YW5jZUN1dG9mZjt1bmlmb3JtIHZlYzIgcHJveGltaXR5Q3V0b2ZmO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjI7ZmxvYXQgZ2V0Vmlld1ooY29uc3QgaW4gZmxvYXQgZGVwdGgpe1xuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xuI2Vsc2VcbnJldHVybiBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XG4jZW5kaWZcbn12ZWMzIGdldFZpZXdQb3NpdGlvbihjb25zdCBpbiB2ZWMyIHNjcmVlblBvc2l0aW9uLGNvbnN0IGluIGZsb2F0IGRlcHRoLGNvbnN0IGluIGZsb2F0IHZpZXdaKXt2ZWM0IGNsaXBQb3NpdGlvbj12ZWM0KHZlYzMoc2NyZWVuUG9zaXRpb24sZGVwdGgpKjIuMC0xLjAsMS4wKTtmbG9hdCBjbGlwVz1wcm9qZWN0aW9uTWF0cml4WzJdWzNdKnZpZXdaK3Byb2plY3Rpb25NYXRyaXhbM11bM107Y2xpcFBvc2l0aW9uKj1jbGlwVztyZXR1cm4oaW52ZXJzZVByb2plY3Rpb25NYXRyaXgqY2xpcFBvc2l0aW9uKS54eXo7fWZsb2F0IGdldEFtYmllbnRPY2NsdXNpb24oY29uc3QgaW4gdmVjMyBwLGNvbnN0IGluIHZlYzMgbixjb25zdCBpbiBmbG9hdCBkZXB0aCxjb25zdCBpbiB2ZWMyIHV2KXtmbG9hdCByYWRpdXNTY2FsZT0xLjAtc21vb3Roc3RlcCgwLjAsZGlzdGFuY2VDdXRvZmYueSxkZXB0aCk7cmFkaXVzU2NhbGU9cmFkaXVzU2NhbGUqKDEuMC1taW5SYWRpdXNTY2FsZSkrbWluUmFkaXVzU2NhbGU7ZmxvYXQgcmFkaXVzPVJBRElVUypyYWRpdXNTY2FsZTtmbG9hdCBub2lzZT10ZXh0dXJlMkQobm9pc2VUZXh0dXJlLHZVdjIpLnI7ZmxvYXQgYmFzZUFuZ2xlPW5vaXNlKlBJMjtmbG9hdCByaW5ncz1TUElSQUxfVFVSTlMqUEkyO2Zsb2F0IG9jY2x1c2lvbj0wLjA7aW50IHRhcHM9MDtmb3IoaW50IGk9MDtpPFNBTVBMRVNfSU5UOysraSl7ZmxvYXQgYWxwaGE9KGZsb2F0KGkpKzAuNSkqSU5WX1NBTVBMRVNfRkxPQVQ7ZmxvYXQgYW5nbGU9YWxwaGEqcmluZ3MrYmFzZUFuZ2xlO3ZlYzIgcm90YXRpb249dmVjMihjb3MoYW5nbGUpLHNpbihhbmdsZSkpO3ZlYzIgY29vcmRzPWFscGhhKnJhZGl1cypyb3RhdGlvbip0ZXhlbFNpemUrdXY7aWYoY29vcmRzLnM8MC4wfHxjb29yZHMucz4xLjB8fGNvb3Jkcy50PDAuMHx8Y29vcmRzLnQ+MS4wKXtjb250aW51ZTt9ZmxvYXQgc2FtcGxlRGVwdGg9cmVhZERlcHRoKGNvb3Jkcyk7ZmxvYXQgdmlld1o9Z2V0Vmlld1ooc2FtcGxlRGVwdGgpO1xuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxuZmxvYXQgbGluZWFyU2FtcGxlRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xuI2Vsc2VcbmZsb2F0IGxpbmVhclNhbXBsZURlcHRoPXNhbXBsZURlcHRoO1xuI2VuZGlmXG5mbG9hdCBwcm94aW1pdHk9YWJzKGRlcHRoLWxpbmVhclNhbXBsZURlcHRoKTtpZihwcm94aW1pdHk8cHJveGltaXR5Q3V0b2ZmLnkpe2Zsb2F0IGZhbGxvZmY9MS4wLXNtb290aHN0ZXAocHJveGltaXR5Q3V0b2ZmLngscHJveGltaXR5Q3V0b2ZmLnkscHJveGltaXR5KTt2ZWMzIFE9Z2V0Vmlld1Bvc2l0aW9uKGNvb3JkcyxzYW1wbGVEZXB0aCx2aWV3Wik7dmVjMyB2PVEtcDtmbG9hdCB2dj1kb3Qodix2KTtmbG9hdCB2bj1kb3QodixuKS1iaWFzO2Zsb2F0IGY9bWF4KFJBRElVU19TUS12diwwLjApL1JBRElVU19TUTtvY2NsdXNpb24rPShmKmYqZiptYXgodm4vKGZhZGUrdnYpLDAuMCkpKmZhbGxvZmY7fSsrdGFwczt9cmV0dXJuIG9jY2x1c2lvbi8oNC4wKm1heChmbG9hdCh0YXBzKSwxLjApKTt9dm9pZCBtYWluKCl7XG4jaWZkZWYgTk9STUFMX0RFUFRIXG52ZWM0IG5vcm1hbERlcHRoPXRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix2VXYpO1xuI2Vsc2VcbnZlYzQgbm9ybWFsRGVwdGg9dmVjNCh0ZXh0dXJlMkQobm9ybWFsQnVmZmVyLHZVdikueHl6LHJlYWREZXB0aCh2VXYpKTtcbiNlbmRpZlxuZmxvYXQgYW89MC4wO2Zsb2F0IGRlcHRoPW5vcm1hbERlcHRoLmE7ZmxvYXQgdmlld1o9Z2V0Vmlld1ooZGVwdGgpO1xuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxuZmxvYXQgbGluZWFyRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xuI2Vsc2VcbmZsb2F0IGxpbmVhckRlcHRoPWRlcHRoO1xuI2VuZGlmXG5pZihsaW5lYXJEZXB0aDxkaXN0YW5jZUN1dG9mZi55KXt2ZWMzIHZpZXdQb3NpdGlvbj1nZXRWaWV3UG9zaXRpb24odlV2LGRlcHRoLHZpZXdaKTt2ZWMzIHZpZXdOb3JtYWw9dW5wYWNrUkdCVG9Ob3JtYWwobm9ybWFsRGVwdGgucmdiKTthbys9Z2V0QW1iaWVudE9jY2x1c2lvbih2aWV3UG9zaXRpb24sdmlld05vcm1hbCxsaW5lYXJEZXB0aCx2VXYpO2Zsb2F0IGQ9c21vb3Roc3RlcChkaXN0YW5jZUN1dG9mZi54LGRpc3RhbmNlQ3V0b2ZmLnksbGluZWFyRGVwdGgpO2FvPW1peChhbywwLjAsZCk7XG4jaWZkZWYgTEVHQUNZX0lOVEVOU0lUWVxuYW89Y2xhbXAoMS4wLXBvdygxLjAtYW8sYWJzKGludGVuc2l0eSkpLDAuMCwxLjApO1xuI2VuZGlmXG59Z2xfRnJhZ0NvbG9yLnI9YW87fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9zc2FvLnZlcnRcbnZhciBzc2FvX2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjMiBub2lzZVNjYWxlO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjI7dm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dlV2Mj12VXYqbm9pc2VTY2FsZTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1NTQU9NYXRlcmlhbC5qc1xudmFyIFNTQU9NYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxNiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNTQU8gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiU1NBT01hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIFNBTVBMRVNfSU5UOiBcIjBcIixcbiAgICAgICAgSU5WX1NBTVBMRVNfRkxPQVQ6IFwiMC4wXCIsXG4gICAgICAgIFNQSVJBTF9UVVJOUzogXCIwLjBcIixcbiAgICAgICAgUkFESVVTOiBcIjEuMFwiLFxuICAgICAgICBSQURJVVNfU1E6IFwiMS4wXCIsXG4gICAgICAgIERJU1RBTkNFX1NDQUxJTkc6IFwiMVwiLFxuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTM5KG51bGwpLFxuICAgICAgICBub3JtYWxCdWZmZXI6IG5ldyBVbmlmb3JtMzkobnVsbCksXG4gICAgICAgIG5vcm1hbERlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTM5KG51bGwpLFxuICAgICAgICBub2lzZVRleHR1cmU6IG5ldyBVbmlmb3JtMzkobnVsbCksXG4gICAgICAgIGludmVyc2VQcm9qZWN0aW9uTWF0cml4OiBuZXcgVW5pZm9ybTM5KG5ldyBNYXRyaXg0MigpKSxcbiAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogbmV3IFVuaWZvcm0zOShuZXcgTWF0cml4NDIoKSksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0zOShuZXcgVmVjdG9yMjIxKCkpLFxuICAgICAgICBjYW1lcmFOZWFyRmFyOiBuZXcgVW5pZm9ybTM5KG5ldyBWZWN0b3IyMjEoKSksXG4gICAgICAgIGRpc3RhbmNlQ3V0b2ZmOiBuZXcgVW5pZm9ybTM5KG5ldyBWZWN0b3IyMjEoKSksXG4gICAgICAgIHByb3hpbWl0eUN1dG9mZjogbmV3IFVuaWZvcm0zOShuZXcgVmVjdG9yMjIxKCkpLFxuICAgICAgICBub2lzZVNjYWxlOiBuZXcgVW5pZm9ybTM5KG5ldyBWZWN0b3IyMjEoKSksXG4gICAgICAgIG1pblJhZGl1c1NjYWxlOiBuZXcgVW5pZm9ybTM5KDAuMzMpLFxuICAgICAgICBpbnRlbnNpdHk6IG5ldyBVbmlmb3JtMzkoMSksXG4gICAgICAgIGZhZGU6IG5ldyBVbmlmb3JtMzkoMC4wMSksXG4gICAgICAgIGJpYXM6IG5ldyBVbmlmb3JtMzkoMClcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE1LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogc3Nhb19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBzc2FvX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBuZXcgVmVjdG9yMjIxKCk7XG4gICAgdGhpcy5yID0gMTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbmVhciBwbGFuZSBzZXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IG5lYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS54O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBmYXIgcGxhbmUgc2V0dGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBmYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS55O1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbWJpbmVkIG5vcm1hbC1kZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG5vcm1hbERlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub3JtYWxEZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSDtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbWJpbmVkIG5vcm1hbC1kZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBub3JtYWxEZXB0aEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0Tm9ybWFsRGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLm5vcm1hbERlcHRoQnVmZmVyID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBub3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugbm9ybWFsQnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXROb3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTApIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbm9pc2UgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgbm9pc2VUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub2lzZVRleHR1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbm9pc2UgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG5vaXNlVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIHNldE5vaXNlVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubm9pc2VUZXh0dXJlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGUgY291bnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5TQU1QTEVTX0lOVCk7XG4gIH1cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuU0FNUExFU19JTlQgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lcy5JTlZfU0FNUExFU19GTE9BVCA9ICgxIC8gdmFsdWUpLnRvRml4ZWQoOSk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBvY2NsdXNpb24gc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzYW1wbGVzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNhbXBsZSBjb3VudC5cbiAgICovXG4gIGdldFNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYW1vdW50IG9mIG9jY2x1c2lvbiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNhbXBsZXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNhbXBsZSBjb3VudC5cbiAgICovXG4gIHNldFNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLnNhbXBsZXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNhbXBsaW5nIHNwaXJhbCByaW5nIGNvdW50LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJpbmdzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLlNQSVJBTF9UVVJOUyk7XG4gIH1cbiAgc2V0IHJpbmdzKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLlNQSVJBTF9UVVJOUyA9IHZhbHVlLnRvRml4ZWQoMSk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBzcGlyYWwgdHVybnMgaW4gdGhlIG9jY2x1c2lvbiBzYW1wbGluZyBwYXR0ZXJuLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmluZ3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmFkaXVzLlxuICAgKi9cbiAgZ2V0UmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmluZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFtb3VudCBvZiBzcGlyYWwgdHVybnMgaW4gdGhlIG9jY2x1c2lvbiBzYW1wbGluZyBwYXR0ZXJuLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJhZGl1cy5cbiAgICovXG4gIHNldFJpbmdzKHZhbHVlKSB7XG4gICAgdGhpcy5yaW5ncyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgU1NBT0VmZmVjdC5pbnRlbnNpdHkgaW5zdGVhZC5cbiAgICovXG4gIGdldCBpbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuaW50ZW5zaXR5LnZhbHVlO1xuICB9XG4gIHNldCBpbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmludGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmRlZmluZXMuTEVHQUNZX0lOVEVOU0lUWSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmRlZmluZXMuTEVHQUNZX0lOVEVOU0lUWSA9IFwiMVwiO1xuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBTU0FPRWZmZWN0LmludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBnZXRJbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuaW50ZW5zaXR5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBTU0FPRWZmZWN0LmludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgaW50ZW5zaXR5LlxuICAgKi9cbiAgc2V0SW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnRlbnNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGZhZGUgZmFjdG9yLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZhZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZmFkZS52YWx1ZTtcbiAgfVxuICBzZXQgZmFkZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZmFkZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXB0aCBmYWRlIGZhY3Rvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZhZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZmFkZSBmYWN0b3IuXG4gICAqL1xuICBnZXRGYWRlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmZhZGUudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGZhZGUgZmFjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZmFkZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZmFkZSBmYWN0b3IuXG4gICAqL1xuICBzZXRGYWRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mYWRlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBiaWFzLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBiaWFzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJpYXMudmFsdWU7XG4gIH1cbiAgc2V0IGJpYXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmJpYXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVwdGggYmlhcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJpYXMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYmlhcy5cbiAgICovXG4gIGdldEJpYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmlhcy52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYmlhcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJpYXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGJpYXMuXG4gICAqL1xuICBzZXRCaWFzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5iaWFzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIHJhZGl1cyBzY2FsZSBmb3IgZGlzdGFuY2Ugc2NhbGluZy4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluUmFkaXVzU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWluUmFkaXVzU2NhbGUudmFsdWU7XG4gIH1cbiAgc2V0IG1pblJhZGl1c1NjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5taW5SYWRpdXNTY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHJhZGl1cyBzY2FsZSBmb3IgZGlzdGFuY2Ugc2NhbGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pblJhZGl1c1NjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlLlxuICAgKi9cbiAgZ2V0TWluUmFkaXVzU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWluUmFkaXVzU2NhbGUudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlIGZvciBkaXN0YW5jZSBzY2FsaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluUmFkaXVzU2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlLlxuICAgKi9cbiAgc2V0TWluUmFkaXVzU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm1pblJhZGl1c1NjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGFic29sdXRlIHJhZGl1cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLnIgKiB0aGlzLnJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMuZGVmaW5lcy5SQURJVVMgPSByYWRpdXMudG9GaXhlZCgxMSk7XG4gICAgdGhpcy5kZWZpbmVzLlJBRElVU19TUSA9IChyYWRpdXMgKiByYWRpdXMpLnRvRml4ZWQoMTEpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIHNhbXBsaW5nIHJhZGl1cy4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnI7XG4gIH1cbiAgc2V0IHJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMuciA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAxZS02KSwgMSk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHJhZGl1cy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJhZGl1cyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYWRpdXMuXG4gICAqL1xuICBnZXRSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmFkaXVzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSByYWRpdXMuIFJhbmdlIFsxZS02LCAxLjBdLlxuICAgKi9cbiAgc2V0UmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy5yYWRpdXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzdGFuY2UtYmFzZWQgcmFkaXVzIHNjYWxpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGlzdGFuY2VTY2FsaW5nKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldCBkaXN0YW5jZVNjYWxpbmcodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzdGFuY2UtYmFzZWQgcmFkaXVzIHNjYWxpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBkaXN0YW5jZSBzY2FsaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc0Rpc3RhbmNlU2NhbGluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VTY2FsaW5nO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGRpc3RhbmNlLWJhc2VkIHJhZGl1cyBzY2FsaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBkaXN0YW5jZSBzY2FsaW5nIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RGlzdGFuY2VTY2FsaW5nRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuZGlzdGFuY2VTY2FsaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gZGlzdGFuY2UgdGhyZXNob2xkLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkaXN0YW5jZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kaXN0YW5jZUN1dG9mZi52YWx1ZS54O1xuICB9XG4gIHNldCBkaXN0YW5jZVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGlzdGFuY2VDdXRvZmYudmFsdWUuc2V0KFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxKSxcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHZhbHVlICsgdGhpcy5kaXN0YW5jZUZhbGxvZmYsIDApLCAxKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gZGlzdGFuY2UgdGhyZXNob2xkIGluIHdvcmxkIHVuaXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5kaXN0YW5jZVRocmVzaG9sZCwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRpc3RhbmNlVGhyZXNob2xkID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gZGlzdGFuY2UgZmFsbG9mZi4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGlzdGFuY2VGYWxsb2ZmKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRpc3RhbmNlQ3V0b2ZmLnZhbHVlLnkgLSB0aGlzLmRpc3RhbmNlVGhyZXNob2xkO1xuICB9XG4gIHNldCBkaXN0YW5jZUZhbGxvZmYodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRpc3RhbmNlQ3V0b2ZmLnZhbHVlLnkgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLmRpc3RhbmNlVGhyZXNob2xkICsgdmFsdWUsIDApLCAxKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBkaXN0YW5jZSBmYWxsb2ZmIGluIHdvcmxkIHVuaXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdvcmxkRGlzdGFuY2VGYWxsb2ZmKCkge1xuICAgIHJldHVybiAtb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKHRoaXMuZGlzdGFuY2VGYWxsb2ZmLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGREaXN0YW5jZUZhbGxvZmYodmFsdWUpIHtcbiAgICB0aGlzLmRpc3RhbmNlRmFsbG9mZiA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCgtdmFsdWUsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gZGlzdGFuY2UgY3V0b2ZmLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGlzdGFuY2VUaHJlc2hvbGQgYW5kIGRpc3RhbmNlRmFsbG9mZiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIGRpc3RhbmNlIHRocmVzaG9sZC4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZhbGxvZmYgLSBUaGUgZmFsbG9mZi4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICovXG4gIHNldERpc3RhbmNlQ3V0b2ZmKHRocmVzaG9sZCwgZmFsbG9mZikge1xuICAgIHRoaXMudW5pZm9ybXMuZGlzdGFuY2VDdXRvZmYudmFsdWUuc2V0KFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodGhyZXNob2xkLCAwKSwgMSksXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh0aHJlc2hvbGQgKyBmYWxsb2ZmLCAwKSwgMSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIHByb3hpbWl0eSB0aHJlc2hvbGQuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByb3hpbWl0eVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5wcm94aW1pdHlDdXRvZmYudmFsdWUueDtcbiAgfVxuICBzZXQgcHJveGltaXR5VGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5wcm94aW1pdHlDdXRvZmYudmFsdWUuc2V0KFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxKSxcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHZhbHVlICsgdGhpcy5wcm94aW1pdHlGYWxsb2ZmLCAwKSwgMSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIHByb3hpbWl0eSB0aHJlc2hvbGQgaW4gd29ybGQgdW5pdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd29ybGRQcm94aW1pdHlUaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5wcm94aW1pdHlUaHJlc2hvbGQsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICB9XG4gIHNldCB3b3JsZFByb3hpbWl0eVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMucHJveGltaXR5VGhyZXNob2xkID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gcHJveGltaXR5IGZhbGxvZmYuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByb3hpbWl0eUZhbGxvZmYoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucHJveGltaXR5Q3V0b2ZmLnZhbHVlLnkgLSB0aGlzLnByb3hpbWl0eVRocmVzaG9sZDtcbiAgfVxuICBzZXQgcHJveGltaXR5RmFsbG9mZih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMucHJveGltaXR5Q3V0b2ZmLnZhbHVlLnkgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLnByb3hpbWl0eVRocmVzaG9sZCArIHZhbHVlLCAwKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gcHJveGltaXR5IGZhbGxvZmYgaW4gd29ybGQgdW5pdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd29ybGRQcm94aW1pdHlGYWxsb2ZmKCkge1xuICAgIHJldHVybiAtb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKHRoaXMucHJveGltaXR5RmFsbG9mZiwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkUHJveGltaXR5RmFsbG9mZih2YWx1ZSkge1xuICAgIHRoaXMucHJveGltaXR5RmFsbG9mZiA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCgtdmFsdWUsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gcHJveGltaXR5IGN1dG9mZi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByb3hpbWl0eVRocmVzaG9sZCBhbmQgcHJveGltaXR5RmFsbG9mZiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIHJhbmdlIHRocmVzaG9sZC4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZhbGxvZmYgLSBUaGUgZmFsbG9mZi4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICovXG4gIHNldFByb3hpbWl0eUN1dG9mZih0aHJlc2hvbGQsIGZhbGxvZmYpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnByb3hpbWl0eUN1dG9mZi52YWx1ZS5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh0aHJlc2hvbGQsIDApLCAxKSxcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHRocmVzaG9sZCArIGZhbGxvZmYsIDApLCAxKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleGVsIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRTaXplKCkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgdGV4ZWwgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHRleGVsIGhlaWdodC5cbiAgICovXG4gIHNldFRleGVsU2l6ZSh4LCB5KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KHgsIHkpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUuc2V0KGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyKTtcbiAgICAgIHRoaXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZS5jb3B5KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgIHRoaXMudW5pZm9ybXMuaW52ZXJzZVByb2plY3Rpb25NYXRyaXgudmFsdWUuY29weShjYW1lcmEucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7XG4gICAgICBpZiAoY2FtZXJhIGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmE0KSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkEgPSBcIjFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IG5vaXNlVGV4dHVyZSA9IHVuaWZvcm1zLm5vaXNlVGV4dHVyZS52YWx1ZTtcbiAgICBpZiAobm9pc2VUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICB1bmlmb3Jtcy5ub2lzZVNjYWxlLnZhbHVlLnNldChcbiAgICAgICAgd2lkdGggLyBub2lzZVRleHR1cmUuaW1hZ2Uud2lkdGgsXG4gICAgICAgIGhlaWdodCAvIG5vaXNlVGV4dHVyZS5pbWFnZS5oZWlnaHRcbiAgICAgICk7XG4gICAgfVxuICAgIHVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgICB0aGlzLnJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvRGVwdGhEb3duc2FtcGxpbmdQYXNzLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzEyLCBGbG9hdFR5cGUgYXMgRmxvYXRUeXBlNCwgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyNSwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0RlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTEsIE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE2LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE3LCBVbmlmb3JtIGFzIFVuaWZvcm00MCwgVmVjdG9yMiBhcyBWZWN0b3IyMjIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWRvd25zYW1wbGluZy5mcmFnXG52YXIgZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQgPSBgI2luY2x1ZGUgPHBhY2tpbmc+XG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZW5kaWZcbiNpZmRlZiBET1dOU0FNUExFX05PUk1BTFNcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbm9ybWFsQnVmZmVyO1xuI2VuZGlmXG52YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2MztmbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XG4jZWxzZVxucmV0dXJuIHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikucjtcbiNlbmRpZlxufWludCBmaW5kQmVzdERlcHRoKGNvbnN0IGluIGZsb2F0IHNhbXBsZXNbNF0pe2Zsb2F0IGM9KHNhbXBsZXNbMF0rc2FtcGxlc1sxXStzYW1wbGVzWzJdK3NhbXBsZXNbM10pKjAuMjU7ZmxvYXQgZGlzdGFuY2VzWzRdO2Rpc3RhbmNlc1swXT1hYnMoYy1zYW1wbGVzWzBdKTtkaXN0YW5jZXNbMV09YWJzKGMtc2FtcGxlc1sxXSk7ZGlzdGFuY2VzWzJdPWFicyhjLXNhbXBsZXNbMl0pO2Rpc3RhbmNlc1szXT1hYnMoYy1zYW1wbGVzWzNdKTtmbG9hdCBtYXhEaXN0YW5jZT1tYXgobWF4KGRpc3RhbmNlc1swXSxkaXN0YW5jZXNbMV0pLG1heChkaXN0YW5jZXNbMl0sZGlzdGFuY2VzWzNdKSk7aW50IHJlbWFpbmluZ1szXTtpbnQgcmVqZWN0ZWRbM107aW50IGksaixrO2ZvcihpPTAsaj0wLGs9MDtpPDQ7KytpKXtpZihkaXN0YW5jZXNbaV08bWF4RGlzdGFuY2Upe3JlbWFpbmluZ1tqKytdPWk7fWVsc2V7cmVqZWN0ZWRbaysrXT1pO319Zm9yKDtqPDM7KytqKXtyZW1haW5pbmdbal09cmVqZWN0ZWRbLS1rXTt9dmVjMyBzPXZlYzMoc2FtcGxlc1tyZW1haW5pbmdbMF1dLHNhbXBsZXNbcmVtYWluaW5nWzFdXSxzYW1wbGVzW3JlbWFpbmluZ1syXV0pO2M9KHMueCtzLnkrcy56KS8zLjA7ZGlzdGFuY2VzWzBdPWFicyhjLXMueCk7ZGlzdGFuY2VzWzFdPWFicyhjLXMueSk7ZGlzdGFuY2VzWzJdPWFicyhjLXMueik7ZmxvYXQgbWluRGlzdGFuY2U9bWluKGRpc3RhbmNlc1swXSxtaW4oZGlzdGFuY2VzWzFdLGRpc3RhbmNlc1syXSkpO2ZvcihpPTA7aTwzOysraSl7aWYoZGlzdGFuY2VzW2ldPT1taW5EaXN0YW5jZSl7YnJlYWs7fX1yZXR1cm4gcmVtYWluaW5nW2ldO312b2lkIG1haW4oKXtmbG9hdCBkWzRdO2RbMF09cmVhZERlcHRoKHZVdjApO2RbMV09cmVhZERlcHRoKHZVdjEpO2RbMl09cmVhZERlcHRoKHZVdjIpO2RbM109cmVhZERlcHRoKHZVdjMpO2ludCBpbmRleD1maW5kQmVzdERlcHRoKGQpO1xuI2lmZGVmIERPV05TQU1QTEVfTk9STUFMU1xudmVjMyBuWzRdO25bMF09dGV4dHVyZTJEKG5vcm1hbEJ1ZmZlcix2VXYwKS5yZ2I7blsxXT10ZXh0dXJlMkQobm9ybWFsQnVmZmVyLHZVdjEpLnJnYjtuWzJdPXRleHR1cmUyRChub3JtYWxCdWZmZXIsdlV2MikucmdiO25bM109dGV4dHVyZTJEKG5vcm1hbEJ1ZmZlcix2VXYzKS5yZ2I7XG4jZWxzZVxudmVjMyBuWzRdO25bMF09dmVjMygwLjApO25bMV09dmVjMygwLjApO25bMl09dmVjMygwLjApO25bM109dmVjMygwLjApO1xuI2VuZGlmXG5nbF9GcmFnQ29sb3I9dmVjNChuW2luZGV4XSxkW2luZGV4XSk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1kb3duc2FtcGxpbmcudmVydFxudmFyIGRlcHRoX2Rvd25zYW1wbGluZ19kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZvaWQgbWFpbigpe3ZlYzIgdXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYwPXV2O3ZVdjE9dmVjMih1di54LHV2LnkrdGV4ZWxTaXplLnkpO3ZVdjI9dmVjMih1di54K3RleGVsU2l6ZS54LHV2LnkpO3ZVdjM9dXYrdGV4ZWxTaXplO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhEb3duc2FtcGxpbmdNYXRlcmlhbC5qc1xudmFyIERlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTcge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBkb3duc2FtcGxpbmcgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkRlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgREVQVEhfUEFDS0lORzogXCIwXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBkZXB0aEJ1ZmZlcjogbmV3IFVuaWZvcm00MChudWxsKSxcbiAgICAgICAgbm9ybWFsQnVmZmVyOiBuZXcgVW5pZm9ybTQwKG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNDAobmV3IFZlY3RvcjIyMigpKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTYsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aF9kb3duc2FtcGxpbmdfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQyXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9XG4gICAqL1xuICBzZXQgZGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlciBhbmQgZGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gYnVmZmVyIC0gVGhlIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldERlcHRoQnVmZmVyKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxMSkge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBub3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkRPV05TQU1QTEVfTk9STUFMUyA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkRPV05TQU1QTEVfTk9STUFMUztcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vcm1hbCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBub3JtYWxCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBub3JtYWwgYnVmZmVyLlxuICAgKi9cbiAgc2V0Tm9ybWFsQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5ub3JtYWxCdWZmZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9EZXB0aERvd25zYW1wbGluZ1Bhc3MuanNcbnZhciBEZXB0aERvd25zYW1wbGluZ1Bhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBkb3duc2FtcGxpbmcgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtvcHRpb25zLm5vcm1hbEJ1ZmZlcj1udWxsXSAtIEEgdGV4dHVyZSB0aGF0IGNvbnRhaW5zIHZpZXcgc3BhY2Ugbm9ybWFscy4gU2VlIHtAbGluayBOb3JtYWxQYXNzfS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBub3JtYWxCdWZmZXIgPSBudWxsLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDAuNSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEZXB0aERvd25zYW1wbGluZ1Bhc3NcIik7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgRGVwdGhEb3duc2FtcGxpbmdNYXRlcmlhbCgpO1xuICAgIG1hdGVyaWFsLm5vcm1hbEJ1ZmZlciA9IG5vcm1hbEJ1ZmZlcjtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxNSgxLCAxLCB7XG4gICAgICBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXI1LFxuICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyNSxcbiAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgIHR5cGU6IEZsb2F0VHlwZTRcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkRlcHRoRG93bnNhbXBsaW5nUGFzcy5UYXJnZXRcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbm9ybWFsKFJHQikgKyBkZXB0aChBKSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBub3JtYWwoUkdCKSArIGRlcHRoKEEpIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzEyKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBEb3duc2FtcGxlcyBkZXB0aCBhbmQgc2NlbmUgbm9ybWFscy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogdGhpcy5yZW5kZXJUYXJnZXQpO1xuICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuICAgIGNvbnN0IHJlbmRlcmFibGUgPSBnbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpIHx8IGdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKTtcbiAgICBpZiAoIXJlbmRlcmFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlbmRlcmluZyB0byBmbG9hdCB0ZXh0dXJlIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zc2FvLmZyYWdcbnZhciBzc2FvX2RlZmF1bHQzID0gYHVuaWZvcm0gbG93cCBzYW1wbGVyMkQgYW9CdWZmZXI7dW5pZm9ybSBmbG9hdCBsdW1pbmFuY2VJbmZsdWVuY2U7dW5pZm9ybSBmbG9hdCBpbnRlbnNpdHk7XG4jaWYgZGVmaW5lZChERVBUSF9BV0FSRV9VUFNBTVBMSU5HKSAmJiBkZWZpbmVkKE5PUk1BTF9ERVBUSClcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgbm9ybWFsRGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcbiNlbmRpZlxuI2VuZGlmXG4jaWZkZWYgQ09MT1JJWkVcbnVuaWZvcm0gdmVjMyBjb2xvcjtcbiNlbmRpZlxudm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gZmxvYXQgZGVwdGgsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2Zsb2F0IGFvTGluZWFyPXRleHR1cmUyRChhb0J1ZmZlcix1dikucjtcbiNpZiBkZWZpbmVkKERFUFRIX0FXQVJFX1VQU0FNUExJTkcpICYmIGRlZmluZWQoTk9STUFMX0RFUFRIKSAmJiBfX1ZFUlNJT05fXyA9PSAzMDBcbnZlYzQgbm9ybWFsRGVwdGhbNF07bm9ybWFsRGVwdGhbMF09dGV4dHVyZU9mZnNldChub3JtYWxEZXB0aEJ1ZmZlcix1dixpdmVjMigwLDApKTtub3JtYWxEZXB0aFsxXT10ZXh0dXJlT2Zmc2V0KG5vcm1hbERlcHRoQnVmZmVyLHV2LGl2ZWMyKDAsMSkpO25vcm1hbERlcHRoWzJdPXRleHR1cmVPZmZzZXQobm9ybWFsRGVwdGhCdWZmZXIsdXYsaXZlYzIoMSwwKSk7bm9ybWFsRGVwdGhbM109dGV4dHVyZU9mZnNldChub3JtYWxEZXB0aEJ1ZmZlcix1dixpdmVjMigxLDEpKTtmbG9hdCBkb3QwMT1kb3Qobm9ybWFsRGVwdGhbMF0ucmdiLG5vcm1hbERlcHRoWzFdLnJnYik7ZmxvYXQgZG90MDI9ZG90KG5vcm1hbERlcHRoWzBdLnJnYixub3JtYWxEZXB0aFsyXS5yZ2IpO2Zsb2F0IGRvdDAzPWRvdChub3JtYWxEZXB0aFswXS5yZ2Isbm9ybWFsRGVwdGhbM10ucmdiKTtmbG9hdCBtaW5Eb3Q9bWluKGRvdDAxLG1pbihkb3QwMixkb3QwMykpO2Zsb2F0IHM9c3RlcChUSFJFU0hPTEQsbWluRG90KTtmbG9hdCBzbWFsbGVzdERpc3RhbmNlPTEuMDtpbnQgaW5kZXg7Zm9yKGludCBpPTA7aTw0OysraSl7ZmxvYXQgZGlzdGFuY2U9YWJzKGRlcHRoLW5vcm1hbERlcHRoW2ldLmEpO2lmKGRpc3RhbmNlPHNtYWxsZXN0RGlzdGFuY2Upe3NtYWxsZXN0RGlzdGFuY2U9ZGlzdGFuY2U7aW5kZXg9aTt9fWl2ZWMyIG9mZnNldHNbNF07b2Zmc2V0c1swXT1pdmVjMigwLDApO29mZnNldHNbMV09aXZlYzIoMCwxKTtvZmZzZXRzWzJdPWl2ZWMyKDEsMCk7b2Zmc2V0c1szXT1pdmVjMigxLDEpO2l2ZWMyIGNvb3JkPWl2ZWMyKHV2KnZlYzIodGV4dHVyZVNpemUoYW9CdWZmZXIsMCkpKStvZmZzZXRzW2luZGV4XTtmbG9hdCBhb05lYXJlc3Q9dGV4ZWxGZXRjaChhb0J1ZmZlcixjb29yZCwwKS5yO2Zsb2F0IGFvPW1peChhb05lYXJlc3QsYW9MaW5lYXIscyk7XG4jZWxzZVxuZmxvYXQgYW89YW9MaW5lYXI7XG4jZW5kaWZcbmZsb2F0IGw9bHVtaW5hbmNlKGlucHV0Q29sb3IucmdiKTthbz1taXgoYW8sMC4wLGwqbHVtaW5hbmNlSW5mbHVlbmNlKTthbz1jbGFtcChhbyppbnRlbnNpdHksMC4wLDEuMCk7XG4jaWZkZWYgQ09MT1JJWkVcbm91dHB1dENvbG9yPXZlYzQoMS4wLWFvKigxLjAtY29sb3IpLGlucHV0Q29sb3IuYSk7XG4jZWxzZVxub3V0cHV0Q29sb3I9dmVjNCh2ZWMzKDEuMC1hbyksaW5wdXRDb2xvci5hKTtcbiNlbmRpZlxufWA7XG5cbi8vIHNyYy9lZmZlY3RzL1NTQU9FZmZlY3QuanNcbnZhciBOT0lTRV9URVhUVVJFX1NJWkUgPSA2NDtcbnZhciBTU0FPRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBTU0FPIGVmZmVjdC5cbiAgICpcbiAgICogQHRvZG8gTW92ZSBub3JtYWxCdWZmZXIgdG8gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtDYW1lcmF9IFtjYW1lcmFdIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtub3JtYWxCdWZmZXJdIC0gQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIHNjZW5lIG5vcm1hbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uTVVMVElQTFldIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRpc3RhbmNlU2NhbGluZz10cnVlXSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGVwdGhBd2FyZVVwc2FtcGxpbmc9dHJ1ZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIGRlcHRoLWF3YXJlIHVwc2FtcGxpbmcuIEhhcyBubyBlZmZlY3QgaWYgV2ViR0wgMiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtvcHRpb25zLm5vcm1hbERlcHRoQnVmZmVyPW51bGxdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhbXBsZXM9OV0gLSBUaGUgYW1vdW50IG9mIHNhbXBsZXMgcGVyIHBpeGVsLiBTaG91bGQgbm90IGJlIGEgbXVsdGlwbGUgb2YgdGhlIHJpbmcgY291bnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yaW5ncz03XSAtIFRoZSBhbW91bnQgb2Ygc3BpcmFsIHR1cm5zIGluIHRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcGF0dGVybi4gU2hvdWxkIGJlIGEgcHJpbWUgbnVtYmVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud29ybGREaXN0YW5jZVRocmVzaG9sZF0gLSBUaGUgd29ybGQgZGlzdGFuY2UgdGhyZXNob2xkIGF0IHdoaWNoIHRoZSBvY2NsdXNpb24gZWZmZWN0IHN0YXJ0cyB0byBmYWRlIG91dC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndvcmxkRGlzdGFuY2VGYWxsb2ZmXSAtIFRoZSB3b3JsZCBkaXN0YW5jZSBmYWxsb2ZmLiBJbmZsdWVuY2VzIHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBvY2NsdXNpb24gY3V0b2ZmLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud29ybGRQcm94aW1pdHlUaHJlc2hvbGRdIC0gVGhlIHdvcmxkIHByb3hpbWl0eSB0aHJlc2hvbGQgYXQgd2hpY2ggdGhlIG9jY2x1c2lvbiBzdGFydHMgdG8gZmFkZSBvdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZFByb3hpbWl0eUZhbGxvZmZdIC0gVGhlIHdvcmxkIHByb3hpbWl0eSBmYWxsb2ZmLiBJbmZsdWVuY2VzIHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBwcm94aW1pdHkgY3V0b2ZmLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGlzdGFuY2VUaHJlc2hvbGQ9MC45N10gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGlzdGFuY2VGYWxsb2ZmPTAuMDNdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhbmdlVGhyZXNob2xkPTAuMDAwNV0gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFuZ2VGYWxsb2ZmPTAuMDAxXSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5SYWRpdXNTY2FsZT0wLjFdIC0gVGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlSW5mbHVlbmNlPTAuN10gLSBEZXRlcm1pbmVzIGhvdyBtdWNoIHRoZSBsdW1pbmFuY2Ugb2YgdGhlIHNjZW5lIGluZmx1ZW5jZXMgdGhlIGFtYmllbnQgb2NjbHVzaW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFkaXVzPTAuMTgyNV0gLSBUaGUgb2NjbHVzaW9uIHNhbXBsaW5nIHJhZGl1cywgZXhwcmVzc2VkIGFzIGEgc2NhbGUgcmVsYXRpdmUgdG8gdGhlIHJlc29sdXRpb24uIFJhbmdlIFsxZS02LCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaW50ZW5zaXR5PTEuMF0gLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpYXM9MC4wMjVdIC0gQW4gb2NjbHVzaW9uIGJpYXMuIEVsaW1pbmF0ZXMgYXJ0aWZhY3RzIGNhdXNlZCBieSBkZXB0aCBkaXNjb250aW51aXRpZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mYWRlPTAuMDFdIC0gSW5mbHVlbmNlcyB0aGUgc21vb3RobmVzcyBvZiB0aGUgc2hhZG93cy4gQSBsb3dlciB2YWx1ZSByZXN1bHRzIGluIGhpZ2hlciBjb250cmFzdC5cbiAgICogQHBhcmFtIHtDb2xvcn0gW29wdGlvbnMuY29sb3I9bnVsbF0gLSBUaGUgY29sb3Igb2YgdGhlIGFtYmllbnQgb2NjbHVzaW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTEuMF0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhLCBub3JtYWxCdWZmZXIsIHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5NVUxUSVBMWSxcbiAgICBzYW1wbGVzID0gOSxcbiAgICByaW5ncyA9IDcsXG4gICAgbm9ybWFsRGVwdGhCdWZmZXIgPSBudWxsLFxuICAgIGRlcHRoQXdhcmVVcHNhbXBsaW5nID0gdHJ1ZSxcbiAgICB3b3JsZERpc3RhbmNlVGhyZXNob2xkLFxuICAgIHdvcmxkRGlzdGFuY2VGYWxsb2ZmLFxuICAgIHdvcmxkUHJveGltaXR5VGhyZXNob2xkLFxuICAgIHdvcmxkUHJveGltaXR5RmFsbG9mZixcbiAgICBkaXN0YW5jZVRocmVzaG9sZCA9IDAuOTcsXG4gICAgZGlzdGFuY2VGYWxsb2ZmID0gMC4wMyxcbiAgICByYW5nZVRocmVzaG9sZCA9IDVlLTQsXG4gICAgcmFuZ2VGYWxsb2ZmID0gMWUtMyxcbiAgICBtaW5SYWRpdXNTY2FsZSA9IDAuMSxcbiAgICBsdW1pbmFuY2VJbmZsdWVuY2UgPSAwLjcsXG4gICAgcmFkaXVzID0gMC4xODI1LFxuICAgIGludGVuc2l0eSA9IDEsXG4gICAgYmlhcyA9IDAuMDI1LFxuICAgIGZhZGUgPSAwLjAxLFxuICAgIGNvbG9yOiBjb2xvcjIgPSBudWxsLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU1NBT0VmZmVjdFwiLCBzc2FvX2RlZmF1bHQzLCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkRFUFRILFxuICAgICAgZGVmaW5lczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJUSFJFU0hPTERcIiwgXCIwLjk5N1wiXVxuICAgICAgXSksXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJhb0J1ZmZlclwiLCBuZXcgVW5pZm9ybTQxKG51bGwpXSxcbiAgICAgICAgW1wibm9ybWFsRGVwdGhCdWZmZXJcIiwgbmV3IFVuaWZvcm00MShub3JtYWxEZXB0aEJ1ZmZlcildLFxuICAgICAgICBbXCJsdW1pbmFuY2VJbmZsdWVuY2VcIiwgbmV3IFVuaWZvcm00MShsdW1pbmFuY2VJbmZsdWVuY2UpXSxcbiAgICAgICAgW1wiY29sb3JcIiwgbmV3IFVuaWZvcm00MShudWxsKV0sXG4gICAgICAgIFtcImludGVuc2l0eVwiLCBuZXcgVW5pZm9ybTQxKGludGVuc2l0eSldLFxuICAgICAgICBbXCJzY2FsZVwiLCBuZXcgVW5pZm9ybTQxKDApXVxuICAgICAgICAvLyBVbnVzZWQuXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTYoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJBTy5UYXJnZXRcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImFvQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcyA9IG5ldyBEZXB0aERvd25zYW1wbGluZ1Bhc3MoeyBub3JtYWxCdWZmZXIsIHJlc29sdXRpb25TY2FsZSB9KTtcbiAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5lbmFibGVkID0gbm9ybWFsRGVwdGhCdWZmZXIgPT09IG51bGw7XG4gICAgdGhpcy5zc2FvUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBTU0FPTWF0ZXJpYWwoY2FtZXJhKSk7XG4gICAgY29uc3Qgbm9pc2VUZXh0dXJlID0gbmV3IE5vaXNlVGV4dHVyZShOT0lTRV9URVhUVVJFX1NJWkUsIE5PSVNFX1RFWFRVUkVfU0laRSwgUkdCQUZvcm1hdDQpO1xuICAgIG5vaXNlVGV4dHVyZS53cmFwUyA9IG5vaXNlVGV4dHVyZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nNDtcbiAgICBjb25zdCBzc2FvTWF0ZXJpYWwgPSB0aGlzLnNzYW9NYXRlcmlhbDtcbiAgICBzc2FvTWF0ZXJpYWwubm9ybWFsQnVmZmVyID0gbm9ybWFsQnVmZmVyO1xuICAgIHNzYW9NYXRlcmlhbC5ub2lzZVRleHR1cmUgPSBub2lzZVRleHR1cmU7XG4gICAgc3Nhb01hdGVyaWFsLm1pblJhZGl1c1NjYWxlID0gbWluUmFkaXVzU2NhbGU7XG4gICAgc3Nhb01hdGVyaWFsLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIHNzYW9NYXRlcmlhbC5yYWRpdXMgPSByYWRpdXM7XG4gICAgc3Nhb01hdGVyaWFsLnJpbmdzID0gcmluZ3M7XG4gICAgc3Nhb01hdGVyaWFsLmZhZGUgPSBmYWRlO1xuICAgIHNzYW9NYXRlcmlhbC5iaWFzID0gYmlhcztcbiAgICBzc2FvTWF0ZXJpYWwuZGlzdGFuY2VUaHJlc2hvbGQgPSBkaXN0YW5jZVRocmVzaG9sZDtcbiAgICBzc2FvTWF0ZXJpYWwuZGlzdGFuY2VGYWxsb2ZmID0gZGlzdGFuY2VGYWxsb2ZmO1xuICAgIHNzYW9NYXRlcmlhbC5wcm94aW1pdHlUaHJlc2hvbGQgPSByYW5nZVRocmVzaG9sZDtcbiAgICBzc2FvTWF0ZXJpYWwucHJveGltaXR5RmFsbG9mZiA9IHJhbmdlRmFsbG9mZjtcbiAgICBpZiAod29ybGREaXN0YW5jZVRocmVzaG9sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBzc2FvTWF0ZXJpYWwud29ybGREaXN0YW5jZVRocmVzaG9sZCA9IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQ7XG4gICAgfVxuICAgIGlmICh3b3JsZERpc3RhbmNlRmFsbG9mZiAhPT0gdm9pZCAwKSB7XG4gICAgICBzc2FvTWF0ZXJpYWwud29ybGREaXN0YW5jZUZhbGxvZmYgPSB3b3JsZERpc3RhbmNlRmFsbG9mZjtcbiAgICB9XG4gICAgaWYgKHdvcmxkUHJveGltaXR5VGhyZXNob2xkICE9PSB2b2lkIDApIHtcbiAgICAgIHNzYW9NYXRlcmlhbC53b3JsZFByb3hpbWl0eVRocmVzaG9sZCA9IHdvcmxkUHJveGltaXR5VGhyZXNob2xkO1xuICAgIH1cbiAgICBpZiAod29ybGRQcm94aW1pdHlGYWxsb2ZmICE9PSB2b2lkIDApIHtcbiAgICAgIHNzYW9NYXRlcmlhbC53b3JsZFByb3hpbWl0eUZhbGxvZmYgPSB3b3JsZFByb3hpbWl0eUZhbGxvZmY7XG4gICAgfVxuICAgIGlmIChub3JtYWxEZXB0aEJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5zc2FvTWF0ZXJpYWwubm9ybWFsRGVwdGhCdWZmZXIgPSBub3JtYWxEZXB0aEJ1ZmZlcjtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJOT1JNQUxfREVQVEhcIiwgXCIxXCIpO1xuICAgIH1cbiAgICB0aGlzLmRlcHRoQXdhcmVVcHNhbXBsaW5nID0gZGVwdGhBd2FyZVVwc2FtcGxpbmc7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yMjtcbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMuY2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbm9ybWFsIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgbm9ybWFsQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9NYXRlcmlhbC5ub3JtYWxCdWZmZXI7XG4gIH1cbiAgc2V0IG5vcm1hbEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLm5vcm1hbEJ1ZmZlciA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5ub3JtYWxCdWZmZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBTU0FPIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7U1NBT01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IHNzYW9NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zc2FvUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFNTQU8gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7U1NBT01hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRTU0FPTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Nhb01hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIG9jY2x1c2lvbiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNzYW9NYXRlcmlhbC5zYW1wbGVzIGluc3RlYWQuXG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zc2FvTWF0ZXJpYWwuc2FtcGxlcztcbiAgfVxuICBzZXQgc2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnNhbXBsZXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBzcGlyYWwgdHVybnMgaW4gdGhlIG9jY2x1c2lvbiBzYW1wbGluZyBwYXR0ZXJuLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3Nhb01hdGVyaWFsLnJpbmdzIGluc3RlYWQuXG4gICAqL1xuICBnZXQgcmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Nhb01hdGVyaWFsLnJpbmdzO1xuICB9XG4gIHNldCByaW5ncyh2YWx1ZSkge1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnJpbmdzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3Nhb01hdGVyaWFsLnJhZGl1cyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5zc2FvTWF0ZXJpYWwucmFkaXVzO1xuICB9XG4gIHNldCByYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5yYWRpdXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGVwdGgtYXdhcmUgdXBzYW1wbGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkZXB0aEF3YXJlVXBzYW1wbGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIkRFUFRIX0FXQVJFX1VQU0FNUExJTkdcIik7XG4gIH1cbiAgc2V0IGRlcHRoQXdhcmVVcHNhbXBsaW5nKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVwdGhBd2FyZVVwc2FtcGxpbmcgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkRFUFRIX0FXQVJFX1VQU0FNUExJTkdcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIkRFUFRIX0FXQVJFX1VQU0FNUExJTkdcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRlcHRoLWF3YXJlIHVwc2FtcGxpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQXdhcmVVcHNhbXBsaW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgZGVwdGgtYXdhcmUgdXBzYW1wbGluZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgaXNEZXB0aEF3YXJlVXBzYW1wbGluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGhBd2FyZVVwc2FtcGxpbmc7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGVwdGgtYXdhcmUgdXBzYW1wbGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQXdhcmVVcHNhbXBsaW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIGRlcHRoLWF3YXJlIHVwc2FtcGxpbmcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXREZXB0aEF3YXJlVXBzYW1wbGluZ0VuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmRlcHRoQXdhcmVVcHNhbXBsaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRpc3RhbmNlLWJhc2VkIHJhZGl1cyBzY2FsaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGRpc3RhbmNlU2NhbGluZygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXQgZGlzdGFuY2VTY2FsaW5nKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgYW1iaWVudCBvY2NsdXNpb24uIFNldCB0byBgbnVsbGAgdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKi9cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImNvbG9yXCIpLnZhbHVlO1xuICB9XG4gIHNldCBjb2xvcih2YWx1ZSkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcbiAgICBjb25zdCBkZWZpbmVzID0gdGhpcy5kZWZpbmVzO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRlZmluZXMuaGFzKFwiQ09MT1JJWkVcIikpIHtcbiAgICAgICAgdW5pZm9ybXMuZ2V0KFwiY29sb3JcIikudmFsdWUuc2V0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZXMuc2V0KFwiQ09MT1JJWkVcIiwgXCIxXCIpO1xuICAgICAgICB1bmlmb3Jtcy5nZXQoXCJjb2xvclwiKS52YWx1ZSA9IG5ldyBDb2xvcjkodmFsdWUpO1xuICAgICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRlZmluZXMuaGFzKFwiQ09MT1JJWkVcIikpIHtcbiAgICAgIGRlZmluZXMuZGVsZXRlKFwiQ09MT1JJWkVcIik7XG4gICAgICB1bmlmb3Jtcy5nZXQoXCJjb2xvclwiKS52YWx1ZSA9IG51bGw7XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgaW5mbHVlbmNlIGZhY3Rvci4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGx1bWluYW5jZUluZmx1ZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJsdW1pbmFuY2VJbmZsdWVuY2VcIikudmFsdWU7XG4gIH1cbiAgc2V0IGx1bWluYW5jZUluZmx1ZW5jZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibHVtaW5hbmNlSW5mbHVlbmNlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImludGVuc2l0eVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgaW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJpbnRlbnNpdHlcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29sb3Igb2YgdGhlIGFtYmllbnQgb2NjbHVzaW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3IgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Q29sb3J9IFRoZSBjb2xvci5cbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgYW1iaWVudCBvY2NsdXNpb24uIFNldCB0byBgbnVsbGAgdG8gZGlzYWJsZSBjb2xvcml6YXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2xvciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NvbG9yfSB2YWx1ZSAtIFRoZSBjb2xvci5cbiAgICovXG4gIHNldENvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gZGlzdGFuY2UgY3V0b2ZmLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3Nhb01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgLSBUaGUgZGlzdGFuY2UgdGhyZXNob2xkLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZmFsbG9mZiAtIFRoZSBmYWxsb2ZmLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0RGlzdGFuY2VDdXRvZmYodGhyZXNob2xkLCBmYWxsb2ZmKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuZGlzdGFuY2VUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuZGlzdGFuY2VGYWxsb2ZmID0gZmFsbG9mZjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb2NjbHVzaW9uIHByb3hpbWl0eSBjdXRvZmYuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZCAtIFRoZSBwcm94aW1pdHkgdGhyZXNob2xkLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZmFsbG9mZiAtIFRoZSBmYWxsb2ZmLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0UHJveGltaXR5Q3V0b2ZmKHRocmVzaG9sZCwgZmFsbG9mZikge1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnByb3hpbWl0eVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5wcm94aW1pdHlGYWxsb2ZmID0gZmFsbG9mZjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTMpIHtcbiAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5zZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcpO1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgaWYgKHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIHRoaXMuc3Nhb1Bhc3MucmVuZGVyKHJlbmRlcmVyLCBudWxsLCByZW5kZXJUYXJnZXQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHRoaXMuY2FtZXJhKTtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUodywgaCk7XG4gICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MucmVzb2x1dGlvbi5zY2FsZSA9IHJlc29sdXRpb24uc2NhbGU7XG4gICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBub3JtYWxEZXB0aEJ1ZmZlciA9IHRoaXMudW5pZm9ybXMuZ2V0KFwibm9ybWFsRGVwdGhCdWZmZXJcIikudmFsdWU7XG4gICAgICBpZiAobm9ybWFsRGVwdGhCdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgICAgIG5vcm1hbERlcHRoQnVmZmVyID0gdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MudGV4dHVyZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJub3JtYWxEZXB0aEJ1ZmZlclwiKS52YWx1ZSA9IG5vcm1hbERlcHRoQnVmZmVyO1xuICAgICAgICB0aGlzLnNzYW9NYXRlcmlhbC5ub3JtYWxEZXB0aEJ1ZmZlciA9IG5vcm1hbERlcHRoQnVmZmVyO1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiTk9STUFMX0RFUFRIXCIsIFwiMVwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9UZXh0dXJlRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00MiwgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMTIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC90ZXh0dXJlLmZyYWdcbnZhciB0ZXh0dXJlX2RlZmF1bHQgPSBgI2lmZGVmIFRFWFRVUkVfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFwO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xuI2VuZGlmXG52YXJ5aW5nIHZlYzIgdlV2Mjt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7XG4jaWZkZWYgVVZfVFJBTlNGT1JNXG52ZWM0IHRleGVsPXRleHR1cmUyRChtYXAsdlV2Mik7XG4jZWxzZVxudmVjNCB0ZXhlbD10ZXh0dXJlMkQobWFwLHV2KTtcbiNlbmRpZlxub3V0cHV0Q29sb3I9VEVYRUw7b3V0cHV0Q29sb3IuYT1tYXgoaW5wdXRDb2xvci5hLG91dHB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3RleHR1cmUudmVydFxudmFyIHRleHR1cmVfZGVmYXVsdDIgPSBgI2lmZGVmIEFTUEVDVF9DT1JSRUNUSU9OXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xuI2Vsc2VcbnVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcbiNlbmRpZlxudmFyeWluZyB2ZWMyIHZVdjI7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXtcbiNpZmRlZiBBU1BFQ1RfQ09SUkVDVElPTlxudlV2Mj11dip2ZWMyKGFzcGVjdCwxLjApKnNjYWxlO1xuI2Vsc2VcbnZVdjI9KHV2VHJhbnNmb3JtKnZlYzModXYsMS4wKSkueHk7XG4jZW5kaWZcbn1gO1xuXG4vLyBzcmMvZWZmZWN0cy9UZXh0dXJlRWZmZWN0LmpzXG52YXIgVGV4dHVyZUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdGV4dHVyZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbb3B0aW9ucy50ZXh0dXJlXSAtIEEgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3BlY3RDb3JyZWN0aW9uPWZhbHNlXSAtIERlcHJlY2F0ZWQuIEFkanVzdCB0aGUgdGV4dHVyZSdzIG9mZnNldCwgcmVwZWF0IGFuZCBjZW50ZXIgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiwgdGV4dHVyZSA9IG51bGwsIGFzcGVjdENvcnJlY3Rpb24gPSBmYWxzZSB9ID0ge30pIHtcbiAgICBzdXBlcihcIlRleHR1cmVFZmZlY3RcIiwgdGV4dHVyZV9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgZGVmaW5lczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJURVhFTFwiLCBcInRleGVsXCJdXG4gICAgICBdKSxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTQyKG51bGwpXSxcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm00MigxKV0sXG4gICAgICAgIFtcInV2VHJhbnNmb3JtXCIsIG5ldyBVbmlmb3JtNDIobnVsbCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5hc3BlY3RDb3JyZWN0aW9uID0gYXNwZWN0Q29ycmVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgY29uc3QgcHJldlRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IGRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG4gICAgaWYgKHByZXZUZXh0dXJlICE9PSB2YWx1ZSkge1xuICAgICAgdW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlID0gdmFsdWU7XG4gICAgICB1bmlmb3Jtcy5nZXQoXCJ1dlRyYW5zZm9ybVwiKS52YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgICAgIGRlZmluZXMuZGVsZXRlKFwiVEVYVFVSRV9QUkVDSVNJT05fSElHSFwiKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodmFsdWUubWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgICAgIGRlZmluZXMuc2V0KFwiVVZfVFJBTlNGT1JNXCIsIFwiMVwiKTtcbiAgICAgICAgICB0aGlzLnNldFZlcnRleFNoYWRlcih0ZXh0dXJlX2RlZmF1bHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZpbmVzLmRlbGV0ZShcIlVWX1RSQU5TRk9STVwiKTtcbiAgICAgICAgICB0aGlzLnNldFZlcnRleFNoYWRlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTEyKSB7XG4gICAgICAgICAgZGVmaW5lcy5zZXQoXCJURVhUVVJFX1BSRUNJU0lPTl9ISUdIXCIsIFwiMVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlRleHR1cmUgPT09IG51bGwgfHwgcHJldlRleHR1cmUudHlwZSAhPT0gdmFsdWUudHlwZSB8fCBwcmV2VGV4dHVyZS5lbmNvZGluZyAhPT0gdmFsdWUuZW5jb2RpbmcpIHtcbiAgICAgICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIHNldFRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnRleHR1cmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgYXNwZWN0IGNvcnJlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgQWRqdXN0IHRoZSB0ZXh0dXJlJ3Mgb2Zmc2V0LCByZXBlYXQsIHJvdGF0aW9uIGFuZCBjZW50ZXIgaW5zdGVhZC5cbiAgICovXG4gIGdldCBhc3BlY3RDb3JyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiQVNQRUNUX0NPUlJFQ1RJT05cIik7XG4gIH1cbiAgc2V0IGFzcGVjdENvcnJlY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5hc3BlY3RDb3JyZWN0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJBU1BFQ1RfQ09SUkVDVElPTlwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiQVNQRUNUX0NPUlJFQ1RJT05cIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIFVWIGNvb3JkaW5hdGVzIHdpbGwgYmUgdHJhbnNmb3JtZWQgdXNpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlLm1hdHJpeEF1dG9VcGRhdGUgaW5zdGVhZC5cbiAgICovXG4gIGdldCB1dlRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIHJldHVybiB0ZXh0dXJlICE9PSBudWxsICYmIHRleHR1cmUubWF0cml4QXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgdXZUcmFuc2Zvcm0odmFsdWUpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIGlmICh0ZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICB0ZXh0dXJlLm1hdHJpeEF1dG9VcGRhdGUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN3aXp6bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnRzIG9mIGEgdGV4ZWwgYmVmb3JlIGl0IGlzIHdyaXR0ZW4gdG8gdGhlIG91dHB1dCBjb2xvci5cbiAgICpcbiAgICogQHBhcmFtIHtDb2xvckNoYW5uZWx9IHIgLSBUaGUgc3dpenpsZSBmb3IgdGhlIGByYCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7Q29sb3JDaGFubmVsfSBbZz1yXSAtIFRoZSBzd2l6emxlIGZvciB0aGUgYGdgIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtDb2xvckNoYW5uZWx9IFtiPXJdIC0gVGhlIHN3aXp6bGUgZm9yIHRoZSBgYmAgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0NvbG9yQ2hhbm5lbH0gW2E9cl0gLSBUaGUgc3dpenpsZSBmb3IgdGhlIGBhYCBjb21wb25lbnQuXG4gICAqL1xuICBzZXRUZXh0dXJlU3dpenpsZVJHQkEociwgZyA9IHIsIGIgPSByLCBhID0gcikge1xuICAgIGNvbnN0IHJnYmEgPSBcInJnYmFcIjtcbiAgICBsZXQgc3dpenpsZSA9IFwiXCI7XG4gICAgaWYgKHIgIT09IENvbG9yQ2hhbm5lbC5SRUQgfHwgZyAhPT0gQ29sb3JDaGFubmVsLkdSRUVOIHx8IGIgIT09IENvbG9yQ2hhbm5lbC5CTFVFIHx8IGEgIT09IENvbG9yQ2hhbm5lbC5BTFBIQSkge1xuICAgICAgc3dpenpsZSA9IFtcIi5cIiwgcmdiYVtyXSwgcmdiYVtnXSwgcmdiYVtiXSwgcmdiYVthXV0uam9pbihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlRFWEVMXCIsIFwidGV4ZWxcIiArIHN3aXp6bGUpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlLm1hdHJpeEF1dG9VcGRhdGUpIHtcbiAgICAgIHRoaXMudGV4dHVyZS51cGRhdGVNYXRyaXgoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1RpbHRTaGlmdEVmZmVjdC5qc1xuaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2UxMiwgVW5pZm9ybSBhcyBVbmlmb3JtNDQsIFZlY3RvcjIgYXMgVmVjdG9yMjI0LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDE3IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvVGlsdFNoaWZ0Qmx1ck1hdGVyaWFsLmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00MywgVmVjdG9yMiBhcyBWZWN0b3IyMjMsIFZlY3RvcjQgYXMgVmVjdG9yNDUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLnRpbHQtc2hpZnQuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX3RpbHRfc2hpZnRfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSB2ZWM0IG1hc2tQYXJhbXM7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdk9mZnNldDtmbG9hdCBsaW5lYXJHcmFkaWVudE1hc2soY29uc3QgaW4gZmxvYXQgeCl7cmV0dXJuIHNtb290aHN0ZXAobWFza1BhcmFtcy54LG1hc2tQYXJhbXMueSx4KS1zbW9vdGhzdGVwKG1hc2tQYXJhbXMudyxtYXNrUGFyYW1zLnoseCk7fXZvaWQgbWFpbigpe3ZlYzIgZFV2PXZPZmZzZXQqKDEuMC1saW5lYXJHcmFkaWVudE1hc2sodlV2Mi55KSk7dmVjNCBzdW09dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZlYzIodlV2LngtZFV2LngsdlV2LnkrZFV2LnkpKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2ZWMyKHZVdi54K2RVdi54LHZVdi55K2RVdi55KSk7c3VtKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdmVjMih2VXYueCtkVXYueCx2VXYueS1kVXYueSkpO3N1bSs9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZlYzIodlV2LngtZFV2LngsdlV2LnktZFV2LnkpKTtnbF9GcmFnQ29sb3I9c3VtKjAuMjU7XG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24udGlsdC1zaGlmdC52ZXJ0XG52YXIgY29udm9sdXRpb25fdGlsdF9zaGlmdF9kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzQgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQga2VybmVsO3VuaWZvcm0gZmxvYXQgc2NhbGU7dW5pZm9ybSBmbG9hdCBhc3BlY3Q7dW5pZm9ybSB2ZWMyIHJvdGF0aW9uO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZPZmZzZXQ7dm9pZCBtYWluKCl7dmVjMiB1dj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdj11djt2VXYyPSh1di0wLjUpKjIuMCp2ZWMyKGFzcGVjdCwxLjApO3ZVdjI9dmVjMihkb3Qocm90YXRpb24sdlV2MiksZG90KHJvdGF0aW9uLHZlYzIodlV2Mi55LC12VXYyLngpKSk7dk9mZnNldD0odGV4ZWxTaXplLnh5KnZlYzIoa2VybmVsKSt0ZXhlbFNpemUuencpKnNjYWxlO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvVGlsdFNoaWZ0Qmx1ck1hdGVyaWFsLmpzXG52YXIgVGlsdFNoaWZ0Qmx1ck1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBLYXdhc2VCbHVyTWF0ZXJpYWwge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyB0aWx0IHNoaWZ0IGJsdXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldD0wLjBdIC0gVGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTAuMF0gLSBUaGUgcm90YXRpb24gb2YgdGhlIGZvY3VzIGFyZWEgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzQXJlYT0wLjRdIC0gVGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mZWF0aGVyPTAuM10gLSBUaGUgc29mdG5lc3Mgb2YgdGhlIGZvY3VzIGFyZWEgZWRnZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuTUVESVVNLFxuICAgIG9mZnNldCA9IDAsXG4gICAgcm90YXRpb24gPSAwLFxuICAgIGZvY3VzQXJlYSA9IDAuNCxcbiAgICBmZWF0aGVyID0gMC4zXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGNvbnZvbHV0aW9uX3RpbHRfc2hpZnRfZGVmYXVsdDtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IGNvbnZvbHV0aW9uX3RpbHRfc2hpZnRfZGVmYXVsdDI7XG4gICAgdGhpcy5rZXJuZWxTaXplID0ga2VybmVsU2l6ZTtcbiAgICB0aGlzLnVuaWZvcm1zLmFzcGVjdCA9IG5ldyBVbmlmb3JtNDMoMSk7XG4gICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvbiA9IG5ldyBVbmlmb3JtNDMobmV3IFZlY3RvcjIyMygpKTtcbiAgICB0aGlzLnVuaWZvcm1zLm1hc2tQYXJhbXMgPSBuZXcgVW5pZm9ybTQzKG5ldyBWZWN0b3I0NSgpKTtcbiAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5fZm9jdXNBcmVhID0gZm9jdXNBcmVhO1xuICAgIHRoaXMuX2ZlYXRoZXIgPSBmZWF0aGVyO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUGFyYW1zKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMudW5pZm9ybXMubWFza1BhcmFtcy52YWx1ZTtcbiAgICBjb25zdCBhID0gTWF0aC5tYXgodGhpcy5mb2N1c0FyZWEsIDApO1xuICAgIGNvbnN0IGIgPSBNYXRoLm1heChhIC0gdGhpcy5mZWF0aGVyLCAwKTtcbiAgICBwYXJhbXMuc2V0KFxuICAgICAgdGhpcy5vZmZzZXQgLSBhLFxuICAgICAgdGhpcy5vZmZzZXQgLSBiLFxuICAgICAgdGhpcy5vZmZzZXQgKyBhLFxuICAgICAgdGhpcy5vZmZzZXQgKyBiXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBmb2N1cyBhcmVhIGluIHJhZGlhbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLnVuaWZvcm1zLnJvdGF0aW9uLnZhbHVlLngpO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMucm90YXRpb24udmFsdWUuc2V0KE1hdGguY29zKHZhbHVlKSwgTWF0aC5zaW4odmFsdWUpKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfVxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5fb2Zmc2V0ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNBcmVhKCkge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c0FyZWE7XG4gIH1cbiAgc2V0IGZvY3VzQXJlYSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvY3VzQXJlYSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzb2Z0bmVzcyBvZiB0aGUgZm9jdXMgYXJlYSBlZGdlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBmZWF0aGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9mZWF0aGVyO1xuICB9XG4gIHNldCBmZWF0aGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fZmVhdGhlciA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBzdXBlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMuYXNwZWN0LnZhbHVlID0gd2lkdGggLyBoZWlnaHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvVGlsdFNoaWZ0Qmx1clBhc3MuanNcbnZhciBUaWx0U2hpZnRCbHVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgS2F3YXNlQmx1clBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBLYXdhc2UgYmx1ciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXQ9MC4wXSAtIFRoZSByZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3RhdGlvbj0wLjBdIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBmb2N1cyBhcmVhIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2N1c0FyZWE9MC40XSAtIFRoZSByZWxhdGl2ZSBzaXplIG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmVhdGhlcj0wLjNdIC0gVGhlIHNvZnRuZXNzIG9mIHRoZSBmb2N1cyBhcmVhIGVkZ2VzLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5NRURJVU1dIC0gVGhlIGJsdXIga2VybmVsIHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG9mZnNldCA9IDAsXG4gICAgcm90YXRpb24gPSAwLFxuICAgIGZvY3VzQXJlYSA9IDAuNCxcbiAgICBmZWF0aGVyID0gMC4zLFxuICAgIGtlcm5lbFNpemUgPSBLZXJuZWxTaXplLk1FRElVTSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgcmVzb2x1dGlvblggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWSA9IFJlc29sdXRpb24uQVVUT19TSVpFXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsga2VybmVsU2l6ZSwgcmVzb2x1dGlvblNjYWxlLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblkgfSk7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwgPSBuZXcgVGlsdFNoaWZ0Qmx1ck1hdGVyaWFsKHsga2VybmVsU2l6ZSwgb2Zmc2V0LCByb3RhdGlvbiwgZm9jdXNBcmVhLCBmZWF0aGVyIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3RpbHQtc2hpZnQuZnJhZ1xudmFyIHRpbHRfc2hpZnRfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFwO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xuI2VuZGlmXG51bmlmb3JtIHZlYzIgbWFza1BhcmFtczt2YXJ5aW5nIHZlYzIgdlV2MjtmbG9hdCBsaW5lYXJHcmFkaWVudE1hc2soY29uc3QgaW4gZmxvYXQgeCl7cmV0dXJuIHN0ZXAobWFza1BhcmFtcy54LHgpLXN0ZXAobWFza1BhcmFtcy55LHgpO312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7ZmxvYXQgbWFzaz1saW5lYXJHcmFkaWVudE1hc2sodlV2Mi55KTt2ZWM0IHRleGVsPXRleHR1cmUyRChtYXAsdXYpO291dHB1dENvbG9yPW1peCh0ZXhlbCxpbnB1dENvbG9yLG1hc2spO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3RpbHQtc2hpZnQudmVydFxudmFyIHRpbHRfc2hpZnRfZGVmYXVsdDIgPSBgdW5pZm9ybSB2ZWMyIHJvdGF0aW9uO3ZhcnlpbmcgdmVjMiB2VXYyO3ZvaWQgbWFpblN1cHBvcnQoY29uc3QgaW4gdmVjMiB1dil7dlV2Mj0odXYtMC41KSoyLjAqdmVjMihhc3BlY3QsMS4wKTt2VXYyPXZlYzIoZG90KHJvdGF0aW9uLHZVdjIpLGRvdChyb3RhdGlvbix2ZWMyKHZVdjIueSwtdlV2Mi54KSkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9UaWx0U2hpZnRFZmZlY3QuanNcbnZhciBUaWx0U2hpZnRFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHRpbHQgc2hpZnQgRWZmZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldD0wLjBdIC0gVGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTAuMF0gLSBUaGUgcm90YXRpb24gb2YgdGhlIGZvY3VzIGFyZWEgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzQXJlYT0wLjRdIC0gVGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mZWF0aGVyPTAuM10gLSBUaGUgc29mdG5lc3Mgb2YgdGhlIGZvY3VzIGFyZWEgZWRnZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iaWFzPTAuMDZdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuTUVESVVNXSAtIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uLFxuICAgIG9mZnNldCA9IDAsXG4gICAgcm90YXRpb24gPSAwLFxuICAgIGZvY3VzQXJlYSA9IDAuNCxcbiAgICBmZWF0aGVyID0gMC4zLFxuICAgIGtlcm5lbFNpemUgPSBLZXJuZWxTaXplLk1FRElVTSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgcmVzb2x1dGlvblggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWSA9IFJlc29sdXRpb24uQVVUT19TSVpFXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiVGlsdFNoaWZ0RWZmZWN0XCIsIHRpbHRfc2hpZnRfZGVmYXVsdCwge1xuICAgICAgdmVydGV4U2hhZGVyOiB0aWx0X3NoaWZ0X2RlZmF1bHQyLFxuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcInJvdGF0aW9uXCIsIG5ldyBVbmlmb3JtNDQobmV3IFZlY3RvcjIyNCgpKV0sXG4gICAgICAgIFtcIm1hc2tQYXJhbXNcIiwgbmV3IFVuaWZvcm00NChuZXcgVmVjdG9yMjI0KCkpXSxcbiAgICAgICAgW1wibWFwXCIsIG5ldyBVbmlmb3JtNDQobnVsbCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLl9mb2N1c0FyZWEgPSBmb2N1c0FyZWE7XG4gICAgdGhpcy5fZmVhdGhlciA9IGZlYXRoZXI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxNygxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIlRpbHRTaGlmdC5UYXJnZXRcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm1hcFwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgdGhpcy5ibHVyUGFzcyA9IG5ldyBUaWx0U2hpZnRCbHVyUGFzcyh7XG4gICAgICBrZXJuZWxTaXplLFxuICAgICAgcmVzb2x1dGlvblNjYWxlLFxuICAgICAgcmVzb2x1dGlvblgsXG4gICAgICByZXNvbHV0aW9uWSxcbiAgICAgIG9mZnNldCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgZm9jdXNBcmVhLFxuICAgICAgZmVhdGhlclxuICAgIH0pO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBtYXNrIHBhcmFtcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVBhcmFtcygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnVuaWZvcm1zLmdldChcIm1hc2tQYXJhbXNcIikudmFsdWU7XG4gICAgY29uc3QgeCA9IE1hdGgubWF4KHRoaXMuZm9jdXNBcmVhIC0gdGhpcy5mZWF0aGVyLCAwKTtcbiAgICBwYXJhbXMuc2V0KHRoaXMub2Zmc2V0IC0geCwgdGhpcy5vZmZzZXQgKyB4KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBmb2N1cyBhcmVhIGluIHJhZGlhbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLnVuaWZvcm1zLmdldChcInJvdGF0aW9uXCIpLnZhbHVlLngpO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwicm90YXRpb25cIikudmFsdWUuc2V0KE1hdGguY29zKHZhbHVlKSwgTWF0aC5zaW4odmFsdWUpKTtcbiAgICB0aGlzLmJsdXJQYXNzLmJsdXJNYXRlcmlhbC5yb3RhdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICB9XG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLl9vZmZzZXQgPSB2YWx1ZTtcbiAgICB0aGlzLmJsdXJQYXNzLmJsdXJNYXRlcmlhbC5vZmZzZXQgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBmb2N1c0FyZWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzQXJlYTtcbiAgfVxuICBzZXQgZm9jdXNBcmVhKHZhbHVlKSB7XG4gICAgdGhpcy5fZm9jdXNBcmVhID0gdmFsdWU7XG4gICAgdGhpcy5ibHVyUGFzcy5ibHVyTWF0ZXJpYWwuZm9jdXNBcmVhID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNvZnRuZXNzIG9mIHRoZSBmb2N1cyBhcmVhIGVkZ2VzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZlYXRoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZlYXRoZXI7XG4gIH1cbiAgc2V0IGZlYXRoZXIodmFsdWUpIHtcbiAgICB0aGlzLl9mZWF0aGVyID0gdmFsdWU7XG4gICAgdGhpcy5ibHVyUGFzcy5ibHVyTWF0ZXJpYWwuZmVhdGhlciA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIEEgYmxlbmQgYmlhcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBiaWFzKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHNldCBiaWFzKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIHRoaXMuYmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgdGhpcy5yZW5kZXJUYXJnZXQpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICAgIHRoaXMuYmx1clBhc3MucmVzb2x1dGlvbi5jb3B5KHJlc29sdXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlMTIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UxMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1RvbmVNYXBwaW5nRWZmZWN0LmpzXG5pbXBvcnQgeyBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIFJFVklTSU9OIGFzIFJFVklTSU9OMywgVW5pZm9ybSBhcyBVbmlmb3JtNDYsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTkgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3Bhc3Nlcy9BZGFwdGl2ZUx1bWluYW5jZVBhc3MuanNcbmltcG9ydCB7IE5lYXJlc3RGaWx0ZXIgYXMgTmVhcmVzdEZpbHRlcjYsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTggfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9BZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxNywgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxOCwgVW5pZm9ybSBhcyBVbmlmb3JtNDUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2FkYXB0aXZlLWx1bWluYW5jZS5mcmFnXG52YXIgYWRhcHRpdmVfbHVtaW5hbmNlX2RlZmF1bHQgPSBgI2luY2x1ZGUgPHBhY2tpbmc+XG4jZGVmaW5lIHBhY2tGbG9hdFRvUkdCQSh2KSBwYWNrRGVwdGhUb1JHQkEodilcbiNkZWZpbmUgdW5wYWNrUkdCQVRvRmxvYXQodikgdW5wYWNrUkdCQVRvRGVwdGgodilcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbHVtaW5hbmNlQnVmZmVyMDt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGx1bWluYW5jZUJ1ZmZlcjE7dW5pZm9ybSBmbG9hdCBtaW5MdW1pbmFuY2U7dW5pZm9ybSBmbG9hdCBkZWx0YVRpbWU7dW5pZm9ybSBmbG9hdCB0YXU7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXtmbG9hdCBsMD11bnBhY2tSR0JBVG9GbG9hdCh0ZXh0dXJlMkQobHVtaW5hbmNlQnVmZmVyMCx2VXYpKTtcbiNpZiBfX1ZFUlNJT05fXyA8IDMwMFxuZmxvYXQgbDE9dGV4dHVyZTJETG9kRVhUKGx1bWluYW5jZUJ1ZmZlcjEsdlV2LE1JUF9MRVZFTF8xWDEpLnI7XG4jZWxzZVxuZmxvYXQgbDE9dGV4dHVyZUxvZChsdW1pbmFuY2VCdWZmZXIxLHZVdixNSVBfTEVWRUxfMVgxKS5yO1xuI2VuZGlmXG5sMD1tYXgobWluTHVtaW5hbmNlLGwwKTtsMT1tYXgobWluTHVtaW5hbmNlLGwxKTtmbG9hdCBhZGFwdGVkTHVtPWwwKyhsMS1sMCkqKDEuMC1leHAoLWRlbHRhVGltZSp0YXUpKTtnbF9GcmFnQ29sb3I9KGFkYXB0ZWRMdW09PTEuMCk/dmVjNCgxLjApOnBhY2tGbG9hdFRvUkdCQShhZGFwdGVkTHVtKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9BZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLmpzXG52YXIgQWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxOCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGFkYXB0aXZlIGx1bWluYW5jZSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBNSVBfTEVWRUxfMVgxOiBcIjAuMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgbHVtaW5hbmNlQnVmZmVyMDogbmV3IFVuaWZvcm00NShudWxsKSxcbiAgICAgICAgbHVtaW5hbmNlQnVmZmVyMTogbmV3IFVuaWZvcm00NShudWxsKSxcbiAgICAgICAgbWluTHVtaW5hbmNlOiBuZXcgVW5pZm9ybTQ1KDAuMDEpLFxuICAgICAgICBkZWx0YVRpbWU6IG5ldyBVbmlmb3JtNDUoMCksXG4gICAgICAgIHRhdTogbmV3IFVuaWZvcm00NSgxKVxuICAgICAgfSxcbiAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgc2hhZGVyVGV4dHVyZUxPRDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTcsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBhZGFwdGl2ZV9sdW1pbmFuY2VfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByaW1hcnkgbHVtaW5hbmNlIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSBkb3duc2FtcGxlZCBhdmVyYWdlIGx1bWluYW5jZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgbHVtaW5hbmNlQnVmZmVyMCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubHVtaW5hbmNlQnVmZmVyMC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmltYXJ5IGx1bWluYW5jZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgZG93bnNhbXBsZWQgYXZlcmFnZSBsdW1pbmFuY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VCdWZmZXIwIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0THVtaW5hbmNlQnVmZmVyMCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubHVtaW5hbmNlQnVmZmVyMC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2Vjb25kYXJ5IGx1bWluYW5jZSBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGx1bWluYW5jZUJ1ZmZlcjEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmx1bWluYW5jZUJ1ZmZlcjEudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2Vjb25kYXJ5IGx1bWluYW5jZSBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VCdWZmZXIxIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0THVtaW5hbmNlQnVmZmVyMSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubHVtaW5hbmNlQnVmZmVyMS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgMXgxIG1pcG1hcCBsZXZlbC5cbiAgICpcbiAgICogVGhpcyBsZXZlbCBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBzbWFsbGVzdCBtaXBtYXAgb2YgdGhlIHByaW1hcnkgbHVtaW5hbmNlIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBtaXBMZXZlbDF4MSh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5NSVBfTEVWRUxfMVgxID0gdmFsdWUudG9GaXhlZCgxKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgMXgxIG1pcG1hcCBsZXZlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pcExldmVsMXgxIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBsZXZlbC5cbiAgICovXG4gIHNldE1pcExldmVsMXgxKHZhbHVlKSB7XG4gICAgdGhpcy5taXBMZXZlbDF4MSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVsdGEgdGltZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBkZWx0YVRpbWUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhVGltZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWx0YSB0aW1lLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVsdGFUaW1lIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkZWx0YSB0aW1lLlxuICAgKi9cbiAgc2V0RGVsdGFUaW1lKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YVRpbWUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxvd2VzdCBwb3NzaWJsZSBsdW1pbmFuY2UgdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluTHVtaW5hbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1pbkx1bWluYW5jZS52YWx1ZTtcbiAgfVxuICBzZXQgbWluTHVtaW5hbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5taW5MdW1pbmFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG93ZXN0IHBvc3NpYmxlIGx1bWluYW5jZSB2YWx1ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkx1bWluYW5jZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtaW5pbXVtIGx1bWluYW5jZS5cbiAgICovXG4gIGdldE1pbkx1bWluYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5taW5MdW1pbmFuY2UudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluTHVtaW5hbmNlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIGx1bWluYW5jZS5cbiAgICovXG4gIHNldE1pbkx1bWluYW5jZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubWluTHVtaW5hbmNlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGFkYXB0YXRpb25SYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRhdS52YWx1ZTtcbiAgfVxuICBzZXQgYWRhcHRhdGlvblJhdGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRhdS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYWRhcHRhdGlvblJhdGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYWRhcHRhdGlvbiByYXRlLlxuICAgKi9cbiAgZ2V0QWRhcHRhdGlvblJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudGF1LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYWRhcHRhdGlvblJhdGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICovXG4gIHNldEFkYXB0YXRpb25SYXRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy50YXUudmFsdWUgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9BZGFwdGl2ZUx1bWluYW5jZVBhc3MuanNcbnZhciBBZGFwdGl2ZUx1bWluYW5jZVBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBhZGFwdGl2ZSBsdW1pbmFuY2UgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBsdW1pbmFuY2VCdWZmZXIgLSBBIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSBjdXJyZW50IHNjZW5lIGx1bWluYW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluTHVtaW5hbmNlPTAuMDFdIC0gVGhlIG1pbmltdW0gbHVtaW5hbmNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWRhcHRhdGlvblJhdGU9MS4wXSAtIFRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobHVtaW5hbmNlQnVmZmVyLCB7IG1pbkx1bWluYW5jZSA9IDAuMDEsIGFkYXB0YXRpb25SYXRlID0gMSB9ID0ge30pIHtcbiAgICBzdXBlcihcIkFkYXB0aXZlTHVtaW5hbmNlUGFzc1wiKTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG5ldyBBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsKCk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTgoMSwgMSwge1xuICAgICAgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyNixcbiAgICAgIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcjYsXG4gICAgICBkZXB0aEJ1ZmZlcjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzLnRleHR1cmUubmFtZSA9IFwiTHVtaW5hbmNlLlByZXZpb3VzXCI7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICBtYXRlcmlhbC5sdW1pbmFuY2VCdWZmZXIwID0gdGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cy50ZXh0dXJlO1xuICAgIG1hdGVyaWFsLmx1bWluYW5jZUJ1ZmZlcjEgPSBsdW1pbmFuY2VCdWZmZXI7XG4gICAgbWF0ZXJpYWwubWluTHVtaW5hbmNlID0gbWluTHVtaW5hbmNlO1xuICAgIG1hdGVyaWFsLmFkYXB0YXRpb25SYXRlID0gYWRhcHRhdGlvblJhdGU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkID0gdGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cy5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC50ZXh0dXJlLm5hbWUgPSBcIkx1bWluYW5jZS5BZGFwdGVkXCI7XG4gICAgdGhpcy5jb3B5UGFzcyA9IG5ldyBDb3B5UGFzcyh0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzLCBmYWxzZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhZGFwdGl2ZSBsdW1pbmFuY2UgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFkYXB0aXZlIDF4MSBsdW1pbmFuY2UgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgMXgxIG1pcG1hcCBsZXZlbC5cbiAgICpcbiAgICogVGhpcyBsZXZlbCBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBzbWFsbGVzdCBtaXBtYXAgb2YgdGhlIG1haW4gbHVtaW5hbmNlIHRleHR1cmUgd2hpY2ggY29udGFpbnMgdGhlIGRvd25zYW1wbGVkXG4gICAqIGF2ZXJhZ2Ugc2NlbmUgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsLm1pcExldmVsMXgxIGluc3RlYWQuXG4gICAqL1xuICBzZXQgbWlwTGV2ZWwxeDEodmFsdWUpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5taXBMZXZlbDF4MSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGFkYXB0YXRpb25SYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IGFkYXB0YXRpb25SYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2NlbmUgbm9ybWFscy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVsdGFUaW1lID0gZGVsdGFUaW1lO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICB0aGlzLmNvcHlQYXNzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkKTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC90b25lLW1hcHBpbmcuZnJhZ1xudmFyIHRvbmVfbWFwcGluZ19kZWZhdWx0ID0gYCNpbmNsdWRlIDx0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50PlxudW5pZm9ybSBmbG9hdCB3aGl0ZVBvaW50O1xuI2lmIFRPTkVfTUFQUElOR19NT0RFID09IDIgfHwgVE9ORV9NQVBQSU5HX01PREUgPT0gM1xudW5pZm9ybSBmbG9hdCBtaWRkbGVHcmV5O1xuI2lmIFRPTkVfTUFQUElOR19NT0RFID09IDNcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbHVtaW5hbmNlQnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gZmxvYXQgYXZlcmFnZUx1bWluYW5jZTtcbiNlbmRpZlxudmVjMyBSZWluaGFyZDJUb25lTWFwcGluZyh2ZWMzIGNvbG9yKXtjb2xvcio9dG9uZU1hcHBpbmdFeHBvc3VyZTtmbG9hdCBsPWx1bWluYW5jZShjb2xvcik7XG4jaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gM1xuZmxvYXQgbHVtQXZnPXVucGFja1JHQkFUb0Zsb2F0KHRleHR1cmUyRChsdW1pbmFuY2VCdWZmZXIsdmVjMigwLjUpKSk7XG4jZWxzZVxuZmxvYXQgbHVtQXZnPWF2ZXJhZ2VMdW1pbmFuY2U7XG4jZW5kaWZcbmZsb2F0IGx1bVNjYWxlZD0obCptaWRkbGVHcmV5KS9tYXgobHVtQXZnLDFlLTYpO2Zsb2F0IGx1bUNvbXByZXNzZWQ9bHVtU2NhbGVkKigxLjArbHVtU2NhbGVkLyh3aGl0ZVBvaW50KndoaXRlUG9pbnQpKTtsdW1Db21wcmVzc2VkLz0oMS4wK2x1bVNjYWxlZCk7cmV0dXJuIGNsYW1wKGx1bUNvbXByZXNzZWQqY29sb3IsMC4wLDEuMCk7fVxuI2VsaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gNFxuI2RlZmluZSBBIDAuMTVcbiNkZWZpbmUgQiAwLjUwXG4jZGVmaW5lIEMgMC4xMFxuI2RlZmluZSBEIDAuMjBcbiNkZWZpbmUgRSAwLjAyXG4jZGVmaW5lIEYgMC4zMFxudmVjMyBVbmNoYXJ0ZWQySGVscGVyKGNvbnN0IGluIHZlYzMgeCl7cmV0dXJuKCh4KihBKngrQypCKStEKkUpLyh4KihBKngrQikrRCpGKSktRS9GO312ZWMzIFVuY2hhcnRlZDJUb25lTWFwcGluZyh2ZWMzIGNvbG9yKXtjb2xvcio9dG9uZU1hcHBpbmdFeHBvc3VyZTtyZXR1cm4gY2xhbXAoVW5jaGFydGVkMkhlbHBlcihjb2xvcikvVW5jaGFydGVkMkhlbHBlcih2ZWMzKHdoaXRlUG9pbnQpKSwwLjAsMS4wKTt9XG4jZW5kaWZcbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtcbiNpZiBUT05FX01BUFBJTkdfTU9ERSA9PSAyIHx8IFRPTkVfTUFQUElOR19NT0RFID09IDNcbm91dHB1dENvbG9yPXZlYzQoUmVpbmhhcmQyVG9uZU1hcHBpbmcoaW5wdXRDb2xvci5yZ2IpLGlucHV0Q29sb3IuYSk7XG4jZWxpZiBUT05FX01BUFBJTkdfTU9ERSA9PSA0XG5vdXRwdXRDb2xvcj12ZWM0KFVuY2hhcnRlZDJUb25lTWFwcGluZyhpbnB1dENvbG9yLnJnYiksaW5wdXRDb2xvci5hKTtcbiNlbHNlXG5vdXRwdXRDb2xvcj12ZWM0KHRvbmVNYXBwaW5nKGlucHV0Q29sb3IucmdiKSxpbnB1dENvbG9yLmEpO1xuI2VuZGlmXG59YDtcblxuLy8gc3JjL2VmZmVjdHMvVG9uZU1hcHBpbmdFZmZlY3QuanNcbnZhciBUb25lTWFwcGluZ0VmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdG9uZSBtYXBwaW5nIGVmZmVjdC5cbiAgICpcbiAgICogVGhlIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBvbmx5IGFmZmVjdCB0aGUgUmVpbmhhcmQyIG9wZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWRhcHRpdmU9ZmFsc2VdIC0gRGVwcmVjYXRlZC4gVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUb25lTWFwcGluZ01vZGV9IFtvcHRpb25zLm1vZGU9VG9uZU1hcHBpbmdNb2RlLkFHWF0gLSBUaGUgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPTI1Nl0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgbHVtaW5hbmNlIHRleHR1cmUuIE11c3QgYmUgYSBwb3dlciBvZiB0d28uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhMdW1pbmFuY2U9NC4wXSAtIERlcHJlY2F0ZWQuIFNhbWUgYXMgd2hpdGVQb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndoaXRlUG9pbnQ9NC4wXSAtIFRoZSB3aGl0ZSBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pZGRsZUdyZXk9MC42XSAtIFRoZSBtaWRkbGUgZ3JleSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5MdW1pbmFuY2U9MC4wMV0gLSBUaGUgbWluaW11bSBsdW1pbmFuY2UuIFByZXZlbnRzIHZlcnkgaGlnaCBleHBvc3VyZSBpbiBkYXJrIHNjZW5lcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF2ZXJhZ2VMdW1pbmFuY2U9MS4wXSAtIFRoZSBhdmVyYWdlIGx1bWluYW5jZS4gVXNlZCBmb3IgdGhlIG5vbi1hZGFwdGl2ZSBSZWluaGFyZCBvcGVyYXRvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFkYXB0YXRpb25SYXRlPTEuMF0gLSBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsXG4gICAgYWRhcHRpdmUgPSBmYWxzZSxcbiAgICBtb2RlID0gYWRhcHRpdmUgPyBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQyX0FEQVBUSVZFIDogVG9uZU1hcHBpbmdNb2RlLkFHWCxcbiAgICByZXNvbHV0aW9uID0gMjU2LFxuICAgIG1heEx1bWluYW5jZSA9IDQsXG4gICAgd2hpdGVQb2ludCA9IG1heEx1bWluYW5jZSxcbiAgICBtaWRkbGVHcmV5ID0gMC42LFxuICAgIG1pbkx1bWluYW5jZSA9IDAuMDEsXG4gICAgYXZlcmFnZUx1bWluYW5jZSA9IDEsXG4gICAgYWRhcHRhdGlvblJhdGUgPSAxXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiVG9uZU1hcHBpbmdFZmZlY3RcIiwgdG9uZV9tYXBwaW5nX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJsdW1pbmFuY2VCdWZmZXJcIiwgbmV3IFVuaWZvcm00NihudWxsKV0sXG4gICAgICAgIFtcIm1heEx1bWluYW5jZVwiLCBuZXcgVW5pZm9ybTQ2KG1heEx1bWluYW5jZSldLFxuICAgICAgICAvLyBVbnVzZWRcbiAgICAgICAgW1wid2hpdGVQb2ludFwiLCBuZXcgVW5pZm9ybTQ2KHdoaXRlUG9pbnQpXSxcbiAgICAgICAgW1wibWlkZGxlR3JleVwiLCBuZXcgVW5pZm9ybTQ2KG1pZGRsZUdyZXkpXSxcbiAgICAgICAgW1wiYXZlcmFnZUx1bWluYW5jZVwiLCBuZXcgVW5pZm9ybTQ2KGF2ZXJhZ2VMdW1pbmFuY2UpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEx1bWluYW5jZSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDE5KDEsIDEsIHtcbiAgICAgIG1pbkZpbHRlcjogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLFxuICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMdW1pbmFuY2UudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0THVtaW5hbmNlLnRleHR1cmUubmFtZSA9IFwiTHVtaW5hbmNlXCI7XG4gICAgdGhpcy5sdW1pbmFuY2VQYXNzID0gbmV3IEx1bWluYW5jZVBhc3Moe1xuICAgICAgcmVuZGVyVGFyZ2V0OiB0aGlzLnJlbmRlclRhcmdldEx1bWluYW5jZVxuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzID0gbmV3IEFkYXB0aXZlTHVtaW5hbmNlUGFzcyh0aGlzLmx1bWluYW5jZVBhc3MudGV4dHVyZSwge1xuICAgICAgbWluTHVtaW5hbmNlLFxuICAgICAgYWRhcHRhdGlvblJhdGVcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImx1bWluYW5jZUJ1ZmZlclwiKS52YWx1ZSA9IHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzLnRleHR1cmU7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqXG4gICAqIEB0eXBlIHtUb25lTWFwcGluZ01vZGV9XG4gICAqL1xuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJUT05FX01BUFBJTkdfTU9ERVwiKSk7XG4gIH1cbiAgc2V0IG1vZGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5tb2RlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXZpc2lvbiA9IFJFVklTSU9OMy5yZXBsYWNlKC9cXEQrL2csIFwiXCIpO1xuICAgIGNvbnN0IGNpbmVvblRvbmVNYXBwaW5nID0gcmV2aXNpb24gPj0gMTY4ID8gXCJDaW5lb25Ub25lTWFwcGluZyh0ZXhlbClcIiA6IFwiT3B0aW1pemVkQ2luZW9uVG9uZU1hcHBpbmcodGV4ZWwpXCI7XG4gICAgdGhpcy5kZWZpbmVzLmNsZWFyKCk7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlRPTkVfTUFQUElOR19NT0RFXCIsIHZhbHVlLnRvRml4ZWQoMCkpO1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgVG9uZU1hcHBpbmdNb2RlLkxJTkVBUjpcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBcIkxpbmVhclRvbmVNYXBwaW5nKHRleGVsKVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRvbmVNYXBwaW5nTW9kZS5SRUlOSEFSRDpcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBcIlJlaW5oYXJkVG9uZU1hcHBpbmcodGV4ZWwpXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9uZU1hcHBpbmdNb2RlLkNJTkVPTjpcbiAgICAgIGNhc2UgVG9uZU1hcHBpbmdNb2RlLk9QVElNSVpFRF9DSU5FT046XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJ0b25lTWFwcGluZyh0ZXhlbClcIiwgY2luZW9uVG9uZU1hcHBpbmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9uZU1hcHBpbmdNb2RlLkFDRVNfRklMTUlDOlxuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwidG9uZU1hcHBpbmcodGV4ZWwpXCIsIFwiQUNFU0ZpbG1pY1RvbmVNYXBwaW5nKHRleGVsKVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRvbmVNYXBwaW5nTW9kZS5BR1g6XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJ0b25lTWFwcGluZyh0ZXhlbClcIiwgXCJBZ1hUb25lTWFwcGluZyh0ZXhlbClcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb25lTWFwcGluZ01vZGUuTkVVVFJBTDpcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBcIk5ldXRyYWxUb25lTWFwcGluZyh0ZXhlbClcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBcInRleGVsXCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MuZW5hYmxlZCA9IHZhbHVlID09PSBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQyX0FEQVBUSVZFO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRvbmUgbWFwcGluZyBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUb25lTWFwcGluZ01vZGV9IFRoZSB0b25lIG1hcHBpbmcgbW9kZS5cbiAgICovXG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VG9uZU1hcHBpbmdNb2RlfSB2YWx1ZSAtIFRoZSB0b25lIG1hcHBpbmcgbW9kZS5cbiAgICovXG4gIHNldE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLm1vZGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdoaXRlIHBvaW50LiBEZWZhdWx0IGlzIGA0LjBgLlxuICAgKlxuICAgKiBPbmx5IGFwcGxpZXMgdG8gUmVpbmhhcmQyIChNb2RpZmllZCAmIEFkYXB0aXZlKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3aGl0ZVBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIndoaXRlUG9pbnRcIikudmFsdWU7XG4gIH1cbiAgc2V0IHdoaXRlUG9pbnQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIndoaXRlUG9pbnRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pZGRsZSBncmV5IGZhY3Rvci4gRGVmYXVsdCBpcyBgMC42YC5cbiAgICpcbiAgICogT25seSBhcHBsaWVzIHRvIFJlaW5oYXJkMiAoTW9kaWZpZWQgJiBBZGFwdGl2ZSkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWlkZGxlR3JleSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJtaWRkbGVHcmV5XCIpLnZhbHVlO1xuICB9XG4gIHNldCBtaWRkbGVHcmV5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtaWRkbGVHcmV5XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhdmVyYWdlIGx1bWluYW5jZS5cbiAgICpcbiAgICogT25seSBhcHBsaWVzIHRvIFJlaW5oYXJkMiAoTW9kaWZpZWQpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGF2ZXJhZ2VMdW1pbmFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiYXZlcmFnZUx1bWluYW5jZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgYXZlcmFnZUx1bWluYW5jZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYXZlcmFnZUx1bWluYW5jZVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYWRhcHRpdmUgbHVtaW5hbmNlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7QWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbH1cbiAgICovXG4gIGdldCBhZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFkYXB0aXZlIGx1bWluYW5jZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7QWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0QWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgbHVtaW5hbmNlIHRleHR1cmUuIE11c3QgYmUgYSBwb3dlciBvZiB0d28uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VQYXNzLnJlc29sdXRpb24ud2lkdGg7XG4gIH1cbiAgc2V0IHJlc29sdXRpb24odmFsdWUpIHtcbiAgICBjb25zdCBleHBvbmVudCA9IE1hdGgubWF4KDAsIE1hdGguY2VpbChNYXRoLmxvZzIodmFsdWUpKSk7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICB0aGlzLmx1bWluYW5jZVBhc3MucmVzb2x1dGlvbi5zZXRQcmVmZXJyZWRTaXplKHNpemUsIHNpemUpO1xuICAgIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbC5taXBMZXZlbDF4MSA9IGV4cG9uZW50O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgbHVtaW5hbmNlIHRleHR1cmUuIE11c3QgYmUgYSBwb3dlciBvZiB0d28uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHBhc3MgdXNlcyBhZGFwdGl2ZSBsdW1pbmFuY2UuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGFkYXB0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGUgPT09IFRvbmVNYXBwaW5nTW9kZS5SRUlOSEFSRDJfQURBUFRJVkU7XG4gIH1cbiAgc2V0IGFkYXB0aXZlKHZhbHVlKSB7XG4gICAgdGhpcy5tb2RlID0gdmFsdWUgPyBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQyX0FEQVBUSVZFIDogVG9uZU1hcHBpbmdNb2RlLlJFSU5IQVJEMjtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSBhZGFwdGF0aW9uIHJhdGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBhZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLmFkYXB0YXRpb25SYXRlIGluc3RlYWQuXG4gICAqL1xuICBnZXQgYWRhcHRhdGlvblJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZTtcbiAgfVxuICBzZXQgYWRhcHRhdGlvblJhdGUodmFsdWUpIHtcbiAgICB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBkaXN0aW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4odGhpcy5uYW1lLCBcImRpc3RpbmN0aW9uIHdhcyByZW1vdmVkLlwiKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBzZXQgZGlzdGluY3Rpb24odmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4odGhpcy5uYW1lLCBcImRpc3RpbmN0aW9uIHdhcyByZW1vdmVkLlwiKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMubHVtaW5hbmNlUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyKTtcbiAgICAgIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzLnJlbmRlcihyZW5kZXJlciwgbnVsbCwgbnVsbCwgZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9WaWduZXR0ZUVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtNDcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC92aWduZXR0ZS5mcmFnXG52YXIgdmlnbmV0dGVfZGVmYXVsdCA9IGB1bmlmb3JtIGZsb2F0IG9mZnNldDt1bmlmb3JtIGZsb2F0IGRhcmtuZXNzO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtjb25zdCB2ZWMyIGNlbnRlcj12ZWMyKDAuNSk7dmVjMyBjb2xvcj1pbnB1dENvbG9yLnJnYjtcbiNpZiBWSUdORVRURV9URUNITklRVUUgPT0gMFxuZmxvYXQgZD1kaXN0YW5jZSh1dixjZW50ZXIpO2NvbG9yKj1zbW9vdGhzdGVwKDAuOCxvZmZzZXQqMC43OTksZCooZGFya25lc3Mrb2Zmc2V0KSk7XG4jZWxzZVxudmVjMiBjb29yZD0odXYtY2VudGVyKSp2ZWMyKG9mZnNldCk7Y29sb3I9bWl4KGNvbG9yLHZlYzMoMS4wLWRhcmtuZXNzKSxkb3QoY29vcmQsY29vcmQpKTtcbiNlbmRpZlxub3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9WaWduZXR0ZUVmZmVjdC5qc1xudmFyIFZpZ25ldHRlRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBWaWduZXR0ZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtWaWduZXR0ZVRlY2huaXF1ZX0gW29wdGlvbnMudGVjaG5pcXVlPVZpZ25ldHRlVGVjaG5pcXVlLkRFRkFVTFRdIC0gVGhlIFZpZ25ldHRlIHRlY2huaXF1ZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lc2tpbD1mYWxzZV0gLSBEZXByZWNhdGVkLiBVc2UgdGVjaG5pcXVlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXQ9MC41XSAtIFRoZSBWaWduZXR0ZSBvZmZzZXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kYXJrbmVzcz0wLjVdIC0gVGhlIFZpZ25ldHRlIGRhcmtuZXNzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgZXNraWwgPSBmYWxzZSxcbiAgICB0ZWNobmlxdWUgPSBlc2tpbCA/IFZpZ25ldHRlVGVjaG5pcXVlLkVTS0lMIDogVmlnbmV0dGVUZWNobmlxdWUuREVGQVVMVCxcbiAgICBvZmZzZXQgPSAwLjUsXG4gICAgZGFya25lc3MgPSAwLjVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJWaWduZXR0ZUVmZmVjdFwiLCB2aWduZXR0ZV9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgZGVmaW5lczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJWSUdORVRURV9URUNITklRVUVcIiwgdGVjaG5pcXVlLnRvRml4ZWQoMCldXG4gICAgICBdKSxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm9mZnNldFwiLCBuZXcgVW5pZm9ybTQ3KG9mZnNldCldLFxuICAgICAgICBbXCJkYXJrbmVzc1wiLCBuZXcgVW5pZm9ybTQ3KGRhcmtuZXNzKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBWaWduZXR0ZSB0ZWNobmlxdWUuXG4gICAqXG4gICAqIEB0eXBlIHtWaWduZXR0ZVRlY2huaXF1ZX1cbiAgICovXG4gIGdldCB0ZWNobmlxdWUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuZ2V0KFwiVklHTkVUVEVfVEVDSE5JUVVFXCIpKTtcbiAgfVxuICBzZXQgdGVjaG5pcXVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudGVjaG5pcXVlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlZJR05FVFRFX1RFQ0hOSVFVRVwiLCB2YWx1ZS50b0ZpeGVkKDApKTtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgRXNraWwncyBWaWduZXR0ZSB0ZWNobmlxdWUgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZWNobmlxdWUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBlc2tpbCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNobmlxdWUgPT09IFZpZ25ldHRlVGVjaG5pcXVlLkVTS0lMO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBFc2tpbCdzIFZpZ25ldHRlIHRlY2huaXF1ZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRlY2huaXF1ZSBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IGVza2lsKHZhbHVlKSB7XG4gICAgdGhpcy50ZWNobmlxdWUgPSB2YWx1ZSA/IFZpZ25ldHRlVGVjaG5pcXVlLkVTS0lMIDogVmlnbmV0dGVUZWNobmlxdWUuREVGQVVMVDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVmlnbmV0dGUgdGVjaG5pcXVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVjaG5pcXVlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZpZ25ldHRlVGVjaG5pcXVlfSBUaGUgdGVjaG5pcXVlLlxuICAgKi9cbiAgZ2V0VGVjaG5pcXVlKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2huaXF1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgVmlnbmV0dGUgdGVjaG5pcXVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVjaG5pcXVlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmlnbmV0dGVUZWNobmlxdWV9IHZhbHVlIC0gVGhlIHRlY2huaXF1ZS5cbiAgICovXG4gIHNldFRlY2huaXF1ZSh2YWx1ZSkge1xuICAgIHRoaXMudGVjaG5pcXVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBWaWduZXR0ZSBvZmZzZXQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm9mZnNldFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJvZmZzZXRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVmlnbmV0dGUgb2Zmc2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb2Zmc2V0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG9mZnNldC5cbiAgICovXG4gIGdldE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIFZpZ25ldHRlIG9mZnNldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9mZnNldCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgb2Zmc2V0LlxuICAgKi9cbiAgc2V0T2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5vZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIFZpZ25ldHRlIGRhcmtuZXNzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRhcmtuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImRhcmtuZXNzXCIpLnZhbHVlO1xuICB9XG4gIHNldCBkYXJrbmVzcyh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZGFya25lc3NcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVmlnbmV0dGUgZGFya25lc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkYXJrbmVzcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkYXJrbmVzcy5cbiAgICovXG4gIGdldERhcmtuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmRhcmtuZXNzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBWaWduZXR0ZSBkYXJrbmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRhcmtuZXNzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkYXJrbmVzcy5cbiAgICovXG4gIHNldERhcmtuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5kYXJrbmVzcyA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbG9hZGVycy9MVVQzZGxMb2FkZXIuanNcbmltcG9ydCB7IEZpbGVMb2FkZXIsIExvYWRlciwgTG9hZGluZ01hbmFnZXIgYXMgTG9hZGluZ01hbmFnZXIyIH0gZnJvbSBcInRocmVlXCI7XG52YXIgTFVUM2RsTG9hZGVyID0gY2xhc3MgZXh0ZW5kcyBMb2FkZXIge1xuICAvKipcbiAgICogTG9hZHMgYSBMVVQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSAzZGwtZmlsZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTG9hZF0gLSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGxvYWRlZCBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIC0gQSBwcm9ncmVzcyBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBYTUxIdHRwUmVxdWVzdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gQW4gZXJyb3IgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgVVJMIG9mIHRoZSBmaWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gICAqL1xuICBsb2FkKHVybCwgb25Mb2FkID0gKCkgPT4ge1xuICB9LCBvblByb2dyZXNzID0gKCkgPT4ge1xuICB9LCBvbkVycm9yID0gbnVsbCkge1xuICAgIGNvbnN0IGV4dGVybmFsTWFuYWdlciA9IHRoaXMubWFuYWdlcjtcbiAgICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIyKCk7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoaW50ZXJuYWxNYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJ0ZXh0XCIpO1xuICAgIGV4dGVybmFsTWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICBsb2FkZXIubG9hZCh1cmwsIChkYXRhKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlKGRhdGEpO1xuICAgICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLm9uRXJyb3IodXJsKTtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cbiAgICB9LCBvblByb2dyZXNzKTtcbiAgfVxuICAvKipcbiAgICogTG9hZHMgYSBMVVQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSAzZGwtZmlsZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIC0gQSBwcm9ncmVzcyBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBYTUxIdHRwUmVxdWVzdCBpbnN0YW5jZS5cbiAgICogQHJldHVybiB7UHJvbWlzZTxMb29rdXBUZXh0dXJlPn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgbG9va3VwIHRleHR1cmUuXG4gICAqL1xuICBsb2FkQXN5bmModXJsLCBvblByb2dyZXNzID0gKCkgPT4ge1xuICB9KSB7XG4gICAgY29uc3QgZXh0ZXJuYWxNYW5hZ2VyID0gdGhpcy5tYW5hZ2VyO1xuICAgIGNvbnN0IGludGVybmFsTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcjIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLm9uRXJyb3IgPSAodXJsMikgPT4ge1xuICAgICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbUVycm9yKHVybDIpO1xuICAgICAgICByZWplY3QoYEZhaWxlZCB0byBsb2FkICR7dXJsMn1gKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmxvYWQodXJsLCByZXNvbHZlLCBvblByb2dyZXNzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgLSBUaGUgTFVUIGRhdGEuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoZSBsb29rdXAgdGV4dHVyZS5cbiAgICogQHRocm93cyB7RXJyb3J9IEZhaWxzIGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gICAqL1xuICBwYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHJlZ0V4cEdyaWRJbmZvID0gL15bXFxkIF0rJC9tO1xuICAgIGNvbnN0IHJlZ0V4cERhdGFQb2ludHMgPSAvXihbXFxkLmUrLV0rKSArKFtcXGQuZSstXSspICsoW1xcZC5lKy1dKykgKiQvZ207XG4gICAgbGV0IHJlc3VsdCA9IHJlZ0V4cEdyaWRJbmZvLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZ3JpZCBpbmZvcm1hdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgZ3JpZExpbmVzID0gcmVzdWx0WzBdLnRyaW0oKS5zcGxpdCgvXFxzKy9nKS5tYXAoKG4pID0+IE51bWJlcihuKSk7XG4gICAgY29uc3QgZ3JpZFN0ZXAgPSBncmlkTGluZXNbMV0gLSBncmlkTGluZXNbMF07XG4gICAgY29uc3Qgc2l6ZSA9IGdyaWRMaW5lcy5sZW5ndGg7XG4gICAgY29uc3Qgc2l6ZVNxID0gc2l6ZSAqKiAyO1xuICAgIGZvciAobGV0IGkgPSAxLCBsID0gZ3JpZExpbmVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgaWYgKGdyaWRTdGVwICE9PSBncmlkTGluZXNbaV0gLSBncmlkTGluZXNbaSAtIDFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29uc2lzdGVudCBncmlkIHNpemVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiogMyAqIDQpO1xuICAgIGxldCBtYXhWYWx1ZSA9IDA7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cERhdGFQb2ludHMuZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCByID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gICAgICBjb25zdCBnID0gTnVtYmVyKHJlc3VsdFsyXSk7XG4gICAgICBjb25zdCBiID0gTnVtYmVyKHJlc3VsdFszXSk7XG4gICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCByLCBnLCBiKTtcbiAgICAgIGNvbnN0IGJMYXllciA9IGluZGV4ICUgc2l6ZTtcbiAgICAgIGNvbnN0IGdMYXllciA9IE1hdGguZmxvb3IoaW5kZXggLyBzaXplKSAlIHNpemU7XG4gICAgICBjb25zdCByTGF5ZXIgPSBNYXRoLmZsb29yKGluZGV4IC8gc2l6ZVNxKSAlIHNpemU7XG4gICAgICBjb25zdCBkNCA9IChiTGF5ZXIgKiBzaXplU3EgKyBnTGF5ZXIgKiBzaXplICsgckxheWVyKSAqIDQ7XG4gICAgICBkYXRhW2Q0ICsgMF0gPSByO1xuICAgICAgZGF0YVtkNCArIDFdID0gZztcbiAgICAgIGRhdGFbZDQgKyAyXSA9IGI7XG4gICAgICBkYXRhW2Q0ICsgM10gPSAxO1xuICAgICAgKytpbmRleDtcbiAgICB9XG4gICAgY29uc3QgYml0cyA9IE1hdGguY2VpbChNYXRoLmxvZzIobWF4VmFsdWUpKTtcbiAgICBjb25zdCBtYXhCaXRWYWx1ZSA9IE1hdGgucG93KDIsIGJpdHMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgIGRhdGFbaSArIDBdIC89IG1heEJpdFZhbHVlO1xuICAgICAgZGF0YVtpICsgMV0gLz0gbWF4Qml0VmFsdWU7XG4gICAgICBkYXRhW2kgKyAyXSAvPSBtYXhCaXRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb29rdXBUZXh0dXJlKGRhdGEsIHNpemUpO1xuICB9XG59O1xuXG4vLyBzcmMvbG9hZGVycy9MVVRDdWJlTG9hZGVyLmpzXG5pbXBvcnQgeyBGaWxlTG9hZGVyIGFzIEZpbGVMb2FkZXIyLCBMb2FkZXIgYXMgTG9hZGVyMiwgTG9hZGluZ01hbmFnZXIgYXMgTG9hZGluZ01hbmFnZXIzLCBWZWN0b3IzIGFzIFZlY3RvcjM3IH0gZnJvbSBcInRocmVlXCI7XG52YXIgTFVUQ3ViZUxvYWRlciA9IGNsYXNzIGV4dGVuZHMgTG9hZGVyMiB7XG4gIC8qKlxuICAgKiBMb2FkcyBhIExVVC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIENVQkUtZmlsZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTG9hZF0gLSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGxvYWRlZCBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIC0gQSBwcm9ncmVzcyBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBYTUxIdHRwUmVxdWVzdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gQW4gZXJyb3IgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgVVJMIG9mIHRoZSBmaWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gICAqL1xuICBsb2FkKHVybCwgb25Mb2FkID0gKCkgPT4ge1xuICB9LCBvblByb2dyZXNzID0gKCkgPT4ge1xuICB9LCBvbkVycm9yID0gbnVsbCkge1xuICAgIGNvbnN0IGV4dGVybmFsTWFuYWdlciA9IHRoaXMubWFuYWdlcjtcbiAgICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIzKCk7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIyKGludGVybmFsTWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwidGV4dFwiKTtcbiAgICBsb2FkZXIubG9hZCh1cmwsIChkYXRhKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlKGRhdGEpO1xuICAgICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLm9uRXJyb3IodXJsKTtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cbiAgICB9LCBvblByb2dyZXNzKTtcbiAgfVxuICAvKipcbiAgICogTG9hZHMgYSBMVVQgYXN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBDVUJFLWZpbGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblByb2dyZXNzXSAtIEEgcHJvZ3Jlc3MgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgWE1MSHR0cFJlcXVlc3QgaW5zdGFuY2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TG9va3VwVGV4dHVyZT59IEEgcHJvbWlzZSB0aGF0IHJldHVybnMgdGhlIGxvb2t1cCB0ZXh0dXJlLlxuICAgKi9cbiAgbG9hZEFzeW5jKHVybCwgb25Qcm9ncmVzcyA9ICgpID0+IHtcbiAgfSkge1xuICAgIGNvbnN0IGV4dGVybmFsTWFuYWdlciA9IHRoaXMubWFuYWdlcjtcbiAgICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIzKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGludGVybmFsTWFuYWdlci5vbkVycm9yID0gKHVybDIpID0+IHtcbiAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FcnJvcih1cmwyKTtcbiAgICAgICAgcmVqZWN0KGBGYWlsZWQgdG8gbG9hZCAke3VybDJ9YCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5sb2FkKHVybCwgcmVzb2x2ZSwgb25Qcm9ncmVzcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IC0gVGhlIExVVCBkYXRhLlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGUgbG9va3VwIHRleHR1cmUuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBGYWlscyBpZiB0aGUgZGF0YSBpcyBpbnZhbGlkLlxuICAgKi9cbiAgcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCByZWdFeHBUaXRsZSA9IC9USVRMRSArXCIoW15cIl0qKVwiLztcbiAgICBjb25zdCByZWdFeHBTaXplID0gL0xVVF8zRF9TSVpFICsoXFxkKykvO1xuICAgIGNvbnN0IHJlZ0V4cERvbWFpbk1pbiA9IC9ET01BSU5fTUlOICsoW1xcZC5dKykgKyhbXFxkLl0rKSArKFtcXGQuXSspLztcbiAgICBjb25zdCByZWdFeHBEb21haW5NYXggPSAvRE9NQUlOX01BWCArKFtcXGQuXSspICsoW1xcZC5dKykgKyhbXFxkLl0rKS87XG4gICAgY29uc3QgcmVnRXhwRGF0YVBvaW50cyA9IC9eKFtcXGQuZSstXSspICsoW1xcZC5lKy1dKykgKyhbXFxkLmUrLV0rKSAqJC9nbTtcbiAgICBsZXQgcmVzdWx0ID0gcmVnRXhwVGl0bGUuZXhlYyhpbnB1dCk7XG4gICAgY29uc3QgdGl0bGUgPSByZXN1bHQgIT09IG51bGwgPyByZXN1bHRbMV0gOiBudWxsO1xuICAgIHJlc3VsdCA9IHJlZ0V4cFNpemUuZXhlYyhpbnB1dCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBMVVRfM0RfU0laRSBpbmZvcm1hdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlcihyZXN1bHRbMV0pO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiogMyAqIDQpO1xuICAgIGNvbnN0IGRvbWFpbk1pbiA9IG5ldyBWZWN0b3IzNygwLCAwLCAwKTtcbiAgICBjb25zdCBkb21haW5NYXggPSBuZXcgVmVjdG9yMzcoMSwgMSwgMSk7XG4gICAgcmVzdWx0ID0gcmVnRXhwRG9tYWluTWluLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIGRvbWFpbk1pbi5zZXQoTnVtYmVyKHJlc3VsdFsxXSksIE51bWJlcihyZXN1bHRbMl0pLCBOdW1iZXIocmVzdWx0WzNdKSk7XG4gICAgfVxuICAgIHJlc3VsdCA9IHJlZ0V4cERvbWFpbk1heC5leGVjKGlucHV0KTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICBkb21haW5NYXguc2V0KE51bWJlcihyZXN1bHRbMV0pLCBOdW1iZXIocmVzdWx0WzJdKSwgTnVtYmVyKHJlc3VsdFszXSkpO1xuICAgIH1cbiAgICBpZiAoZG9tYWluTWluLnggPiBkb21haW5NYXgueCB8fCBkb21haW5NaW4ueSA+IGRvbWFpbk1heC55IHx8IGRvbWFpbk1pbi56ID4gZG9tYWluTWF4LnopIHtcbiAgICAgIGRvbWFpbk1pbi5zZXQoMCwgMCwgMCk7XG4gICAgICBkb21haW5NYXguc2V0KDEsIDEsIDEpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBkb21haW5cIik7XG4gICAgfVxuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cERhdGFQb2ludHMuZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICBkYXRhW2krK10gPSBOdW1iZXIocmVzdWx0WzFdKTtcbiAgICAgIGRhdGFbaSsrXSA9IE51bWJlcihyZXN1bHRbMl0pO1xuICAgICAgZGF0YVtpKytdID0gTnVtYmVyKHJlc3VsdFszXSk7XG4gICAgICBkYXRhW2krK10gPSAxO1xuICAgIH1cbiAgICBjb25zdCBsdXQgPSBuZXcgTG9va3VwVGV4dHVyZShkYXRhLCBzaXplKTtcbiAgICBsdXQuZG9tYWluTWluLmNvcHkoZG9tYWluTWluKTtcbiAgICBsdXQuZG9tYWluTWF4LmNvcHkoZG9tYWluTWF4KTtcbiAgICBpZiAodGl0bGUgIT09IG51bGwpIHtcbiAgICAgIGx1dC5uYW1lID0gdGl0bGU7XG4gICAgfVxuICAgIHJldHVybiBsdXQ7XG4gIH1cbn07XG5cbi8vIHNyYy9sb2FkZXJzL1NNQUFJbWFnZUxvYWRlci5qc1xuaW1wb3J0IHsgTG9hZGVyIGFzIExvYWRlcjMsIExvYWRpbmdNYW5hZ2VyIGFzIExvYWRpbmdNYW5hZ2VyNCB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIFNNQUFJbWFnZUxvYWRlciA9IGNsYXNzIGV4dGVuZHMgTG9hZGVyMyB7XG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgU01BQSBkYXRhIGltYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTG9hZF0gLSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIHNlYXJjaCBpbWFnZSBhbmQgYXJlYSBpbWFnZSBhcyBhIHBhaXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSAtIEFuIGVycm9yIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UgdGhhdCBmYWlsZWQgdG8gbG9hZC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxJbWFnZVtdPn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgc2VhcmNoIGltYWdlIGFuZCBhcmVhIGltYWdlIGFzIGEgcGFpci5cbiAgICovXG4gIGxvYWQob25Mb2FkID0gKCkgPT4ge1xuICB9LCBvbkVycm9yID0gbnVsbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICBvbkxvYWQgPSBhcmd1bWVudHNbMV07XG4gICAgICBvbkVycm9yID0gYXJndW1lbnRzWzNdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyB8fCB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9uTG9hZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIG9uRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlcm5hbE1hbmFnZXIgPSB0aGlzLm1hbmFnZXI7XG4gICAgY29uc3QgaW50ZXJuYWxNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyNCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzZWFyY2hJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgY29uc3QgYXJlYUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBpbnRlcm5hbE1hbmFnZXIub25FcnJvciA9ICh1cmwpID0+IHtcbiAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICBpZiAob25FcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgIG9uRXJyb3IoYEZhaWxlZCB0byBsb2FkICR7dXJsfWApO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoYEZhaWxlZCB0byBsb2FkICR7dXJsfWApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLm9uTG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3NlYXJjaEltYWdlLCBhcmVhSW1hZ2VdO1xuICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHNlYXJjaEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICBpbnRlcm5hbE1hbmFnZXIuaXRlbUVycm9yKFwic21hYS1zZWFyY2hcIik7XG4gICAgICB9KTtcbiAgICAgIGFyZWFJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1FcnJvcihcInNtYWEtYXJlYVwiKTtcbiAgICAgIH0pO1xuICAgICAgc2VhcmNoSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbUVuZChcInNtYWEtc2VhcmNoXCIpO1xuICAgICAgICBpbnRlcm5hbE1hbmFnZXIuaXRlbUVuZChcInNtYWEtc2VhcmNoXCIpO1xuICAgICAgfSk7XG4gICAgICBhcmVhSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbUVuZChcInNtYWEtYXJlYVwiKTtcbiAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLWFyZWFcIik7XG4gICAgICB9KTtcbiAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtU3RhcnQoXCJzbWFhLXNlYXJjaFwiKTtcbiAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtU3RhcnQoXCJzbWFhLWFyZWFcIik7XG4gICAgICBpbnRlcm5hbE1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1zZWFyY2hcIik7XG4gICAgICBpbnRlcm5hbE1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1hcmVhXCIpO1xuICAgICAgc2VhcmNoSW1hZ2Uuc3JjID0gc2VhcmNoSW1hZ2VEYXRhVVJMX2RlZmF1bHQ7XG4gICAgICBhcmVhSW1hZ2Uuc3JjID0gYXJlYUltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0JveEJsdXJNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTgsIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhNSwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxOSwgVW5pZm9ybSBhcyBVbmlmb3JtNDgsIFZlY3RvcjIgYXMgVmVjdG9yMjI1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5ib3guZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2JveF9kZWZhdWx0ID0gYCNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG4jaWZkZWYgQklMQVRFUkFMXG4jaW5jbHVkZSA8cGFja2luZz5cbnVuaWZvcm0gdmVjMiBjYW1lcmFOZWFyRmFyO1xuI2lmZGVmIE5PUk1BTF9ERVBUSFxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xuI2VuZGlmXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIHRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix1dikuYTt9XG4jZWxzZVxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbGlmIGRlZmluZWQoR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gpXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2VuZGlmXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XG4jZWxzZVxucmV0dXJuIHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikucjtcbiNlbmRpZlxufVxuI2VuZGlmXG5mbG9hdCBnZXRWaWV3Wihjb25zdCBpbiBmbG9hdCBkZXB0aCl7XG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5yZXR1cm4gcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XG4jZWxzZVxucmV0dXJuIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcbiNlbmRpZlxufVxuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxuI2RlZmluZSBsaW5lYXJEZXB0aCh2KSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoZ2V0Vmlld1oocmVhZERlcHRoKHYpKSwgY2FtZXJhTmVhckZhci54LCBjYW1lcmFOZWFyRmFyLnkpXG4jZWxzZVxuI2RlZmluZSBsaW5lYXJEZXB0aCh2KSByZWFkRGVwdGgodilcbiNlbmRpZlxuI2VuZGlmXG4jZGVmaW5lIGdldFRleGVsKHYpIHRleHR1cmUyRChpbnB1dEJ1ZmZlciwgdilcbiNpZiBLRVJORUxfU0laRSA9PSAzXG52YXJ5aW5nIHZlYzIgdlV2MDAsdlV2MDEsdlV2MDI7dmFyeWluZyB2ZWMyIHZVdjAzLHZVdjA0LHZVdjA1O3ZhcnlpbmcgdmVjMiB2VXYwNix2VXYwNyx2VXYwODtcbiNlbGlmIEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxM1xudmFyeWluZyB2ZWMyIHZVdjAwLHZVdjAxLHZVdjAyLHZVdjAzLHZVdjA0O3ZhcnlpbmcgdmVjMiB2VXYwNSx2VXYwNix2VXYwNyx2VXYwOCx2VXYwOTt2YXJ5aW5nIHZlYzIgdlV2MTAsdlV2MTEsdlV2MTIsdlV2MTMsdlV2MTQ7dmFyeWluZyB2ZWMyIHZVdjE1LHZVdjE2LHZVdjE3LHZVdjE4LHZVdjE5O3ZhcnlpbmcgdmVjMiB2VXYyMCx2VXYyMSx2VXYyMix2VXYyMyx2VXYyNDtcbiNlbHNlXG51bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZVdjtcbiNlbmRpZlxudm9pZCBtYWluKCl7XG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xudmVjNCBjW109dmVjNFtLRVJORUxfU0laRV9TUV0oZ2V0VGV4ZWwodlV2MDApLGdldFRleGVsKHZVdjAxKSxnZXRUZXhlbCh2VXYwMiksZ2V0VGV4ZWwodlV2MDMpLGdldFRleGVsKHZVdjA0KSxnZXRUZXhlbCh2VXYwNSksZ2V0VGV4ZWwodlV2MDYpLGdldFRleGVsKHZVdjA3KSxnZXRUZXhlbCh2VXYwOCkpO1xuI2lmZGVmIEJJTEFURVJBTFxuZmxvYXQgeltdPWZsb2F0W0tFUk5FTF9TSVpFX1NRXShsaW5lYXJEZXB0aCh2VXYwMCksbGluZWFyRGVwdGgodlV2MDEpLGxpbmVhckRlcHRoKHZVdjAyKSxsaW5lYXJEZXB0aCh2VXYwMyksbGluZWFyRGVwdGgodlV2MDQpLGxpbmVhckRlcHRoKHZVdjA1KSxsaW5lYXJEZXB0aCh2VXYwNiksbGluZWFyRGVwdGgodlV2MDcpLGxpbmVhckRlcHRoKHZVdjA4KSk7XG4jZW5kaWZcbiNlbGlmIEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxM1xudmVjNCBjW109dmVjNFtLRVJORUxfU0laRV9TUV0oZ2V0VGV4ZWwodlV2MDApLGdldFRleGVsKHZVdjAxKSxnZXRUZXhlbCh2VXYwMiksZ2V0VGV4ZWwodlV2MDMpLGdldFRleGVsKHZVdjA0KSxnZXRUZXhlbCh2VXYwNSksZ2V0VGV4ZWwodlV2MDYpLGdldFRleGVsKHZVdjA3KSxnZXRUZXhlbCh2VXYwOCksZ2V0VGV4ZWwodlV2MDkpLGdldFRleGVsKHZVdjEwKSxnZXRUZXhlbCh2VXYxMSksZ2V0VGV4ZWwodlV2MTIpLGdldFRleGVsKHZVdjEzKSxnZXRUZXhlbCh2VXYxNCksZ2V0VGV4ZWwodlV2MTUpLGdldFRleGVsKHZVdjE2KSxnZXRUZXhlbCh2VXYxNyksZ2V0VGV4ZWwodlV2MTgpLGdldFRleGVsKHZVdjE5KSxnZXRUZXhlbCh2VXYyMCksZ2V0VGV4ZWwodlV2MjEpLGdldFRleGVsKHZVdjIyKSxnZXRUZXhlbCh2VXYyMyksZ2V0VGV4ZWwodlV2MjQpKTtcbiNpZmRlZiBCSUxBVEVSQUxcbmZsb2F0IHpbXT1mbG9hdFtLRVJORUxfU0laRV9TUV0obGluZWFyRGVwdGgodlV2MDApLGxpbmVhckRlcHRoKHZVdjAxKSxsaW5lYXJEZXB0aCh2VXYwMiksbGluZWFyRGVwdGgodlV2MDMpLGxpbmVhckRlcHRoKHZVdjA0KSxsaW5lYXJEZXB0aCh2VXYwNSksbGluZWFyRGVwdGgodlV2MDYpLGxpbmVhckRlcHRoKHZVdjA3KSxsaW5lYXJEZXB0aCh2VXYwOCksbGluZWFyRGVwdGgodlV2MDkpLGxpbmVhckRlcHRoKHZVdjEwKSxsaW5lYXJEZXB0aCh2VXYxMSksbGluZWFyRGVwdGgodlV2MTIpLGxpbmVhckRlcHRoKHZVdjEzKSxsaW5lYXJEZXB0aCh2VXYxNCksbGluZWFyRGVwdGgodlV2MTUpLGxpbmVhckRlcHRoKHZVdjE2KSxsaW5lYXJEZXB0aCh2VXYxNyksbGluZWFyRGVwdGgodlV2MTgpLGxpbmVhckRlcHRoKHZVdjE5KSxsaW5lYXJEZXB0aCh2VXYyMCksbGluZWFyRGVwdGgodlV2MjEpLGxpbmVhckRlcHRoKHZVdjIyKSxsaW5lYXJEZXB0aCh2VXYyMyksbGluZWFyRGVwdGgodlV2MjQpKTtcbiNlbmRpZlxuI2VuZGlmXG52ZWM0IHJlc3VsdD12ZWM0KDAuMCk7XG4jaWZkZWYgQklMQVRFUkFMXG5mbG9hdCB3PTAuMDtcbiNpZiBLRVJORUxfU0laRSA9PSAzIHx8IChLRVJORUxfU0laRSA9PSA1ICYmIE1BWF9WQVJZSU5HX1ZFQ1RPUlMgPj0gMTMpXG5mbG9hdCBjZW50ZXJEZXB0aD16W0tFUk5FTF9TSVpFX1NRX0hBTEZdO2ZvcihpbnQgaT0wO2k8S0VSTkVMX1NJWkVfU1E7KytpKXtmbG9hdCBkPXN0ZXAoYWJzKHpbaV0tY2VudGVyRGVwdGgpLERJU1RBTkNFX1RIUkVTSE9MRCk7cmVzdWx0Kz1jW2ldKmQ7dys9ZDt9XG4jZWxzZVxuZmxvYXQgY2VudGVyRGVwdGg9bGluZWFyRGVwdGgodlV2KTt2ZWMyIHM9dGV4ZWxTaXplKnNjYWxlO2ZvcihpbnQgeD0tS0VSTkVMX1NJWkVfSEFMRjt4PD1LRVJORUxfU0laRV9IQUxGOysreCl7Zm9yKGludCB5PS1LRVJORUxfU0laRV9IQUxGO3k8PUtFUk5FTF9TSVpFX0hBTEY7Kyt5KXt2ZWMyIGNvb3Jkcz12VXYrdmVjMih4LHkpKnM7dmVjNCBjPWdldFRleGVsKGNvb3Jkcyk7ZmxvYXQgej0oeD09MCYmeT09MCk/Y2VudGVyRGVwdGg6bGluZWFyRGVwdGgoY29vcmRzKTtmbG9hdCBkPXN0ZXAoYWJzKHotY2VudGVyRGVwdGgpLERJU1RBTkNFX1RIUkVTSE9MRCk7cmVzdWx0Kz1jKmQ7dys9ZDt9fVxuI2VuZGlmXG5nbF9GcmFnQ29sb3I9cmVzdWx0L21heCh3LDEuMCk7XG4jZWxzZVxuI2lmIEtFUk5FTF9TSVpFID09IDMgfHwgKEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxMylcbmZvcihpbnQgaT0wO2k8S0VSTkVMX1NJWkVfU1E7KytpKXtyZXN1bHQrPWNbaV07fVxuI2Vsc2VcbnZlYzIgcz10ZXhlbFNpemUqc2NhbGU7Zm9yKGludCB4PS1LRVJORUxfU0laRV9IQUxGO3g8PUtFUk5FTF9TSVpFX0hBTEY7Kyt4KXtmb3IoaW50IHk9LUtFUk5FTF9TSVpFX0hBTEY7eTw9S0VSTkVMX1NJWkVfSEFMRjsrK3kpe3Jlc3VsdCs9Z2V0VGV4ZWwodXYrdmVjMih4LHkpKnMpO319XG4jZW5kaWZcbmdsX0ZyYWdDb2xvcj1yZXN1bHQqSU5WX0tFUk5FTF9TSVpFX1NRO1xuI2VuZGlmXG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmJveC52ZXJ0XG52YXIgY29udm9sdXRpb25fYm94X2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBzY2FsZTtcbiNpZiBLRVJORUxfU0laRSA9PSAzXG52YXJ5aW5nIHZlYzIgdlV2MDAsdlV2MDEsdlV2MDI7dmFyeWluZyB2ZWMyIHZVdjAzLHZVdjA0LHZVdjA1O3ZhcnlpbmcgdmVjMiB2VXYwNix2VXYwNyx2VXYwODtcbiNlbGlmIEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxM1xudmFyeWluZyB2ZWMyIHZVdjAwLHZVdjAxLHZVdjAyLHZVdjAzLHZVdjA0O3ZhcnlpbmcgdmVjMiB2VXYwNSx2VXYwNix2VXYwNyx2VXYwOCx2VXYwOTt2YXJ5aW5nIHZlYzIgdlV2MTAsdlV2MTEsdlV2MTIsdlV2MTMsdlV2MTQ7dmFyeWluZyB2ZWMyIHZVdjE1LHZVdjE2LHZVdjE3LHZVdjE4LHZVdjE5O3ZhcnlpbmcgdmVjMiB2VXYyMCx2VXYyMSx2VXYyMix2VXYyMyx2VXYyNDtcbiNlbHNlXG52YXJ5aW5nIHZlYzIgdlV2O1xuI2VuZGlmXG52b2lkIG1haW4oKXt2ZWMyIHV2PXBvc2l0aW9uLnh5KjAuNSswLjU7XG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xudmVjMiBzPXRleGVsU2l6ZSpzY2FsZTt2VXYwMD11ditzKnZlYzIoLTEuMCwtMS4wKTt2VXYwMT11ditzKnZlYzIoMC4wLC0xLjApO3ZVdjAyPXV2K3MqdmVjMigxLjAsLTEuMCk7dlV2MDM9dXYrcyp2ZWMyKC0xLjAsMC4wKTt2VXYwND11djt2VXYwNT11ditzKnZlYzIoMS4wLDAuMCk7dlV2MDY9dXYrcyp2ZWMyKC0xLjAsMS4wKTt2VXYwNz11ditzKnZlYzIoMC4wLDEuMCk7dlV2MDg9dXYrcyp2ZWMyKDEuMCwxLjApO1xuI2VsaWYgS0VSTkVMX1NJWkUgPT0gNVxudmVjMiBzPXRleGVsU2l6ZSpzY2FsZTt2VXYwMD11ditzKnZlYzIoLTIuMCwtMi4wKTt2VXYwMT11ditzKnZlYzIoLTEuMCwtMi4wKTt2VXYwMj11ditzKnZlYzIoMC4wLC0yLjApO3ZVdjAzPXV2K3MqdmVjMigxLjAsLTIuMCk7dlV2MDQ9dXYrcyp2ZWMyKDIuMCwtMi4wKTt2VXYwNT11ditzKnZlYzIoLTIuMCwtMS4wKTt2VXYwNj11ditzKnZlYzIoLTEuMCwtMS4wKTt2VXYwNz11ditzKnZlYzIoMC4wLC0xLjApO3ZVdjA4PXV2K3MqdmVjMigxLjAsLTEuMCk7dlV2MDk9dXYrcyp2ZWMyKDIuMCwtMS4wKTt2VXYxMD11ditzKnZlYzIoLTIuMCwwLjApO3ZVdjExPXV2K3MqdmVjMigtMS4wLDAuMCk7dlV2MTI9dXY7dlV2MTM9dXYrcyp2ZWMyKDEuMCwwLjApO3ZVdjE0PXV2K3MqdmVjMigyLjAsMC4wKTt2VXYxNT11ditzKnZlYzIoLTIuMCwxLjApO3ZVdjE2PXV2K3MqdmVjMigtMS4wLDEuMCk7dlV2MTc9dXYrcyp2ZWMyKDAuMCwxLjApO3ZVdjE4PXV2K3MqdmVjMigxLjAsMS4wKTt2VXYxOT11ditzKnZlYzIoMi4wLDEuMCk7dlV2MjA9dXYrcyp2ZWMyKC0yLjAsMi4wKTt2VXYyMT11ditzKnZlYzIoLTEuMCwyLjApO3ZVdjIyPXV2K3MqdmVjMigwLjAsMi4wKTt2VXYyMz11ditzKnZlYzIoMS4wLDIuMCk7dlV2MjQ9dXYrcyp2ZWMyKDIuMCwyLjApO1xuI2Vsc2VcbnZVdj11djtcbiNlbmRpZlxuZ2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9Cb3hCbHVyTWF0ZXJpYWwuanNcbnZhciBCb3hCbHVyTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTkge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBib3ggYmx1ciBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmlsYXRlcmFsPWZhbHNlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgYmlsYXRlcmFsIGJsdXJyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMua2VybmVsU2l6ZT01XSAtIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmlsYXRlcmFsID0gZmFsc2UsIGtlcm5lbFNpemUgPSA1IH0gPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQm94Qmx1ck1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiLFxuICAgICAgICBESVNUQU5DRV9USFJFU0hPTEQ6IFwiMC4xXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm00OChudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtNDgobnVsbCksXG4gICAgICAgIG5vcm1hbERlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTQ4KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNDgobmV3IFZlY3RvcjIyNSgpKSxcbiAgICAgICAgY2FtZXJhTmVhckZhcjogbmV3IFVuaWZvcm00OChuZXcgVmVjdG9yMjI1KCkpLFxuICAgICAgICBzY2FsZTogbmV3IFVuaWZvcm00OCgxKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTgsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBjb252b2x1dGlvbl9ib3hfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29udm9sdXRpb25fYm94X2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5iaWxhdGVyYWwgPSBiaWxhdGVyYWw7XG4gICAgdGhpcy5rZXJuZWxTaXplID0ga2VybmVsU2l6ZTtcbiAgICB0aGlzLm1heFZhcnlpbmdWZWN0b3JzID0gODtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIHZhcnlpbmcgdmVjdG9ycy5cbiAgICpcbiAgICogU2hvdWxkIGJlIHN5bmNlZCB3aXRoIGByZW5kZXJlci5jYXBhYmlsaXRpZXMubWF4VmFyeWluZ3NgLiBEZWZhdWx0IGlzIDguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgbWF4VmFyeWluZ1ZlY3RvcnModmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuTUFYX1ZBUllJTkdfVkVDVE9SUyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogLSBNdXN0IGJlIGFuIG9kZCBudW1iZXJcbiAgICogLSBLZXJuZWwgc2l6ZSAzIGFuZCA1IHVzZSBvcHRpbWl6ZWQgY29kZSBwYXRoc1xuICAgKiAtIERlZmF1bHQgaXMgNVxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGtlcm5lbFNpemUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuS0VSTkVMX1NJWkUpO1xuICB9XG4gIHNldCBrZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICUgMiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGtlcm5lbCBzaXplIG11c3QgYmUgYW4gb2RkIG51bWJlclwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWZpbmVzLktFUk5FTF9TSVpFID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuS0VSTkVMX1NJWkVfSEFMRiA9IE1hdGguZmxvb3IodmFsdWUgLyAyKS50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lcy5LRVJORUxfU0laRV9TUSA9ICh2YWx1ZSAqKiAyKS50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lcy5LRVJORUxfU0laRV9TUV9IQUxGID0gTWF0aC5mbG9vcih2YWx1ZSAqKiAyIC8gMikudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuSU5WX0tFUk5FTF9TSVpFX1NRID0gKDEgLyB2YWx1ZSAqKiAyKS50b0ZpeGVkKDYpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IG5lYXIgcGxhbmUgc2V0dGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBuZWFyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUueDtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgZmFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZmFyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUueTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbWJpbmVkIG5vcm1hbC1kZXB0aCBidWZmZXIuIE92ZXJyaWRlcyB7QGxpbmsgZGVwdGhCdWZmZXJ9IGlmIHNldC5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgbm9ybWFsRGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbERlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlZmluZXMuTk9STUFMX0RFUFRIID0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuTk9STUFMX0RFUFRIO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgYmlsYXRlcmFsIGZpbHRlcmluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBiaWxhdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5CSUxBVEVSQUwgIT09IHZvaWQgMDtcbiAgfVxuICBzZXQgYmlsYXRlcmFsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlZmluZXMuQklMQVRFUkFMID0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuQklMQVRFUkFMO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJpbGF0ZXJhbCBmaWx0ZXIgZGlzdGFuY2UgdGhyZXNob2xkIGluIHdvcmxkIHVuaXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooTnVtYmVyKHRoaXMuZGVmaW5lcy5ESVNUQU5DRV9USFJFU0hPTEQpLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGREaXN0YW5jZVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCgtdmFsdWUsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICAgIHRoaXMuZGVmaW5lcy5ESVNUQU5DRV9USFJFU0hPTEQgPSB0aHJlc2hvbGQudG9GaXhlZCgxMik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS5zZXQoY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIpO1xuICAgICAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhNSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0RlcHRoQ29weU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE0LCBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxOSwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwyMCwgVW5pZm9ybSBhcyBVbmlmb3JtNDksIFZlY3RvcjIgYXMgVmVjdG9yMjI2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1jb3B5LmZyYWdcbnZhciBkZXB0aF9jb3B5X2RlZmF1bHQgPSBgI2luY2x1ZGUgPHBhY2tpbmc+XG52YXJ5aW5nIHZlYzIgdlV2O1xuI2lmZGVmIE5PUk1BTF9ERVBUSFxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xuI2VuZGlmXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIHRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix1dikuYTt9XG4jZWxzZVxuI2lmIElOUFVUX0RFUFRIX1BBQ0tJTkcgPT0gMzIwMVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbGlmIGRlZmluZWQoR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gpXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2VuZGlmXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XG4jaWYgSU5QVVRfREVQVEhfUEFDS0lORyA9PSAzMjAxXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XG4jZWxzZVxucmV0dXJuIHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikucjtcbiNlbmRpZlxufVxuI2VuZGlmXG52b2lkIG1haW4oKXtcbiNpZiBJTlBVVF9ERVBUSF9QQUNLSU5HID09IE9VVFBVVF9ERVBUSF9QQUNLSU5HXG5nbF9GcmFnQ29sb3I9dGV4dHVyZTJEKGRlcHRoQnVmZmVyLHZVdik7XG4jZWxzZVxuZmxvYXQgZGVwdGg9cmVhZERlcHRoKHZVdik7XG4jaWYgT1VUUFVUX0RFUFRIX1BBQ0tJTkcgPT0gMzIwMVxuZ2xfRnJhZ0NvbG9yPShkZXB0aD09MS4wKT92ZWM0KDEuMCk6cGFja0RlcHRoVG9SR0JBKGRlcHRoKTtcbiNlbHNlXG5nbF9GcmFnQ29sb3I9dmVjNCh2ZWMzKGRlcHRoKSwxLjApO1xuI2VuZGlmXG4jZW5kaWZcbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZGVwdGgtY29weS52ZXJ0XG52YXIgZGVwdGhfY29weV9kZWZhdWx0MiA9IGB2YXJ5aW5nIHZlYzIgdlV2O1xuI2lmIERFUFRIX0NPUFlfTU9ERSA9PSAxXG51bmlmb3JtIHZlYzIgdGV4ZWxQb3NpdGlvbjtcbiNlbmRpZlxudm9pZCBtYWluKCl7XG4jaWYgREVQVEhfQ09QWV9NT0RFID09IDFcbnZVdj10ZXhlbFBvc2l0aW9uO1xuI2Vsc2VcbnZVdj1wb3NpdGlvbi54eSowLjUrMC41O1xuI2VuZGlmXG5nbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0RlcHRoQ29weU1hdGVyaWFsLmpzXG52YXIgRGVwdGhDb3B5TWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMjAge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBjb3B5IG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJEZXB0aENvcHlNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBJTlBVVF9ERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgT1VUUFVUX0RFUFRIX1BBQ0tJTkc6IFwiMFwiLFxuICAgICAgICBERVBUSF9DT1BZX01PREU6IFwiMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtNDkobnVsbCksXG4gICAgICAgIHRleGVsUG9zaXRpb246IG5ldyBVbmlmb3JtNDkobmV3IFZlY3RvcjIyNigpKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTksXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aF9jb3B5X2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoX2NvcHlfZGVmYXVsdDJcbiAgICB9KTtcbiAgICB0aGlzLmRlcHRoQ29weU1vZGUgPSBEZXB0aENvcHlNb2RlLkZVTEw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGRlcHRoQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlO1xuICB9XG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGlucHV0RGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLklOUFVUX0RFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgZ2V0IG91dHB1dERlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyk7XG4gIH1cbiAgc2V0IG91dHB1dERlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBpbnB1dERlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTQpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuaW5wdXREZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgaW5wdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gVGhlIGlucHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBnZXRJbnB1dERlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5JTlBVVF9ERVBUSF9QQUNLSU5HKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0RGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gdmFsdWUgLSBUaGUgbmV3IGlucHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXRJbnB1dERlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5JTlBVVF9ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBvdXRwdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG91dHB1dERlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBUaGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBnZXRPdXRwdXREZXB0aFBhY2tpbmcoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuT1VUUFVUX0RFUFRIX1BBQ0tJTkcpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvdXRwdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG91dHB1dERlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IHZhbHVlIC0gVGhlIG5ldyBvdXRwdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldE91dHB1dERlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gdXNlZCBmb3Igc2luZ2xlLXRleGVsIGNvcHkgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXQgdGV4ZWxQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50ZXhlbFBvc2l0aW9uLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gdXNlZCBmb3Igc2luZ2xlLXRleGVsIGNvcHkgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleGVsUG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0VGV4ZWxQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50ZXhlbFBvc2l0aW9uLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gdXNlZCBmb3Igc2luZ2xlLXRleGVsIGNvcHkgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2YWx1ZSAtIFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIHNldFRleGVsUG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsUG9zaXRpb24udmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGNvcHkgbW9kZS5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoQ29weU1vZGV9XG4gICAqL1xuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aENvcHlNb2RlO1xuICB9XG4gIHNldCBtb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5kZXB0aENvcHlNb2RlID0gdmFsdWU7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX0NPUFlfTU9ERSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlcHRoIGNvcHkgbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RGVwdGhDb3B5TW9kZX0gVGhlIGRlcHRoIGNvcHkgbW9kZS5cbiAgICovXG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggY29weSBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0RlcHRoQ29weU1vZGV9IHZhbHVlIC0gVGhlIG5ldyBtb2RlLlxuICAgKi9cbiAgc2V0TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMubW9kZSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0VmZmVjdE1hdGVyaWFsLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE1LCBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcyMCwgUGVyc3BlY3RpdmVDYW1lcmEgYXMgUGVyc3BlY3RpdmVDYW1lcmE2LCBSRVZJU0lPTiBhcyBSRVZJU0lPTjQsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMjEsIFVuaWZvcm0gYXMgVW5pZm9ybTUwLCBWZWN0b3IyIGFzIFZlY3RvcjIyNyB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZWZmZWN0LmZyYWdcbnZhciBlZmZlY3RfZGVmYXVsdCA9IGAjaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPHBhY2tpbmc+XG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XG4jZGVmaW5lIHBhY2tGbG9hdFRvUkdCQSh2KSBwYWNrRGVwdGhUb1JHQkEodilcbiNkZWZpbmUgdW5wYWNrUkdCQVRvRmxvYXQodikgdW5wYWNrUkdCQVRvRGVwdGgodilcbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2VsaWYgZGVmaW5lZChHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSClcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZW5kaWZcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO3VuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBjYW1lcmFOZWFyO3VuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO3VuaWZvcm0gZmxvYXQgYXNwZWN0O3VuaWZvcm0gZmxvYXQgdGltZTt2YXJ5aW5nIHZlYzIgdlV2O3ZlYzQgc1JHQlRvTGluZWFyKGNvbnN0IGluIHZlYzQgdmFsdWUpe3JldHVybiB2ZWM0KG1peChwb3codmFsdWUucmdiKjAuOTQ3ODY3Mjk4Nit2ZWMzKDAuMDUyMTMyNzAxNCksdmVjMygyLjQpKSx2YWx1ZS5yZ2IqMC4wNzczOTkzODA4LHZlYzMobGVzc1RoYW5FcXVhbCh2YWx1ZS5yZ2IsdmVjMygwLjA0MDQ1KSkpKSx2YWx1ZS5hKTt9ZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxucmV0dXJuIHVucGFja1JHQkFUb0RlcHRoKHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikpO1xuI2Vsc2VcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XG4jZW5kaWZcbn1mbG9hdCBnZXRWaWV3Wihjb25zdCBpbiBmbG9hdCBkZXB0aCl7XG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5yZXR1cm4gcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xuI2Vsc2VcbnJldHVybiBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xuI2VuZGlmXG59dmVjMyBSR0JUb0hDVihjb25zdCBpbiB2ZWMzIFJHQil7dmVjNCBQPW1peCh2ZWM0KFJHQi5iZywtMS4wLDIuMC8zLjApLHZlYzQoUkdCLmdiLDAuMCwtMS4wLzMuMCksc3RlcChSR0IuYixSR0IuZykpO3ZlYzQgUT1taXgodmVjNChQLnh5dyxSR0IuciksdmVjNChSR0IucixQLnl6eCksc3RlcChQLngsUkdCLnIpKTtmbG9hdCBDPVEueC1taW4oUS53LFEueSk7ZmxvYXQgSD1hYnMoKFEudy1RLnkpLyg2LjAqQytFUFNJTE9OKStRLnopO3JldHVybiB2ZWMzKEgsQyxRLngpO312ZWMzIFJHQlRvSFNMKGNvbnN0IGluIHZlYzMgUkdCKXt2ZWMzIEhDVj1SR0JUb0hDVihSR0IpO2Zsb2F0IEw9SENWLnotSENWLnkqMC41O2Zsb2F0IFM9SENWLnkvKDEuMC1hYnMoTCoyLjAtMS4wKStFUFNJTE9OKTtyZXR1cm4gdmVjMyhIQ1YueCxTLEwpO312ZWMzIEh1ZVRvUkdCKGNvbnN0IGluIGZsb2F0IEgpe2Zsb2F0IFI9YWJzKEgqNi4wLTMuMCktMS4wO2Zsb2F0IEc9Mi4wLWFicyhIKjYuMC0yLjApO2Zsb2F0IEI9Mi4wLWFicyhIKjYuMC00LjApO3JldHVybiBjbGFtcCh2ZWMzKFIsRyxCKSwwLjAsMS4wKTt9dmVjMyBIU0xUb1JHQihjb25zdCBpbiB2ZWMzIEhTTCl7dmVjMyBSR0I9SHVlVG9SR0IoSFNMLngpO2Zsb2F0IEM9KDEuMC1hYnMoMi4wKkhTTC56LTEuMCkpKkhTTC55O3JldHVybihSR0ItMC41KSpDK0hTTC56O31GUkFHTUVOVF9IRUFEIHZvaWQgbWFpbigpe0ZSQUdNRU5UX01BSU5fVVYgdmVjNCBjb2xvcjA9dGV4dHVyZTJEKGlucHV0QnVmZmVyLFVWKTt2ZWM0IGNvbG9yMT12ZWM0KDAuMCk7RlJBR01FTlRfTUFJTl9JTUFHRSBjb2xvcjAuYT1jbGFtcChjb2xvcjAuYSwwLjAsMS4wKTtnbF9GcmFnQ29sb3I9Y29sb3IwO1xuI2lmZGVmIEVOQ09ERV9PVVRQVVRcbiNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxuI2VuZGlmXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9lZmZlY3QudmVydFxudmFyIGVmZmVjdF9kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjt1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjt1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjt1bmlmb3JtIGZsb2F0IGFzcGVjdDt1bmlmb3JtIGZsb2F0IHRpbWU7dmFyeWluZyB2ZWMyIHZVdjtWRVJURVhfSEVBRCB2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTtWRVJURVhfTUFJTl9TVVBQT1JUIGdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRWZmZWN0TWF0ZXJpYWwuanNcbnZhciBFZmZlY3RNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwyMSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVmZmVjdCBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBTdHJpbmc+fSBbc2hhZGVyUGFydHNdIC0gRGVwcmVjYXRlZC4gVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBTdHJpbmc+fSBbZGVmaW5lc10gLSBEZXByZWNhdGVkLiBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFVuaWZvcm0+fSBbdW5pZm9ybXNdIC0gRGVwcmVjYXRlZC4gVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IFtjYW1lcmFdIC0gQSBjYW1lcmEuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RpdGhlcmluZz1mYWxzZV0gLSBEZXByZWNhdGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2hhZGVyUGFydHMsIGRlZmluZXMsIHVuaWZvcm1zLCBjYW1lcmEsIGRpdGhlcmluZyA9IGZhbHNlKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJFZmZlY3RNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBUSFJFRV9SRVZJU0lPTjogUkVWSVNJT040LnJlcGxhY2UoL1xcRCsvZywgXCJcIiksXG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiLFxuICAgICAgICBFTkNPREVfT1VUUFVUOiBcIjFcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTUwKG51bGwpLFxuICAgICAgICBkZXB0aEJ1ZmZlcjogbmV3IFVuaWZvcm01MChudWxsKSxcbiAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVuaWZvcm01MChuZXcgVmVjdG9yMjI3KCkpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNTAobmV3IFZlY3RvcjIyNygpKSxcbiAgICAgICAgY2FtZXJhTmVhcjogbmV3IFVuaWZvcm01MCgwLjMpLFxuICAgICAgICBjYW1lcmFGYXI6IG5ldyBVbmlmb3JtNTAoMWUzKSxcbiAgICAgICAgYXNwZWN0OiBuZXcgVW5pZm9ybTUwKDEpLFxuICAgICAgICB0aW1lOiBuZXcgVW5pZm9ybTUwKDApXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcyMCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZGl0aGVyaW5nXG4gICAgfSk7XG4gICAgaWYgKHNoYWRlclBhcnRzKSB7XG4gICAgICB0aGlzLnNldFNoYWRlclBhcnRzKHNoYWRlclBhcnRzKTtcbiAgICB9XG4gICAgaWYgKGRlZmluZXMpIHtcbiAgICAgIHRoaXMuc2V0RGVmaW5lcyhkZWZpbmVzKTtcbiAgICB9XG4gICAgaWYgKHVuaWZvcm1zKSB7XG4gICAgICB0aGlzLnNldFVuaWZvcm1zKHVuaWZvcm1zKTtcbiAgICB9XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGRlcHRoQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlO1xuICB9XG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgZ2V0IGRlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HKTtcbiAgfVxuICBzZXQgZGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlciBhbmQgZGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gYnVmZmVyIC0gVGhlIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldERlcHRoQnVmZmVyKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxNSkge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNoYWRlciBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0VmZmVjdFNoYWRlckRhdGF9IGRhdGEgLSBUaGUgc2hhZGVyIGRhdGEuXG4gICAqIEByZXR1cm4ge0VmZmVjdE1hdGVyaWFsfSBUaGlzIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0U2hhZGVyRGF0YShkYXRhKSB7XG4gICAgdGhpcy5zZXRTaGFkZXJQYXJ0cyhkYXRhLnNoYWRlclBhcnRzKTtcbiAgICB0aGlzLnNldERlZmluZXMoZGF0YS5kZWZpbmVzKTtcbiAgICB0aGlzLnNldFVuaWZvcm1zKGRhdGEudW5pZm9ybXMpO1xuICAgIHRoaXMuc2V0RXh0ZW5zaW9ucyhkYXRhLmV4dGVuc2lvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaGFkZXIgcGFydHMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gc2hhZGVyUGFydHMgLSBBIGNvbGxlY3Rpb24gb2Ygc2hhZGVyIHNuaXBwZXRzLiBTZWUge0BsaW5rIEVmZmVjdFNoYWRlclNlY3Rpb259LlxuICAgKiBAcmV0dXJuIHtFZmZlY3RNYXRlcmlhbH0gVGhpcyBtYXRlcmlhbC5cbiAgICovXG4gIHNldFNoYWRlclBhcnRzKHNoYWRlclBhcnRzKSB7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGVmZmVjdF9kZWZhdWx0LnJlcGxhY2UoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFELCBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFEKSB8fCBcIlwiKS5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9VViwgc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9VVikgfHwgXCJcIikucmVwbGFjZShFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fSU1BR0UsIHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fSU1BR0UpIHx8IFwiXCIpO1xuICAgIHRoaXMudmVydGV4U2hhZGVyID0gZWZmZWN0X2RlZmF1bHQyLnJlcGxhY2UoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfSEVBRCwgc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX0hFQUQpIHx8IFwiXCIpLnJlcGxhY2UoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfTUFJTl9TVVBQT1JULCBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfTUFJTl9TVVBQT1JUKSB8fCBcIlwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2hhZGVyIG1hY3Jvcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBTdHJpbmc+fSBkZWZpbmVzIC0gQSBjb2xsZWN0aW9uIG9mIHByZXByb2Nlc3NvciBtYWNybyBkZWZpbml0aW9ucy5cbiAgICogQHJldHVybiB7RWZmZWN0TWF0ZXJpYWx9IFRoaXMgbWF0ZXJpYWwuXG4gICAqL1xuICBzZXREZWZpbmVzKGRlZmluZXMpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRlZmluZXMuZW50cmllcygpKSB7XG4gICAgICB0aGlzLmRlZmluZXNbZW50cnlbMF1dID0gZW50cnlbMV07XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaGFkZXIgdW5pZm9ybXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgVW5pZm9ybT59IHVuaWZvcm1zIC0gQSBjb2xsZWN0aW9uIG9mIHVuaWZvcm1zLlxuICAgKiBAcmV0dXJuIHtFZmZlY3RNYXRlcmlhbH0gVGhpcyBtYXRlcmlhbC5cbiAgICovXG4gIHNldFVuaWZvcm1zKHVuaWZvcm1zKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB1bmlmb3Jtcy5lbnRyaWVzKCkpIHtcbiAgICAgIHRoaXMudW5pZm9ybXNbZW50cnlbMF1dID0gZW50cnlbMV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXF1aXJlZCBzaGFkZXIgZXh0ZW5zaW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtTZXQ8V2ViR0xFeHRlbnNpb24+fSBleHRlbnNpb25zIC0gQSBjb2xsZWN0aW9uIG9mIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm4ge0VmZmVjdE1hdGVyaWFsfSBUaGlzIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgICAgdGhpcy5leHRlbnNpb25zW2V4dGVuc2lvbl0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3V0cHV0IGVuY29kaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGVuY29kZU91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLkVOQ09ERV9PVVRQVVQgIT09IHZvaWQgMDtcbiAgfVxuICBzZXQgZW5jb2RlT3V0cHV0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZW5jb2RlT3V0cHV0ICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5FTkNPREVfT1VUUFVUID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkVOQ09ERV9PVVRQVVQ7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIG91dHB1dCBlbmNvZGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZW5jb2RlT3V0cHV0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3V0cHV0IGVuY29kaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc091dHB1dEVuY29kaW5nRW5hYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZU91dHB1dDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBvdXRwdXQgZW5jb2RpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlbmNvZGVPdXRwdXQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgb3V0cHV0IGVuY29kaW5nIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0T3V0cHV0RW5jb2RpbmdFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5lbmNvZGVPdXRwdXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRpbWUgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB0aW1lKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRpbWUudmFsdWU7XG4gIH1cbiAgc2V0IHRpbWUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRpbWUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVsdGEgdGltZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRpbWUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGRlbHRhIHRpbWUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHNldERlbHRhVGltZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZSArPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoZSBzZXR0aW5ncyBvZiB0aGUgZ2l2ZW4gY2FtZXJhLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29weUNhbWVyYVNldHRpbmdzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGFkb3B0Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKSB7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoZSBzZXR0aW5ncyBvZiB0aGUgZ2l2ZW4gY2FtZXJhLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBjb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKSB7XG4gICAgaWYgKGNhbWVyYSkge1xuICAgICAgdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XG4gICAgICBpZiAoY2FtZXJhIGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmE2KSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkEgPSBcIjFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIHVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIHVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgICB1bmlmb3Jtcy5hc3BlY3QudmFsdWUgPSB3aWR0aCAvIGhlaWdodDtcbiAgfVxuICAvKipcbiAgICogQW4gZW51bWVyYXRpb24gb2Ygc2hhZGVyIGNvZGUgcGxhY2Vob2xkZXJzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgRWZmZWN0U2hhZGVyU2VjdGlvbiBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBTZWN0aW9uKCkge1xuICAgIHJldHVybiBFZmZlY3RTaGFkZXJTZWN0aW9uO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0dhdXNzaWFuQmx1ck1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcyMSwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwyMiwgVW5pZm9ybSBhcyBVbmlmb3JtNTEsIFZlY3RvcjIgYXMgVmVjdG9yMjI4IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5nYXVzc2lhbi5mcmFnXG52YXIgY29udm9sdXRpb25fZ2F1c3NpYW5fZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSB2ZWMyIGtlcm5lbFtTVEVQU107dmFyeWluZyB2ZWMyIHZPZmZzZXQ7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2ZWM0IHJlc3VsdD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KSprZXJuZWxbMF0ueTtmb3IoaW50IGk9MTtpPFNURVBTOysraSl7dmVjMiBvZmZzZXQ9a2VybmVsW2ldLngqdk9mZnNldDt2ZWM0IGMwPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYrb2Zmc2V0KTt2ZWM0IGMxPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYtb2Zmc2V0KTtyZXN1bHQrPShjMCtjMSkqa2VybmVsW2ldLnk7fWdsX0ZyYWdDb2xvcj1yZXN1bHQ7XG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uZ2F1c3NpYW4udmVydFxudmFyIGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSB2ZWMyIGRpcmVjdGlvbjt1bmlmb3JtIGZsb2F0IHNjYWxlO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0O3ZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dk9mZnNldD1kaXJlY3Rpb24qdGV4ZWxTaXplKnNjYWxlO3ZVdj1wb3NpdGlvbi54eSowLjUrMC41O2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvR2F1c3NpYW5CbHVyTWF0ZXJpYWwuanNcbnZhciBHYXVzc2lhbkJsdXJNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwyMiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbnZvbHV0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPTM1XSAtIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsga2VybmVsU2l6ZSA9IDM1IH0gPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiR2F1c3NpYW5CbHVyTWF0ZXJpYWxcIixcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTUxKG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNTEobmV3IFZlY3RvcjIyOCgpKSxcbiAgICAgICAgZGlyZWN0aW9uOiBuZXcgVW5pZm9ybTUxKG5ldyBWZWN0b3IyMjgoKSksXG4gICAgICAgIGtlcm5lbDogbmV3IFVuaWZvcm01MShudWxsKSxcbiAgICAgICAgc2NhbGU6IG5ldyBVbmlmb3JtNTEoMSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzIxLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fZ2F1c3NpYW5fZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29udm9sdXRpb25fZ2F1c3NpYW5fZGVmYXVsdDJcbiAgICB9KTtcbiAgICB0aGlzLl9rZXJuZWxTaXplID0gMDtcbiAgICB0aGlzLmtlcm5lbFNpemUgPSBrZXJuZWxTaXplO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGtlcm5lbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLl9rZXJuZWxTaXplID0gdmFsdWU7XG4gICAgdGhpcy5nZW5lcmF0ZUtlcm5lbCh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIGRpcmVjdGlvbi5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRpcmVjdGlvbi52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIga2VybmVsIHNjYWxlLiBWYWx1ZXMgZ3JlYXRlciB0aGFuIDEuMCBtYXkgaW50cm9kdWNlIGFydGlmYWN0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgR2F1c3Mga2VybmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IGtlcm5lbFNpemUgLSBUaGUga2VybmVsIHNpemUuIFNob3VsZCBiZSBhbiBvZGQgbnVtYmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2VuZXJhdGVLZXJuZWwoa2VybmVsU2l6ZSkge1xuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyBHYXVzc0tlcm5lbChrZXJuZWxTaXplKTtcbiAgICBjb25zdCBzdGVwcyA9IGtlcm5lbC5saW5lYXJTdGVwcztcbiAgICBjb25zdCBrZXJuZWxEYXRhID0gbmV3IEZsb2F0NjRBcnJheShzdGVwcyAqIDIpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHN0ZXBzOyArK2kpIHtcbiAgICAgIGtlcm5lbERhdGFbaisrXSA9IGtlcm5lbC5saW5lYXJPZmZzZXRzW2ldO1xuICAgICAga2VybmVsRGF0YVtqKytdID0ga2VybmVsLmxpbmVhcldlaWdodHNbaV07XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMua2VybmVsLnZhbHVlID0ga2VybmVsRGF0YTtcbiAgICB0aGlzLmRlZmluZXMuU1RFUFMgPSBzdGVwcy50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQm94Qmx1clBhc3MuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTYsIFNSR0JDb2xvclNwYWNlIGFzIFNSR0JDb2xvclNwYWNlMTMsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTEzLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDIwIH0gZnJvbSBcInRocmVlXCI7XG52YXIgQm94Qmx1clBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBib3ggYmx1ciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPTVdIC0gTXVzdCBiZSBhbiBvZGQgbnVtYmVyLiBUaGUgc2l6ZXMgMyBhbmQgNSB1c2Ugb3B0aW1pemVkIGNvZGUgcGF0aHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pdGVyYXRpb25zPTFdIC0gVGhlIGFtb3VudCBvZiB0aW1lcyB0aGUgYmx1ciBzaG91bGQgYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpbGF0ZXJhbD1mYWxzZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIGJpbGF0ZXJhbCBibHVycmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAga2VybmVsU2l6ZSA9IDUsXG4gICAgaXRlcmF0aW9ucyA9IDEsXG4gICAgYmlsYXRlcmFsID0gZmFsc2UsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICByZXNvbHV0aW9uWCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25ZID0gUmVzb2x1dGlvbi5BVVRPX1NJWkVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJCb3hCbHVyUGFzc1wiKTtcbiAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gYmlsYXRlcmFsO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIwKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLm5hbWUgPSBcIkJsdXIuVGFyZ2V0LkFcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQyMCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5CXCI7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwgPSBuZXcgQm94Qmx1ck1hdGVyaWFsKHsgYmlsYXRlcmFsLCBrZXJuZWxTaXplIH0pO1xuICAgIHRoaXMuY29weU1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxNikge1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmx1ci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEEgPSB0aGlzLnJlbmRlclRhcmdldEE7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QjtcbiAgICBjb25zdCBibHVyTWF0ZXJpYWwgPSB0aGlzLmJsdXJNYXRlcmlhbDtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IGJsdXJNYXRlcmlhbDtcbiAgICBsZXQgcHJldmlvdXNCdWZmZXIgPSBpbnB1dEJ1ZmZlcjtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KHRoaXMuaXRlcmF0aW9ucywgMSk7IGkgPCBsOyArK2kpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IChpICYgMSkgPT09IDAgPyByZW5kZXJUYXJnZXRBIDogcmVuZGVyVGFyZ2V0QjtcbiAgICAgIGJsdXJNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoYnVmZmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHByZXZpb3VzQnVmZmVyID0gYnVmZmVyO1xuICAgIH1cbiAgICB0aGlzLmNvcHlNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB0aGlzLmNvcHlNYXRlcmlhbDtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBvdXRwdXRCdWZmZXIpO1xuICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBpZiAocmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYmx1ck1hdGVyaWFsLm1heFZhcnlpbmdWZWN0b3JzID0gcmVuZGVyZXIuY2FwYWJpbGl0aWVzLm1heFZhcnlpbmdzO1xuICAgIH1cbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTEzKSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UxMykge1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UxMztcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMTM7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0RlcHRoUGlja2luZ1Bhc3MuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTgsIEZsb2F0VHlwZSBhcyBGbG9hdFR5cGU2LCBSRVZJU0lPTiBhcyBSRVZJU0lPTjUsIFJHQkFEZXB0aFBhY2tpbmcgYXMgUkdCQURlcHRoUGFja2luZzUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3Bhc3Nlcy9EZXB0aENvcHlQYXNzLmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE3LFxuICBGbG9hdFR5cGUgYXMgRmxvYXRUeXBlNSxcbiAgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyNyxcbiAgUkdCQURlcHRoUGFja2luZyBhcyBSR0JBRGVwdGhQYWNraW5nNCxcbiAgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMTQsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MjFcbn0gZnJvbSBcInRocmVlXCI7XG52YXIgRGVwdGhDb3B5UGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIHNhdmUgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtvcHRpb25zLmRlcHRoUGFja2luZz1SR0JBRGVwdGhQYWNraW5nXSAtIFRoZSBvdXRwdXQgZGVwdGggcGFja2luZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZzQgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEZXB0aENvcHlQYXNzXCIpO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IERlcHRoQ29weU1hdGVyaWFsKCk7XG4gICAgbWF0ZXJpYWwub3V0cHV0RGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgdGhpcy5uZWVkc0RlcHRoVGV4dHVyZSA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIxKDEsIDEsIHtcbiAgICAgIHR5cGU6IGRlcHRoUGFja2luZyA9PT0gUkdCQURlcHRoUGFja2luZzQgPyBVbnNpZ25lZEJ5dGVUeXBlMTQgOiBGbG9hdFR5cGU1LFxuICAgICAgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyNyxcbiAgICAgIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcjcsXG4gICAgICBkZXB0aEJ1ZmZlcjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkRlcHRoQ29weVBhc3MuVGFyZ2V0XCI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3V0cHV0IGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG91dHB1dCBkZXB0aCBwYWNraW5nLlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIGdldCBkZXB0aFBhY2tpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLm91dHB1dERlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBnZXREZXB0aFBhY2tpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLm91dHB1dERlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTcpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5pbnB1dERlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGRlcHRoIGZyb20gYSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0RlcHRoUGlja2luZ1Bhc3MuanNcbnZhciB0aHJlZVJldmlzaW9uID0gTnVtYmVyKFJFVklTSU9ONS5yZXBsYWNlKC9cXEQrL2csIFwiXCIpKTtcbnZhciB1bnBhY2tEb3duc2NhbGUgPSAyNTUgLyAyNTY7XG52YXIgdW5wYWNrRmFjdG9yc0xlZ2FjeSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICB1bnBhY2tEb3duc2NhbGUgLyAyNTYgKiogMyxcbiAgdW5wYWNrRG93bnNjYWxlIC8gMjU2ICoqIDIsXG4gIHVucGFja0Rvd25zY2FsZSAvIDI1NixcbiAgdW5wYWNrRG93bnNjYWxlXG5dKTtcbnZhciB1bnBhY2tGYWN0b3JzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gIHVucGFja0Rvd25zY2FsZSxcbiAgdW5wYWNrRG93bnNjYWxlIC8gMjU2LFxuICB1bnBhY2tEb3duc2NhbGUgLyAyNTYgKiogMixcbiAgMSAvIDI1NiAqKiAzXG5dKTtcbmZ1bmN0aW9uIHVucGFja1JHQkFUb0RlcHRoKHBhY2tlZERlcHRoKSB7XG4gIGNvbnN0IGYgPSB0aHJlZVJldmlzaW9uID49IDE2NyA/IHVucGFja0ZhY3RvcnMgOiB1bnBhY2tGYWN0b3JzTGVnYWN5O1xuICByZXR1cm4gKHBhY2tlZERlcHRoWzBdICogZlswXSArIHBhY2tlZERlcHRoWzFdICogZlsxXSArIHBhY2tlZERlcHRoWzJdICogZlsyXSArIHBhY2tlZERlcHRoWzNdICogZlszXSkgLyAyNTU7XG59XG52YXIgRGVwdGhQaWNraW5nUGFzcyA9IGNsYXNzIGV4dGVuZHMgRGVwdGhDb3B5UGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIHBpY2tpbmcgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtvcHRpb25zLmRlcHRoUGFja2luZz1SR0JBRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubW9kZT1EZXB0aENvcHlNb2RlLlNJTkdMRV0gLSBUaGUgZGVwdGggY29weSBtb2RlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nNSwgbW9kZSA9IERlcHRoQ29weU1vZGUuU0lOR0xFIH0gPSB7fSkge1xuICAgIGlmIChkZXB0aFBhY2tpbmcgIT09IFJHQkFEZXB0aFBhY2tpbmc1ICYmIGRlcHRoUGFja2luZyAhPT0gQmFzaWNEZXB0aFBhY2tpbmcxOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZXB0aCBwYWNraW5nOiAke2RlcHRoUGFja2luZ31gKTtcbiAgICB9XG4gICAgc3VwZXIoeyBkZXB0aFBhY2tpbmcgfSk7XG4gICAgdGhpcy5uYW1lID0gXCJEZXB0aFBpY2tpbmdQYXNzXCI7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5waXhlbEJ1ZmZlciA9IGRlcHRoUGFja2luZyA9PT0gUkdCQURlcHRoUGFja2luZzUgPyBuZXcgVWludDhBcnJheSg0KSA6IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIGRlcHRoIGF0IGEgc3BlY2lmaWMgc2NyZWVuIHBvc2l0aW9uLlxuICAgKlxuICAgKiBPbmx5IG9uZSBkZXB0aCB2YWx1ZSBjYW4gYmUgcGlja2VkIHBlciBmcmFtZS4gQ2FsbGluZyB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyBwZXIgZnJhbWUgd2lsbCBvdmVyd3JpdGUgdGhlXG4gICAqIHBpY2tpbmcgY29vcmRpbmF0ZXMuIFVucmVzb2x2ZWQgcHJvbWlzZXMgd2lsbCBiZSBhYmFuZG9uZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG5kYyA9IG5ldyBWZWN0b3IzKCk7XG4gICAqIGNvbnN0IGNsaWVudFJlY3QgPSBteVZpZXdwb3J0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgKiBjb25zdCBjbGllbnRYID0gcG9pbnRlckV2ZW50LmNsaWVudFggLSBjbGllbnRSZWN0LmxlZnQ7XG4gICAqIGNvbnN0IGNsaWVudFkgPSBwb2ludGVyRXZlbnQuY2xpZW50WSAtIGNsaWVudFJlY3QudG9wO1xuICAgKiBuZGMueCA9IChjbGllbnRYIC8gbXlWaWV3cG9ydC5jbGllbnRXaWR0aCkgKiAyLjAgLSAxLjA7XG4gICAqIG5kYy55ID0gLShjbGllbnRZIC8gbXlWaWV3cG9ydC5jbGllbnRIZWlnaHQpICogMi4wICsgMS4wO1xuICAgKiBjb25zdCBkZXB0aCA9IGF3YWl0IGRlcHRoUGlja2luZ1Bhc3MucmVhZERlcHRoKG5kYyk7XG4gICAqIG5kYy56ID0gZGVwdGggKiAyLjAgLSAxLjA7XG4gICAqXG4gICAqIGNvbnN0IHdvcmxkUG9zaXRpb24gPSBuZGMudW5wcm9qZWN0KGNhbWVyYSk7XG4gICAqXG4gICAqIEBwYXJhbSB7VmVjdG9yMnxWZWN0b3IzfSBuZGMgLSBOb3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlcy4gT25seSBYIGFuZCBZIGFyZSByZWxldmFudC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxOdW1iZXI+fSBBIHByb21pc2UgdGhhdCByZXR1cm5zIHRoZSBkZXB0aCBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICovXG4gIHJlYWREZXB0aChuZGMpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC50ZXhlbFBvc2l0aW9uLnNldChuZGMueCAqIDAuNSArIDAuNSwgbmRjLnkgKiAwLjUgKyAwLjUpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IHJlc29sdmU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBkZXB0aCBhbmQgcmVzb2x2ZXMgZGVwdGggcGlja2luZyBwcm9taXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICBjb25zdCBtb2RlID0gbWF0ZXJpYWwubW9kZTtcbiAgICBpZiAobW9kZSA9PT0gRGVwdGhDb3B5TW9kZS5GVUxMKSB7XG4gICAgICBzdXBlci5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgICBjb25zdCBwaXhlbEJ1ZmZlciA9IHRoaXMucGl4ZWxCdWZmZXI7XG4gICAgICBjb25zdCBwYWNrZWQgPSByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICE9PSBGbG9hdFR5cGU2O1xuICAgICAgbGV0IHggPSAwLCB5ID0gMDtcbiAgICAgIGlmIChtb2RlID09PSBEZXB0aENvcHlNb2RlLlNJTkdMRSkge1xuICAgICAgICBzdXBlci5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4ZWxQb3NpdGlvbiA9IG1hdGVyaWFsLnRleGVsUG9zaXRpb247XG4gICAgICAgIHggPSBNYXRoLnJvdW5kKHRleGVsUG9zaXRpb24ueCAqIHJlbmRlclRhcmdldC53aWR0aCk7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKHRleGVsUG9zaXRpb24ueSAqIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyhyZW5kZXJUYXJnZXQsIHgsIHksIDEsIDEsIHBpeGVsQnVmZmVyKTtcbiAgICAgIHRoaXMuY2FsbGJhY2socGFja2VkID8gdW5wYWNrUkdCQVRvRGVwdGgocGl4ZWxCdWZmZXIpIDogcGl4ZWxCdWZmZXJbMF0pO1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5tb2RlID09PSBEZXB0aENvcHlNb2RlLkZVTEwpIHtcbiAgICAgIHN1cGVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0VmZmVjdFBhc3MuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTksIE5vQ29sb3JTcGFjZSBhcyBOb0NvbG9yU3BhY2UyLCBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTE0LCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxNSB9IGZyb20gXCJ0aHJlZVwiO1xuZnVuY3Rpb24gcHJlZml4U3Vic3RyaW5ncyhwcmVmaXgsIHN1YnN0cmluZ3MsIHN0cmluZ3MpIHtcbiAgZm9yIChjb25zdCBzdWJzdHJpbmcgb2Ygc3Vic3RyaW5ncykge1xuICAgIGNvbnN0IHByZWZpeGVkID0gXCIkMVwiICsgcHJlZml4ICsgc3Vic3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3Vic3RyaW5nLnNsaWNlKDEpO1xuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCIoW15cXFxcLl0pKFxcXFxiXCIgKyBzdWJzdHJpbmcgKyBcIlxcXFxiKVwiLCBcImdcIik7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBzdHJpbmdzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGVudHJ5WzFdICE9PSBudWxsKSB7XG4gICAgICAgIHN0cmluZ3Muc2V0KGVudHJ5WzBdLCBlbnRyeVsxXS5yZXBsYWNlKHJlZ0V4cCwgcHJlZml4ZWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVncmF0ZUVmZmVjdChwcmVmaXgsIGVmZmVjdCwgZGF0YSkge1xuICBsZXQgZnJhZ21lbnRTaGFkZXIgPSBlZmZlY3QuZ2V0RnJhZ21lbnRTaGFkZXIoKTtcbiAgbGV0IHZlcnRleFNoYWRlciA9IGVmZmVjdC5nZXRWZXJ0ZXhTaGFkZXIoKTtcbiAgY29uc3QgbWFpbkltYWdlRXhpc3RzID0gZnJhZ21lbnRTaGFkZXIgIT09IHZvaWQgMCAmJiAvbWFpbkltYWdlLy50ZXN0KGZyYWdtZW50U2hhZGVyKTtcbiAgY29uc3QgbWFpblV2RXhpc3RzID0gZnJhZ21lbnRTaGFkZXIgIT09IHZvaWQgMCAmJiAvbWFpblV2Ly50ZXN0KGZyYWdtZW50U2hhZGVyKTtcbiAgZGF0YS5hdHRyaWJ1dGVzIHw9IGVmZmVjdC5nZXRBdHRyaWJ1dGVzKCk7XG4gIGlmIChmcmFnbWVudFNoYWRlciA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGZyYWdtZW50IHNoYWRlciAoJHtlZmZlY3QubmFtZX0pYCk7XG4gIH0gZWxzZSBpZiAobWFpblV2RXhpc3RzICYmIChkYXRhLmF0dHJpYnV0ZXMgJiBFZmZlY3RBdHRyaWJ1dGUuQ09OVk9MVVRJT04pICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFZmZlY3RzIHRoYXQgdHJhbnNmb3JtIFVWcyBhcmUgaW5jb21wYXRpYmxlIHdpdGggY29udm9sdXRpb24gZWZmZWN0cyAoJHtlZmZlY3QubmFtZX0pYCk7XG4gIH0gZWxzZSBpZiAoIW1haW5JbWFnZUV4aXN0cyAmJiAhbWFpblV2RXhpc3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBtYWluSW1hZ2Ugb3IgbWFpblV2IGZ1bmN0aW9uICgke2VmZmVjdC5uYW1lfSlgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmdW5jdGlvblJlZ0V4cCA9IC9cXHcrXFxzKyhcXHcrKVxcKFtcXHdcXHMsXSpcXClcXHMqey9nO1xuICAgIGNvbnN0IHNoYWRlclBhcnRzID0gZGF0YS5zaGFkZXJQYXJ0cztcbiAgICBsZXQgZnJhZ21lbnRIZWFkID0gc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCkgfHwgXCJcIjtcbiAgICBsZXQgZnJhZ21lbnRNYWluVXYgPSBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX1VWKSB8fCBcIlwiO1xuICAgIGxldCBmcmFnbWVudE1haW5JbWFnZSA9IHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fSU1BR0UpIHx8IFwiXCI7XG4gICAgbGV0IHZlcnRleEhlYWQgPSBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfSEVBRCkgfHwgXCJcIjtcbiAgICBsZXQgdmVydGV4TWFpblN1cHBvcnQgPSBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfTUFJTl9TVVBQT1JUKSB8fCBcIlwiO1xuICAgIGNvbnN0IHZhcnlpbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBuYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgaWYgKG1haW5VdkV4aXN0cykge1xuICAgICAgZnJhZ21lbnRNYWluVXYgKz0gYFx0JHtwcmVmaXh9TWFpblV2KFVWKTtcbmA7XG4gICAgICBkYXRhLnV2VHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodmVydGV4U2hhZGVyICE9PSBudWxsICYmIC9tYWluU3VwcG9ydC8udGVzdCh2ZXJ0ZXhTaGFkZXIpKSB7XG4gICAgICBjb25zdCBuZWVkc1V2ID0gL21haW5TdXBwb3J0ICpcXChbXFx3XFxzXSo/dXZcXHMqP1xcKS8udGVzdCh2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgdmVydGV4TWFpblN1cHBvcnQgKz0gYFx0JHtwcmVmaXh9TWFpblN1cHBvcnQoYDtcbiAgICAgIHZlcnRleE1haW5TdXBwb3J0ICs9IG5lZWRzVXYgPyBcInZVdik7XFxuXCIgOiBcIik7XFxuXCI7XG4gICAgICBmb3IgKGNvbnN0IG0yIG9mIHZlcnRleFNoYWRlci5tYXRjaEFsbCgvKD86dmFyeWluZ1xccytcXHcrXFxzKyhbXFxTXFxzXSo/KTspL2cpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBtMlsxXS5zcGxpdCgvXFxzKixcXHMqLykpIHtcbiAgICAgICAgICBkYXRhLnZhcnlpbmdzLmFkZChuKTtcbiAgICAgICAgICB2YXJ5aW5ncy5hZGQobik7XG4gICAgICAgICAgbmFtZXMuYWRkKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG0yIG9mIHZlcnRleFNoYWRlci5tYXRjaEFsbChmdW5jdGlvblJlZ0V4cCkpIHtcbiAgICAgICAgbmFtZXMuYWRkKG0yWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBtMiBvZiBmcmFnbWVudFNoYWRlci5tYXRjaEFsbChmdW5jdGlvblJlZ0V4cCkpIHtcbiAgICAgIG5hbWVzLmFkZChtMlsxXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZCBvZiBlZmZlY3QuZGVmaW5lcy5rZXlzKCkpIHtcbiAgICAgIG5hbWVzLmFkZChkLnJlcGxhY2UoL1xcKFtcXHdcXHMsXSpcXCkvZywgXCJcIikpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHUgb2YgZWZmZWN0LnVuaWZvcm1zLmtleXMoKSkge1xuICAgICAgbmFtZXMuYWRkKHUpO1xuICAgIH1cbiAgICBuYW1lcy5kZWxldGUoXCJ3aGlsZVwiKTtcbiAgICBuYW1lcy5kZWxldGUoXCJmb3JcIik7XG4gICAgbmFtZXMuZGVsZXRlKFwiaWZcIik7XG4gICAgZWZmZWN0LnVuaWZvcm1zLmZvckVhY2goKHZhbCwga2V5KSA9PiBkYXRhLnVuaWZvcm1zLnNldChwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSksIHZhbCkpO1xuICAgIGVmZmVjdC5kZWZpbmVzLmZvckVhY2goKHZhbCwga2V5KSA9PiBkYXRhLmRlZmluZXMuc2V0KHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKSwgdmFsKSk7XG4gICAgY29uc3Qgc2hhZGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbXCJmcmFnbWVudFwiLCBmcmFnbWVudFNoYWRlcl0sIFtcInZlcnRleFwiLCB2ZXJ0ZXhTaGFkZXJdXSk7XG4gICAgcHJlZml4U3Vic3RyaW5ncyhwcmVmaXgsIG5hbWVzLCBkYXRhLmRlZmluZXMpO1xuICAgIHByZWZpeFN1YnN0cmluZ3MocHJlZml4LCBuYW1lcywgc2hhZGVycyk7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJzLmdldChcImZyYWdtZW50XCIpO1xuICAgIHZlcnRleFNoYWRlciA9IHNoYWRlcnMuZ2V0KFwidmVydGV4XCIpO1xuICAgIGNvbnN0IGJsZW5kTW9kZSA9IGVmZmVjdC5ibGVuZE1vZGU7XG4gICAgZGF0YS5ibGVuZE1vZGVzLnNldChibGVuZE1vZGUuYmxlbmRGdW5jdGlvbiwgYmxlbmRNb2RlKTtcbiAgICBpZiAobWFpbkltYWdlRXhpc3RzKSB7XG4gICAgICBpZiAoZWZmZWN0LmlucHV0Q29sb3JTcGFjZSAhPT0gbnVsbCAmJiBlZmZlY3QuaW5wdXRDb2xvclNwYWNlICE9PSBkYXRhLmNvbG9yU3BhY2UpIHtcbiAgICAgICAgZnJhZ21lbnRNYWluSW1hZ2UgKz0gZWZmZWN0LmlucHV0Q29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UxNCA/IFwiY29sb3IwID0gc1JHQlRyYW5zZmVyT0VURihjb2xvcjApO1xcblx0XCIgOiBcImNvbG9yMCA9IHNSR0JUb0xpbmVhcihjb2xvcjApO1xcblx0XCI7XG4gICAgICB9XG4gICAgICBpZiAoZWZmZWN0Lm91dHB1dENvbG9yU3BhY2UgIT09IE5vQ29sb3JTcGFjZTIpIHtcbiAgICAgICAgZGF0YS5jb2xvclNwYWNlID0gZWZmZWN0Lm91dHB1dENvbG9yU3BhY2U7XG4gICAgICB9IGVsc2UgaWYgKGVmZmVjdC5pbnB1dENvbG9yU3BhY2UgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YS5jb2xvclNwYWNlID0gZWZmZWN0LmlucHV0Q29sb3JTcGFjZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcHRoUGFyYW1SZWdFeHAgPSAvTWFpbkltYWdlICpcXChbXFx3XFxzLF0qP2RlcHRoW1xcd1xccyxdKj9cXCkvO1xuICAgICAgZnJhZ21lbnRNYWluSW1hZ2UgKz0gYCR7cHJlZml4fU1haW5JbWFnZShjb2xvcjAsIFVWLCBgO1xuICAgICAgaWYgKChkYXRhLmF0dHJpYnV0ZXMgJiBFZmZlY3RBdHRyaWJ1dGUuREVQVEgpICE9PSAwICYmIGRlcHRoUGFyYW1SZWdFeHAudGVzdChmcmFnbWVudFNoYWRlcikpIHtcbiAgICAgICAgZnJhZ21lbnRNYWluSW1hZ2UgKz0gXCJkZXB0aCwgXCI7XG4gICAgICAgIGRhdGEucmVhZERlcHRoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IFwiY29sb3IxKTtcXG5cdFwiO1xuICAgICAgY29uc3QgYmxlbmRPcGFjaXR5ID0gcHJlZml4ICsgXCJCbGVuZE9wYWNpdHlcIjtcbiAgICAgIGRhdGEudW5pZm9ybXMuc2V0KGJsZW5kT3BhY2l0eSwgYmxlbmRNb2RlLm9wYWNpdHkpO1xuICAgICAgZnJhZ21lbnRNYWluSW1hZ2UgKz0gYGNvbG9yMCA9IGJsZW5kJHtibGVuZE1vZGUuYmxlbmRGdW5jdGlvbn0oY29sb3IwLCBjb2xvcjEsICR7YmxlbmRPcGFjaXR5fSk7XG5cblx0YDtcbiAgICAgIGZyYWdtZW50SGVhZCArPSBgdW5pZm9ybSBmbG9hdCAke2JsZW5kT3BhY2l0eX07XG5cbmA7XG4gICAgfVxuICAgIGZyYWdtZW50SGVhZCArPSBmcmFnbWVudFNoYWRlciArIFwiXFxuXCI7XG4gICAgaWYgKHZlcnRleFNoYWRlciAhPT0gbnVsbCkge1xuICAgICAgdmVydGV4SGVhZCArPSB2ZXJ0ZXhTaGFkZXIgKyBcIlxcblwiO1xuICAgIH1cbiAgICBzaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFELCBmcmFnbWVudEhlYWQpO1xuICAgIHNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYsIGZyYWdtZW50TWFpblV2KTtcbiAgICBzaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFLCBmcmFnbWVudE1haW5JbWFnZSk7XG4gICAgc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX0hFQUQsIHZlcnRleEhlYWQpO1xuICAgIHNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9NQUlOX1NVUFBPUlQsIHZlcnRleE1haW5TdXBwb3J0KTtcbiAgICBpZiAoZWZmZWN0LmV4dGVuc2lvbnMgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIGVmZmVjdC5leHRlbnNpb25zKSB7XG4gICAgICAgIGRhdGEuZXh0ZW5zaW9ucy5hZGQoZXh0ZW5zaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBFZmZlY3RQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZWZmZWN0IHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7Li4uRWZmZWN0fSBlZmZlY3RzIC0gVGhlIGVmZmVjdHMgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGJ5IHRoaXMgcGFzcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSwgLi4uZWZmZWN0cykge1xuICAgIHN1cGVyKFwiRWZmZWN0UGFzc1wiKTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG5ldyBFZmZlY3RNYXRlcmlhbChudWxsLCBudWxsLCBudWxsLCBjYW1lcmEpO1xuICAgIHRoaXMubGlzdGVuZXIgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgIHRoaXMuc2V0RWZmZWN0cyhlZmZlY3RzKTtcbiAgICB0aGlzLnNraXBSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1pblRpbWUgPSAxO1xuICAgIHRoaXMubWF4VGltZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLnRpbWVTY2FsZSA9IDE7XG4gIH1cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0Lm1haW5TY2VuZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyh2YWx1ZSk7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QubWFpbkNhbWVyYSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBwYXNzIGVuY29kZXMgaXRzIG91dHB1dCB3aGVuIHJlbmRlcmluZyB0byBzY3JlZW4uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsLmVuY29kZU91dHB1dCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGVuY29kZU91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZW5jb2RlT3V0cHV0O1xuICB9XG4gIHNldCBlbmNvZGVPdXRwdXQodmFsdWUpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5lbmNvZGVPdXRwdXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGl0aGVyaW5nO1xuICB9XG4gIHNldCBkaXRoZXJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgIG1hdGVyaWFsLmRpdGhlcmluZyA9IHZhbHVlO1xuICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWZmZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtFZmZlY3RbXX0gZWZmZWN0cyAtIFRoZSBlZmZlY3RzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXRFZmZlY3RzKGVmZmVjdHMpIHtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMubGlzdGVuZXIpO1xuICAgIH1cbiAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzLnNvcnQoKGEsIGIpID0+IGIuYXR0cmlidXRlcyAtIGEuYXR0cmlidXRlcyk7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvdW5kIHNoYWRlciBtYXRlcmlhbC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlTWF0ZXJpYWwoKSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBFZmZlY3RTaGFkZXJEYXRhKCk7XG4gICAgbGV0IGlkID0gMDtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGlmIChlZmZlY3QuYmxlbmRNb2RlLmJsZW5kRnVuY3Rpb24gPT09IEJsZW5kRnVuY3Rpb24uRFNUKSB7XG4gICAgICAgIGRhdGEuYXR0cmlidXRlcyB8PSBlZmZlY3QuZ2V0QXR0cmlidXRlcygpICYgRWZmZWN0QXR0cmlidXRlLkRFUFRIO1xuICAgICAgfSBlbHNlIGlmICgoZGF0YS5hdHRyaWJ1dGVzICYgZWZmZWN0LmdldEF0dHJpYnV0ZXMoKSAmIEVmZmVjdEF0dHJpYnV0ZS5DT05WT0xVVElPTikgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252b2x1dGlvbiBlZmZlY3RzIGNhbm5vdCBiZSBtZXJnZWQgKCR7ZWZmZWN0Lm5hbWV9KWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZWdyYXRlRWZmZWN0KFwiZVwiICsgaWQrKywgZWZmZWN0LCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZyYWdtZW50SGVhZCA9IGRhdGEuc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCk7XG4gICAgbGV0IGZyYWdtZW50TWFpbkltYWdlID0gZGF0YS5zaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFKTtcbiAgICBsZXQgZnJhZ21lbnRNYWluVXYgPSBkYXRhLnNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYpO1xuICAgIGNvbnN0IGJsZW5kUmVnRXhwID0gL1xcYmJsZW5kXFxiL2c7XG4gICAgZm9yIChjb25zdCBibGVuZE1vZGUgb2YgZGF0YS5ibGVuZE1vZGVzLnZhbHVlcygpKSB7XG4gICAgICBmcmFnbWVudEhlYWQgKz0gYmxlbmRNb2RlLmdldFNoYWRlckNvZGUoKS5yZXBsYWNlKGJsZW5kUmVnRXhwLCBgYmxlbmQke2JsZW5kTW9kZS5ibGVuZEZ1bmN0aW9ufWApICsgXCJcXG5cIjtcbiAgICB9XG4gICAgaWYgKChkYXRhLmF0dHJpYnV0ZXMgJiBFZmZlY3RBdHRyaWJ1dGUuREVQVEgpICE9PSAwKSB7XG4gICAgICBpZiAoZGF0YS5yZWFkRGVwdGgpIHtcbiAgICAgICAgZnJhZ21lbnRNYWluSW1hZ2UgPSBcImZsb2F0IGRlcHRoID0gcmVhZERlcHRoKFVWKTtcXG5cXG5cdFwiICsgZnJhZ21lbnRNYWluSW1hZ2U7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gdGhpcy5nZXREZXB0aFRleHR1cmUoKSA9PT0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZWVkc0RlcHRoVGV4dHVyZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZTE0KSB7XG4gICAgICBmcmFnbWVudE1haW5JbWFnZSArPSBcImNvbG9yMCA9IHNSR0JUb0xpbmVhcihjb2xvcjApO1xcblx0XCI7XG4gICAgfVxuICAgIGlmIChkYXRhLnV2VHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIGZyYWdtZW50TWFpblV2ID0gXCJ2ZWMyIHRyYW5zZm9ybWVkVXYgPSB2VXY7XFxuXCIgKyBmcmFnbWVudE1haW5VdjtcbiAgICAgIGRhdGEuZGVmaW5lcy5zZXQoXCJVVlwiLCBcInRyYW5zZm9ybWVkVXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuZGVmaW5lcy5zZXQoXCJVVlwiLCBcInZVdlwiKTtcbiAgICB9XG4gICAgZGF0YS5zaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFELCBmcmFnbWVudEhlYWQpO1xuICAgIGRhdGEuc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSwgZnJhZ21lbnRNYWluSW1hZ2UpO1xuICAgIGRhdGEuc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9VViwgZnJhZ21lbnRNYWluVXYpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEuc2hhZGVyUGFydHMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhLnNoYWRlclBhcnRzLnNldChrZXksIHZhbHVlLnRyaW0oKS5yZXBsYWNlKC9eIy8sIFwiXFxuI1wiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2tpcFJlbmRlcmluZyA9IGlkID09PSAwO1xuICAgIHRoaXMubmVlZHNTd2FwID0gIXRoaXMuc2tpcFJlbmRlcmluZztcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaGFkZXJEYXRhKGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBSZWJ1aWxkcyB0aGUgc2hhZGVyIG1hdGVyaWFsLlxuICAgKi9cbiAgcmVjb21waWxlKCkge1xuICAgIHRoaXMudXBkYXRlTWF0ZXJpYWwoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAqL1xuICBnZXREZXB0aFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoQnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxOSkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5zZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC51cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2tpcFJlbmRlcmluZyB8fCB0aGlzLnJlbmRlclRvU2NyZWVuKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgICAgbWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBpbnB1dEJ1ZmZlci50ZXh0dXJlO1xuICAgICAgbWF0ZXJpYWwudGltZSArPSBkZWx0YVRpbWUgKiB0aGlzLnRpbWVTY2FsZTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IG91dHB1dEJ1ZmZlcik7XG4gICAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTWF0ZXJpYWwoKTtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDAgJiYgZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlMTUpIHtcbiAgICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgZGlzcG9zYWJsZSBvYmplY3RzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIGVmZmVjdC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBBbiBldmVudC5cbiAgICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiY2hhbmdlXCI6XG4gICAgICAgIHRoaXMucmVjb21waWxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9HYXVzc2lhbkJsdXJQYXNzLmpzXG5pbXBvcnQgeyBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTE1LCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxNiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQyMiB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIEdhdXNzaWFuQmx1clBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBHYXVzc2lhbiBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtlcm5lbFNpemU9MzVdIC0gVGhlIGtlcm5lbCBzaXplLiBTaG91bGQgYmUgYW4gb2RkIG51bWJlciBpbiB0aGUgcmFuZ2UgWzMsIDEwMjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaXRlcmF0aW9ucz0xXSAtIFRoZSBhbW91bnQgb2YgdGltZXMgdGhlIGJsdXIgc2hvdWxkIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MS4wXSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGtlcm5lbFNpemUgPSAzNSxcbiAgICBpdGVyYXRpb25zID0gMSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAxLFxuICAgIHJlc29sdXRpb25YID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblkgPSBSZXNvbHV0aW9uLkFVVE9fU0laRVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdhdXNzaWFuQmx1clBhc3NcIik7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MjIoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQVwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QS5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLm5hbWUgPSBcIkJsdXIuVGFyZ2V0LkJcIjtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbCA9IG5ldyBHYXVzc2lhbkJsdXJNYXRlcmlhbCh7IGtlcm5lbFNpemUgfSk7XG4gICAgdGhpcy5jb3B5TWF0ZXJpYWwgPSBuZXcgQ29weU1hdGVyaWFsKCk7XG4gICAgdGhpcy5jb3B5TWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBibHVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QSA9IHRoaXMucmVuZGVyVGFyZ2V0QTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRCID0gdGhpcy5yZW5kZXJUYXJnZXRCO1xuICAgIGNvbnN0IGJsdXJNYXRlcmlhbCA9IHRoaXMuYmx1ck1hdGVyaWFsO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gYmx1ck1hdGVyaWFsO1xuICAgIGxldCBwcmV2aW91c0J1ZmZlciA9IGlucHV0QnVmZmVyO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gTWF0aC5tYXgodGhpcy5pdGVyYXRpb25zLCAxKTsgaSA8IGw7ICsraSkge1xuICAgICAgYmx1ck1hdGVyaWFsLmRpcmVjdGlvbi5zZXQoMSwgMCk7XG4gICAgICBibHVyTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBwcmV2aW91c0J1ZmZlci50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldEEpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgYmx1ck1hdGVyaWFsLmRpcmVjdGlvbi5zZXQoMCwgMSk7XG4gICAgICBibHVyTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSByZW5kZXJUYXJnZXRBLnRleHR1cmU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0Qik7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBpZiAoaSA9PT0gMCAmJiBsID4gMSkge1xuICAgICAgICBwcmV2aW91c0J1ZmZlciA9IHJlbmRlclRhcmdldEI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gdGhpcy5jb3B5TWF0ZXJpYWw7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogb3V0cHV0QnVmZmVyKTtcbiAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUxNikge1xuICAgICAgICB0aGlzLmJsdXJNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICAgIHRoaXMuY29weU1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UxNSkge1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UxNTtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMTU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0xhbWJkYVBhc3MuanNcbnZhciBMYW1iZGFQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbGFtYmRhIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgLSBBIGZ1bmN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZikge1xuICAgIHN1cGVyKFwiTGFtYmRhUGFzc1wiLCBudWxsLCBudWxsKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgdGhpcy5mKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTm9ybWFsUGFzcy5qc1xuaW1wb3J0IHsgQ29sb3IgYXMgQ29sb3IxMCwgTWVzaE5vcm1hbE1hdGVyaWFsLCBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXI4LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDIzIH0gZnJvbSBcInRocmVlXCI7XG52YXIgTm9ybWFsUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vcm1hbCBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRvIHVzZSB0byByZW5kZXIgdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IFtvcHRpb25zLnJlbmRlclRhcmdldF0gLSBBIGN1c3RvbSByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTEuMF0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwge1xuICAgIHJlbmRlclRhcmdldCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAxLFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIk5vcm1hbFBhc3NcIik7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhLCBuZXcgTWVzaE5vcm1hbE1hdGVyaWFsKCkpO1xuICAgIGNvbnN0IHJlbmRlclBhc3MgPSB0aGlzLnJlbmRlclBhc3M7XG4gICAgcmVuZGVyUGFzcy5pZ25vcmVCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICByZW5kZXJQYXNzLnNraXBTaGFkb3dNYXBVcGRhdGUgPSB0cnVlO1xuICAgIGNvbnN0IGNsZWFyUGFzcyA9IHJlbmRlclBhc3MuZ2V0Q2xlYXJQYXNzKCk7XG4gICAgY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjEwKDc4Mjk1MDMpO1xuICAgIGNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQWxwaGEgPSAxO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgIGlmICh0aGlzLnJlbmRlclRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIzKDEsIDEsIHtcbiAgICAgICAgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyOCxcbiAgICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyOFxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIk5vcm1hbFBhc3MuVGFyZ2V0XCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLnJlbmRlclBhc3MubWFpblNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLnJlbmRlclBhc3MubWFpbkNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbm9ybWFsIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCBvciByZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvblNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBuZXcgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggb3IgcmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIHNldFJlc29sdXRpb25TY2FsZShzY2FsZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zY2FsZSA9IHNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzY2VuZSBub3JtYWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIHRoaXMucmVuZGVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9sdXQvVGV0cmFoZWRyYWxVcHNjYWxlci5qc1xudmFyIFAgPSBbXG4gIG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gIG5ldyBGbG9hdDMyQXJyYXkoMylcbl07XG52YXIgQyA9IFtcbiAgbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgbmV3IEZsb2F0MzJBcnJheSgzKVxuXTtcbnZhciBUID0gW1xuICBbXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pXG4gIF0sXG4gIFtcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDFdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSlcbiAgXSxcbiAgW1xuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMV0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKVxuICBdLFxuICBbXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pXG4gIF0sXG4gIFtcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDFdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSlcbiAgXSxcbiAgW1xuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMV0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKVxuICBdXG5dO1xuZnVuY3Rpb24gY2FsY3VsYXRlVGV0cmFoZWRyb25Wb2x1bWUoYSwgYiwgYzIsIGQpIHtcbiAgY29uc3QgYmNYID0gYzJbMF0gLSBiWzBdO1xuICBjb25zdCBiY1kgPSBjMlsxXSAtIGJbMV07XG4gIGNvbnN0IGJjWiA9IGMyWzJdIC0gYlsyXTtcbiAgY29uc3QgYmFYID0gYVswXSAtIGJbMF07XG4gIGNvbnN0IGJhWSA9IGFbMV0gLSBiWzFdO1xuICBjb25zdCBiYVogPSBhWzJdIC0gYlsyXTtcbiAgY29uc3QgY3Jvc3NYID0gYmNZICogYmFaIC0gYmNaICogYmFZO1xuICBjb25zdCBjcm9zc1kgPSBiY1ogKiBiYVggLSBiY1ggKiBiYVo7XG4gIGNvbnN0IGNyb3NzWiA9IGJjWCAqIGJhWSAtIGJjWSAqIGJhWDtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KGNyb3NzWCAqIGNyb3NzWCArIGNyb3NzWSAqIGNyb3NzWSArIGNyb3NzWiAqIGNyb3NzWik7XG4gIGNvbnN0IHRyaWFuZ2xlQXJlYSA9IGxlbmd0aCAqIDAuNTtcbiAgY29uc3Qgbm9ybWFsWCA9IGNyb3NzWCAvIGxlbmd0aDtcbiAgY29uc3Qgbm9ybWFsWSA9IGNyb3NzWSAvIGxlbmd0aDtcbiAgY29uc3Qgbm9ybWFsWiA9IGNyb3NzWiAvIGxlbmd0aDtcbiAgY29uc3QgY29uc3RhbnQgPSAtKGFbMF0gKiBub3JtYWxYICsgYVsxXSAqIG5vcm1hbFkgKyBhWzJdICogbm9ybWFsWik7XG4gIGNvbnN0IGRvdCA9IGRbMF0gKiBub3JtYWxYICsgZFsxXSAqIG5vcm1hbFkgKyBkWzJdICogbm9ybWFsWjtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMoZG90ICsgY29uc3RhbnQpO1xuICByZXR1cm4gaGVpZ2h0ICogdHJpYW5nbGVBcmVhIC8gMztcbn1cbmZ1bmN0aW9uIHNhbXBsZShkYXRhLCBzaXplLCB4LCB5LCB6LCBjb2xvcjIpIHtcbiAgY29uc3QgaTQgPSAoeCArIHkgKiBzaXplICsgeiAqIHNpemUgKiBzaXplKSAqIDQ7XG4gIGNvbG9yMlswXSA9IGRhdGFbaTQgKyAwXTtcbiAgY29sb3IyWzFdID0gZGF0YVtpNCArIDFdO1xuICBjb2xvcjJbMl0gPSBkYXRhW2k0ICsgMl07XG59XG5mdW5jdGlvbiB0ZXRyYWhlZHJhbFNhbXBsZShkYXRhLCBzaXplLCB1LCB2MywgdywgY29sb3IyKSB7XG4gIGNvbnN0IHB4ID0gdSAqIChzaXplIC0gMSk7XG4gIGNvbnN0IHB5ID0gdjMgKiAoc2l6ZSAtIDEpO1xuICBjb25zdCBweiA9IHcgKiAoc2l6ZSAtIDEpO1xuICBjb25zdCBtaW5YID0gTWF0aC5mbG9vcihweCk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLmZsb29yKHB5KTtcbiAgY29uc3QgbWluWiA9IE1hdGguZmxvb3IocHopO1xuICBjb25zdCBtYXhYID0gTWF0aC5jZWlsKHB4KTtcbiAgY29uc3QgbWF4WSA9IE1hdGguY2VpbChweSk7XG4gIGNvbnN0IG1heFogPSBNYXRoLmNlaWwocHopO1xuICBjb25zdCBzdSA9IHB4IC0gbWluWDtcbiAgY29uc3Qgc3YgPSBweSAtIG1pblk7XG4gIGNvbnN0IHN3ID0gcHogLSBtaW5aO1xuICBpZiAobWluWCA9PT0gcHggJiYgbWluWSA9PT0gcHkgJiYgbWluWiA9PT0gcHopIHtcbiAgICBzYW1wbGUoZGF0YSwgc2l6ZSwgcHgsIHB5LCBweiwgY29sb3IyKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgdmVydGljZXM7XG4gICAgaWYgKHN1ID49IHN2ICYmIHN2ID49IHN3KSB7XG4gICAgICB2ZXJ0aWNlcyA9IFRbMF07XG4gICAgfSBlbHNlIGlmIChzdSA+PSBzdyAmJiBzdyA+PSBzdikge1xuICAgICAgdmVydGljZXMgPSBUWzFdO1xuICAgIH0gZWxzZSBpZiAoc3cgPj0gc3UgJiYgc3UgPj0gc3YpIHtcbiAgICAgIHZlcnRpY2VzID0gVFsyXTtcbiAgICB9IGVsc2UgaWYgKHN2ID49IHN1ICYmIHN1ID49IHN3KSB7XG4gICAgICB2ZXJ0aWNlcyA9IFRbM107XG4gICAgfSBlbHNlIGlmIChzdiA+PSBzdyAmJiBzdyA+PSBzdSkge1xuICAgICAgdmVydGljZXMgPSBUWzRdO1xuICAgIH0gZWxzZSBpZiAoc3cgPj0gc3YgJiYgc3YgPj0gc3UpIHtcbiAgICAgIHZlcnRpY2VzID0gVFs1XTtcbiAgICB9XG4gICAgY29uc3QgW1AwLCBQMSwgUDIsIFAzXSA9IHZlcnRpY2VzO1xuICAgIGNvbnN0IGNvb3JkcyA9IFBbMF07XG4gICAgY29vcmRzWzBdID0gc3U7XG4gICAgY29vcmRzWzFdID0gc3Y7XG4gICAgY29vcmRzWzJdID0gc3c7XG4gICAgY29uc3QgdG1wID0gUFsxXTtcbiAgICBjb25zdCBkaWZmWCA9IG1heFggLSBtaW5YO1xuICAgIGNvbnN0IGRpZmZZID0gbWF4WSAtIG1pblk7XG4gICAgY29uc3QgZGlmZlogPSBtYXhaIC0gbWluWjtcbiAgICB0bXBbMF0gPSBkaWZmWCAqIFAwWzBdICsgbWluWDtcbiAgICB0bXBbMV0gPSBkaWZmWSAqIFAwWzFdICsgbWluWTtcbiAgICB0bXBbMl0gPSBkaWZmWiAqIFAwWzJdICsgbWluWjtcbiAgICBzYW1wbGUoZGF0YSwgc2l6ZSwgdG1wWzBdLCB0bXBbMV0sIHRtcFsyXSwgQ1swXSk7XG4gICAgdG1wWzBdID0gZGlmZlggKiBQMVswXSArIG1pblg7XG4gICAgdG1wWzFdID0gZGlmZlkgKiBQMVsxXSArIG1pblk7XG4gICAgdG1wWzJdID0gZGlmZlogKiBQMVsyXSArIG1pblo7XG4gICAgc2FtcGxlKGRhdGEsIHNpemUsIHRtcFswXSwgdG1wWzFdLCB0bXBbMl0sIENbMV0pO1xuICAgIHRtcFswXSA9IGRpZmZYICogUDJbMF0gKyBtaW5YO1xuICAgIHRtcFsxXSA9IGRpZmZZICogUDJbMV0gKyBtaW5ZO1xuICAgIHRtcFsyXSA9IGRpZmZaICogUDJbMl0gKyBtaW5aO1xuICAgIHNhbXBsZShkYXRhLCBzaXplLCB0bXBbMF0sIHRtcFsxXSwgdG1wWzJdLCBDWzJdKTtcbiAgICB0bXBbMF0gPSBkaWZmWCAqIFAzWzBdICsgbWluWDtcbiAgICB0bXBbMV0gPSBkaWZmWSAqIFAzWzFdICsgbWluWTtcbiAgICB0bXBbMl0gPSBkaWZmWiAqIFAzWzJdICsgbWluWjtcbiAgICBzYW1wbGUoZGF0YSwgc2l6ZSwgdG1wWzBdLCB0bXBbMV0sIHRtcFsyXSwgQ1szXSk7XG4gICAgY29uc3QgVjAgPSBjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZShQMSwgUDIsIFAzLCBjb29yZHMpICogNjtcbiAgICBjb25zdCBWMSA9IGNhbGN1bGF0ZVRldHJhaGVkcm9uVm9sdW1lKFAwLCBQMiwgUDMsIGNvb3JkcykgKiA2O1xuICAgIGNvbnN0IFYyID0gY2FsY3VsYXRlVGV0cmFoZWRyb25Wb2x1bWUoUDAsIFAxLCBQMywgY29vcmRzKSAqIDY7XG4gICAgY29uc3QgVjMgPSBjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZShQMCwgUDEsIFAyLCBjb29yZHMpICogNjtcbiAgICBDWzBdWzBdICo9IFYwO1xuICAgIENbMF1bMV0gKj0gVjA7XG4gICAgQ1swXVsyXSAqPSBWMDtcbiAgICBDWzFdWzBdICo9IFYxO1xuICAgIENbMV1bMV0gKj0gVjE7XG4gICAgQ1sxXVsyXSAqPSBWMTtcbiAgICBDWzJdWzBdICo9IFYyO1xuICAgIENbMl1bMV0gKj0gVjI7XG4gICAgQ1syXVsyXSAqPSBWMjtcbiAgICBDWzNdWzBdICo9IFYzO1xuICAgIENbM11bMV0gKj0gVjM7XG4gICAgQ1szXVsyXSAqPSBWMztcbiAgICBjb2xvcjJbMF0gPSBDWzBdWzBdICsgQ1sxXVswXSArIENbMl1bMF0gKyBDWzNdWzBdO1xuICAgIGNvbG9yMlsxXSA9IENbMF1bMV0gKyBDWzFdWzFdICsgQ1syXVsxXSArIENbM11bMV07XG4gICAgY29sb3IyWzJdID0gQ1swXVsyXSArIENbMV1bMl0gKyBDWzJdWzJdICsgQ1szXVsyXTtcbiAgfVxufVxudmFyIFRldHJhaGVkcmFsVXBzY2FsZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBFeHBhbmRzIHRoZSBnaXZlbiBkYXRhIHRvIHRoZSB0YXJnZXQgc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBkYXRhIC0gVGhlIGlucHV0IFJHQkEgZGF0YS4gQXNzdW1lZCB0byBiZSBjdWJpYy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgdGFyZ2V0IHNpemUuXG4gICAqIEByZXR1cm4ge1R5cGVkQXJyYXl9IFRoZSBuZXcgZGF0YS5cbiAgICovXG4gIHN0YXRpYyBleHBhbmQoZGF0YSwgc2l6ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsU2l6ZSA9IE1hdGguY2JydChkYXRhLmxlbmd0aCAvIDQpO1xuICAgIGNvbnN0IHJnYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgZGF0YS5jb25zdHJ1Y3RvcihzaXplICoqIDMgKiA0KTtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gMjU1IDogMTtcbiAgICBjb25zdCBzaXplU3EgPSBzaXplICoqIDI7XG4gICAgY29uc3QgcyA9IDEgLyAoc2l6ZSAtIDEpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgc2l6ZTsgKyt6KSB7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemU7ICsreSkge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemU7ICsreCkge1xuICAgICAgICAgIGNvbnN0IHUgPSB4ICogcztcbiAgICAgICAgICBjb25zdCB2MyA9IHkgKiBzO1xuICAgICAgICAgIGNvbnN0IHcgPSB6ICogcztcbiAgICAgICAgICBjb25zdCBpNCA9IE1hdGgucm91bmQoeCArIHkgKiBzaXplICsgeiAqIHNpemVTcSkgKiA0O1xuICAgICAgICAgIHRldHJhaGVkcmFsU2FtcGxlKGRhdGEsIG9yaWdpbmFsU2l6ZSwgdSwgdjMsIHcsIHJnYik7XG4gICAgICAgICAgYXJyYXlbaTQgKyAwXSA9IHJnYlswXTtcbiAgICAgICAgICBhcnJheVtpNCArIDFdID0gcmdiWzFdO1xuICAgICAgICAgIGFycmF5W2k0ICsgMl0gPSByZ2JbMl07XG4gICAgICAgICAgYXJyYXlbaTQgKyAzXSA9IG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvU01BQUFyZWFJbWFnZURhdGEuanNcbnZhciBhcmVhID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KDIpLFxuICBuZXcgRmxvYXQzMkFycmF5KDIpXG5dO1xudmFyIE9SVEhPR09OQUxfU0laRSA9IDE2O1xudmFyIERJQUdPTkFMX1NJWkUgPSAyMDtcbnZhciBESUFHT05BTF9TQU1QTEVTID0gMzA7XG52YXIgU01PT1RIX01BWF9ESVNUQU5DRSA9IDMyO1xudmFyIG9ydGhvZ29uYWxTdWJzYW1wbGluZ09mZnNldHMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgMCxcbiAgLTAuMjUsXG4gIDAuMjUsXG4gIC0wLjEyNSxcbiAgMC4xMjUsXG4gIC0wLjM3NSxcbiAgMC4zNzVcbl0pO1xudmFyIGRpYWdvbmFsU3Vic2FtcGxpbmdPZmZzZXRzID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAuMjUsIC0wLjI1XSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWy0wLjI1LCAwLjI1XSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAuMTI1LCAtMC4xMjVdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbLTAuMTI1LCAwLjEyNV0pXG5dO1xudmFyIG9ydGhvZ29uYWxFZGdlcyA9IFtcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzQsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzQsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDRdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDRdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzQsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDRdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzQsIDRdKVxuXTtcbnZhciBkaWFnb25hbEVkZ2VzID0gW1xuICBuZXcgVWludDhBcnJheShbMCwgMF0pLFxuICBuZXcgVWludDhBcnJheShbMSwgMF0pLFxuICBuZXcgVWludDhBcnJheShbMCwgMl0pLFxuICBuZXcgVWludDhBcnJheShbMSwgMl0pLFxuICBuZXcgVWludDhBcnJheShbMiwgMF0pLFxuICBuZXcgVWludDhBcnJheShbMywgMF0pLFxuICBuZXcgVWludDhBcnJheShbMiwgMl0pLFxuICBuZXcgVWludDhBcnJheShbMywgMl0pLFxuICBuZXcgVWludDhBcnJheShbMCwgMV0pLFxuICBuZXcgVWludDhBcnJheShbMSwgMV0pLFxuICBuZXcgVWludDhBcnJheShbMCwgM10pLFxuICBuZXcgVWludDhBcnJheShbMSwgM10pLFxuICBuZXcgVWludDhBcnJheShbMiwgMV0pLFxuICBuZXcgVWludDhBcnJheShbMywgMV0pLFxuICBuZXcgVWludDhBcnJheShbMiwgM10pLFxuICBuZXcgVWludDhBcnJheShbMywgM10pXG5dO1xuZnVuY3Rpb24gbGVycChhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5mdW5jdGlvbiBzYXR1cmF0ZShhKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChhLCAwKSwgMSk7XG59XG5mdW5jdGlvbiBzbW9vdGhBcmVhKGQpIHtcbiAgY29uc3QgYTEgPSBhcmVhWzBdO1xuICBjb25zdCBhMiA9IGFyZWFbMV07XG4gIGNvbnN0IGIxWCA9IE1hdGguc3FydChhMVswXSAqIDIpICogMC41O1xuICBjb25zdCBiMVkgPSBNYXRoLnNxcnQoYTFbMV0gKiAyKSAqIDAuNTtcbiAgY29uc3QgYjJYID0gTWF0aC5zcXJ0KGEyWzBdICogMikgKiAwLjU7XG4gIGNvbnN0IGIyWSA9IE1hdGguc3FydChhMlsxXSAqIDIpICogMC41O1xuICBjb25zdCBwID0gc2F0dXJhdGUoZCAvIFNNT09USF9NQVhfRElTVEFOQ0UpO1xuICBhMVswXSA9IGxlcnAoYjFYLCBhMVswXSwgcCk7XG4gIGExWzFdID0gbGVycChiMVksIGExWzFdLCBwKTtcbiAgYTJbMF0gPSBsZXJwKGIyWCwgYTJbMF0sIHApO1xuICBhMlsxXSA9IGxlcnAoYjJZLCBhMlsxXSwgcCk7XG59XG5mdW5jdGlvbiBnZXRPcnRoQXJlYShwMVgsIHAxWSwgcDJYLCBwMlksIHgsIHJlc3VsdCkge1xuICBjb25zdCBkWCA9IHAyWCAtIHAxWDtcbiAgY29uc3QgZFkgPSBwMlkgLSBwMVk7XG4gIGNvbnN0IHgxID0geDtcbiAgY29uc3QgeDIgPSB4ICsgMTtcbiAgY29uc3QgeTEgPSBwMVkgKyBkWSAqICh4MSAtIHAxWCkgLyBkWDtcbiAgY29uc3QgeTIgPSBwMVkgKyBkWSAqICh4MiAtIHAxWCkgLyBkWDtcbiAgaWYgKHgxID49IHAxWCAmJiB4MSA8IHAyWCB8fCB4MiA+IHAxWCAmJiB4MiA8PSBwMlgpIHtcbiAgICBpZiAoTWF0aC5zaWduKHkxKSA9PT0gTWF0aC5zaWduKHkyKSB8fCBNYXRoLmFicyh5MSkgPCAxZS00IHx8IE1hdGguYWJzKHkyKSA8IDFlLTQpIHtcbiAgICAgIGNvbnN0IGEgPSAoeTEgKyB5MikgLyAyO1xuICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgIHJlc3VsdFswXSA9IE1hdGguYWJzKGEpO1xuICAgICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gTWF0aC5hYnMoYSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSAtcDFZICogZFggLyBkWSArIHAxWDtcbiAgICAgIGNvbnN0IHRJbnQgPSBNYXRoLnRydW5jKHQpO1xuICAgICAgY29uc3QgYTEgPSB0ID4gcDFYID8geTEgKiAodCAtIHRJbnQpIC8gMiA6IDA7XG4gICAgICBjb25zdCBhMiA9IHQgPCBwMlggPyB5MiAqICgxIC0gKHQgLSB0SW50KSkgLyAyIDogMDtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLmFicyhhMSkgPiBNYXRoLmFicyhhMikgPyBhMSA6IC1hMjtcbiAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICByZXN1bHRbMF0gPSBNYXRoLmFicyhhMSk7XG4gICAgICAgIHJlc3VsdFsxXSA9IE1hdGguYWJzKGEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFswXSA9IE1hdGguYWJzKGEyKTtcbiAgICAgICAgcmVzdWx0WzFdID0gTWF0aC5hYnMoYTEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHRbMF0gPSAwO1xuICAgIHJlc3VsdFsxXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE9ydGhBcmVhRm9yUGF0dGVybihwYXR0ZXJuLCBsZWZ0LCByaWdodCwgb2Zmc2V0LCByZXN1bHQpIHtcbiAgY29uc3QgYTEgPSBhcmVhWzBdO1xuICBjb25zdCBhMiA9IGFyZWFbMV07XG4gIGNvbnN0IG8xID0gMC41ICsgb2Zmc2V0O1xuICBjb25zdCBvMiA9IDAuNSArIG9mZnNldCAtIDE7XG4gIGNvbnN0IGQgPSBsZWZ0ICsgcmlnaHQgKyAxO1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgaWYgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQgLyAyLCAwLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDI6IHtcbiAgICAgIGlmIChsZWZ0ID49IHJpZ2h0KSB7XG4gICAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMiwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAzOiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCAvIDIsIDAsIGxlZnQsIGExKTtcbiAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMiwgbGVmdCwgYTIpO1xuICAgICAgc21vb3RoQXJlYShkLCBhcmVhKTtcbiAgICAgIHJlc3VsdFswXSA9IGExWzBdICsgYTJbMF07XG4gICAgICByZXN1bHRbMV0gPSBhMVsxXSArIGEyWzFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNDoge1xuICAgICAgaWYgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQgLyAyLCAwLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDU6IHtcbiAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNjoge1xuICAgICAgaWYgKE1hdGguYWJzKG9mZnNldCkgPiAwKSB7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8xLCBkLCBvMiwgbGVmdCwgYTEpO1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMSwgZCAvIDIsIDAsIGxlZnQsIGEyKTtcbiAgICAgICAgZ2V0T3J0aEFyZWEoZCAvIDIsIDAsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgICBhMlswXSA9IGEyWzBdICsgcmVzdWx0WzBdO1xuICAgICAgICBhMlsxXSA9IGEyWzFdICsgcmVzdWx0WzFdO1xuICAgICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNzoge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgODoge1xuICAgICAgaWYgKGxlZnQgPj0gcmlnaHQpIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoZCAvIDIsIDAsIGQsIG8xLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDk6IHtcbiAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQpID4gMCkge1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCwgbzEsIGxlZnQsIGExKTtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQgLyAyLCAwLCBsZWZ0LCBhMik7XG4gICAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMSwgbGVmdCwgcmVzdWx0KTtcbiAgICAgICAgYTJbMF0gPSBhMlswXSArIHJlc3VsdFswXTtcbiAgICAgICAgYTJbMV0gPSBhMlsxXSArIHJlc3VsdFsxXTtcbiAgICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8yLCBkLCBvMSwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEwOiB7XG4gICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDExOiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCwgbzEsIGxlZnQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMjoge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQgLyAyLCAwLCBsZWZ0LCBhMSk7XG4gICAgICBnZXRPcnRoQXJlYShkIC8gMiwgMCwgZCwgbzEsIGxlZnQsIGEyKTtcbiAgICAgIHNtb290aEFyZWEoZCwgYXJlYSk7XG4gICAgICByZXN1bHRbMF0gPSBhMVswXSArIGEyWzBdO1xuICAgICAgcmVzdWx0WzFdID0gYTFbMV0gKyBhMlsxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEzOiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCwgbzEsIGxlZnQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxNDoge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTU6IHtcbiAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0luc2lkZUFyZWEoYTFYLCBhMVksIGEyWCwgYTJZLCB4LCB5KSB7XG4gIGxldCByZXN1bHQgPSBhMVggPT09IGEyWCAmJiBhMVkgPT09IGEyWTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICBjb25zdCB4bSA9IChhMVggKyBhMlgpIC8gMjtcbiAgICBjb25zdCB5bSA9IChhMVkgKyBhMlkpIC8gMjtcbiAgICBjb25zdCBhID0gYTJZIC0gYTFZO1xuICAgIGNvbnN0IGIgPSBhMVggLSBhMlg7XG4gICAgY29uc3QgYzIgPSBhICogKHggLSB4bSkgKyBiICogKHkgLSB5bSk7XG4gICAgcmVzdWx0ID0gYzIgPiAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREaWFnQXJlYUZvclBpeGVsKGExWCwgYTFZLCBhMlgsIGEyWSwgcFgsIHBZKSB7XG4gIGxldCBuID0gMDtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBESUFHT05BTF9TQU1QTEVTOyArK3kpIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IERJQUdPTkFMX1NBTVBMRVM7ICsreCkge1xuICAgICAgY29uc3Qgb2Zmc2V0WCA9IHggLyAoRElBR09OQUxfU0FNUExFUyAtIDEpO1xuICAgICAgY29uc3Qgb2Zmc2V0WSA9IHkgLyAoRElBR09OQUxfU0FNUExFUyAtIDEpO1xuICAgICAgaWYgKGlzSW5zaWRlQXJlYShhMVgsIGExWSwgYTJYLCBhMlksIHBYICsgb2Zmc2V0WCwgcFkgKyBvZmZzZXRZKSkge1xuICAgICAgICArK247XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuIC8gKERJQUdPTkFMX1NBTVBMRVMgKiBESUFHT05BTF9TQU1QTEVTKTtcbn1cbmZ1bmN0aW9uIGdldERpYWdBcmVhKHBhdHRlcm4sIGExWCwgYTFZLCBhMlgsIGEyWSwgbGVmdCwgb2Zmc2V0LCByZXN1bHQpIHtcbiAgY29uc3QgZSA9IGRpYWdvbmFsRWRnZXNbcGF0dGVybl07XG4gIGNvbnN0IGUxID0gZVswXTtcbiAgY29uc3QgZTIgPSBlWzFdO1xuICBpZiAoZTEgPiAwKSB7XG4gICAgYTFYICs9IG9mZnNldFswXTtcbiAgICBhMVkgKz0gb2Zmc2V0WzFdO1xuICB9XG4gIGlmIChlMiA+IDApIHtcbiAgICBhMlggKz0gb2Zmc2V0WzBdO1xuICAgIGEyWSArPSBvZmZzZXRbMV07XG4gIH1cbiAgcmVzdWx0WzBdID0gMSAtIGdldERpYWdBcmVhRm9yUGl4ZWwoYTFYLCBhMVksIGEyWCwgYTJZLCAxICsgbGVmdCwgMCArIGxlZnQpO1xuICByZXN1bHRbMV0gPSBnZXREaWFnQXJlYUZvclBpeGVsKGExWCwgYTFZLCBhMlgsIGEyWSwgMSArIGxlZnQsIDEgKyBsZWZ0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldERpYWdBcmVhRm9yUGF0dGVybihwYXR0ZXJuLCBsZWZ0LCByaWdodCwgb2Zmc2V0LCByZXN1bHQpIHtcbiAgY29uc3QgYTEgPSBhcmVhWzBdO1xuICBjb25zdCBhMiA9IGFyZWFbMV07XG4gIGNvbnN0IGQgPSBsZWZ0ICsgcmlnaHQgKyAxO1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAwICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMCwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDM6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNDoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMCArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDU6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDAgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA2OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDc6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA4OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAwLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgOToge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEwOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAwLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTE6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMjoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMzoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDE0OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTU6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0dGVybnMocGF0dGVybnMsIG9mZnNldCwgb3J0aG9nb25hbCkge1xuICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBhdHRlcm5zLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcbiAgICBjb25zdCBkYXRhID0gcGF0dGVybi5kYXRhO1xuICAgIGNvbnN0IHNpemUgPSBwYXR0ZXJuLndpZHRoO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZTsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemU7ICsreCkge1xuICAgICAgICBpZiAob3J0aG9nb25hbCkge1xuICAgICAgICAgIGdldE9ydGhBcmVhRm9yUGF0dGVybihpLCB4LCB5LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2V0RGlhZ0FyZWFGb3JQYXR0ZXJuKGksIHgsIHksIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjMiA9ICh5ICogc2l6ZSArIHgpICogMjtcbiAgICAgICAgZGF0YVtjMl0gPSByZXN1bHRbMF0gKiAyNTU7XG4gICAgICAgIGRhdGFbYzIgKyAxXSA9IHJlc3VsdFsxXSAqIDI1NTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VtYmxlKGJhc2VYLCBiYXNlWSwgcGF0dGVybnMsIGVkZ2VzMiwgc2l6ZSwgb3J0aG9nb25hbCwgdGFyZ2V0KSB7XG4gIGNvbnN0IGRzdERhdGEgPSB0YXJnZXQuZGF0YTtcbiAgY29uc3QgZHN0V2lkdGggPSB0YXJnZXQud2lkdGg7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcGF0dGVybnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgZWRnZSA9IGVkZ2VzMltpXTtcbiAgICBjb25zdCBwYXR0ZXJuID0gcGF0dGVybnNbaV07XG4gICAgY29uc3Qgc3JjRGF0YSA9IHBhdHRlcm4uZGF0YTtcbiAgICBjb25zdCBzcmNXaWR0aCA9IHBhdHRlcm4ud2lkdGg7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplOyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZTsgKyt4KSB7XG4gICAgICAgIGNvbnN0IHBYID0gZWRnZVswXSAqIHNpemUgKyBiYXNlWCArIHg7XG4gICAgICAgIGNvbnN0IHBZID0gZWRnZVsxXSAqIHNpemUgKyBiYXNlWSArIHk7XG4gICAgICAgIGNvbnN0IGMyID0gKHBZICogZHN0V2lkdGggKyBwWCkgKiA0O1xuICAgICAgICBjb25zdCBkID0gb3J0aG9nb25hbCA/ICh5ICogeSAqIHNyY1dpZHRoICsgeCAqIHgpICogMiA6ICh5ICogc3JjV2lkdGggKyB4KSAqIDI7XG4gICAgICAgIGRzdERhdGFbYzJdID0gc3JjRGF0YVtkXTtcbiAgICAgICAgZHN0RGF0YVtjMiArIDFdID0gc3JjRGF0YVtkICsgMV07XG4gICAgICAgIGRzdERhdGFbYzIgKyAyXSA9IDA7XG4gICAgICAgIGRzdERhdGFbYzIgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBTTUFBQXJlYUltYWdlRGF0YSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYXJlYSBpbWFnZS5cbiAgICpcbiAgICogQHJldHVybiB7UmF3SW1hZ2VEYXRhfSBUaGUgZ2VuZXJhdGVkIGltYWdlIGRhdGEuXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3Qgd2lkdGggPSAyICogNSAqIE9SVEhPR09OQUxfU0laRTtcbiAgICBjb25zdCBoZWlnaHQgPSBvcnRob2dvbmFsU3Vic2FtcGxpbmdPZmZzZXRzLmxlbmd0aCAqIDUgKiBPUlRIT0dPTkFMX1NJWkU7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBSYXdJbWFnZURhdGEod2lkdGgsIGhlaWdodCwgZGF0YSk7XG4gICAgY29uc3Qgb3J0aFBhdHRlcm5TaXplID0gTWF0aC5wb3coT1JUSE9HT05BTF9TSVpFIC0gMSwgMikgKyAxO1xuICAgIGNvbnN0IGRpYWdQYXR0ZXJuU2l6ZSA9IERJQUdPTkFMX1NJWkU7XG4gICAgY29uc3Qgb3J0aG9nb25hbFBhdHRlcm5zID0gW107XG4gICAgY29uc3QgZGlhZ29uYWxQYXR0ZXJucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAzLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgIGRhdGFbaV0gPSAyNTU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgb3J0aG9nb25hbFBhdHRlcm5zLnB1c2gobmV3IFJhd0ltYWdlRGF0YShcbiAgICAgICAgb3J0aFBhdHRlcm5TaXplLFxuICAgICAgICBvcnRoUGF0dGVyblNpemUsXG4gICAgICAgIG5ldyBVaW50OENsYW1wZWRBcnJheShvcnRoUGF0dGVyblNpemUgKiBvcnRoUGF0dGVyblNpemUgKiAyKSxcbiAgICAgICAgMlxuICAgICAgKSk7XG4gICAgICBkaWFnb25hbFBhdHRlcm5zLnB1c2gobmV3IFJhd0ltYWdlRGF0YShcbiAgICAgICAgZGlhZ1BhdHRlcm5TaXplLFxuICAgICAgICBkaWFnUGF0dGVyblNpemUsXG4gICAgICAgIG5ldyBVaW50OENsYW1wZWRBcnJheShkaWFnUGF0dGVyblNpemUgKiBkaWFnUGF0dGVyblNpemUgKiAyKSxcbiAgICAgICAgMlxuICAgICAgKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3J0aG9nb25hbFN1YnNhbXBsaW5nT2Zmc2V0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGdlbmVyYXRlUGF0dGVybnMob3J0aG9nb25hbFBhdHRlcm5zLCBvcnRob2dvbmFsU3Vic2FtcGxpbmdPZmZzZXRzW2ldLCB0cnVlKTtcbiAgICAgIGFzc2VtYmxlKFxuICAgICAgICAwLFxuICAgICAgICA1ICogT1JUSE9HT05BTF9TSVpFICogaSxcbiAgICAgICAgb3J0aG9nb25hbFBhdHRlcm5zLFxuICAgICAgICBvcnRob2dvbmFsRWRnZXMsXG4gICAgICAgIE9SVEhPR09OQUxfU0laRSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgcmVzdWx0XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRpYWdvbmFsU3Vic2FtcGxpbmdPZmZzZXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgZ2VuZXJhdGVQYXR0ZXJucyhkaWFnb25hbFBhdHRlcm5zLCBkaWFnb25hbFN1YnNhbXBsaW5nT2Zmc2V0c1tpXSwgZmFsc2UpO1xuICAgICAgYXNzZW1ibGUoXG4gICAgICAgIDUgKiBPUlRIT0dPTkFMX1NJWkUsXG4gICAgICAgIDQgKiBESUFHT05BTF9TSVpFICogaSxcbiAgICAgICAgZGlhZ29uYWxQYXR0ZXJucyxcbiAgICAgICAgZGlhZ29uYWxFZGdlcyxcbiAgICAgICAgRElBR09OQUxfU0laRSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHJlc3VsdFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvU01BQUltYWdlR2VuZXJhdG9yLmpzXG5pbXBvcnQgeyBMb2FkaW5nTWFuYWdlciBhcyBMb2FkaW5nTWFuYWdlcjUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gdGVtcC9zbWFhL3dvcmtlci50eHRcbnZhciB3b3JrZXJfZGVmYXVsdDIgPSAnXCJ1c2Ugc3RyaWN0XCI7KCgpPT57ZnVuY3Rpb24gcSh0LGEscyl7bGV0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxuPWUuZ2V0Q29udGV4dChcIjJkXCIpO2lmKGUud2lkdGg9dCxlLmhlaWdodD1hLHMgaW5zdGFuY2VvZiBJbWFnZSluLmRyYXdJbWFnZShzLDAsMCk7ZWxzZXtsZXQgcj1uLmNyZWF0ZUltYWdlRGF0YSh0LGEpO3IuZGF0YS5zZXQocyksbi5wdXRJbWFnZURhdGEociwwLDApfXJldHVybiBlfXZhciBGPWNsYXNzIHR7Y29uc3RydWN0b3IoYT0wLHM9MCxlPW51bGwpe3RoaXMud2lkdGg9YSx0aGlzLmhlaWdodD1zLHRoaXMuZGF0YT1lfXRvQ2FudmFzKCl7cmV0dXJuIHR5cGVvZiBkb2N1bWVudD09XCJ1bmRlZmluZWRcIj9udWxsOnEodGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLmRhdGEpfXN0YXRpYyBmcm9tKGEpe2xldHt3aWR0aDpzLGhlaWdodDplfT1hLG47aWYoYSBpbnN0YW5jZW9mIEltYWdlKXtsZXQgcj1xKHMsZSxhKTtyIT09bnVsbCYmKG49ci5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsMCxzLGUpLmRhdGEpfWVsc2Ugbj1hLmRhdGE7cmV0dXJuIG5ldyB0KHMsZSxuKX19O3ZhciBNPVtuZXcgRmxvYXQzMkFycmF5KDIpLG5ldyBGbG9hdDMyQXJyYXkoMildLEQ9MTYsVz0yMCxJPTMwLGo9MzIsdj1uZXcgRmxvYXQzMkFycmF5KFswLC0uMjUsLjI1LC0uMTI1LC4xMjUsLS4zNzUsLjM3NV0pLE49W25ldyBGbG9hdDMyQXJyYXkoWzAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWy4yNSwtLjI1XSksbmV3IEZsb2F0MzJBcnJheShbLS4yNSwuMjVdKSxuZXcgRmxvYXQzMkFycmF5KFsuMTI1LC0uMTI1XSksbmV3IEZsb2F0MzJBcnJheShbLS4xMjUsLjEyNV0pXSx6PVtuZXcgVWludDhBcnJheShbMCwwXSksbmV3IFVpbnQ4QXJyYXkoWzMsMF0pLG5ldyBVaW50OEFycmF5KFswLDNdKSxuZXcgVWludDhBcnJheShbMywzXSksbmV3IFVpbnQ4QXJyYXkoWzEsMF0pLG5ldyBVaW50OEFycmF5KFs0LDBdKSxuZXcgVWludDhBcnJheShbMSwzXSksbmV3IFVpbnQ4QXJyYXkoWzQsM10pLG5ldyBVaW50OEFycmF5KFswLDFdKSxuZXcgVWludDhBcnJheShbMywxXSksbmV3IFVpbnQ4QXJyYXkoWzAsNF0pLG5ldyBVaW50OEFycmF5KFszLDRdKSxuZXcgVWludDhBcnJheShbMSwxXSksbmV3IFVpbnQ4QXJyYXkoWzQsMV0pLG5ldyBVaW50OEFycmF5KFsxLDRdKSxuZXcgVWludDhBcnJheShbNCw0XSldLHA9W25ldyBVaW50OEFycmF5KFswLDBdKSxuZXcgVWludDhBcnJheShbMSwwXSksbmV3IFVpbnQ4QXJyYXkoWzAsMl0pLG5ldyBVaW50OEFycmF5KFsxLDJdKSxuZXcgVWludDhBcnJheShbMiwwXSksbmV3IFVpbnQ4QXJyYXkoWzMsMF0pLG5ldyBVaW50OEFycmF5KFsyLDJdKSxuZXcgVWludDhBcnJheShbMywyXSksbmV3IFVpbnQ4QXJyYXkoWzAsMV0pLG5ldyBVaW50OEFycmF5KFsxLDFdKSxuZXcgVWludDhBcnJheShbMCwzXSksbmV3IFVpbnQ4QXJyYXkoWzEsM10pLG5ldyBVaW50OEFycmF5KFsyLDFdKSxuZXcgVWludDhBcnJheShbMywxXSksbmV3IFVpbnQ4QXJyYXkoWzIsM10pLG5ldyBVaW50OEFycmF5KFszLDNdKV07ZnVuY3Rpb24gQyh0LGEscyl7cmV0dXJuIHQrKGEtdCkqc31mdW5jdGlvbiBCKHQpe3JldHVybiBNYXRoLm1pbihNYXRoLm1heCh0LDApLDEpfWZ1bmN0aW9uIF8odCl7bGV0IGE9TVswXSxzPU1bMV0sZT1NYXRoLnNxcnQoYVswXSoyKSouNSxuPU1hdGguc3FydChhWzFdKjIpKi41LHI9TWF0aC5zcXJ0KHNbMF0qMikqLjUsbz1NYXRoLnNxcnQoc1sxXSoyKSouNSxjPUIodC9qKTthWzBdPUMoZSxhWzBdLGMpLGFbMV09QyhuLGFbMV0sYyksc1swXT1DKHIsc1swXSxjKSxzWzFdPUMobyxzWzFdLGMpfWZ1bmN0aW9uIGQodCxhLHMsZSxuLHIpe2xldCBvPXMtdCxjPWUtYSxoPW4saT1uKzEsdz1hK2MqKGgtdCkvbyxiPWErYyooaS10KS9vO2lmKGg+PXQmJmg8c3x8aT50JiZpPD1zKWlmKE1hdGguc2lnbih3KT09PU1hdGguc2lnbihiKXx8TWF0aC5hYnModyk8MWUtNHx8TWF0aC5hYnMoYik8MWUtNCl7bGV0IGc9KHcrYikvMjtnPDA/KHJbMF09TWF0aC5hYnMoZyksclsxXT0wKTooclswXT0wLHJbMV09TWF0aC5hYnMoZykpfWVsc2V7bGV0IGc9LWEqby9jK3Qsaz1NYXRoLnRydW5jKGcpLG09Zz50P3cqKGctaykvMjowLFU9ZzxzP2IqKDEtKGctaykpLzI6MDsoTWF0aC5hYnMobSk+TWF0aC5hYnMoVSk/bTotVSk8MD8oclswXT1NYXRoLmFicyhtKSxyWzFdPU1hdGguYWJzKFUpKTooclswXT1NYXRoLmFicyhVKSxyWzFdPU1hdGguYWJzKG0pKX1lbHNlIHJbMF09MCxyWzFdPTA7cmV0dXJuIHJ9ZnVuY3Rpb24gSih0LGEscyxlLG4pe2xldCByPU1bMF0sbz1NWzFdLGM9LjUrZSxoPS41K2UtMSxpPWErcysxO3N3aXRjaCh0KXtjYXNlIDA6e25bMF09MCxuWzFdPTA7YnJlYWt9Y2FzZSAxOnthPD1zP2QoMCxoLGkvMiwwLGEsbik6KG5bMF09MCxuWzFdPTApO2JyZWFrfWNhc2UgMjp7YT49cz9kKGkvMiwwLGksaCxhLG4pOihuWzBdPTAsblsxXT0wKTticmVha31jYXNlIDM6e2QoMCxoLGkvMiwwLGEsciksZChpLzIsMCxpLGgsYSxvKSxfKGksTSksblswXT1yWzBdK29bMF0sblsxXT1yWzFdK29bMV07YnJlYWt9Y2FzZSA0OnthPD1zP2QoMCxjLGkvMiwwLGEsbik6KG5bMF09MCxuWzFdPTApO2JyZWFrfWNhc2UgNTp7blswXT0wLG5bMV09MDticmVha31jYXNlIDY6e01hdGguYWJzKGUpPjA/KGQoMCxjLGksaCxhLHIpLGQoMCxjLGkvMiwwLGEsbyksZChpLzIsMCxpLGgsYSxuKSxvWzBdPW9bMF0rblswXSxvWzFdPW9bMV0rblsxXSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yKTpkKDAsYyxpLGgsYSxuKTticmVha31jYXNlIDc6e2QoMCxjLGksaCxhLG4pO2JyZWFrfWNhc2UgODp7YT49cz9kKGkvMiwwLGksYyxhLG4pOihuWzBdPTAsblsxXT0wKTticmVha31jYXNlIDk6e01hdGguYWJzKGUpPjA/KGQoMCxoLGksYyxhLHIpLGQoMCxoLGkvMiwwLGEsbyksZChpLzIsMCxpLGMsYSxuKSxvWzBdPW9bMF0rblswXSxvWzFdPW9bMV0rblsxXSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yKTpkKDAsaCxpLGMsYSxuKTticmVha31jYXNlIDEwOntuWzBdPTAsblsxXT0wO2JyZWFrfWNhc2UgMTE6e2QoMCxoLGksYyxhLG4pO2JyZWFrfWNhc2UgMTI6e2QoMCxjLGkvMiwwLGEsciksZChpLzIsMCxpLGMsYSxvKSxfKGksTSksblswXT1yWzBdK29bMF0sblsxXT1yWzFdK29bMV07YnJlYWt9Y2FzZSAxMzp7ZCgwLGgsaSxjLGEsbik7YnJlYWt9Y2FzZSAxNDp7ZCgwLGMsaSxoLGEsbik7YnJlYWt9Y2FzZSAxNTp7blswXT0wLG5bMV09MDticmVha319cmV0dXJuIG59ZnVuY3Rpb24gSyh0LGEscyxlLG4scil7bGV0IG89dD09PXMmJmE9PT1lO2lmKCFvKXtsZXQgYz0odCtzKS8yLGg9KGErZSkvMixpPWUtYSx3PXQtcztvPWkqKG4tYykrdyooci1oKT4wfXJldHVybiBvfWZ1bmN0aW9uIEcodCxhLHMsZSxuLHIpe2xldCBvPTA7Zm9yKGxldCBjPTA7YzxJOysrYylmb3IobGV0IGg9MDtoPEk7KytoKXtsZXQgaT1oLyhJLTEpLHc9Yy8oSS0xKTtLKHQsYSxzLGUsbitpLHIrdykmJisrb31yZXR1cm4gby8oSSpJKX1mdW5jdGlvbiBBKHQsYSxzLGUsbixyLG8sYyl7bGV0IGg9cFt0XSxpPWhbMF0sdz1oWzFdO3JldHVybiBpPjAmJihhKz1vWzBdLHMrPW9bMV0pLHc+MCYmKGUrPW9bMF0sbis9b1sxXSksY1swXT0xLUcoYSxzLGUsbiwxK3IsMCtyKSxjWzFdPUcoYSxzLGUsbiwxK3IsMStyKSxjfWZ1bmN0aW9uIFEodCxhLHMsZSxuKXtsZXQgcj1NWzBdLG89TVsxXSxjPWErcysxO3N3aXRjaCh0KXtjYXNlIDA6e0EodCwxLDEsMStjLDErYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgMTp7QSh0LDEsMCwwK2MsMCtjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAyOntBKHQsMCwwLDErYywwK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDM6e0EodCwxLDAsMStjLDArYyxhLGUsbik7YnJlYWt9Y2FzZSA0OntBKHQsMSwxLDArYywwK2MsYSxlLHIpLEEodCwxLDEsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDU6e0EodCwxLDEsMCtjLDArYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgNjp7QSh0LDEsMSwxK2MsMCtjLGEsZSxuKTticmVha31jYXNlIDc6e0EodCwxLDEsMStjLDArYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgODp7QSh0LDAsMCwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywxK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSA5OntBKHQsMSwwLDErYywxK2MsYSxlLG4pLEEodCwxLDAsMStjLDErYyxhLGUsbik7YnJlYWt9Y2FzZSAxMDp7QSh0LDAsMCwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAxMTp7QSh0LDEsMCwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAxMjp7QSh0LDEsMSwxK2MsMStjLGEsZSxuKTticmVha31jYXNlIDEzOntBKHQsMSwxLDErYywxK2MsYSxlLHIpLEEodCwxLDAsMStjLDErYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDE0OntBKHQsMSwxLDErYywxK2MsYSxlLHIpLEEodCwxLDEsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDE1OntBKHQsMSwxLDErYywxK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha319cmV0dXJuIG59ZnVuY3Rpb24gUih0LGEscyl7bGV0IGU9bmV3IEZsb2F0MzJBcnJheSgyKTtmb3IobGV0IG49MCxyPXQubGVuZ3RoO248cjsrK24pe2xldCBvPXRbbl0sYz1vLmRhdGEsaD1vLndpZHRoO2ZvcihsZXQgaT0wO2k8aDsrK2kpZm9yKGxldCB3PTA7dzxoOysrdyl7cz9KKG4sdyxpLGEsZSk6UShuLHcsaSxhLGUpO2xldCBiPShpKmgrdykqMjtjW2JdPWVbMF0qMjU1LGNbYisxXT1lWzFdKjI1NX19fWZ1bmN0aW9uIFQodCxhLHMsZSxuLHIsbyl7bGV0IGM9by5kYXRhLGg9by53aWR0aDtmb3IobGV0IGk9MCx3PXMubGVuZ3RoO2k8dzsrK2kpe2xldCBiPWVbaV0sZz1zW2ldLGs9Zy5kYXRhLG09Zy53aWR0aDtmb3IobGV0IFU9MDtVPG47KytVKWZvcihsZXQgeD0wO3g8bjsrK3gpe2xldCBaPWJbMF0qbit0K3gsTz0oKGJbMV0qbithK1UpKmgrWikqNCxMPXI/KFUqVSptK3gqeCkqMjooVSptK3gpKjI7Y1tPXT1rW0xdLGNbTysxXT1rW0wrMV0sY1tPKzJdPTAsY1tPKzNdPTI1NX19fXZhciBTPWNsYXNze3N0YXRpYyBnZW5lcmF0ZSgpe2xldCBhPTEwKkQscz12Lmxlbmd0aCo1KkQsZT1uZXcgVWludDhDbGFtcGVkQXJyYXkoYSpzKjQpLG49bmV3IEYoYSxzLGUpLHI9TWF0aC5wb3coRC0xLDIpKzEsbz1XLGM9W10saD1bXTtmb3IobGV0IGk9Myx3PWUubGVuZ3RoO2k8dztpKz00KWVbaV09MjU1O2ZvcihsZXQgaT0wO2k8MTY7KytpKWMucHVzaChuZXcgRihyLHIsbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHIqcioyKSwyKSksaC5wdXNoKG5ldyBGKG8sbyxuZXcgVWludDhDbGFtcGVkQXJyYXkobypvKjIpLDIpKTtmb3IobGV0IGk9MCx3PXYubGVuZ3RoO2k8dzsrK2kpUihjLHZbaV0sITApLFQoMCw1KkQqaSxjLHosRCwhMCxuKTtmb3IobGV0IGk9MCx3PU4ubGVuZ3RoO2k8dzsrK2kpUihoLE5baV0sITEpLFQoNSpELDQqVyppLGgscCxXLCExLG4pO3JldHVybiBufX07dmFyIFA9bmV3IE1hcChbW3koMCwwLDAsMCksbmV3IEZsb2F0MzJBcnJheShbMCwwLDAsMF0pXSxbeSgwLDAsMCwxKSxuZXcgRmxvYXQzMkFycmF5KFswLDAsMCwxXSldLFt5KDAsMCwxLDApLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwxLDBdKV0sW3koMCwwLDEsMSksbmV3IEZsb2F0MzJBcnJheShbMCwwLDEsMV0pXSxbeSgwLDEsMCwwKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMCwwXSldLFt5KDAsMSwwLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwwLDFdKV0sW3koMCwxLDEsMCksbmV3IEZsb2F0MzJBcnJheShbMCwxLDEsMF0pXSxbeSgwLDEsMSwxKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMSwxXSldLFt5KDEsMCwwLDApLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwLDBdKV0sW3koMSwwLDAsMSksbmV3IEZsb2F0MzJBcnJheShbMSwwLDAsMV0pXSxbeSgxLDAsMSwwKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMSwwXSldLFt5KDEsMCwxLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwxLDFdKV0sW3koMSwxLDAsMCksbmV3IEZsb2F0MzJBcnJheShbMSwxLDAsMF0pXSxbeSgxLDEsMCwxKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMCwxXSldLFt5KDEsMSwxLDApLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxLDBdKV0sW3koMSwxLDEsMSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDEsMV0pXV0pO2Z1bmN0aW9uIEgodCxhLHMpe3JldHVybiB0KyhhLXQpKnN9ZnVuY3Rpb24geSh0LGEscyxlKXtsZXQgbj1IKHQsYSwuNzUpLHI9SChzLGUsMS0uMjUpO3JldHVybiBIKG4sciwxLS4xMjUpfWZ1bmN0aW9uIFYodCxhKXtsZXQgcz0wO3JldHVybiBhWzNdPT09MSYmKHMrPTEpLHM9PT0xJiZhWzJdPT09MSYmdFsxXSE9PTEmJnRbM10hPT0xJiYocys9MSksc31mdW5jdGlvbiAkKHQsYSl7bGV0IHM9MDtyZXR1cm4gYVszXT09PTEmJnRbMV0hPT0xJiZ0WzNdIT09MSYmKHMrPTEpLHM9PT0xJiZhWzJdPT09MSYmdFswXSE9PTEmJnRbMl0hPT0xJiYocys9MSksc312YXIgRT1jbGFzc3tzdGF0aWMgZ2VuZXJhdGUoKXtsZXQgbz1uZXcgVWludDhDbGFtcGVkQXJyYXkoMjE3OCksYz1uZXcgVWludDhDbGFtcGVkQXJyYXkoMTAyNCo0KTtmb3IobGV0IGg9MDtoPDMzOysraClmb3IobGV0IGk9MDtpPDY2OysraSl7bGV0IHc9LjAzMTI1KmksYj0uMDMxMjUqaDtpZihQLmhhcyh3KSYmUC5oYXMoYikpe2xldCBnPVAuZ2V0KHcpLGs9UC5nZXQoYiksbT1oKjY2K2k7b1ttXT0xMjcqVihnLGspLG9bbSszM109MTI3KiQoZyxrKX19Zm9yKGxldCBoPTAsaT0xNztpPDMzOysraSlmb3IobGV0IHc9MDt3PDY0OysrdyxoKz00KWNbaF09b1tpKjY2K3ddLGNbaCszXT0yNTU7cmV0dXJuIG5ldyBGKDY0LDE2LGMpfX07c2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHQ9PntsZXQgYT1TLmdlbmVyYXRlKCkscz1FLmdlbmVyYXRlKCk7cG9zdE1lc3NhZ2Uoe2FyZWFJbWFnZURhdGE6YSxzZWFyY2hJbWFnZURhdGE6c30sW2EuZGF0YS5idWZmZXIscy5kYXRhLmJ1ZmZlcl0pLGNsb3NlKCl9KTt9KSgpO1xcbic7XG5cbi8vIHNyYy90ZXh0dXJlcy9zbWFhL1NNQUFJbWFnZUdlbmVyYXRvci5qc1xuZnVuY3Rpb24gZ2VuZXJhdGUodXNlQ2FjaGUgPSB0cnVlKSB7XG4gIGNvbnN0IHdvcmtlclVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dvcmtlcl9kZWZhdWx0Ml0sIHtcbiAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiXG4gIH0pKTtcbiAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVUkwpO1xuICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHJlamVjdChldmVudC5lcnJvcikpO1xuICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlYXJjaEltYWdlRGF0YSA9IFJhd0ltYWdlRGF0YS5mcm9tKGV2ZW50LmRhdGEuc2VhcmNoSW1hZ2VEYXRhKTtcbiAgICAgIGNvbnN0IGFyZWFJbWFnZURhdGEgPSBSYXdJbWFnZURhdGEuZnJvbShldmVudC5kYXRhLmFyZWFJbWFnZURhdGEpO1xuICAgICAgY29uc3QgdXJscyA9IFtcbiAgICAgICAgc2VhcmNoSW1hZ2VEYXRhLnRvQ2FudmFzKCkudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIsIDEpLFxuICAgICAgICBhcmVhSW1hZ2VEYXRhLnRvQ2FudmFzKCkudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIsIDEpXG4gICAgICBdO1xuICAgICAgaWYgKHVzZUNhY2hlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic21hYS1zZWFyY2hcIiwgdXJsc1swXSk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic21hYS1hcmVhXCIsIHVybHNbMV0pO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSh1cmxzKTtcbiAgICB9KTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH0pO1xufVxudmFyIFNNQUFJbWFnZUdlbmVyYXRvciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgU01BQSBpbWFnZSBnZW5lcmF0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRpc2FibGVDYWNoZSA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGNhY2hpbmcgdmlhIGxvY2FsU3RvcmFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIGNhY2hlIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0Q2FjaGVFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5kaXNhYmxlQ2FjaGUgPSAhdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgU01BQSBkYXRhIGltYWdlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogU01BQUltYWdlR2VuZXJhdG9yLmdlbmVyYXRlKCkudGhlbigoW3NlYXJjaCwgYXJlYV0pID0+IHtcbiAgICogICBjb25zdCBzbWFhRWZmZWN0ID0gbmV3IFNNQUFFZmZlY3Qoc2VhcmNoLCBhcmVhKTtcbiAgICogfSk7XG4gICAqIEByZXR1cm4ge1Byb21pc2U8SW1hZ2VbXT59IEEgcHJvbWlzZSB0aGF0IHJldHVybnMgdGhlIHNlYXJjaCBpbWFnZSBhbmQgYXJlYSBpbWFnZSBhcyBhIHBhaXIuXG4gICAqL1xuICBnZW5lcmF0ZSgpIHtcbiAgICBjb25zdCB1c2VDYWNoZSA9ICF0aGlzLmRpc2FibGVDYWNoZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlICE9PSB2b2lkIDA7XG4gICAgY29uc3QgY2FjaGVkVVJMcyA9IHVzZUNhY2hlID8gW1xuICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzbWFhLXNlYXJjaFwiKSxcbiAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic21hYS1hcmVhXCIpXG4gICAgXSA6IFtudWxsLCBudWxsXTtcbiAgICBjb25zdCBwcm9taXNlID0gY2FjaGVkVVJMc1swXSAhPT0gbnVsbCAmJiBjYWNoZWRVUkxzWzFdICE9PSBudWxsID8gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFVSTHMpIDogZ2VuZXJhdGUodXNlQ2FjaGUpO1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHVybHMpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNlYXJjaEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IGFyZWFJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyNSgpO1xuICAgICAgICBtYW5hZ2VyLm9uTG9hZCA9ICgpID0+IHJlc29sdmUoW3NlYXJjaEltYWdlLCBhcmVhSW1hZ2VdKTtcbiAgICAgICAgbWFuYWdlci5vbkVycm9yID0gcmVqZWN0O1xuICAgICAgICBzZWFyY2hJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IG1hbmFnZXIuaXRlbUVycm9yKFwic21hYS1zZWFyY2hcIikpO1xuICAgICAgICBhcmVhSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiBtYW5hZ2VyLml0ZW1FcnJvcihcInNtYWEtYXJlYVwiKSk7XG4gICAgICAgIHNlYXJjaEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IG1hbmFnZXIuaXRlbUVuZChcInNtYWEtc2VhcmNoXCIpKTtcbiAgICAgICAgYXJlYUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IG1hbmFnZXIuaXRlbUVuZChcInNtYWEtYXJlYVwiKSk7XG4gICAgICAgIG1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1zZWFyY2hcIik7XG4gICAgICAgIG1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1hcmVhXCIpO1xuICAgICAgICBzZWFyY2hJbWFnZS5zcmMgPSB1cmxzWzBdO1xuICAgICAgICBhcmVhSW1hZ2Uuc3JjID0gdXJsc1sxXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdGV4dHVyZXMvc21hYS9TTUFBU2VhcmNoSW1hZ2VEYXRhLmpzXG52YXIgZWRnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtiaWxpbmVhcigwLCAwLCAwLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMF0pXSxcbiAgW2JpbGluZWFyKDAsIDAsIDAsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxXSldLFxuICBbYmlsaW5lYXIoMCwgMCwgMSwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDBdKV0sXG4gIFtiaWxpbmVhcigwLCAwLCAxLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMV0pXSxcbiAgW2JpbGluZWFyKDAsIDEsIDAsIDApLCBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwLCAwXSldLFxuICBbYmlsaW5lYXIoMCwgMSwgMCwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDAsIDFdKV0sXG4gIFtiaWxpbmVhcigwLCAxLCAxLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMF0pXSxcbiAgW2JpbGluZWFyKDAsIDEsIDEsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAxLCAxXSldLFxuICBbYmlsaW5lYXIoMSwgMCwgMCwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDBdKV0sXG4gIFtiaWxpbmVhcigxLCAwLCAwLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMV0pXSxcbiAgW2JpbGluZWFyKDEsIDAsIDEsIDApLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAxLCAwXSldLFxuICBbYmlsaW5lYXIoMSwgMCwgMSwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDEsIDFdKV0sXG4gIFtiaWxpbmVhcigxLCAxLCAwLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMCwgMF0pXSxcbiAgW2JpbGluZWFyKDEsIDEsIDAsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwLCAxXSldLFxuICBbYmlsaW5lYXIoMSwgMSwgMSwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDBdKV0sXG4gIFtiaWxpbmVhcigxLCAxLCAxLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pXVxuXSk7XG5mdW5jdGlvbiBsZXJwMihhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5mdW5jdGlvbiBiaWxpbmVhcihlMCwgZTEsIGUyLCBlMykge1xuICBjb25zdCBhID0gbGVycDIoZTAsIGUxLCAxIC0gMC4yNSk7XG4gIGNvbnN0IGIgPSBsZXJwMihlMiwgZTMsIDEgLSAwLjI1KTtcbiAgcmV0dXJuIGxlcnAyKGEsIGIsIDEgLSAwLjEyNSk7XG59XG5mdW5jdGlvbiBkZWx0YUxlZnQobGVmdCwgdG9wKSB7XG4gIGxldCBkID0gMDtcbiAgaWYgKHRvcFszXSA9PT0gMSkge1xuICAgIGQgKz0gMTtcbiAgfVxuICBpZiAoZCA9PT0gMSAmJiB0b3BbMl0gPT09IDEgJiYgbGVmdFsxXSAhPT0gMSAmJiBsZWZ0WzNdICE9PSAxKSB7XG4gICAgZCArPSAxO1xuICB9XG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gZGVsdGFSaWdodChsZWZ0LCB0b3ApIHtcbiAgbGV0IGQgPSAwO1xuICBpZiAodG9wWzNdID09PSAxICYmIGxlZnRbMV0gIT09IDEgJiYgbGVmdFszXSAhPT0gMSkge1xuICAgIGQgKz0gMTtcbiAgfVxuICBpZiAoZCA9PT0gMSAmJiB0b3BbMl0gPT09IDEgJiYgbGVmdFswXSAhPT0gMSAmJiBsZWZ0WzJdICE9PSAxKSB7XG4gICAgZCArPSAxO1xuICB9XG4gIHJldHVybiBkO1xufVxudmFyIFNNQUFTZWFyY2hJbWFnZURhdGEgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHNlYXJjaCBpbWFnZS5cbiAgICpcbiAgICogQHJldHVybiB7UmF3SW1hZ2VEYXRhfSBUaGUgZ2VuZXJhdGVkIGltYWdlIGRhdGEuXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3Qgd2lkdGggPSA2NjtcbiAgICBjb25zdCBoZWlnaHQgPSAzMztcbiAgICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgY29uc3QgY3JvcHBlZFdpZHRoID0gNjQ7XG4gICAgY29uc3QgY3JvcHBlZEhlaWdodCA9IDE2O1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgIGNvbnN0IGNyb3BwZWREYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGNyb3BwZWRXaWR0aCAqIGNyb3BwZWRIZWlnaHQgKiA0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgcyA9IDAuMDMxMjUgKiB4O1xuICAgICAgICBjb25zdCB0ID0gMC4wMzEyNSAqIHk7XG4gICAgICAgIGlmIChlZGdlcy5oYXMocykgJiYgZWRnZXMuaGFzKHQpKSB7XG4gICAgICAgICAgY29uc3QgZTEgPSBlZGdlcy5nZXQocyk7XG4gICAgICAgICAgY29uc3QgZTIgPSBlZGdlcy5nZXQodCk7XG4gICAgICAgICAgY29uc3QgaSA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgZGF0YVtpXSA9IDEyNyAqIGRlbHRhTGVmdChlMSwgZTIpO1xuICAgICAgICAgIGRhdGFbaSArIGhhbGZXaWR0aF0gPSAxMjcgKiBkZWx0YVJpZ2h0KGUxLCBlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIHkgPSBoZWlnaHQgLSBjcm9wcGVkSGVpZ2h0OyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY3JvcHBlZFdpZHRoOyArK3gsIGkgKz0gNCkge1xuICAgICAgICBjcm9wcGVkRGF0YVtpXSA9IGRhdGFbeSAqIHdpZHRoICsgeF07XG4gICAgICAgIGNyb3BwZWREYXRhW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSYXdJbWFnZURhdGEoY3JvcHBlZFdpZHRoLCBjcm9wcGVkSGVpZ2h0LCBjcm9wcGVkRGF0YSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBBU0NJSUVmZmVjdCxcbiAgQVNDSUlUZXh0dXJlLFxuICBBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLFxuICBBZGFwdGl2ZUx1bWluYW5jZVBhc3MsXG4gIEJsZW5kRnVuY3Rpb24sXG4gIEJsZW5kTW9kZSxcbiAgQmxvb21FZmZlY3QsXG4gIEthd2FzZUJsdXJQYXNzIGFzIEJsdXJQYXNzLFxuICBCb2tlaEVmZmVjdCxcbiAgQm9rZWhNYXRlcmlhbCxcbiAgQm94Qmx1ck1hdGVyaWFsLFxuICBCb3hCbHVyUGFzcyxcbiAgQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0LFxuICBDaHJvbWF0aWNBYmVycmF0aW9uRWZmZWN0LFxuICBDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsLFxuICBDbGVhck1hc2tQYXNzLFxuICBDbGVhclBhc3MsXG4gIENvbG9yQXZlcmFnZUVmZmVjdCxcbiAgQ29sb3JDaGFubmVsLFxuICBDb2xvckRlcHRoRWZmZWN0LFxuICBFZGdlRGV0ZWN0aW9uTWF0ZXJpYWwgYXMgQ29sb3JFZGdlc01hdGVyaWFsLFxuICBLYXdhc2VCbHVyTWF0ZXJpYWwgYXMgQ29udm9sdXRpb25NYXRlcmlhbCxcbiAgQ29weU1hdGVyaWFsLFxuICBDb3B5UGFzcyxcbiAgRGVwdGhDb21wYXJpc29uTWF0ZXJpYWwsXG4gIERlcHRoQ29weU1hdGVyaWFsLFxuICBEZXB0aENvcHlNb2RlLFxuICBEZXB0aENvcHlQYXNzLFxuICBEZXB0aERvd25zYW1wbGluZ01hdGVyaWFsLFxuICBEZXB0aERvd25zYW1wbGluZ1Bhc3MsXG4gIERlcHRoRWZmZWN0LFxuICBEZXB0aE1hc2tNYXRlcmlhbCxcbiAgRGVwdGhPZkZpZWxkRWZmZWN0LFxuICBEZXB0aFBhc3MsXG4gIERlcHRoUGlja2luZ1Bhc3MsXG4gIERlcHRoQ29weVBhc3MgYXMgRGVwdGhTYXZlUGFzcyxcbiAgRGVwdGhUZXN0U3RyYXRlZ3ksXG4gIERpc3Bvc2FibGUsXG4gIERvdFNjcmVlbkVmZmVjdCxcbiAgRG93bnNhbXBsaW5nTWF0ZXJpYWwsXG4gIEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCxcbiAgRWRnZURldGVjdGlvbk1vZGUsXG4gIEVmZmVjdCxcbiAgRWZmZWN0QXR0cmlidXRlLFxuICBFZmZlY3RDb21wb3NlcixcbiAgRWZmZWN0TWF0ZXJpYWwsXG4gIEVmZmVjdFBhc3MsXG4gIEVmZmVjdFNoYWRlckRhdGEsXG4gIEVmZmVjdFNoYWRlclNlY3Rpb24sXG4gIEZYQUFFZmZlY3QsXG4gIEdhbW1hQ29ycmVjdGlvbkVmZmVjdCxcbiAgR2F1c3NLZXJuZWwsXG4gIEdhdXNzaWFuQmx1ck1hdGVyaWFsLFxuICBHYXVzc2lhbkJsdXJQYXNzLFxuICBHbGl0Y2hFZmZlY3QsXG4gIEdsaXRjaE1vZGUsXG4gIEdvZFJheXNFZmZlY3QsXG4gIEdvZFJheXNNYXRlcmlhbCxcbiAgR3JpZEVmZmVjdCxcbiAgSHVlU2F0dXJhdGlvbkVmZmVjdCxcbiAgSW1tdXRhYmxlVGltZXIsXG4gIEluaXRpYWxpemFibGUsXG4gIEthd2FzZUJsdXJNYXRlcmlhbCxcbiAgS2F3YXNlQmx1clBhc3MsXG4gIEtlcm5lbFNpemUsXG4gIExVVDFERWZmZWN0LFxuICBMVVQzREVmZmVjdCxcbiAgTFVUM2RsTG9hZGVyLFxuICBMVVRDdWJlTG9hZGVyLFxuICBMVVQzREVmZmVjdCBhcyBMVVRFZmZlY3QsXG4gIExVVE9wZXJhdGlvbixcbiAgTGFtYmRhUGFzcyxcbiAgTGVuc0Rpc3RvcnRpb25FZmZlY3QsXG4gIExvb2t1cFRleHR1cmUsXG4gIExvb2t1cFRleHR1cmUgYXMgTG9va3VwVGV4dHVyZTNELFxuICBMdW1pbmFuY2VNYXRlcmlhbCxcbiAgTHVtaW5hbmNlUGFzcyxcbiAgTWFza0Z1bmN0aW9uLFxuICBNYXNrTWF0ZXJpYWwsXG4gIE1hc2tQYXNzLFxuICBNaXBtYXBCbHVyUGFzcyxcbiAgTm9pc2VFZmZlY3QsXG4gIE5vaXNlVGV4dHVyZSxcbiAgTm9ybWFsUGFzcyxcbiAgT3V0bGluZU1hdGVyaWFsIGFzIE91dGxpbmVFZGdlc01hdGVyaWFsLFxuICBPdXRsaW5lRWZmZWN0LFxuICBPdXRsaW5lTWF0ZXJpYWwsXG4gIE92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyLFxuICBQYXNzLFxuICBQaXhlbGF0aW9uRWZmZWN0LFxuICBQcmVkaWNhdGlvbk1vZGUsXG4gIFJhd0ltYWdlRGF0YSxcbiAgUmVhbGlzdGljQm9rZWhFZmZlY3QsXG4gIFJlbmRlclBhc3MsXG4gIFJlc2l6YWJsZSxcbiAgUmVzb2x1dGlvbiBhcyBSZXNpemVyLFxuICBSZXNvbHV0aW9uLFxuICBTTUFBQXJlYUltYWdlRGF0YSxcbiAgU01BQUVmZmVjdCxcbiAgU01BQUltYWdlR2VuZXJhdG9yLFxuICBTTUFBSW1hZ2VMb2FkZXIsXG4gIFNNQUFQcmVzZXQsXG4gIFNNQUFTZWFyY2hJbWFnZURhdGEsXG4gIFNNQUFXZWlnaHRzTWF0ZXJpYWwsXG4gIFNTQU9FZmZlY3QsXG4gIFNTQU9NYXRlcmlhbCxcbiAgQ29weVBhc3MgYXMgU2F2ZVBhc3MsXG4gIFNjYW5saW5lRWZmZWN0LFxuICBFZmZlY3RTaGFkZXJTZWN0aW9uIGFzIFNlY3Rpb24sXG4gIFNlbGVjdGlvbixcbiAgU2VsZWN0aXZlQmxvb21FZmZlY3QsXG4gIFNlcGlhRWZmZWN0LFxuICBTaGFkZXJQYXNzLFxuICBTaG9ja1dhdmVFZmZlY3QsXG4gIFRldHJhaGVkcmFsVXBzY2FsZXIsXG4gIFRleHR1cmVFZmZlY3QsXG4gIFRpbHRTaGlmdEJsdXJNYXRlcmlhbCxcbiAgVGlsdFNoaWZ0Qmx1clBhc3MsXG4gIFRpbHRTaGlmdEVmZmVjdCxcbiAgVGltZXIsXG4gIFRvbmVNYXBwaW5nRWZmZWN0LFxuICBUb25lTWFwcGluZ01vZGUsXG4gIFVwc2FtcGxpbmdNYXRlcmlhbCxcbiAgVmlnbmV0dGVFZmZlY3QsXG4gIFZpZ25ldHRlVGVjaG5pcXVlLFxuICBXZWJHTEV4dGVuc2lvbixcbiAgdmVyc2lvblxufTtcbiJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiRGlzcG9zYWJsZSIsImRpc3Bvc2UiLCJEZXB0aFN0ZW5jaWxGb3JtYXQiLCJEZXB0aFRleHR1cmUiLCJMaW5lYXJGaWx0ZXIiLCJMaW5lYXJGaWx0ZXIyIiwiU1JHQkNvbG9yU3BhY2UiLCJTUkdCQ29sb3JTcGFjZTIiLCJVbnNpZ25lZEJ5dGVUeXBlIiwiVW5zaWduZWRCeXRlVHlwZTIiLCJVbnNpZ25lZEludFR5cGUiLCJVbnNpZ25lZEludDI0OFR5cGUiLCJWZWN0b3IyIiwiV2ViR0xSZW5kZXJUYXJnZXQiLCJXZWJHTFJlbmRlclRhcmdldDMiLCJNSUxMSVNFQ09ORFNfVE9fU0VDT05EUyIsIlNFQ09ORFNfVE9fTUlMTElTRUNPTkRTIiwiVGltZXIiLCJjb25zdHJ1Y3RvciIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwicHJldmlvdXNUaW1lIiwiY3VycmVudFRpbWUiLCJfZGVsdGEiLCJfZWxhcHNlZCIsIl9maXhlZERlbHRhIiwidGltZXNjYWxlIiwidXNlRml4ZWREZWx0YSIsIl9hdXRvUmVzZXQiLCJhdXRvUmVzZXQiLCJ2YWx1ZSIsImRvY3VtZW50IiwiaGlkZGVuIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWx0YSIsImZpeGVkRGVsdGEiLCJlbGFwc2VkIiwidXBkYXRlIiwidGltZXN0YW1wIiwicmVzZXQiLCJnZXREZWx0YSIsImdldEVsYXBzZWQiLCJoYW5kbGVFdmVudCIsImUiLCJCYXNpY0RlcHRoUGFja2luZyIsIkJ1ZmZlckF0dHJpYnV0ZSIsIkJ1ZmZlckdlb21ldHJ5IiwiQ2FtZXJhIiwiTWF0ZXJpYWwiLCJNZXNoIiwiU2NlbmUiLCJUZXh0dXJlIiwiZnVsbHNjcmVlbkdlb21ldHJ5IiwidmVydGljZXMiLCJGbG9hdDMyQXJyYXkiLCJ1dnMiLCJnZW9tZXRyeSIsInNldEF0dHJpYnV0ZSIsIlBhc3MiLCJfUGFzcyIsIm5hbWUiLCJzY2VuZSIsImNhbWVyYSIsInJlbmRlcmVyIiwic2NyZWVuIiwicnR0IiwibmVlZHNTd2FwIiwibmVlZHNEZXB0aFRleHR1cmUiLCJlbmFibGVkIiwicmVuZGVyVG9TY3JlZW4iLCJtYXRlcmlhbCIsImZ1bGxzY3JlZW5NYXRlcmlhbCIsIm5lZWRzVXBkYXRlIiwibWFpblNjZW5lIiwibWFpbkNhbWVyYSIsInNldFJlbmRlcmVyIiwiaXNFbmFibGVkIiwic2V0RW5hYmxlZCIsImZydXN0dW1DdWxsZWQiLCJhZGQiLCJnZXRGdWxsc2NyZWVuTWF0ZXJpYWwiLCJzZXRGdWxsc2NyZWVuTWF0ZXJpYWwiLCJnZXREZXB0aFRleHR1cmUiLCJzZXREZXB0aFRleHR1cmUiLCJkZXB0aFRleHR1cmUiLCJkZXB0aFBhY2tpbmciLCJyZW5kZXIiLCJpbnB1dEJ1ZmZlciIsIm91dHB1dEJ1ZmZlciIsImRlbHRhVGltZSIsInN0ZW5jaWxUZXN0IiwiRXJyb3IiLCJzZXRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJpbml0aWFsaXplIiwiYWxwaGEiLCJmcmFtZUJ1ZmZlclR5cGUiLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwicHJvcGVydHkiLCJpc0Rpc3Bvc2FibGUiLCJDbGVhck1hc2tQYXNzIiwic3RlbmNpbCIsInN0YXRlIiwiYnVmZmVycyIsInNldExvY2tlZCIsInNldFRlc3QiLCJXZWJHTFJlbmRlclRhcmdldDIiLCJOb0JsZW5kaW5nIiwiU2hhZGVyTWF0ZXJpYWwiLCJVbmlmb3JtIiwiY29weV9kZWZhdWx0IiwiY29tbW9uX2RlZmF1bHQiLCJDb3B5TWF0ZXJpYWwiLCJ1bmlmb3JtcyIsIm9wYWNpdHkiLCJibGVuZGluZyIsInRvbmVNYXBwZWQiLCJkZXB0aFdyaXRlIiwiZGVwdGhUZXN0IiwiZnJhZ21lbnRTaGFkZXIiLCJ2ZXJ0ZXhTaGFkZXIiLCJzZXRJbnB1dEJ1ZmZlciIsImdldE9wYWNpdHkiLCJzZXRPcGFjaXR5IiwiQ29weVBhc3MiLCJyZW5kZXJUYXJnZXQiLCJhdXRvUmVzaXplIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwic3RlbmNpbEJ1ZmZlciIsImRlcHRoQnVmZmVyIiwidGV4dHVyZSIsInJlc2l6ZSIsImdldFRleHR1cmUiLCJzZXRBdXRvUmVzaXplRW5hYmxlZCIsInNldFJlbmRlclRhcmdldCIsInR5cGUiLCJkZWZpbmVzIiwiRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0giLCJvdXRwdXRDb2xvclNwYWNlIiwiY29sb3JTcGFjZSIsIkNvbG9yIiwiY29sb3IiLCJDbGVhclBhc3MiLCJjb2xvcjIiLCJkZXB0aCIsIm92ZXJyaWRlQ2xlYXJDb2xvciIsIm92ZXJyaWRlQ2xlYXJBbHBoYSIsInNldENsZWFyRmxhZ3MiLCJnZXRPdmVycmlkZUNsZWFyQ29sb3IiLCJzZXRPdmVycmlkZUNsZWFyQ29sb3IiLCJnZXRPdmVycmlkZUNsZWFyQWxwaGEiLCJzZXRPdmVycmlkZUNsZWFyQWxwaGEiLCJjbGVhckFscGhhIiwiZ2V0Q2xlYXJBbHBoYSIsImhhc092ZXJyaWRlQ2xlYXJDb2xvciIsImhhc092ZXJyaWRlQ2xlYXJBbHBoYSIsImdldENsZWFyQ29sb3IiLCJzZXRDbGVhckNvbG9yIiwic2V0Q2xlYXJBbHBoYSIsImNsZWFyIiwiTWFza1Bhc3MiLCJjbGVhclBhc3MiLCJpbnZlcnNlIiwiaW52ZXJ0ZWQiLCJnZXRDbGVhclBhc3MiLCJpc0ludmVydGVkIiwic2V0SW52ZXJ0ZWQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsIndyaXRlVmFsdWUiLCJjbGVhclZhbHVlIiwic2V0TWFzayIsInNldE9wIiwiUkVQTEFDRSIsInNldEZ1bmMiLCJBTFdBWVMiLCJzZXRDbGVhciIsIkVRVUFMIiwiS0VFUCIsIkVmZmVjdENvbXBvc2VyIiwibXVsdGlzYW1wbGluZyIsImNyZWF0ZUJ1ZmZlciIsImNsb25lIiwiY29weVBhc3MiLCJwYXNzZXMiLCJ0aW1lciIsImF1dG9SZW5kZXJUb1NjcmVlbiIsInNhbXBsZXMiLCJidWZmZXIiLCJnZXRUaW1lciIsImdldFJlbmRlcmVyIiwic2l6ZSIsImdldFNpemUiLCJnZXRDb250ZXh0QXR0cmlidXRlcyIsImF1dG9DbGVhciIsInBhc3MiLCJyZXBsYWNlUmVuZGVyZXIiLCJ1cGRhdGVET00iLCJvbGRSZW5kZXJlciIsInBhcmVudCIsImRvbUVsZW1lbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZURlcHRoVGV4dHVyZSIsImZvcm1hdCIsImRlbGV0ZURlcHRoVGV4dHVyZSIsImdldERyYXdpbmdCdWZmZXJTaXplIiwib3B0aW9ucyIsImlnbm9yZURlcHRoRm9yTXVsdGlzYW1wbGVDb3B5IiwiZ2VuZXJhdGVNaXBtYXBzIiwic2V0TWFpblNjZW5lIiwic2V0TWFpbkNhbWVyYSIsImFkZFBhc3MiLCJpbmRleCIsImRyYXdpbmdCdWZmZXJTaXplIiwibGVuZ3RoIiwic3BsaWNlIiwicHVzaCIsInJlbW92ZVBhc3MiLCJpbmRleE9mIiwiZXhpc3RzIiwicmVtb3ZlZCIsInJlZHVjZXIiLCJhIiwiYiIsImRlcHRoVGV4dHVyZVJlcXVpcmVkIiwicmVkdWNlIiwicmVtb3ZlQWxsUGFzc2VzIiwiTk9URVFVQUwiLCJ1cGRhdGVTdHlsZSIsImN1cnJlbnRTaXplIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJFZmZlY3RBdHRyaWJ1dGUiLCJOT05FIiwiREVQVEgiLCJDT05WT0xVVElPTiIsIkVmZmVjdFNoYWRlclNlY3Rpb24iLCJGUkFHTUVOVF9IRUFEIiwiRlJBR01FTlRfTUFJTl9VViIsIkZSQUdNRU5UX01BSU5fSU1BR0UiLCJWRVJURVhfSEVBRCIsIlZFUlRFWF9NQUlOX1NVUFBPUlQiLCJFZmZlY3RTaGFkZXJEYXRhIiwic2hhZGVyUGFydHMiLCJNYXAiLCJibGVuZE1vZGVzIiwiZXh0ZW5zaW9ucyIsIlNldCIsImF0dHJpYnV0ZXMiLCJ2YXJ5aW5ncyIsInV2VHJhbnNmb3JtYXRpb24iLCJyZWFkRGVwdGgiLCJnZXRDb2VmZmljaWVudHMiLCJuIiwicmVzdWx0IiwiRmxvYXQ2NEFycmF5Iiwicm93MCIsInJvdzEiLCJ5IiwieCIsIkdhdXNzS2VybmVsIiwia2VybmVsU2l6ZSIsImVkZ2VCaWFzIiwid2VpZ2h0cyIsIm9mZnNldHMiLCJsaW5lYXJXZWlnaHRzIiwibGluZWFyT2Zmc2V0cyIsImdlbmVyYXRlIiwic3RlcHMiLCJsaW5lYXJTdGVwcyIsImNvZWZmaWNpZW50cyIsInNsaWNlIiwibWlkIiwiTWF0aCIsImZsb29yIiwic3VtIiwiQXJyYXkiLCJpIiwiaiIsImwiLCJvZmZzZXQwIiwib2Zmc2V0MSIsIndlaWdodDAiLCJ3ZWlnaHQxIiwidyIsIm8iLCJzIiwibGluZWFyV2VpZ2h0U3VtIiwiSW1tdXRhYmxlVGltZXIiLCJOYU4iLCJJbml0aWFsaXphYmxlIiwiQmFja1NpZGUiLCJEb3VibGVTaWRlIiwiRnJvbnRTaWRlIiwiU2hhZGVyTWF0ZXJpYWwyIiwid29ya2Fyb3VuZEVuYWJsZWQiLCJPdmVycmlkZU1hdGVyaWFsTWFuYWdlciIsIm9yaWdpbmFsTWF0ZXJpYWxzIiwibWF0ZXJpYWxzIiwibWF0ZXJpYWxzQmFja1NpZGUiLCJtYXRlcmlhbHNEb3VibGVTaWRlIiwibWF0ZXJpYWxzRmxhdFNoYWRlZCIsIm1hdGVyaWFsc0ZsYXRTaGFkZWRCYWNrU2lkZSIsIm1hdGVyaWFsc0ZsYXRTaGFkZWREb3VibGVTaWRlIiwic2V0TWF0ZXJpYWwiLCJtZXNoQ291bnQiLCJyZXBsYWNlTWF0ZXJpYWwiLCJub2RlIiwiaXNNZXNoIiwiZmxhdFNoYWRpbmciLCJzaWRlIiwic2V0IiwiaXNTa2lubmVkTWVzaCIsImlzSW5zdGFuY2VkTWVzaCIsImNsb25lTWF0ZXJpYWwiLCJ0ZXh0dXJlVW5pZm9ybXMiLCJpc1JlbmRlclRhcmdldFRleHR1cmUiLCJlbnRyeSIsImRpc3Bvc2VNYXRlcmlhbHMiLCJtMiIsImFzc2lnbiIsInNraW5uaW5nIiwibWFwIiwiYzIiLCJzaGFkb3dNYXBFbmFibGVkIiwic2hhZG93TWFwIiwidHJhdmVyc2UiLCJvdmVycmlkZU1hdGVyaWFsIiwiY29uY2F0IiwiUmVzaXphYmxlIiwiRXZlbnREaXNwYXRjaGVyIiwiVmVjdG9yMjIiLCJBVVRPX1NJWkUiLCJSZXNvbHV0aW9uIiwicmVzaXphYmxlIiwic2NhbGUiLCJiYXNlU2l6ZSIsInByZWZlcnJlZFNpemUiLCJ0YXJnZXQiLCJlZmZlY3RpdmVTaXplIiwidXBkYXRlRWZmZWN0aXZlU2l6ZSIsImJhc2UiLCJwcmVmZXJyZWQiLCJlZmZlY3RpdmUiLCJyb3VuZCIsIm1heCIsInByZWZlcnJlZFdpZHRoIiwicHJlZmVycmVkSGVpZ2h0IiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJzZXRTY2FsYXIiLCJkaXNwYXRjaEV2ZW50IiwiZ2V0U2NhbGUiLCJzZXRTY2FsZSIsImJhc2VXaWR0aCIsImdldEJhc2VXaWR0aCIsInNldEJhc2VXaWR0aCIsImJhc2VIZWlnaHQiLCJnZXRCYXNlSGVpZ2h0Iiwic2V0QmFzZUhlaWdodCIsInNldEJhc2VTaXplIiwiZ2V0UHJlZmVycmVkV2lkdGgiLCJzZXRQcmVmZXJyZWRXaWR0aCIsImdldFByZWZlcnJlZEhlaWdodCIsInNldFByZWZlcnJlZEhlaWdodCIsInNldFByZWZlcnJlZFNpemUiLCJjb3B5IiwicmVzb2x1dGlvbiIsIklkTWFuYWdlciIsImluaXRpYWxJZCIsIm5leHRJZCIsImdldE5leHRJZCIsImlkTWFuYWdlciIsIlNlbGVjdGlvbiIsIml0ZXJhYmxlIiwibGF5ZXIiLCJleGNsdXNpdmUiLCJfbGF5ZXIiLCJjb25zb2xlIiwid2FybiIsImN1cnJlbnRMYXllciIsIm9iamVjdCIsImxheWVycyIsImRpc2FibGUiLCJlbmFibGUiLCJnZXRMYXllciIsInNldExheWVyIiwiaXNFeGNsdXNpdmUiLCJzZXRFeGNsdXNpdmUiLCJvYmplY3RzIiwiaGFzIiwiZGVsZXRlIiwidG9nZ2xlIiwic2V0VmlzaWJsZSIsInZpc2libGUiLCJFdmVudERpc3BhdGNoZXIyIiwiVW5pZm9ybTIiLCJCbGVuZEZ1bmN0aW9uIiwiU0tJUCIsIlNFVCIsIkFERCIsIkFMUEhBIiwiQVZFUkFHRSIsIkNPTE9SIiwiQ09MT1JfQlVSTiIsIkNPTE9SX0RPREdFIiwiREFSS0VOIiwiRElGRkVSRU5DRSIsIkRJVklERSIsIkRTVCIsIkVYQ0xVU0lPTiIsIkhBUkRfTElHSFQiLCJIQVJEX01JWCIsIkhVRSIsIklOVkVSVCIsIklOVkVSVF9SR0IiLCJMSUdIVEVOIiwiTElORUFSX0JVUk4iLCJMSU5FQVJfRE9ER0UiLCJMSU5FQVJfTElHSFQiLCJMVU1JTk9TSVRZIiwiTVVMVElQTFkiLCJORUdBVElPTiIsIk5PUk1BTCIsIk9WRVJMQVkiLCJQSU5fTElHSFQiLCJSRUZMRUNUIiwiU0FUVVJBVElPTiIsIlNDUkVFTiIsIlNPRlRfTElHSFQiLCJTUkMiLCJTVUJUUkFDVCIsIlZJVklEX0xJR0hUIiwiYWRkX2RlZmF1bHQiLCJhbHBoYV9kZWZhdWx0IiwiYXZlcmFnZV9kZWZhdWx0IiwiY29sb3JfZGVmYXVsdCIsImNvbG9yX2J1cm5fZGVmYXVsdCIsImNvbG9yX2RvZGdlX2RlZmF1bHQiLCJkYXJrZW5fZGVmYXVsdCIsImRpZmZlcmVuY2VfZGVmYXVsdCIsImRpdmlkZV9kZWZhdWx0IiwiZXhjbHVzaW9uX2RlZmF1bHQiLCJoYXJkX2xpZ2h0X2RlZmF1bHQiLCJoYXJkX21peF9kZWZhdWx0IiwiaHVlX2RlZmF1bHQiLCJpbnZlcnRfZGVmYXVsdCIsImludmVydF9yZ2JfZGVmYXVsdCIsImxpZ2h0ZW5fZGVmYXVsdCIsImxpbmVhcl9idXJuX2RlZmF1bHQiLCJsaW5lYXJfZG9kZ2VfZGVmYXVsdCIsImxpbmVhcl9saWdodF9kZWZhdWx0IiwibHVtaW5vc2l0eV9kZWZhdWx0IiwibXVsdGlwbHlfZGVmYXVsdCIsIm5lZ2F0aW9uX2RlZmF1bHQiLCJub3JtYWxfZGVmYXVsdCIsIm92ZXJsYXlfZGVmYXVsdCIsInBpbl9saWdodF9kZWZhdWx0IiwicmVmbGVjdF9kZWZhdWx0Iiwic2F0dXJhdGlvbl9kZWZhdWx0Iiwic2NyZWVuX2RlZmF1bHQiLCJzb2Z0X2xpZ2h0X2RlZmF1bHQiLCJzcmNfZGVmYXVsdCIsInN1YnRyYWN0X2RlZmF1bHQiLCJ2aXZpZF9saWdodF9kZWZhdWx0IiwiYmxlbmRGdW5jdGlvbnMiLCJCbGVuZE1vZGUiLCJibGVuZEZ1bmN0aW9uIiwiX2JsZW5kRnVuY3Rpb24iLCJnZXRCbGVuZEZ1bmN0aW9uIiwic2V0QmxlbmRGdW5jdGlvbiIsImdldFNoYWRlckNvZGUiLCJnZXQiLCJDb2xvcjIiLCJVbmlmb3JtMyIsIlZlY3RvcjIzIiwiVmVjdG9yNCIsIkNhbnZhc1RleHR1cmUiLCJSZXBlYXRXcmFwcGluZyIsIkFTQ0lJVGV4dHVyZSIsImNoYXJhY3RlcnMiLCJmb250IiwiZm9udFNpemUiLCJjZWxsQ291bnQiLCJjcmVhdGVFbGVtZW50IiwiY2FudmFzIiwiaW1hZ2UiLCJjZWxsU2l6ZSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxTdHlsZSIsImNoYXIiLCJmaWxsVGV4dCIsImNoYXJhY3RlckNvdW50IiwiQmFzaWNEZXB0aFBhY2tpbmcyIiwiRXZlbnREaXNwYXRjaGVyMyIsIkxpbmVhclNSR0JDb2xvclNwYWNlMiIsIk1hdGVyaWFsMiIsIk5vQ29sb3JTcGFjZSIsIlRleHR1cmUyIiwiV2ViR0xSZW5kZXJUYXJnZXQ0IiwiRWZmZWN0IiwiYmxlbmRNb2RlIiwiZXZlbnQiLCJzZXRDaGFuZ2VkIiwiX2lucHV0Q29sb3JTcGFjZSIsIl9vdXRwdXRDb2xvclNwYWNlIiwiaW5wdXRDb2xvclNwYWNlIiwiZ2V0TmFtZSIsImdldERlZmluZXMiLCJnZXRVbmlmb3JtcyIsImdldEV4dGVuc2lvbnMiLCJnZXRCbGVuZE1vZGUiLCJnZXRBdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlcyIsImdldEZyYWdtZW50U2hhZGVyIiwic2V0RnJhZ21lbnRTaGFkZXIiLCJnZXRWZXJ0ZXhTaGFkZXIiLCJzZXRWZXJ0ZXhTaGFkZXIiLCJhc2NpaV9kZWZhdWx0IiwiQVNDSUlFZmZlY3QiLCJhc2NpaVRleHR1cmUiLCJfY2VsbFNpemUiLCJjdXJyZW50VGV4dHVyZSIsInRvRml4ZWQiLCJ1cGRhdGVDZWxsQ291bnQiLCJ6IiwiU1JHQkNvbG9yU3BhY2U1IiwiVW5pZm9ybTgiLCJXZWJHTFJlbmRlclRhcmdldDgiLCJLZXJuZWxTaXplIiwiVkVSWV9TTUFMTCIsIlNNQUxMIiwiTUVESVVNIiwiTEFSR0UiLCJWRVJZX0xBUkdFIiwiSFVHRSIsIlNSR0JDb2xvclNwYWNlMyIsIlVuc2lnbmVkQnl0ZVR5cGUzIiwiV2ViR0xSZW5kZXJUYXJnZXQ1IiwiTm9CbGVuZGluZzIiLCJTaGFkZXJNYXRlcmlhbDMiLCJVbmlmb3JtNCIsIlZlY3RvcjQyIiwiY29udm9sdXRpb25fa2F3YXNlX2RlZmF1bHQiLCJjb252b2x1dGlvbl9rYXdhc2VfZGVmYXVsdDIiLCJrZXJuZWxQcmVzZXRzIiwiS2F3YXNlQmx1ck1hdGVyaWFsIiwidGV4ZWxTaXplIiwia2VybmVsIiwic2V0VGV4ZWxTaXplIiwia2VybmVsU2VxdWVuY2UiLCJnZXRLZXJuZWwiLCJzZXRLZXJuZWwiLCJLYXdhc2VCbHVyUGFzcyIsInJlc29sdXRpb25TY2FsZSIsInJlc29sdXRpb25YIiwicmVzb2x1dGlvblkiLCJyZW5kZXJUYXJnZXRBIiwicmVuZGVyVGFyZ2V0QiIsIl9ibHVyTWF0ZXJpYWwiLCJjb3B5TWF0ZXJpYWwiLCJnZXRSZXNvbHV0aW9uIiwiYmx1ck1hdGVyaWFsIiwiZGl0aGVyaW5nIiwiZ2V0S2VybmVsU2l6ZSIsInNldEtlcm5lbFNpemUiLCJnZXRSZXNvbHV0aW9uU2NhbGUiLCJzZXRSZXNvbHV0aW9uU2NhbGUiLCJwcmV2aW91c0J1ZmZlciIsImgiLCJVbnNpZ25lZEJ5dGVUeXBlNCIsIldlYkdMUmVuZGVyVGFyZ2V0NiIsIk5vQmxlbmRpbmczIiwiUkVWSVNJT04iLCJTaGFkZXJNYXRlcmlhbDQiLCJVbmlmb3JtNSIsImx1bWluYW5jZV9kZWZhdWx0IiwiTHVtaW5hbmNlTWF0ZXJpYWwiLCJjb2xvck91dHB1dCIsImx1bWluYW5jZVJhbmdlIiwiVEhSRUVfUkVWSVNJT04iLCJyZXBsYWNlIiwidGhyZXNob2xkIiwic21vb3RoaW5nIiwicmFuZ2UiLCJUSFJFU0hPTEQiLCJnZXRUaHJlc2hvbGQiLCJzZXRUaHJlc2hvbGQiLCJnZXRTbW9vdGhpbmdGYWN0b3IiLCJzZXRTbW9vdGhpbmdGYWN0b3IiLCJ1c2VUaHJlc2hvbGQiLCJpc0NvbG9yT3V0cHV0RW5hYmxlZCIsInNldENvbG9yT3V0cHV0RW5hYmxlZCIsInVzZVJhbmdlIiwiUkFOR0UiLCJnZXRMdW1pbmFuY2VSYW5nZSIsInNldEx1bWluYW5jZVJhbmdlIiwiTHVtaW5hbmNlUGFzcyIsIlNSR0JDb2xvclNwYWNlNCIsIlVuc2lnbmVkQnl0ZVR5cGU1IiwiVmVjdG9yMjYiLCJXZWJHTFJlbmRlclRhcmdldDciLCJOb0JsZW5kaW5nNCIsIlNoYWRlck1hdGVyaWFsNSIsIlVuaWZvcm02IiwiVmVjdG9yMjQiLCJjb252b2x1dGlvbl9kb3duc2FtcGxpbmdfZGVmYXVsdCIsImNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MiIsIkRvd25zYW1wbGluZ01hdGVyaWFsIiwiTm9CbGVuZGluZzUiLCJTaGFkZXJNYXRlcmlhbDYiLCJVbmlmb3JtNyIsIlZlY3RvcjI1IiwiY29udm9sdXRpb25fdXBzYW1wbGluZ19kZWZhdWx0IiwiY29udm9sdXRpb25fdXBzYW1wbGluZ19kZWZhdWx0MiIsIlVwc2FtcGxpbmdNYXRlcmlhbCIsInN1cHBvcnRCdWZmZXIiLCJyYWRpdXMiLCJNaXBtYXBCbHVyUGFzcyIsImRvd25zYW1wbGluZ01pcG1hcHMiLCJ1cHNhbXBsaW5nTWlwbWFwcyIsImRvd25zYW1wbGluZ01hdGVyaWFsIiwidXBzYW1wbGluZ01hdGVyaWFsIiwibGV2ZWxzIiwibWlwbWFwIiwibWlwbWFwcyIsImJsb29tX2RlZmF1bHQiLCJCbG9vbUVmZmVjdCIsImx1bWluYW5jZVRocmVzaG9sZCIsImx1bWluYW5jZVNtb290aGluZyIsIm1pcG1hcEJsdXIiLCJpbnRlbnNpdHkiLCJibHVyUGFzcyIsImx1bWluYW5jZVBhc3MiLCJsdW1pbmFuY2VNYXRlcmlhbCIsIm1pcG1hcEJsdXJQYXNzIiwiZ2V0Qmx1clBhc3MiLCJnZXRMdW1pbmFuY2VQYXNzIiwiZ2V0THVtaW5hbmNlTWF0ZXJpYWwiLCJkaXN0aW5jdGlvbiIsImdldEludGVuc2l0eSIsInNldEludGVuc2l0eSIsIlVuaWZvcm05IiwiYm9rZWhfZGVmYXVsdCIsIkJva2VoRWZmZWN0IiwiZm9jdXMiLCJkb2YiLCJhcGVydHVyZSIsIm1heEJsdXIiLCJTUkdCQ29sb3JTcGFjZTYiLCJVbmlmb3JtMTAiLCJicmlnaHRuZXNzX2NvbnRyYXN0X2RlZmF1bHQiLCJCcmlnaHRuZXNzQ29udHJhc3RFZmZlY3QiLCJicmlnaHRuZXNzIiwiY29udHJhc3QiLCJnZXRCcmlnaHRuZXNzIiwic2V0QnJpZ2h0bmVzcyIsImdldENvbnRyYXN0Iiwic2V0Q29udHJhc3QiLCJjb2xvcl9hdmVyYWdlX2RlZmF1bHQiLCJDb2xvckF2ZXJhZ2VFZmZlY3QiLCJVbmlmb3JtMTEiLCJjb2xvcl9kZXB0aF9kZWZhdWx0IiwiQ29sb3JEZXB0aEVmZmVjdCIsImJpdHMiLCJiaXREZXB0aCIsInBvdyIsImdldEJpdERlcHRoIiwic2V0Qml0RGVwdGgiLCJVbmlmb3JtMTIiLCJWZWN0b3IyNyIsImNocm9tYXRpY19hYmVycmF0aW9uX2RlZmF1bHQiLCJjaHJvbWF0aWNfYWJlcnJhdGlvbl9kZWZhdWx0MiIsIkNocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QiLCJvZmZzZXQiLCJyYWRpYWxNb2R1bGF0aW9uIiwibW9kdWxhdGlvbk9mZnNldCIsImdldE9mZnNldCIsInNldE9mZnNldCIsImRlcHRoX2RlZmF1bHQiLCJEZXB0aEVmZmVjdCIsIkJhc2ljRGVwdGhQYWNraW5nNCIsIlNSR0JDb2xvclNwYWNlNyIsIlVuaWZvcm0xNiIsIlVuc2lnbmVkQnl0ZVR5cGU4IiwiV2ViR0xSZW5kZXJUYXJnZXQ5IiwiQ29sb3JDaGFubmVsIiwiUkVEIiwiR1JFRU4iLCJCTFVFIiwiTWFza0Z1bmN0aW9uIiwiRElTQ0FSRCIsIk1VTFRJUExZX1JHQl9TRVRfQUxQSEEiLCJNVUxUSVBMWV9SR0IiLCJOb0JsZW5kaW5nNiIsIlNoYWRlck1hdGVyaWFsNyIsIlVuaWZvcm0xMyIsIlZlY3RvcjI4IiwiY29udm9sdXRpb25fYm9rZWhfZGVmYXVsdCIsIkJva2VoTWF0ZXJpYWwiLCJmaWxsIiwiZm9yZWdyb3VuZCIsIlBBU1MiLCJjb2NCdWZmZXIiLCJrZXJuZWw2NCIsImtlcm5lbDE2IiwiRk9SRUdST1VORCIsImdlbmVyYXRlS2VybmVsIiwic2V0Q29DQnVmZmVyIiwiR09MREVOX0FOR0xFIiwicG9pbnRzNjQiLCJwb2ludHMxNiIsImk2NCIsImkxNiIsInNxcnQ4MCIsInNxcnQiLCJ0aGV0YSIsInIiLCJ1IiwiY29zIiwidjMiLCJzaW4iLCJCYXNpY0RlcHRoUGFja2luZzMiLCJOb0JsZW5kaW5nNyIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiU2hhZGVyTWF0ZXJpYWw4IiwiVW5pZm9ybTE0Iiwib3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaIiwibmVhciIsImZhciIsInZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCIsInZpZXdaIiwibWluIiwiY2lyY2xlX29mX2NvbmZ1c2lvbl9kZWZhdWx0IiwiQ2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbCIsIkRFUFRIX1BBQ0tJTkciLCJmb2N1c0Rpc3RhbmNlIiwiZm9jdXNSYW5nZSIsImNhbWVyYU5lYXIiLCJjYW1lcmFGYXIiLCJmb2NhbExlbmd0aCIsImNvcHlDYW1lcmFTZXR0aW5ncyIsInNldERlcHRoQnVmZmVyIiwid29ybGRGb2N1c0Rpc3RhbmNlIiwiZ2V0Rm9jdXNEaXN0YW5jZSIsInNldEZvY3VzRGlzdGFuY2UiLCJ3b3JsZEZvY3VzUmFuZ2UiLCJnZXRGb2NhbExlbmd0aCIsInNldEZvY2FsTGVuZ3RoIiwiYWRvcHRDYW1lcmFTZXR0aW5ncyIsIlBFUlNQRUNUSVZFX0NBTUVSQSIsIk5vQmxlbmRpbmc4IiwiU2hhZGVyTWF0ZXJpYWw5IiwiVW5pZm9ybTE1IiwiVW5zaWduZWRCeXRlVHlwZTYiLCJtYXNrX2RlZmF1bHQiLCJNYXNrTWF0ZXJpYWwiLCJtYXNrVGV4dHVyZSIsInN0cmVuZ3RoIiwiY29sb3JDaGFubmVsIiwibWFza0Z1bmN0aW9uIiwiTUFTS19QUkVDSVNJT05fSElHSCIsInNldE1hc2tUZXh0dXJlIiwiQ09MT1JfQ0hBTk5FTCIsInNldENvbG9yQ2hhbm5lbCIsIk1BU0tfRlVOQ1RJT04iLCJzZXRNYXNrRnVuY3Rpb24iLCJJTlZFUlRFRCIsImdldFN0cmVuZ3RoIiwic2V0U3RyZW5ndGgiLCJVbnNpZ25lZEJ5dGVUeXBlNyIsIlNoYWRlclBhc3MiLCJpbnB1dCIsInNldElucHV0IiwiZGVwdGhfb2ZfZmllbGRfZGVmYXVsdCIsIkRlcHRoT2ZGaWVsZEVmZmVjdCIsImJva2VoU2NhbGUiLCJyZW5kZXJUYXJnZXRNYXNrZWQiLCJyZW5kZXJUYXJnZXROZWFyIiwicmVuZGVyVGFyZ2V0RmFyIiwicmVuZGVyVGFyZ2V0Q29DIiwicmVuZGVyVGFyZ2V0Q29DQmx1cnJlZCIsImNvY1Bhc3MiLCJjb2NNYXRlcmlhbCIsIm1hc2tQYXNzIiwibWFza01hdGVyaWFsIiwiYm9rZWhOZWFyQmFzZVBhc3MiLCJib2tlaE5lYXJGaWxsUGFzcyIsImJva2VoRmFyQmFzZVBhc3MiLCJib2tlaEZhckZpbGxQYXNzIiwiY29jVGV4dHVyZSIsImNpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwiLCJnZXRDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsIiwiZ2V0Qm9rZWhTY2FsZSIsInNldEJva2VoU2NhbGUiLCJnZXRUYXJnZXQiLCJzZXRUYXJnZXQiLCJjYWxjdWxhdGVGb2N1c0Rpc3RhbmNlIiwiZGlzdGFuY2UiLCJwb3NpdGlvbiIsImRpc3RhbmNlVG8iLCJjYXBhYmlsaXRpZXMiLCJsb2dhcml0aG1pY0RlcHRoQnVmZmVyIiwiTE9HX0RFUFRIIiwiVW5pZm9ybTE3IiwiVmVjdG9yMjkiLCJkb3Rfc2NyZWVuX2RlZmF1bHQiLCJEb3RTY3JlZW5FZmZlY3QiLCJhbmdsZSIsIlBJIiwiYWNvcyIsImdldEFuZ2xlIiwic2V0QW5nbGUiLCJmeGFhX2RlZmF1bHQiLCJmeGFhX2RlZmF1bHQyIiwiRlhBQUVmZmVjdCIsIm1pbkVkZ2VUaHJlc2hvbGQiLCJOdW1iZXIiLCJtYXhFZGdlVGhyZXNob2xkIiwic3VicGl4ZWxRdWFsaXR5IiwiVW5pZm9ybTE4IiwiZ2FtbWFfY29ycmVjdGlvbl9kZWZhdWx0IiwiR2FtbWFDb3JyZWN0aW9uRWZmZWN0IiwiZ2FtbWEiLCJOZWFyZXN0RmlsdGVyIiwiUmVwZWF0V3JhcHBpbmcyIiwiUkdCQUZvcm1hdCIsIlJHQkFGb3JtYXQyIiwiVW5pZm9ybTE5IiwiVmVjdG9yMjEwIiwiR2xpdGNoTW9kZSIsIkRJU0FCTEVEIiwiU1BPUkFESUMiLCJDT05TVEFOVF9NSUxEIiwiQ09OU1RBTlRfV0lMRCIsIkRhdGFUZXh0dXJlIiwiUmVkRm9ybWF0IiwiUkdGb3JtYXQiLCJVbnNpZ25lZEJ5dGVUeXBlOSIsImdldE5vaXNlIiwiY2hhbm5lbHMiLCJkYXRhIiwiZXJyb3IiLCJVaW50OEFycmF5IiwicmFuZG9tIiwiTm9pc2VUZXh0dXJlIiwiZ2xpdGNoX2RlZmF1bHQiLCJ0ZXh0dXJlVGFnIiwicmFuZG9tRmxvYXQiLCJsb3ciLCJoaWdoIiwiR2xpdGNoRWZmZWN0IiwiY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCIsImRlbGF5IiwiZHVyYXRpb24iLCJjb2x1bW5zIiwicmF0aW8iLCJwZXJ0dXJiYXRpb25NYXAiLCJkdFNpemUiLCJ0aW1lIiwiZGlzdG9ydGlvbiIsImJyZWFrUG9pbnQiLCJtb2RlIiwic2VlZHMiLCJhY3RpdmUiLCJpc0FjdGl2ZSIsIm1pbkRlbGF5IiwiZ2V0TWluRGVsYXkiLCJzZXRNaW5EZWxheSIsIm1heERlbGF5IiwiZ2V0TWF4RGVsYXkiLCJzZXRNYXhEZWxheSIsIm1pbkR1cmF0aW9uIiwiZ2V0TWluRHVyYXRpb24iLCJzZXRNaW5EdXJhdGlvbiIsIm1heER1cmF0aW9uIiwiZ2V0TWF4RHVyYXRpb24iLCJzZXRNYXhEdXJhdGlvbiIsIm1pblN0cmVuZ3RoIiwiZ2V0TWluU3RyZW5ndGgiLCJzZXRNaW5TdHJlbmd0aCIsIm1heFN0cmVuZ3RoIiwiZ2V0TWF4U3RyZW5ndGgiLCJzZXRNYXhTdHJlbmd0aCIsImdldE1vZGUiLCJzZXRNb2RlIiwiZ2V0R2xpdGNoUmF0aW8iLCJzZXRHbGl0Y2hSYXRpbyIsImdldEdsaXRjaENvbHVtbnMiLCJzZXRHbGl0Y2hDb2x1bW5zIiwiZ2V0Q2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCIsInNldENocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQiLCJjdXJyZW50TWFwIiwid3JhcFMiLCJ3cmFwVCIsImdldFBlcnR1cmJhdGlvbk1hcCIsInNldFBlcnR1cmJhdGlvbk1hcCIsImdlbmVyYXRlUGVydHVyYmF0aW9uTWFwIiwidHJpZ2dlciIsIm11bHRpcGx5U2NhbGFyIiwiQmFzaWNEZXB0aFBhY2tpbmc2IiwiQ29sb3IzIiwiRGVwdGhUZXh0dXJlMiIsIk1hdHJpeDQiLCJTY2VuZTIiLCJTUkdCQ29sb3JTcGFjZTgiLCJVbmlmb3JtMjIiLCJWZWN0b3IyMTIiLCJWZWN0b3IzIiwiV2ViR0xSZW5kZXJUYXJnZXQxMCIsIkFsd2F5c0RlcHRoIiwiQmFzaWNEZXB0aFBhY2tpbmc1IiwiRXF1YWxEZXB0aCIsIkdyZWF0ZXJEZXB0aCIsIkdyZWF0ZXJFcXVhbERlcHRoIiwiTGVzc0RlcHRoIiwiTGVzc0VxdWFsRGVwdGgiLCJOZXZlckRlcHRoIiwiTm9CbGVuZGluZzkiLCJOb3RFcXVhbERlcHRoIiwiUGVyc3BlY3RpdmVDYW1lcmEyIiwiU2hhZGVyTWF0ZXJpYWwxMCIsIlVuaWZvcm0yMCIsIlZlY3RvcjIxMSIsIkRlcHRoVGVzdFN0cmF0ZWd5IiwiREVGQVVMVCIsIktFRVBfTUFYX0RFUFRIIiwiRElTQ0FSRF9NQVhfREVQVEgiLCJkZXB0aF9tYXNrX2RlZmF1bHQiLCJEZXB0aE1hc2tNYXRlcmlhbCIsIkRFUFRIX0VQU0lMT04iLCJERVBUSF9QQUNLSU5HXzAiLCJERVBUSF9QQUNLSU5HXzEiLCJERVBUSF9URVNUX1NUUkFURUdZIiwiZGVwdGhCdWZmZXIwIiwiZGVwdGhCdWZmZXIxIiwiY2FtZXJhTmVhckZhciIsImRlcHRoTW9kZSIsImRlcHRoUGFja2luZzAiLCJzZXREZXB0aEJ1ZmZlcjAiLCJkZXB0aFBhY2tpbmcxIiwic2V0RGVwdGhCdWZmZXIxIiwibWF4RGVwdGhTdHJhdGVneSIsImtlZXBGYXIiLCJnZXRNYXhEZXB0aFN0cmF0ZWd5Iiwic2V0TWF4RGVwdGhTdHJhdGVneSIsImVwc2lsb24iLCJnZXRFcHNpbG9uIiwic2V0RXBzaWxvbiIsIkRFUFRIX01PREUiLCJnZXREZXB0aE1vZGUiLCJzZXREZXB0aE1vZGUiLCJOb0JsZW5kaW5nMTAiLCJTaGFkZXJNYXRlcmlhbDExIiwiVW5pZm9ybTIxIiwiY29udm9sdXRpb25fZ29kX3JheXNfZGVmYXVsdCIsIkdvZFJheXNNYXRlcmlhbCIsImxpZ2h0UG9zaXRpb24iLCJTQU1QTEVTX0lOVCIsIlNBTVBMRVNfRkxPQVQiLCJkZW5zaXR5IiwiZGVjYXkiLCJ3ZWlnaHQiLCJleHBvc3VyZSIsImNsYW1wTWF4IiwiZ2V0TGlnaHRQb3NpdGlvbiIsInNldExpZ2h0UG9zaXRpb24iLCJnZXREZW5zaXR5Iiwic2V0RGVuc2l0eSIsImdldERlY2F5Iiwic2V0RGVjYXkiLCJnZXRXZWlnaHQiLCJzZXRXZWlnaHQiLCJnZXRFeHBvc3VyZSIsInNldEV4cG9zdXJlIiwibWF4SW50ZW5zaXR5IiwiZ2V0TWF4SW50ZW5zaXR5Iiwic2V0TWF4SW50ZW5zaXR5IiwiZ2V0U2FtcGxlcyIsInNldFNhbXBsZXMiLCJSZW5kZXJQYXNzIiwib3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIiLCJpZ25vcmVCYWNrZ3JvdW5kIiwic2tpcFNoYWRvd01hcFVwZGF0ZSIsInNlbGVjdGlvbiIsIm1hbmFnZXIiLCJnZXRPdmVycmlkZU1hdGVyaWFsIiwic2V0T3ZlcnJpZGVNYXRlcmlhbCIsImdldFNlbGVjdGlvbiIsInNldFNlbGVjdGlvbiIsImlzQmFja2dyb3VuZERpc2FibGVkIiwic2V0QmFja2dyb3VuZERpc2FibGVkIiwiaXNTaGFkb3dNYXBEaXNhYmxlZCIsInNldFNoYWRvd01hcERpc2FibGVkIiwibWFzayIsImJhY2tncm91bmQiLCJzaGFkb3dNYXBBdXRvVXBkYXRlIiwiYXV0b1VwZGF0ZSIsImdvZF9yYXlzX2RlZmF1bHQiLCJ2IiwibSIsIkdvZFJheXNFZmZlY3QiLCJsaWdodFNvdXJjZSIsImJsdXIiLCJfbGlnaHRTb3VyY2UiLCJsaWdodFNjZW5lIiwic2NyZWVuUG9zaXRpb24iLCJyZW5kZXJUYXJnZXRMaWdodCIsInJlbmRlclBhc3NMaWdodCIsImRlcHRoTWFza1Bhc3MiLCJkZXB0aE1hc2tNYXRlcmlhbCIsImdvZFJheXNQYXNzIiwiZ29kUmF5c01hdGVyaWFsIiwidHJhbnNwYXJlbnQiLCJnZXRHb2RSYXlzTWF0ZXJpYWwiLCJtYXRyaXhBdXRvVXBkYXRlIiwidXBkYXRlV29ybGRNYXRyaXgiLCJtYXRyaXgiLCJtYXRyaXhXb3JsZCIsInNldEZyb21NYXRyaXhQb3NpdGlvbiIsInByb2plY3QiLCJVbmlmb3JtMjMiLCJWZWN0b3IyMTMiLCJncmlkX2RlZmF1bHQiLCJHcmlkRWZmZWN0IiwibGluZVdpZHRoIiwiZ2V0TGluZVdpZHRoIiwic2V0TGluZVdpZHRoIiwiYXNwZWN0IiwiVW5pZm9ybTI0IiwiVmVjdG9yMzIiLCJodWVfc2F0dXJhdGlvbl9kZWZhdWx0IiwiSHVlU2F0dXJhdGlvbkVmZmVjdCIsImh1ZSIsInNhdHVyYXRpb24iLCJnZXRTYXR1cmF0aW9uIiwic2V0U2F0dXJhdGlvbiIsImdldEh1ZSIsInNldEh1ZSIsIlVuaWZvcm0yNSIsIlZlY3RvcjIxNCIsImxlbnNfZGlzdG9ydGlvbl9kZWZhdWx0IiwiTGVuc0Rpc3RvcnRpb25FZmZlY3QiLCJwcmluY2lwYWxQb2ludCIsInNrZXciLCJGbG9hdFR5cGUiLCJIYWxmRmxvYXRUeXBlIiwiVW5pZm9ybTI2IiwibHV0XzFkX2RlZmF1bHQiLCJMVVQxREVmZmVjdCIsImx1dCIsIkRhdGEzRFRleHR1cmUiLCJEYXRhM0RUZXh0dXJlMiIsIkZsb2F0VHlwZTMiLCJIYWxmRmxvYXRUeXBlMiIsIkxpbmVhckZpbHRlcjQiLCJOZWFyZXN0RmlsdGVyMiIsIlNSR0JDb2xvclNwYWNlMTAiLCJVbmlmb3JtMjciLCJWZWN0b3IzNCIsIkNvbG9yNCIsIkNsYW1wVG9FZGdlV3JhcHBpbmciLCJEYXRhVGV4dHVyZTIiLCJGbG9hdFR5cGUyIiwiTGluZWFyRmlsdGVyMyIsIkxpbmVhclNSR0JDb2xvclNwYWNlMyIsIlJHQkFGb3JtYXQzIiwiU1JHQkNvbG9yU3BhY2U5IiwiVW5zaWduZWRCeXRlVHlwZTEwIiwiVmVjdG9yMzMiLCJMVVRPcGVyYXRpb24iLCJTQ0FMRV9VUCIsImNyZWF0ZUNhbnZhcyIsIkltYWdlIiwiZHJhd0ltYWdlIiwiaW1hZ2VEYXRhIiwiY3JlYXRlSW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwiUmF3SW1hZ2VEYXRhIiwiX1Jhd0ltYWdlRGF0YSIsInRvQ2FudmFzIiwiZnJvbSIsImdldEltYWdlRGF0YSIsIndvcmtlcl9kZWZhdWx0IiwiYyIsIkxvb2t1cFRleHR1cmUiLCJfTG9va3VwVGV4dHVyZSIsIndyYXBSIiwidW5wYWNrQWxpZ25tZW50IiwiZG9tYWluTWluIiwiZG9tYWluTWF4IiwiaXNMb29rdXBUZXh0dXJlM0QiLCJzY2FsZVVwIiwidHJhbnNmZXJEYXRhIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNvbHZlIiwid29ya2VyVVJMIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiQmxvYiIsIndvcmtlciIsIldvcmtlciIsInJldm9rZU9iamVjdFVSTCIsInRyYW5zZmVyTGlzdCIsInBvc3RNZXNzYWdlIiwib3BlcmF0aW9uIiwiYXBwbHlMVVQiLCJpbWcwIiwiaW1nMSIsInNpemUwIiwic2l6ZTEiLCJkYXRhMCIsImRhdGExIiwic2l6ZVNxIiwiaTQiLCJnIiwiaVJHQiIsImNvbnZlcnRUb1VpbnQ4IiwiZmxvYXREYXRhIiwidWludDhEYXRhIiwiY29udmVydFRvRmxvYXQiLCJjb252ZXJ0VG9SR0JBIiwiY29udmVydExpbmVhclRvU1JHQiIsImZyb21BcnJheSIsInRvQXJyYXkiLCJjb252ZXJ0U1JHQlRvTGluZWFyIiwidG9EYXRhVGV4dHVyZSIsInJhd0ltYWdlRGF0YSIsInNyYyIsImo0IiwiY3JlYXRlTmV1dHJhbCIsImx1dF8zZF9kZWZhdWx0IiwiTFVUM0RFZmZlY3QiLCJ0ZXRyYWhlZHJhbEludGVycG9sYXRpb24iLCJnZXRMVVQiLCJzZXRMVVQiLCJ1cGRhdGVTY2FsZU9mZnNldCIsImRvbWFpblNjYWxlIiwic3ViIiwiZGl2aWRlIiwibmVnYXRlIiwibXVsdGlwbHkiLCJhZGRTY2FsYXIiLCJjb25maWd1cmVUZXRyYWhlZHJhbEludGVycG9sYXRpb24iLCJzZXRUZXRyYWhlZHJhbEludGVycG9sYXRpb25FbmFibGVkIiwiRGVwdGhDb3B5TW9kZSIsIkZVTEwiLCJTSU5HTEUiLCJFZGdlRGV0ZWN0aW9uTW9kZSIsIkxVTUEiLCJQcmVkaWNhdGlvbk1vZGUiLCJDVVNUT00iLCJTTUFBUHJlc2V0IiwiTE9XIiwiSElHSCIsIlVMVFJBIiwiVG9uZU1hcHBpbmdNb2RlIiwiTElORUFSIiwiUkVJTkhBUkQiLCJSRUlOSEFSRDIiLCJSRUlOSEFSRDJfQURBUFRJVkUiLCJVTkNIQVJURUQyIiwiT1BUSU1JWkVEX0NJTkVPTiIsIkNJTkVPTiIsIkFDRVNfRklMTUlDIiwiQUdYIiwiTkVVVFJBTCIsIlZpZ25ldHRlVGVjaG5pcXVlIiwiRVNLSUwiLCJXZWJHTEV4dGVuc2lvbiIsIkRFUklWQVRJVkVTIiwiRlJBR19ERVBUSCIsIkRSQVdfQlVGRkVSUyIsIlNIQURFUl9URVhUVVJFX0xPRCIsIm5vaXNlX2RlZmF1bHQiLCJOb2lzZUVmZmVjdCIsInByZW11bHRpcGx5IiwiaXNQcmVtdWx0aXBsaWVkIiwic2V0UHJlbXVsdGlwbGllZCIsIkNvbG9yNiIsIlJlcGVhdFdyYXBwaW5nMyIsIlVuaWZvcm0zMCIsIlVuc2lnbmVkQnl0ZVR5cGUxMSIsIldlYkdMUmVuZGVyVGFyZ2V0MTIiLCJOb0JsZW5kaW5nMTEiLCJQZXJzcGVjdGl2ZUNhbWVyYTMiLCJSR0JBRGVwdGhQYWNraW5nIiwiU2hhZGVyTWF0ZXJpYWwxMiIsIlVuaWZvcm0yOCIsImRlcHRoX2NvbXBhcmlzb25fZGVmYXVsdCIsImRlcHRoX2NvbXBhcmlzb25fZGVmYXVsdDIiLCJEZXB0aENvbXBhcmlzb25NYXRlcmlhbCIsIk5vQmxlbmRpbmcxMiIsIlNoYWRlck1hdGVyaWFsMTMiLCJVbmlmb3JtMjkiLCJWZWN0b3IyMTUiLCJvdXRsaW5lX2RlZmF1bHQiLCJvdXRsaW5lX2RlZmF1bHQyIiwiT3V0bGluZU1hdGVyaWFsIiwiQ29sb3I1IiwiTWVzaERlcHRoTWF0ZXJpYWwiLCJOZWFyZXN0RmlsdGVyMyIsIlJHQkFEZXB0aFBhY2tpbmcyIiwiV2ViR0xSZW5kZXJUYXJnZXQxMSIsIkRlcHRoUGFzcyIsInJlbmRlclBhc3MiLCJvdXRsaW5lX2RlZmF1bHQzIiwib3V0bGluZV9kZWZhdWx0NCIsIk91dGxpbmVFZmZlY3QiLCJwYXR0ZXJuVGV4dHVyZSIsInBhdHRlcm5TY2FsZSIsImVkZ2VTdHJlbmd0aCIsInB1bHNlU3BlZWQiLCJ2aXNpYmxlRWRnZUNvbG9yIiwiaGlkZGVuRWRnZUNvbG9yIiwieFJheSIsInJlbmRlclRhcmdldE1hc2siLCJyZW5kZXJUYXJnZXRPdXRsaW5lIiwiZGVwdGhQYXNzIiwib3V0bGluZVBhc3MiLCJvdXRsaW5lTWF0ZXJpYWwiLCJmb3JjZVVwZGF0ZSIsImdldFB1bHNlU3BlZWQiLCJzZXRQdWxzZVNwZWVkIiwic2VsZWN0aW9uTGF5ZXIiLCJpc1hSYXlFbmFibGVkIiwic2V0WFJheUVuYWJsZWQiLCJzZXRQYXR0ZXJuVGV4dHVyZSIsImNsZWFyU2VsZWN0aW9uIiwic2VsZWN0T2JqZWN0IiwiZGVzZWxlY3RPYmplY3QiLCJwdWxzZSIsIlVuaWZvcm0zMSIsIlZlY3RvcjIxNiIsIlZlY3RvcjQzIiwicGl4ZWxhdGlvbl9kZWZhdWx0IiwiUGl4ZWxhdGlvbkVmZmVjdCIsImdyYW51bGFyaXR5IiwiX2dyYW51bGFyaXR5IiwiZCIsImdldEdyYW51bGFyaXR5Iiwic2V0R3JhbnVsYXJpdHkiLCJVbmlmb3JtMzIiLCJWZWN0b3I0NCIsInJlYWxpc3RpY19ib2tlaF9kZWZhdWx0IiwiUmVhbGlzdGljQm9rZWhFZmZlY3QiLCJmU3RvcCIsImx1bWluYW5jZUdhaW4iLCJiaWFzIiwiZnJpbmdlIiwicmluZ3MiLCJzaG93Rm9jdXMiLCJtYW51YWxEb0YiLCJwZW50YWdvbiIsInBhcnNlSW50IiwiVW5pZm9ybTMzIiwiVmVjdG9yMjE3Iiwic2NhbmxpbmVzX2RlZmF1bHQiLCJTY2FubGluZUVmZmVjdCIsInNjcm9sbFNwZWVkIiwiVW5pZm9ybTM0IiwiVmVjdG9yMjE4IiwiVmVjdG9yMzUiLCJzaG9ja193YXZlX2RlZmF1bHQiLCJzaG9ja193YXZlX2RlZmF1bHQyIiwiSEFMRl9QSSIsInYyIiwiYWIiLCJTaG9ja1dhdmVFZmZlY3QiLCJzcGVlZCIsIm1heFJhZGl1cyIsIndhdmVTaXplIiwiYW1wbGl0dWRlIiwiZXBpY2VudGVyIiwiZ2V0UG9zaXRpb24iLCJzZXRQb3NpdGlvbiIsImdldFNwZWVkIiwic2V0U3BlZWQiLCJleHBsb2RlIiwidUFjdGl2ZSIsImdldFdvcmxkRGlyZWN0aW9uIiwiYW5nbGVUbyIsIkJhc2ljRGVwdGhQYWNraW5nNyIsIkNvbG9yNyIsIk5vdEVxdWFsRGVwdGgyIiwiRXF1YWxEZXB0aDIiLCJSR0JBRGVwdGhQYWNraW5nMyIsIlNSR0JDb2xvclNwYWNlMTEiLCJXZWJHTFJlbmRlclRhcmdldDEzIiwiU2VsZWN0aXZlQmxvb21FZmZlY3QiLCJfaW52ZXJ0ZWQiLCJfaWdub3JlQmFja2dyb3VuZCIsIlVuaWZvcm0zNSIsIlZlY3RvcjM2Iiwic2VwaWFfZGVmYXVsdCIsIlNlcGlhRWZmZWN0Iiwid2VpZ2h0c1IiLCJ3ZWlnaHRzRyIsIndlaWdodHNCIiwiQmFzaWNEZXB0aFBhY2tpbmc5IiwiQ29sb3I4IiwiTGluZWFyRmlsdGVyNSIsIkxvYWRpbmdNYW5hZ2VyIiwiTmVhcmVzdEZpbHRlcjQiLCJUZXh0dXJlMyIsIlVuaWZvcm0zOCIsIldlYkdMUmVuZGVyVGFyZ2V0MTQiLCJCYXNpY0RlcHRoUGFja2luZzgiLCJOb0JsZW5kaW5nMTMiLCJSRVZJU0lPTjIiLCJTaGFkZXJNYXRlcmlhbDE0IiwiVW5pZm9ybTM2IiwiVmVjdG9yMjE5IiwiZWRnZV9kZXRlY3Rpb25fZGVmYXVsdCIsImVkZ2VfZGV0ZWN0aW9uX2RlZmF1bHQyIiwiRWRnZURldGVjdGlvbk1hdGVyaWFsIiwiTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IiLCJFREdFX1RIUkVTSE9MRCIsIkRFUFRIX1RIUkVTSE9MRCIsIlBSRURJQ0FUSU9OX01PREUiLCJQUkVESUNBVElPTl9USFJFU0hPTEQiLCJQUkVESUNBVElPTl9TQ0FMRSIsIlBSRURJQ0FUSU9OX1NUUkVOR1RIIiwicHJlZGljYXRpb25CdWZmZXIiLCJlZGdlRGV0ZWN0aW9uTW9kZSIsIkVER0VfREVURUNUSU9OX01PREUiLCJnZXRFZGdlRGV0ZWN0aW9uTW9kZSIsInNldEVkZ2VEZXRlY3Rpb25Nb2RlIiwibG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IiLCJnZXRMb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3RvciIsInNldExvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yIiwiZWRnZURldGVjdGlvblRocmVzaG9sZCIsImdldEVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQiLCJzZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkIiwicHJlZGljYXRpb25Nb2RlIiwiZ2V0UHJlZGljYXRpb25Nb2RlIiwic2V0UHJlZGljYXRpb25Nb2RlIiwic2V0UHJlZGljYXRpb25CdWZmZXIiLCJwcmVkaWNhdGlvblRocmVzaG9sZCIsImdldFByZWRpY2F0aW9uVGhyZXNob2xkIiwic2V0UHJlZGljYXRpb25UaHJlc2hvbGQiLCJwcmVkaWNhdGlvblNjYWxlIiwiZ2V0UHJlZGljYXRpb25TY2FsZSIsInNldFByZWRpY2F0aW9uU2NhbGUiLCJwcmVkaWNhdGlvblN0cmVuZ3RoIiwiZ2V0UHJlZGljYXRpb25TdHJlbmd0aCIsInNldFByZWRpY2F0aW9uU3RyZW5ndGgiLCJOb0JsZW5kaW5nMTQiLCJTaGFkZXJNYXRlcmlhbDE1IiwiVW5pZm9ybTM3IiwiVmVjdG9yMjIwIiwic21hYV93ZWlnaHRzX2RlZmF1bHQiLCJzbWFhX3dlaWdodHNfZGVmYXVsdDIiLCJTTUFBV2VpZ2h0c01hdGVyaWFsIiwiTUFYX1NFQVJDSF9TVEVQU19JTlQiLCJNQVhfU0VBUkNIX1NURVBTX0ZMT0FUIiwiTUFYX1NFQVJDSF9TVEVQU19ESUFHX0lOVCIsIk1BWF9TRUFSQ0hfU1RFUFNfRElBR19GTE9BVCIsIkNPUk5FUl9ST1VORElORyIsIkNPUk5FUl9ST1VORElOR19OT1JNIiwiQVJFQVRFWF9NQVhfRElTVEFOQ0UiLCJBUkVBVEVYX01BWF9ESVNUQU5DRV9ESUFHIiwiQVJFQVRFWF9QSVhFTF9TSVpFIiwiQVJFQVRFWF9TVUJURVhfU0laRSIsIlNFQVJDSFRFWF9TSVpFIiwiU0VBUkNIVEVYX1BBQ0tFRF9TSVpFIiwic2VhcmNoVGV4dHVyZSIsImFyZWFUZXh0dXJlIiwic2V0TG9va3VwVGV4dHVyZXMiLCJzZWFyY2giLCJhcmVhMiIsIm9ydGhvZ29uYWxTZWFyY2hTdGVwcyIsInNldE9ydGhvZ29uYWxTZWFyY2hTdGVwcyIsImRpYWdvbmFsU2VhcmNoU3RlcHMiLCJzZXREaWFnb25hbFNlYXJjaFN0ZXBzIiwiZGlhZ29uYWxEZXRlY3Rpb24iLCJESVNBQkxFX0RJQUdfREVURUNUSU9OIiwiaXNEaWFnb25hbERldGVjdGlvbkVuYWJsZWQiLCJzZXREaWFnb25hbERldGVjdGlvbkVuYWJsZWQiLCJjb3JuZXJSb3VuZGluZyIsInNldENvcm5lclJvdW5kaW5nIiwiY29ybmVyRGV0ZWN0aW9uIiwiRElTQUJMRV9DT1JORVJfREVURUNUSU9OIiwiaXNDb3JuZXJSb3VuZGluZ0VuYWJsZWQiLCJzZXRDb3JuZXJSb3VuZGluZ0VuYWJsZWQiLCJzZWFyY2hJbWFnZURhdGFVUkxfZGVmYXVsdCIsImFyZWFJbWFnZURhdGFVUkxfZGVmYXVsdCIsInNtYWFfZGVmYXVsdCIsInNtYWFfZGVmYXVsdDIiLCJTTUFBRWZmZWN0IiwicHJlc2V0Iiwic2VhcmNoSW1hZ2UiLCJhcmVhSW1hZ2UiLCJhcmd1bWVudHMiLCJyZW5kZXJUYXJnZXRFZGdlcyIsInJlbmRlclRhcmdldFdlaWdodHMiLCJlZGdlRGV0ZWN0aW9uUGFzcyIsImVkZ2VEZXRlY3Rpb25NYXRlcmlhbCIsIndlaWdodHNQYXNzIiwibG9hZGluZ01hbmFnZXIiLCJvbkxvYWQiLCJmbGlwWSIsIndlaWdodHNNYXRlcmlhbCIsIml0ZW1TdGFydCIsIml0ZW1FbmQiLCJhcHBseVByZXNldCIsImVkZ2VzVGV4dHVyZSIsImdldEVkZ2VzVGV4dHVyZSIsIndlaWdodHNUZXh0dXJlIiwiZ2V0V2VpZ2h0c1RleHR1cmUiLCJjb2xvckVkZ2VzTWF0ZXJpYWwiLCJnZXRFZGdlRGV0ZWN0aW9uTWF0ZXJpYWwiLCJnZXRXZWlnaHRzTWF0ZXJpYWwiLCJzZWFyY2hJbWFnZURhdGFVUkwiLCJhcmVhSW1hZ2VEYXRhVVJMIiwiQmFzaWNEZXB0aFBhY2tpbmcxMyIsIkNvbG9yOSIsIlJlcGVhdFdyYXBwaW5nNCIsIlJHQkFGb3JtYXQ0IiwiVW5pZm9ybTQxIiwiV2ViR0xSZW5kZXJUYXJnZXQxNiIsIkJhc2ljRGVwdGhQYWNraW5nMTAiLCJNYXRyaXg0MiIsIk5vQmxlbmRpbmcxNSIsIlBlcnNwZWN0aXZlQ2FtZXJhNCIsIlNoYWRlck1hdGVyaWFsMTYiLCJVbmlmb3JtMzkiLCJWZWN0b3IyMjEiLCJzc2FvX2RlZmF1bHQiLCJzc2FvX2RlZmF1bHQyIiwiU1NBT01hdGVyaWFsIiwiSU5WX1NBTVBMRVNfRkxPQVQiLCJTUElSQUxfVFVSTlMiLCJSQURJVVMiLCJSQURJVVNfU1EiLCJESVNUQU5DRV9TQ0FMSU5HIiwibm9ybWFsQnVmZmVyIiwibm9ybWFsRGVwdGhCdWZmZXIiLCJub2lzZVRleHR1cmUiLCJpbnZlcnNlUHJvamVjdGlvbk1hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJkaXN0YW5jZUN1dG9mZiIsInByb3hpbWl0eUN1dG9mZiIsIm5vaXNlU2NhbGUiLCJtaW5SYWRpdXNTY2FsZSIsImZhZGUiLCJOT1JNQUxfREVQVEgiLCJzZXROb3JtYWxEZXB0aEJ1ZmZlciIsInNldE5vcm1hbEJ1ZmZlciIsInNldE5vaXNlVGV4dHVyZSIsImdldFJpbmdzIiwic2V0UmluZ3MiLCJMRUdBQ1lfSU5URU5TSVRZIiwiZ2V0RmFkZSIsInNldEZhZGUiLCJnZXRCaWFzIiwic2V0QmlhcyIsImdldE1pblJhZGl1c1NjYWxlIiwic2V0TWluUmFkaXVzU2NhbGUiLCJ1cGRhdGVSYWRpdXMiLCJnZXRSYWRpdXMiLCJzZXRSYWRpdXMiLCJkaXN0YW5jZVNjYWxpbmciLCJpc0Rpc3RhbmNlU2NhbGluZ0VuYWJsZWQiLCJzZXREaXN0YW5jZVNjYWxpbmdFbmFibGVkIiwiZGlzdGFuY2VUaHJlc2hvbGQiLCJkaXN0YW5jZUZhbGxvZmYiLCJ3b3JsZERpc3RhbmNlVGhyZXNob2xkIiwid29ybGREaXN0YW5jZUZhbGxvZmYiLCJzZXREaXN0YW5jZUN1dG9mZiIsImZhbGxvZmYiLCJwcm94aW1pdHlUaHJlc2hvbGQiLCJwcm94aW1pdHlGYWxsb2ZmIiwid29ybGRQcm94aW1pdHlUaHJlc2hvbGQiLCJ3b3JsZFByb3hpbWl0eUZhbGxvZmYiLCJzZXRQcm94aW1pdHlDdXRvZmYiLCJpbnZlcnQiLCJCYXNpY0RlcHRoUGFja2luZzEyIiwiRmxvYXRUeXBlNCIsIk5lYXJlc3RGaWx0ZXI1IiwiV2ViR0xSZW5kZXJUYXJnZXQxNSIsIkJhc2ljRGVwdGhQYWNraW5nMTEiLCJOb0JsZW5kaW5nMTYiLCJTaGFkZXJNYXRlcmlhbDE3IiwiVW5pZm9ybTQwIiwiVmVjdG9yMjIyIiwiZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQiLCJkZXB0aF9kb3duc2FtcGxpbmdfZGVmYXVsdDIiLCJEZXB0aERvd25zYW1wbGluZ01hdGVyaWFsIiwiRE9XTlNBTVBMRV9OT1JNQUxTIiwiRGVwdGhEb3duc2FtcGxpbmdQYXNzIiwiZ2wiLCJyZW5kZXJhYmxlIiwiZ2V0RXh0ZW5zaW9uIiwic3Nhb19kZWZhdWx0MyIsIk5PSVNFX1RFWFRVUkVfU0laRSIsIlNTQU9FZmZlY3QiLCJkZXB0aEF3YXJlVXBzYW1wbGluZyIsInJhbmdlVGhyZXNob2xkIiwicmFuZ2VGYWxsb2ZmIiwibHVtaW5hbmNlSW5mbHVlbmNlIiwiZGVwdGhEb3duc2FtcGxpbmdQYXNzIiwic3Nhb1Bhc3MiLCJzc2FvTWF0ZXJpYWwiLCJnZXRTU0FPTWF0ZXJpYWwiLCJpc0RlcHRoQXdhcmVVcHNhbXBsaW5nRW5hYmxlZCIsInNldERlcHRoQXdhcmVVcHNhbXBsaW5nRW5hYmxlZCIsImdldENvbG9yIiwic2V0Q29sb3IiLCJVbmlmb3JtNDIiLCJVbnNpZ25lZEJ5dGVUeXBlMTIiLCJ0ZXh0dXJlX2RlZmF1bHQiLCJ0ZXh0dXJlX2RlZmF1bHQyIiwiVGV4dHVyZUVmZmVjdCIsImFzcGVjdENvcnJlY3Rpb24iLCJwcmV2VGV4dHVyZSIsImVuY29kaW5nIiwic2V0VGV4dHVyZSIsInV2VHJhbnNmb3JtIiwic2V0VGV4dHVyZVN3aXp6bGVSR0JBIiwicmdiYSIsInN3aXp6bGUiLCJqb2luIiwidXBkYXRlTWF0cml4IiwiU1JHQkNvbG9yU3BhY2UxMiIsIlVuaWZvcm00NCIsIlZlY3RvcjIyNCIsIldlYkdMUmVuZGVyVGFyZ2V0MTciLCJVbmlmb3JtNDMiLCJWZWN0b3IyMjMiLCJWZWN0b3I0NSIsImNvbnZvbHV0aW9uX3RpbHRfc2hpZnRfZGVmYXVsdCIsImNvbnZvbHV0aW9uX3RpbHRfc2hpZnRfZGVmYXVsdDIiLCJUaWx0U2hpZnRCbHVyTWF0ZXJpYWwiLCJyb3RhdGlvbiIsImZvY3VzQXJlYSIsImZlYXRoZXIiLCJtYXNrUGFyYW1zIiwiX29mZnNldCIsIl9mb2N1c0FyZWEiLCJfZmVhdGhlciIsInVwZGF0ZVBhcmFtcyIsInBhcmFtcyIsIlRpbHRTaGlmdEJsdXJQYXNzIiwidGlsdF9zaGlmdF9kZWZhdWx0IiwidGlsdF9zaGlmdF9kZWZhdWx0MiIsIlRpbHRTaGlmdEVmZmVjdCIsIkxpbmVhck1pcG1hcExpbmVhckZpbHRlciIsIlJFVklTSU9OMyIsIlVuaWZvcm00NiIsIldlYkdMUmVuZGVyVGFyZ2V0MTkiLCJOZWFyZXN0RmlsdGVyNiIsIldlYkdMUmVuZGVyVGFyZ2V0MTgiLCJOb0JsZW5kaW5nMTciLCJTaGFkZXJNYXRlcmlhbDE4IiwiVW5pZm9ybTQ1IiwiYWRhcHRpdmVfbHVtaW5hbmNlX2RlZmF1bHQiLCJBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsIiwiTUlQX0xFVkVMXzFYMSIsImx1bWluYW5jZUJ1ZmZlcjAiLCJsdW1pbmFuY2VCdWZmZXIxIiwibWluTHVtaW5hbmNlIiwidGF1Iiwic2hhZGVyVGV4dHVyZUxPRCIsInNldEx1bWluYW5jZUJ1ZmZlcjAiLCJzZXRMdW1pbmFuY2VCdWZmZXIxIiwibWlwTGV2ZWwxeDEiLCJzZXRNaXBMZXZlbDF4MSIsInNldERlbHRhVGltZSIsImdldE1pbkx1bWluYW5jZSIsInNldE1pbkx1bWluYW5jZSIsImFkYXB0YXRpb25SYXRlIiwiZ2V0QWRhcHRhdGlvblJhdGUiLCJzZXRBZGFwdGF0aW9uUmF0ZSIsIkFkYXB0aXZlTHVtaW5hbmNlUGFzcyIsImx1bWluYW5jZUJ1ZmZlciIsInJlbmRlclRhcmdldFByZXZpb3VzIiwicmVuZGVyVGFyZ2V0QWRhcHRlZCIsInRvbmVfbWFwcGluZ19kZWZhdWx0IiwiVG9uZU1hcHBpbmdFZmZlY3QiLCJhZGFwdGl2ZSIsIm1heEx1bWluYW5jZSIsIndoaXRlUG9pbnQiLCJtaWRkbGVHcmV5IiwiYXZlcmFnZUx1bWluYW5jZSIsInJlbmRlclRhcmdldEx1bWluYW5jZSIsImFkYXB0aXZlTHVtaW5hbmNlUGFzcyIsInJldmlzaW9uIiwiY2luZW9uVG9uZU1hcHBpbmciLCJhZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsIiwiZ2V0QWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCIsImV4cG9uZW50IiwiY2VpbCIsImxvZzIiLCJzZXRSZXNvbHV0aW9uIiwiVW5pZm9ybTQ3IiwidmlnbmV0dGVfZGVmYXVsdCIsIlZpZ25ldHRlRWZmZWN0IiwiZXNraWwiLCJ0ZWNobmlxdWUiLCJkYXJrbmVzcyIsImdldFRlY2huaXF1ZSIsInNldFRlY2huaXF1ZSIsImdldERhcmtuZXNzIiwic2V0RGFya25lc3MiLCJGaWxlTG9hZGVyIiwiTG9hZGVyIiwiTG9hZGluZ01hbmFnZXIyIiwiTFVUM2RsTG9hZGVyIiwibG9hZCIsInVybCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwiZXh0ZXJuYWxNYW5hZ2VyIiwiaW50ZXJuYWxNYW5hZ2VyIiwibG9hZGVyIiwic2V0UGF0aCIsInBhdGgiLCJzZXRSZXNwb25zZVR5cGUiLCJwYXJzZSIsImxvYWRBc3luYyIsInVybDIiLCJpdGVtRXJyb3IiLCJyZWdFeHBHcmlkSW5mbyIsInJlZ0V4cERhdGFQb2ludHMiLCJleGVjIiwiZ3JpZExpbmVzIiwidHJpbSIsInNwbGl0IiwiZ3JpZFN0ZXAiLCJtYXhWYWx1ZSIsImJMYXllciIsImdMYXllciIsInJMYXllciIsImQ0IiwibWF4Qml0VmFsdWUiLCJGaWxlTG9hZGVyMiIsIkxvYWRlcjIiLCJMb2FkaW5nTWFuYWdlcjMiLCJWZWN0b3IzNyIsIkxVVEN1YmVMb2FkZXIiLCJyZWdFeHBUaXRsZSIsInJlZ0V4cFNpemUiLCJyZWdFeHBEb21haW5NaW4iLCJyZWdFeHBEb21haW5NYXgiLCJ0aXRsZSIsIkxvYWRlcjMiLCJMb2FkaW5nTWFuYWdlcjQiLCJTTUFBSW1hZ2VMb2FkZXIiLCJOb0JsZW5kaW5nMTgiLCJQZXJzcGVjdGl2ZUNhbWVyYTUiLCJTaGFkZXJNYXRlcmlhbDE5IiwiVW5pZm9ybTQ4IiwiVmVjdG9yMjI1IiwiY29udm9sdXRpb25fYm94X2RlZmF1bHQiLCJjb252b2x1dGlvbl9ib3hfZGVmYXVsdDIiLCJCb3hCbHVyTWF0ZXJpYWwiLCJiaWxhdGVyYWwiLCJESVNUQU5DRV9USFJFU0hPTEQiLCJtYXhWYXJ5aW5nVmVjdG9ycyIsIk1BWF9WQVJZSU5HX1ZFQ1RPUlMiLCJLRVJORUxfU0laRSIsIktFUk5FTF9TSVpFX0hBTEYiLCJLRVJORUxfU0laRV9TUSIsIktFUk5FTF9TSVpFX1NRX0hBTEYiLCJJTlZfS0VSTkVMX1NJWkVfU1EiLCJCSUxBVEVSQUwiLCJCYXNpY0RlcHRoUGFja2luZzE0IiwiTm9CbGVuZGluZzE5IiwiU2hhZGVyTWF0ZXJpYWwyMCIsIlVuaWZvcm00OSIsIlZlY3RvcjIyNiIsImRlcHRoX2NvcHlfZGVmYXVsdCIsImRlcHRoX2NvcHlfZGVmYXVsdDIiLCJEZXB0aENvcHlNYXRlcmlhbCIsIklOUFVUX0RFUFRIX1BBQ0tJTkciLCJPVVRQVVRfREVQVEhfUEFDS0lORyIsIkRFUFRIX0NPUFlfTU9ERSIsInRleGVsUG9zaXRpb24iLCJkZXB0aENvcHlNb2RlIiwiaW5wdXREZXB0aFBhY2tpbmciLCJvdXRwdXREZXB0aFBhY2tpbmciLCJnZXRJbnB1dERlcHRoUGFja2luZyIsInNldElucHV0RGVwdGhQYWNraW5nIiwiZ2V0T3V0cHV0RGVwdGhQYWNraW5nIiwic2V0T3V0cHV0RGVwdGhQYWNraW5nIiwiZ2V0VGV4ZWxQb3NpdGlvbiIsInNldFRleGVsUG9zaXRpb24iLCJCYXNpY0RlcHRoUGFja2luZzE1IiwiTm9CbGVuZGluZzIwIiwiUGVyc3BlY3RpdmVDYW1lcmE2IiwiUkVWSVNJT040IiwiU2hhZGVyTWF0ZXJpYWwyMSIsIlVuaWZvcm01MCIsIlZlY3RvcjIyNyIsImVmZmVjdF9kZWZhdWx0IiwiZWZmZWN0X2RlZmF1bHQyIiwiRWZmZWN0TWF0ZXJpYWwiLCJFTkNPREVfT1VUUFVUIiwic2V0U2hhZGVyUGFydHMiLCJzZXREZWZpbmVzIiwic2V0VW5pZm9ybXMiLCJzZXRTaGFkZXJEYXRhIiwic2V0RXh0ZW5zaW9ucyIsImVudHJpZXMiLCJleHRlbnNpb24iLCJlbmNvZGVPdXRwdXQiLCJpc091dHB1dEVuY29kaW5nRW5hYmxlZCIsInNldE91dHB1dEVuY29kaW5nRW5hYmxlZCIsIlNlY3Rpb24iLCJOb0JsZW5kaW5nMjEiLCJTaGFkZXJNYXRlcmlhbDIyIiwiVW5pZm9ybTUxIiwiVmVjdG9yMjI4IiwiY29udm9sdXRpb25fZ2F1c3NpYW5fZGVmYXVsdCIsImNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQyIiwiR2F1c3NpYW5CbHVyTWF0ZXJpYWwiLCJkaXJlY3Rpb24iLCJfa2VybmVsU2l6ZSIsImtlcm5lbERhdGEiLCJTVEVQUyIsIkJhc2ljRGVwdGhQYWNraW5nMTYiLCJTUkdCQ29sb3JTcGFjZTEzIiwiVW5zaWduZWRCeXRlVHlwZTEzIiwiV2ViR0xSZW5kZXJUYXJnZXQyMCIsIkJveEJsdXJQYXNzIiwiaXRlcmF0aW9ucyIsIm1heFZhcnlpbmdzIiwiQmFzaWNEZXB0aFBhY2tpbmcxOCIsIkZsb2F0VHlwZTYiLCJSRVZJU0lPTjUiLCJSR0JBRGVwdGhQYWNraW5nNSIsIkJhc2ljRGVwdGhQYWNraW5nMTciLCJGbG9hdFR5cGU1IiwiTmVhcmVzdEZpbHRlcjciLCJSR0JBRGVwdGhQYWNraW5nNCIsIlVuc2lnbmVkQnl0ZVR5cGUxNCIsIldlYkdMUmVuZGVyVGFyZ2V0MjEiLCJEZXB0aENvcHlQYXNzIiwiZ2V0RGVwdGhQYWNraW5nIiwidGhyZWVSZXZpc2lvbiIsInVucGFja0Rvd25zY2FsZSIsInVucGFja0ZhY3RvcnNMZWdhY3kiLCJ1bnBhY2tGYWN0b3JzIiwidW5wYWNrUkdCQVRvRGVwdGgiLCJwYWNrZWREZXB0aCIsImYiLCJEZXB0aFBpY2tpbmdQYXNzIiwicGl4ZWxCdWZmZXIiLCJjYWxsYmFjayIsIm5kYyIsInBhY2tlZCIsInJlYWRSZW5kZXJUYXJnZXRQaXhlbHMiLCJCYXNpY0RlcHRoUGFja2luZzE5IiwiTm9Db2xvclNwYWNlMiIsIlNSR0JDb2xvclNwYWNlMTQiLCJVbnNpZ25lZEJ5dGVUeXBlMTUiLCJwcmVmaXhTdWJzdHJpbmdzIiwicHJlZml4Iiwic3Vic3RyaW5ncyIsInN0cmluZ3MiLCJzdWJzdHJpbmciLCJwcmVmaXhlZCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwicmVnRXhwIiwiUmVnRXhwIiwiaW50ZWdyYXRlRWZmZWN0IiwiZWZmZWN0IiwibWFpbkltYWdlRXhpc3RzIiwidGVzdCIsIm1haW5VdkV4aXN0cyIsImZ1bmN0aW9uUmVnRXhwIiwiZnJhZ21lbnRIZWFkIiwiZnJhZ21lbnRNYWluVXYiLCJmcmFnbWVudE1haW5JbWFnZSIsInZlcnRleEhlYWQiLCJ2ZXJ0ZXhNYWluU3VwcG9ydCIsIm5hbWVzIiwibmVlZHNVdiIsIm1hdGNoQWxsIiwiZm9yRWFjaCIsInZhbCIsInNoYWRlcnMiLCJkZXB0aFBhcmFtUmVnRXhwIiwiYmxlbmRPcGFjaXR5IiwiRWZmZWN0UGFzcyIsImVmZmVjdHMiLCJsaXN0ZW5lciIsInNldEVmZmVjdHMiLCJza2lwUmVuZGVyaW5nIiwibWluVGltZSIsIm1heFRpbWUiLCJQT1NJVElWRV9JTkZJTklUWSIsInRpbWVTY2FsZSIsInNvcnQiLCJ1cGRhdGVNYXRlcmlhbCIsImlkIiwiYmxlbmRSZWdFeHAiLCJ2YWx1ZXMiLCJyZWNvbXBpbGUiLCJTUkdCQ29sb3JTcGFjZTE1IiwiVW5zaWduZWRCeXRlVHlwZTE2IiwiV2ViR0xSZW5kZXJUYXJnZXQyMiIsIkdhdXNzaWFuQmx1clBhc3MiLCJMYW1iZGFQYXNzIiwiQ29sb3IxMCIsIk1lc2hOb3JtYWxNYXRlcmlhbCIsIk5lYXJlc3RGaWx0ZXI4IiwiV2ViR0xSZW5kZXJUYXJnZXQyMyIsIk5vcm1hbFBhc3MiLCJQIiwiQyIsIlQiLCJjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZSIsImJjWCIsImJjWSIsImJjWiIsImJhWCIsImJhWSIsImJhWiIsImNyb3NzWCIsImNyb3NzWSIsImNyb3NzWiIsInRyaWFuZ2xlQXJlYSIsIm5vcm1hbFgiLCJub3JtYWxZIiwibm9ybWFsWiIsImNvbnN0YW50IiwiZG90IiwiYWJzIiwic2FtcGxlIiwidGV0cmFoZWRyYWxTYW1wbGUiLCJweCIsInB5IiwicHoiLCJtaW5YIiwibWluWSIsIm1pbloiLCJtYXhYIiwibWF4WSIsIm1heFoiLCJzdSIsInN2Iiwic3ciLCJQMCIsIlAxIiwiUDIiLCJQMyIsImNvb3JkcyIsInRtcCIsImRpZmZYIiwiZGlmZlkiLCJkaWZmWiIsIlYwIiwiVjEiLCJWMiIsIlYzIiwiVGV0cmFoZWRyYWxVcHNjYWxlciIsImV4cGFuZCIsIm9yaWdpbmFsU2l6ZSIsImNicnQiLCJyZ2IiLCJhcnJheSIsImFyZWEiLCJPUlRIT0dPTkFMX1NJWkUiLCJESUFHT05BTF9TSVpFIiwiRElBR09OQUxfU0FNUExFUyIsIlNNT09USF9NQVhfRElTVEFOQ0UiLCJvcnRob2dvbmFsU3Vic2FtcGxpbmdPZmZzZXRzIiwiZGlhZ29uYWxTdWJzYW1wbGluZ09mZnNldHMiLCJvcnRob2dvbmFsRWRnZXMiLCJkaWFnb25hbEVkZ2VzIiwibGVycCIsInAiLCJzYXR1cmF0ZSIsInNtb290aEFyZWEiLCJhMSIsImEyIiwiYjFYIiwiYjFZIiwiYjJYIiwiYjJZIiwiZ2V0T3J0aEFyZWEiLCJwMVgiLCJwMVkiLCJwMlgiLCJwMlkiLCJkWCIsImRZIiwieDEiLCJ4MiIsInkxIiwieTIiLCJzaWduIiwidCIsInRJbnQiLCJ0cnVuYyIsImdldE9ydGhBcmVhRm9yUGF0dGVybiIsInBhdHRlcm4iLCJsZWZ0IiwicmlnaHQiLCJvMSIsIm8yIiwiaXNJbnNpZGVBcmVhIiwiYTFYIiwiYTFZIiwiYTJYIiwiYTJZIiwieG0iLCJ5bSIsImdldERpYWdBcmVhRm9yUGl4ZWwiLCJwWCIsInBZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJnZXREaWFnQXJlYSIsImUxIiwiZTIiLCJnZXREaWFnQXJlYUZvclBhdHRlcm4iLCJnZW5lcmF0ZVBhdHRlcm5zIiwicGF0dGVybnMiLCJvcnRob2dvbmFsIiwiYXNzZW1ibGUiLCJiYXNlWCIsImJhc2VZIiwiZWRnZXMyIiwiZHN0RGF0YSIsImRzdFdpZHRoIiwiZWRnZSIsInNyY0RhdGEiLCJzcmNXaWR0aCIsIlNNQUFBcmVhSW1hZ2VEYXRhIiwiVWludDhDbGFtcGVkQXJyYXkiLCJvcnRoUGF0dGVyblNpemUiLCJkaWFnUGF0dGVyblNpemUiLCJvcnRob2dvbmFsUGF0dGVybnMiLCJkaWFnb25hbFBhdHRlcm5zIiwiTG9hZGluZ01hbmFnZXI1Iiwid29ya2VyX2RlZmF1bHQyIiwidXNlQ2FjaGUiLCJzZWFyY2hJbWFnZURhdGEiLCJhcmVhSW1hZ2VEYXRhIiwidXJscyIsInRvRGF0YVVSTCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJTTUFBSW1hZ2VHZW5lcmF0b3IiLCJkaXNhYmxlQ2FjaGUiLCJzZXRDYWNoZUVuYWJsZWQiLCJ3aW5kb3ciLCJjYWNoZWRVUkxzIiwiZ2V0SXRlbSIsInRoZW4iLCJlZGdlcyIsImJpbGluZWFyIiwibGVycDIiLCJlMCIsImUzIiwiZGVsdGFMZWZ0IiwidG9wIiwiZGVsdGFSaWdodCIsIlNNQUFTZWFyY2hJbWFnZURhdGEiLCJoYWxmV2lkdGgiLCJjcm9wcGVkV2lkdGgiLCJjcm9wcGVkSGVpZ2h0IiwiY3JvcHBlZERhdGEiLCJCbHVyUGFzcyIsIkNvbG9yRWRnZXNNYXRlcmlhbCIsIkNvbnZvbHV0aW9uTWF0ZXJpYWwiLCJEZXB0aFNhdmVQYXNzIiwiTFVURWZmZWN0IiwiTG9va3VwVGV4dHVyZTNEIiwiT3V0bGluZUVkZ2VzTWF0ZXJpYWwiLCJSZXNpemVyIiwiU2F2ZVBhc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/postprocessing/build/index.js\n");

/***/ })

};
;